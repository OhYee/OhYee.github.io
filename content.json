[{"title":"HDU 6206.Apple","date":"2017-09-21T14:22:02.000Z","path":"/post/HDU/6206.html","text":"题目点击显/隐题目 Apple is Taotao’s favourite fruit. In his backyard, there are three apple trees with coordinates $(x_1, y_1)$, $(x_2, y_2)$, and $(x_3, y_3)$. Now Taotao is planning to plant a new one, but he is not willing to take these trees too close. He believes that the new apple tree should be outside the circle which the three apple trees that already exist is on. Taotao picked a potential position $(x,y)$ of the new tree. Could you tell him if it is outside the circle or not?The first line contains an integer $T$, indicating that there are $T(T \\leq 30)$ cases.In the first line of each case, there are eight integers $x_1, y_1, x_2, y_2, x_3,y_3,x,y$, as described above.The absolute values of integers in input are less than or equal to $1,000,000,000,000$.It is guaranteed that, any three of the four positions do not lie on a straight line.For each case, output “Accepted” if the position is outside the circle, or “Rejected” if the position is on or inside the circle.3-2 0 0 -2 2 0 2 -2-2 0 0 -2 2 0 0 2-2 0 0 -2 2 0 1 1AcceptedRejectedRejected 题解 求4个点中的第四个点是否在前三个点的外接圆外 大体思路就是中位线交点求圆心,比较距离数据高达 1e12 因此需要用到高精度计算 然而这题会卡Java的BigDecimal(黑科技数据) 尽可能少用除法根据公式可以发现可能会影响精度的地方如下: 求中点时除以2 求交点时除法 求距离时平方根 因为我们只需要比较最后的大小关系,因此比较距离可以变为比较距离的平方同时,把求交点时的除法提取出来,可以变成把除数乘到点上这样只需要除以2就行了,这样就不会被数据卡了 这题一点意思都没有,虽然比赛的时候没过 代码点击显/隐代码 Apple代码备份import java.io.*;import java.util.*;import java.math.*;class Point &#123; BigDecimal x, y; public Point() &#123; &#125; public Point(BigDecimal _x, BigDecimal _y) &#123; this.x = _x; this.y = _y; &#125;&#125;class Segment &#123; Point a, b; public Segment() &#123; &#125; public Segment(Point _a, Point _b) &#123; this.a = _a; this.b = _b; &#125;&#125;public class Main &#123; static Scanner cin; static BigDecimal two; static BigDecimal f1; static Point read_point() &#123; BigDecimal x = cin.nextBigDecimal(); BigDecimal y = cin.nextBigDecimal(); return new Point(x, y); &#125; static Point pa(Point a, Point b) &#123; return new Point(a.x.add(b.x), a.y.add(b.y)); &#125; static Point ps(Point a, Point b) &#123; return new Point(a.x.subtract(b.x), a.y.subtract(b.y)); &#125; static Point getPoint(Point a, Point b) &#123; Point p = pa(a, b); p.x = p.x.divide(two); p.y = p.y.divide(two); return p; &#125; static Point fa(Point p) &#123; return new Point(p.y.multiply(f1), p.x); &#125; static Segment getSegment(Segment s) &#123; Point mp = getPoint(s.a, s.b); Point vec = fa(ps(s.b, s.a)); return new Segment(mp, pa(mp, vec)); &#125; static Point Seg_Seg(Segment L1, Segment L2, BigDecimal[] f) &#123; BigDecimal a = L1.b.x.subtract(L1.a.x); BigDecimal b = L2.b.x.subtract(L2.a.x); BigDecimal c = L1.b.y.subtract(L1.a.y); BigDecimal d = L2.b.y.subtract(L2.a.y); f[0] = a.multiply(d).subtract(b.multiply(c)); BigDecimal g = L2.b.x.subtract(L1.a.x); BigDecimal h = L2.b.y.subtract(L1.a.y); BigDecimal t = d.multiply(g).subtract(b.multiply(h)); Point p = new Point(L1.a.x.add(t.multiply(a)), L1.a.y.add(t.multiply(c))); return p; &#125; static BigDecimal distance(Point a, Point b) &#123; Point p = ps(a, b); return p.x.multiply(p.x).add(p.y.multiply(p.y)); &#125; static void sprint(Segment s) &#123; pprint(s.a, false); pprint(s.b, false); System.out.print(\"\\n\"); &#125; static void pprint(Point p, boolean f) &#123; System.out.print(\"(\"); System.out.print(p.x); System.out.print(\" \"); System.out.print(p.y); System.out.print(\")\"); if (f == true) System.out.print(\"\\n\"); &#125; public static void main(String[] args) &#123; cin = new Scanner(new BufferedInputStream(System.in)); two = BigDecimal.valueOf(2); f1 = BigDecimal.valueOf(-1); Point p[] = new Point[4]; int T = cin.nextInt(); for (int kase = 0; kase &lt; T; ++kase) &#123; for (int i = 0; i &lt; 4; ++i) &#123; p[i] = read_point(); &#125; Segment a = getSegment(new Segment(p[0], p[1])); Segment b = getSegment(new Segment(p[1], p[2])); BigDecimal[] f = &#123; two &#125;; Point o = Seg_Seg(a, b, f); p[0].x = p[0].x.multiply(f[0]); p[0].y = p[0].y.multiply(f[0]); p[3].x = p[3].x.multiply(f[0]); p[3].y = p[3].y.multiply(f[0]); BigDecimal r = distance(p[0], o); BigDecimal dis = distance(p[3], o); //sprint(a); //sprint(b); // System.out.println(r); // pprint(o, true); // System.out.println(dis); if (dis.subtract(r).signum() &gt; 0) &#123; System.out.println(\"Accepted\"); &#125; else &#123; System.out.println(\"Rejected\"); &#125; &#125; cin.close(); &#125;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"计算几何","slug":"geometry","permalink":"https://www.oyohyee.com/tags/geometry/"},{"name":"高精度算法","slug":"High-precision","permalink":"https://www.oyohyee.com/tags/High-precision/"}]},{"title":"POJ 1696.Space Ant","date":"2017-09-13T16:42:00.000Z","path":"/post/POJ/1696.html","text":"题目点击显/隐题目 The most exciting space discovery occurred at the end of the 20th century. In 1999, scientists traced down an ant-like creature in the planet Y1999 and called it M11. It has only one eye on the left side of its head and just three feet all on the right side of its body and suffers from three walking limitations:It can not turn right due to its special body structure.It leaves a red path while walking.It hates to pass over a previously red colored path, and never does that.The pictures transmitted by the Discovery space ship depicts that plants in the Y1999 grow in special points on the planet. Analysis of several thousands of the pictures have resulted in discovering a magic coordinate system governing the grow points of the plants. In this coordinate system with x and y axes, no two plants share the same x or y.An M11 needs to eat exactly one plant in each day to stay alive. When it eats one plant, it remains there for the rest of the day with no move. Next day, it looks for another plant to go there and eat it. If it can not reach any other plant it dies by the end of the day. Notice that it can reach a plant in any distance.The problem is to find a path for an M11 to let it live longest.Input is a set of (x, y) coordinates of plants. Suppose A with the coordinates (xA, yA) is the plant with the least y-coordinate. M11 starts from point (0,yA) heading towards plant A. Notice that the solution path should not cross itself and all of the turns should be counter-clockwise. Also note that the solution may visit more than two plants located on a same straight line.The first line of the input is M, the number of test cases to be solved (1 &lt;= M &lt;= 10). For each test case, the first line is N, the number of plants in that test case (1 &lt;= N &lt;= 50), followed by N lines for each plant data. Each plant data consists of three integers: the first number is the unique plant index (1..N), followed by two positive integers x and y representing the coordinates of the plant. Plants are sorted by the increasing order on their indices in the input file. Suppose that the values of coordinates are at most 100.Output should have one separate line for the solution of each test case. A solution is the number of plants on the solution path, followed by the indices of visiting plants in the path in the order of their visits.2101 4 52 9 83 5 94 1 75 3 26 6 37 10 108 8 19 2 410 7 6141 6 112 11 93 8 74 12 85 9 206 3 27 1 68 2 139 15 110 14 1711 13 1912 5 1813 7 314 10 1610 8 7 3 4 9 5 6 2 1 1014 9 10 11 5 12 8 7 6 13 4 14 1 3 2 题解 对一个只能向左转的蚂蚁,求它尽可能经过最多点的路径 容易画出来蚂蚁必然能通过所有点 本质上就是将整个散点图分成一层层凸包 需要特别注意除了最外层凸包,里面的凸包起点要由上一层凸包决定 代码点击显/隐代码 Space Ant代码备份#include &lt;algorithm&gt;#include &lt;complex&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;using namespace std;#define Log(format, ...) // printf(format, ##__VA_ARGS__)/* 计算几何模板 */const double eps = 1e-8;const double INF = 9e50;inline int sgn(const double &amp;x) &#123; if (fabs(x) &lt; eps) return 0; return x &gt; 0 ? 1 : -1;&#125;struct Vector &#123; double x, y; int n; Vector(double _x = 0, double _y = 0, int _n = 0) : x(_x), y(_y), n(_n) &#123;&#125; bool operator==(const Vector &amp;rhs) const &#123; return sgn(x - rhs.x) == 0 &amp;&amp; sgn(y - rhs.y) == 0; &#125; bool operator!=(const Vector &amp;rhs) const &#123; return !(*this == rhs); &#125; bool operator&lt;(const Vector &amp;rhs) const &#123; if (sgn(y - rhs.y) == 0) return sgn(x - rhs.x) &lt; 0; return sgn(y - rhs.y) &lt; 0; &#125; Vector operator+(const Vector &amp;rhs) const &#123; return Vector(x + rhs.x, y + rhs.y); &#125; Vector operator-(const Vector &amp;rhs) const &#123; return Vector(x - rhs.x, y - rhs.y); &#125; double squre() const &#123; return x * x + y * y; &#125; double distance() const &#123; return sqrt(squre()); &#125; void print(bool flag = 0) const &#123; Log(\"(%.f %.f)\", x, y); if (flag) Log(\"\\n\"); &#125;&#125;;typedef Vector Point;struct Segment &#123; Point a, b; Segment() &#123;&#125; Segment(Point _a, Point _b) : a(_a), b(_b) &#123;&#125; Vector toVector() const &#123; return b - a; &#125; double distance() const &#123; return (b - a).distance(); &#125; void print(bool flag = 0) const &#123; a.print(); Log(\" -&gt; \"); b.print(); if (flag) Log(\"\\n\"); &#125;&#125;;/** * 读入一个点的坐标 * @return 读入的点 */inline Point read_Point() &#123; double x, y; scanf(\"%lf%lf\", &amp;x, &amp;y); return Point(x, y);&#125;/** * 计算两个向量的叉积 * @param a 向量1 * @param b 向量2 * @return 叉积 */inline double Cross(const Vector &amp;a, const Vector &amp;b) &#123; return a.x * b.y - a.y * b.x;&#125;/** * 计算两个向量的点积 * @param a 向量1 * @param b 向量2 * @return 点积 */inline double Dot(const Vector &amp;a, const Vector &amp;b) &#123; return a.x * b.x + a.y * b.y;&#125;/** * 计算两点之间的距离 * @param a 线段L1 * @param b 线段L2 * @return 两点间的距离 */inline double Distance(const Point &amp;a, const Point &amp;b) &#123; return (a - b).distance();&#125;/** * 点和直线的关系 * @param p 目标点 * @param L 目标直线 * @return 1 在左侧,0 在直线上,-1在右侧 */inline int Point_Segment(const Vector &amp;p, const Segment &amp;L) &#123; return sgn(Cross(L.b - L.a, p - L.a));&#125;/** * 计算两个线段的位置关系 * @param L1 线段L1 * @param L2 线段L2 * @param p 返回交点坐标 * @return 2 重叠 1 相交 0 延长线相交 -1 平行 -2 共线不交 */inline int Segment_Segment(const Segment L1, const Segment L2, Point *p = NULL) &#123; double a = L1.b.x - L1.a.x; double b = L2.b.x - L2.a.x; double c = L1.b.y - L1.a.y; double d = L2.b.y - L2.a.y; double f = a * d - b * c; // 平行或重叠 if (sgn(f) == 0) &#123; if (Point_Segment(L1.a, L2)) &#123; // 平行 return -1; &#125; else &#123; // 共线 int len = max(max(Distance(L1.a, L2.a), Distance(L1.a, L2.b)), max(Distance(L1.b, L2.a), Distance(L1.b, L2.b))); if (sgn(len - L1.distance() - L2.distance()) &gt; 0) &#123; // 共线不交 return -2; &#125; else &#123; // 重叠 return 2; &#125; &#125; &#125; double g = L2.b.x - L1.a.x; double h = L2.b.y - L1.a.y; double t = (d * g - b * h) / f; double s = (-c * g + a * h) / f; if (p != NULL) *p = Point(L1.a.x + t * a, L1.a.y + t * c); // 在延长线上 if (t &lt; 0 || t &gt; 1 || s &lt; 0 || s &gt; 1) return 0; // 线段相交 return 1;&#125;/** * 判断点是否在多边形内部 * @param p 需要判断的点 * @param polygon 多边形点集,需要保证有序 * @param numberOfSide 多边形边数 * @return true 点在多边形内,false 点不在多边形内 */bool Point_Polygon(Point p, Point polygon[], int numberOfSide) &#123; bool ok = Point_Segment(p, Segment(polygon[numberOfSide - 1], polygon[0])) &gt;= 0; for (int i = 1; i &lt; numberOfSide &amp;&amp; ok; ++i) &#123; if (!(Point_Segment(p, Segment(polygon[i - 1], polygon[i])) &gt;= 0)) ok = false; &#125; return ok;&#125;/** * 求点集的凸包 * @param p 点集,需要保证已经排序 * @param numOfPoint 点集内的点的个数 * @param vis 记录点对应的编号是否可以选择 * @param ans 返回的凸包 * @param begin 起始位置 * @return 返回凸包上点的个数 */int Convex_Hull(Point p[], int numOfPoint, bool vis[], Point ans[], int begin = 0) &#123; int pos = begin - 1; // 右链 for (int i = 0; i &lt; numOfPoint; ++i) &#123; if (!vis[p[i].n]) &#123; while (pos &gt; 0 &amp;&amp; Point_Segment(p[i], Segment(ans[pos], ans[pos - 1])) &gt; 0) &#123; vis[ans[pos--].n] = false; &#125; ans[++pos] = p[i]; vis[ans[pos].n] = true; &#125; &#125; // 左链 for (int i = numOfPoint - 2; i &gt; 0; --i) &#123; if (!vis[p[i].n]) &#123; while (pos &gt; 0 &amp;&amp; Point_Segment(p[i], Segment(ans[pos], ans[pos - 1])) &gt; 0) &#123; vis[ans[pos--].n] = false; &#125; ans[++pos] = p[i]; vis[ans[pos].n] = true; &#125; &#125; return pos + 1;&#125;const int maxn = 105;int n;Point points[maxn];Point ans[maxn];bool vis[maxn];void solve() &#123; int len = 0; sort(points, points + n); memset(vis, false, (n + 5) * sizeof(bool)); while (len != n) &#123; len = Convex_Hull(points, n, vis, ans, len); Log(\"%d\\n\", len); &#125; printf(\"%d\", len); for (int i = 0; i &lt; len; ++i) printf(\" %d\", ans[i].n); printf(\"\\n\");&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; int t; scanf(\"%d\", &amp;t); points[i] = read_Point(); points[i].n = t; &#125; solve(); &#125; return 0;&#125;","tags":[{"name":"计算几何","slug":"geometry","permalink":"https://www.oyohyee.com/tags/geometry/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"},{"name":"凸包","slug":"Convex-Hull","permalink":"https://www.oyohyee.com/tags/Convex-Hull/"}]},{"title":"POJ 1410.Intersection","date":"2017-09-13T14:36:20.000Z","path":"/post/POJ/1410.html","text":"题目点击显/隐题目 You are to write a program that has to decide whether a given line segment intersects a given rectangle.An example:line: start point: (4,9)end point: (11,2)rectangle: left-top: (1,5)right-bottom: (7,1)Figure 1: Line segment does not intersect rectangleThe line is said to intersect the rectangle if the line and the rectangle have at least one point in common. The rectangle consists of four straight lines and the area in between. Although all input values are integer numbers, valid intersection points do not have to lay on the integer grid.The input consists of n test cases. The first line of the input file contains the number n. Each following line contains one test case of the format: xstart ystart xend yend xleft ytop xright ybottomwhere (xstart, ystart) is the start and (xend, yend) the end point of the line and (xleft, ytop) the top left and (xright, ybottom) the bottom right corner of the rectangle. The eight numbers are separated by a blank. The terms top left and bottom right do not imply any ordering of coordinates.For each test case in the input file, the output file should contain a line consisting either of the letter “T” if the line segment intersects the rectangle or the letter “F” if the line segment does not intersect the rectangle.14 9 11 2 1 5 7 1F 题解 判断一个直线是否与矩形相交或者在矩形内部 先针对四条边分别判断一下线段关系,再判断一下线段是否在矩形内部需要注意的是描述多边形点要有顺序 代码点击显/隐代码 Intersection代码备份#include &lt;algorithm&gt;#include &lt;complex&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define Log(format, ...) // printf(format, ##__VA_ARGS__)/* 计算几何模板 */const double eps = 1e-8;const double INF = 9e50;inline int sgn(const double &amp;x) &#123; if (fabs(x) &lt; eps) return 0; return x &gt; 0 ? 1 : -1;&#125;struct Vector &#123; double x, y; Vector(double _x = 0, double _y = 0) : x(_x), y(_y) &#123;&#125; bool operator==(const Vector &amp;rhs) const &#123; return sgn(x - rhs.x) == 0 &amp;&amp; sgn(y - rhs.y) == 0; &#125; bool operator!=(const Vector &amp;rhs) const &#123; return !(*this == rhs); &#125; bool operator&lt;(const Vector &amp;rhs) const &#123; if (sgn(x - rhs.x) == 0) return sgn(y - rhs.y) &lt; 0; return sgn(x - rhs.x) &lt; 0; &#125; Vector operator+(const Vector &amp;rhs) const &#123; return Vector(x + rhs.x, y + rhs.y); &#125; Vector operator-(const Vector &amp;rhs) const &#123; return Vector(x - rhs.x, y - rhs.y); &#125; double squre() const &#123; return x * x + y * y; &#125; double distance() const &#123; return sqrt(squre()); &#125; void print() const &#123; Log(\"(%.f %.f)\", x, y); &#125;&#125;;typedef Vector Point;struct Segment &#123; Point a, b; Segment() &#123;&#125; Segment(Point _a, Point _b) : a(_a), b(_b) &#123;&#125; Vector toVector() const &#123; return b - a; &#125; double distance() const &#123; return (b - a).distance(); &#125; void print() const &#123; a.print(); Log(\" -&gt; \"); b.print(); &#125;&#125;;/** * 读入一个点的坐标 * @return 读入的点 */inline Point read_Point() &#123; double x, y; scanf(\"%lf%lf\", &amp;x, &amp;y); return Point(x, y);&#125;/** * 计算两个向量的叉积 * @param a 向量1 * @param b 向量2 * @return 叉积 */inline double Cross(const Vector &amp;a, const Vector &amp;b) &#123; return a.x * b.y - a.y * b.x;&#125;/** * 计算两个向量的点积 * @param a 向量1 * @param b 向量2 * @return 点积 */inline double Dot(const Vector &amp;a, const Vector &amp;b) &#123; return a.x * b.x + a.y * b.y;&#125;/** * 计算两点之间的距离 * @param a 线段L1 * @param b 线段L2 * @return 两点间的距离 */inline double Distance(const Point &amp;a, const Point &amp;b) &#123; return (a - b).distance();&#125;/** * 点和直线的关系 * @param p 目标点 * @param L 目标直线 * @return 1 在左侧,0 在直线上,-1在右侧 */inline int Point_Segment(const Vector &amp;p, const Segment &amp;L) &#123; p.print(); Log(\" \"); L.print(); Log(\" %d\\n\", sgn(Cross(L.b - L.a, p - L.a))); return sgn(Cross(L.b - L.a, p - L.a));&#125;/** * 计算两个线段的位置关系 * @param L1 线段L1 * @param L2 线段L2 * @param p 返回交点坐标 * @return 2 重叠 1 相交 0 延长线相交 -1 平行 -2 共线不交 */inline int Segment_Segment(const Segment L1, const Segment L2, Point *p = NULL) &#123; double a = L1.b.x - L1.a.x; double b = L2.b.x - L2.a.x; double c = L1.b.y - L1.a.y; double d = L2.b.y - L2.a.y; double f = a * d - b * c; // 平行或重叠 if (sgn(f) == 0) &#123; if (Point_Segment(L1.a, L2)) &#123; // 平行 return -1; &#125; else &#123; // 共线 int len = max(max(Distance(L1.a, L2.a), Distance(L1.a, L2.b)), max(Distance(L1.b, L2.a), Distance(L1.b, L2.b))); if (sgn(len - L1.distance() - L2.distance()) &gt; 0) &#123; // 共线不交 return -2; &#125; else &#123; // 重叠 return 2; &#125; &#125; &#125; double g = L2.b.x - L1.a.x; double h = L2.b.y - L1.a.y; double t = (d * g - b * h) / f; double s = (-c * g + a * h) / f; if (p != NULL) *p = Point(L1.a.x + t * a, L1.a.y + t * c); // 在延长线上 if (t &lt; 0 || t &gt; 1 || s &lt; 0 || s &gt; 1) return 0; // 线段相交 return 1;&#125;/** * 判断点是否在多边形内部 * @param p 需要判断的点 * @param polygon 多边形点集,需要保证有序 * @param numberOfSide 多边形边数 * @return true 点在多边形内,false 点不在多边形内 */bool Point_Polygon(Point p, Point polygon[], int numberOfSide) &#123; bool ok = Point_Segment(p, Segment(polygon[numberOfSide - 1], polygon[0])) &gt;= 0; for (int i = 1; i &lt; numberOfSide &amp;&amp; ok; ++i) &#123; if (!(Point_Segment(p, Segment(polygon[i - 1], polygon[i])) &gt;= 0)) ok = false; &#125; return ok;&#125;/** * 求点集的凸包 * @param p 点集 * @param numOfPoint 点集内的点的个数 * @param ans 返回的凸包 *void Convex_Hull(Point p[], int numOfPoint, Point ans[]) &#123; sort(p, p + numberOfPoint); bool *vis = new bool[numOfPoint + 5]; ans[0] = p[0]; for (int i = 0; i &lt; numberOfPoint; ++i) &#123; &#125;&#125;*/int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; Segment s; s.a = read_Point(); s.b = read_Point(); Point p1 = read_Point(); Point p2 = read_Point(); Point pots[4] = &#123;p1, p2, Point(p1.x, p2.y), Point(p2.x, p1.y)&#125;; sort(pots, pots + 4); Segment segs[4] = &#123;Segment(pots[0], pots[2]), Segment(pots[2], pots[3]), Segment(pots[3], pots[1]), Segment(pots[1], pots[0])&#125;; swap(pots[1], pots[2]); swap(pots[2], pots[3]); // 判断是否在多边形内部 bool ans = Point_Polygon(s.a, pots, 4) &amp;&amp; Point_Polygon(s.b, pots, 4); // 判断相交 for (int i = 0; i &lt; 4; ++i) ans |= Segment_Segment(segs[i], s) &gt; 0; printf(\"%c\\n\", ans ? 'T' : 'F'); &#125; return 0;&#125;","tags":[{"name":"计算几何","slug":"geometry","permalink":"https://www.oyohyee.com/tags/geometry/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"POJ 1066.Treasure Hunt","date":"2017-09-12T16:21:10.000Z","path":"/post/POJ/1066.html","text":"题目点击显/隐题目 Archeologists from the Antiquities and Curios Museum (ACM) have flown to Egypt to examine the great pyramid of Key-Ops. Using state-of-the-art technology they are able to determine that the lower floor of the pyramid is constructed from a series of straightline walls, which intersect to form numerous enclosed chambers. Currently, no doors exist to allow access to any chamber. This state-of-the-art technology has also pinpointed the location of the treasure room. What these dedicated (and greedy) archeologists want to do is blast doors through the walls to get to the treasure room. However, to minimize the damage to the artwork in the intervening chambers (and stay under their government grant for dynamite) they want to blast through the minimum number of doors. For structural integrity purposes, doors should only be blasted at the midpoint of the wall of the room being entered. You are to write a program which determines this minimum number of doors.An example is shown below: The input will consist of one case. The first line will be an integer n (0 &lt;= n &lt;= 30) specifying number of interior walls, followed by n lines containing integer endpoints of each wall x1 y1 x2 y2 . The 4 enclosing walls of the pyramid have fixed endpoints at (0,0); (0,100); (100,100) and (100,0) and are not included in the list of walls. The interior walls always span from one exterior wall to another exterior wall and are arranged such that no more than two walls intersect at any point. You may assume that no two given walls coincide. After the listing of the interior walls there will be one final line containing the floating point coordinates of the treasure in the treasure room (guaranteed not to lie on a wall).Print a single line listing the minimum number of doors which need to be created, in the format shown below.720 0 37 10040 0 76 10085 0 0 75100 90 0 900 71 100 610 14 100 38100 47 47 10054.5 55.4Number of doors = 2 题解一开始没仔细读题,没有考虑中点,直接求了向各个方向相交最小值(一般按照套路也只能这样算) 注意到中点后,推了一下,发现好像不需要刻意考虑中点大概理由如下:从任意一个位置到宝藏处,要通过的墙是确定的,不需要可以考虑墙的先后顺序如果直接走过来不穿这个墙,就说明这个墙对我们毫无影响如果直接走过来穿了这个墙,不管先穿后穿只打一个洞就行了(相当于通过了这一层) 因此直接跑就行了 最后记得记上边界墙同时判断相交不考虑端点情况特判 n==0 代码点击显/隐代码 Treasure Hunt代码备份#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;complex&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define Log(format, ...) // printf(format, ##__VA_ARGS__)/* 计算几何模板 */const double eps = 1e-8;const double INF = 9e50;typedef complex&lt;double&gt; Vector;typedef Vector Point;struct Segment &#123; Point a, b; Segment() &#123;&#125; Segment(Point _a, Point _b) : a(_a), b(_b) &#123;&#125; Vector toVector() &#123; return b - a; &#125;&#125;;inline Point read_Point() &#123; double x, y; scanf(\"%lf%lf\", &amp;x, &amp;y); return Point(x, y);&#125;inline int sgn(const double &amp;x) &#123; if (fabs(x) &lt; eps) return 0; return x &gt; 0 ? 1 : -1;&#125;inline bool operator==(const Vector &amp;vec1, const Vector &amp;vec2) &#123; return sgn(vec1.real() - vec2.real()) == 0 &amp;&amp; sgn(vec1.imag() - vec2.imag()) == 0;&#125;inline bool operator!=(const Vector &amp;vec1, const Vector &amp;vec2) &#123; return !(vec1 == vec2);&#125;inline int Cross(const Vector &amp;a, const Vector &amp;b) &#123; return a.real() * b.imag() - a.imag() * b.real();&#125;inline int Dot(const Vector &amp;a, const Vector &amp;b) &#123; return a.real() * b.real() + a.imag() * b.imag();&#125;inline double Distance(const Point &amp;a, const Point &amp;b) &#123; return abs(a - b); &#125;inline int Point_Segment(const Vector &amp;p, const Segment &amp;L) &#123; return sgn(Cross(L.b - L.a, p - L.a));&#125;inline int Segment_Segment(const Segment L1, const Segment L2) &#123; double a = L1.b.real() - L1.a.real(); double b = L2.b.real() - L2.a.real(); double c = L1.b.imag() - L1.a.imag(); double d = L2.b.imag() - L2.a.imag(); double f = a * d - b * c; // 平行或重叠 if (sgn(f) == 0) return -1; double g = L2.b.real() - L1.a.real(); double h = L2.b.imag() - L1.a.imag(); double t = (d * g - b * h) / f; double s = (-c * g + a * h) / f; // 在延长线上 if (t &lt;= 0 || t &gt;= 1 || s &lt;= 0 || s &gt;= 1) return 0; // 线段相交 return 1;&#125;const int maxn = 35;int n;Segment segments[maxn];int calc(Segment L) &#123; int cnt = 0; for (int i = 0; i &lt; n; ++i) cnt += (Segment_Segment(L, segments[i]) &gt; 0); return cnt;&#125;int main() &#123; while (~scanf(\"%d\", &amp;n)) &#123; for (int i = 0; i &lt; n; ++i) &#123; segments[i].a = read_Point(); segments[i].b = read_Point(); &#125; Point target = read_Point(); int ans = 9999999; for (int i = 0; i &lt; n; i++) &#123; ans = min(ans, calc(Segment(target, segments[i].a))); ans = min(ans, calc(Segment(target, segments[i].b))); &#125; if (n == 0) ans = 0; printf(\"Number of doors = %d\\n\", ans + 1); &#125; return 0;&#125;","tags":[{"name":"计算几何","slug":"geometry","permalink":"https://www.oyohyee.com/tags/geometry/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"POJ 2653.Pick-up sticks","date":"2017-09-12T13:22:13.000Z","path":"/post/POJ/2653.html","text":"题目点击显/隐题目 Stan has n sticks of various length. He throws them one at a time on the floor in a random way. After finishing throwing, Stan tries to find the top sticks, that is these sticks such that there is no stick on top of them. Stan has noticed that the last thrown stick is always on top but he wants to know all the sticks that are on top. Stan sticks are very, very thin such that their thickness can be neglected.Input consists of a number of cases. The data for each case start with 1 &lt;= n &lt;= 100000, the number of sticks for this case. The following n lines contain four numbers each, these numbers are the planar coordinates of the endpoints of one stick. The sticks are listed in the order in which Stan has thrown them. You may assume that there are no more than 1000 top sticks. The input is ended by the case with n=0. This case should not be processed.For each input case, print one line of output listing the top sticks in the format given in the sample. The top sticks should be listed in order in which they were thrown.The picture to the right below illustrates the first case from input.51 1 4 22 3 3 11 -2.0 8 41 4 8 23 3 6 -2.030 0 1 11 0 2 12 0 3 10Top sticks: 2, 4, 5.Top sticks: 1, 2, 3. 题解 按顺序扔木棍,找到所有上面没有压东西的木棍 基本思路就是判断线段相交 不过看数据量O(n2)会爆炸然而搜了一下大家全都这样写的……交了一次 TLE对了一下发现对for的循环顺序还有要求…… 不懂出题人的高级操作 代码点击显/隐代码 Pick-up sticks代码备份#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;complex&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define Log(format, ...) // printf(format, ##__VA_ARGS__)/* 计算几何模板 */const double eps = 1e-8;const double INF = 9e50;typedef complex&lt;double&gt; Vector;typedef Vector Point;struct Segment &#123; Point a, b; Segment() &#123;&#125; Segment(Point _a, Point _b) : a(_a), b(_b) &#123;&#125; Vector toVector() &#123; return b - a; &#125;&#125;;inline Point read_Point() &#123; double x, y; scanf(\"%lf%lf\", &amp;x, &amp;y); return Point(x, y);&#125;inline int sgn(const double &amp;x) &#123; if (fabs(x) &lt; eps) return 0; return x &gt; 0 ? 1 : -1;&#125;inline bool operator==(const Vector &amp;vec1, const Vector &amp;vec2) &#123; return sgn(vec1.real() - vec2.real()) == 0 &amp;&amp; sgn(vec1.imag() - vec2.imag()) == 0;&#125;inline bool operator!=(const Vector &amp;vec1, const Vector &amp;vec2) &#123; return !(vec1 == vec2);&#125;inline int Cross(const Vector &amp;a, const Vector &amp;b) &#123; return a.real() * b.imag() - a.imag() * b.real();&#125;inline int Dot(const Vector &amp;a, const Vector &amp;b) &#123; return a.real() * b.real() + a.imag() * b.imag();&#125;inline double Distance(const Point &amp;a, const Point &amp;b) &#123; return abs(a - b); &#125;inline int Point_Segment(const Vector &amp;p, const Segment &amp;L) &#123; return sgn(Cross(L.b - L.a, p - L.a));&#125;inline int Segment_Segment(const Segment L1, const Segment L2) &#123; double a = L1.b.real() - L1.a.real(); double b = L2.b.real() - L2.a.real(); double c = L1.b.imag() - L1.a.imag(); double d = L2.b.imag() - L2.a.imag(); double f = a * d - b * c; // 平行或重叠 if (sgn(f) == 0) return -1; double g = L2.b.real() - L1.a.real(); double h = L2.b.imag() - L1.a.imag(); double t = (d * g - b * h) / f; double s = (-c * g + a * h) / f; // 在延长线上 if (t &lt; 0 || t &gt; 1 || s &lt; 0 || s &gt; 1) return 0; // 线段相交 return 1;&#125;const int maxn = 100005;bool flag[maxn];Segment Segments[maxn];int main() &#123; int n; while (scanf(\"%d\", &amp;n), n) &#123; for (int i = 0; i &lt; n; ++i) &#123; Point p1 = read_Point(); Point p2 = read_Point(); Segments[i] = Segment(p1, p2); &#125; memset(flag, false, sizeof(bool) * (n + 5)); for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; if (Segment_Segment(Segments[i], Segments[j]) &gt; 0) &#123; flag[i] = true; break; &#125; &#125; &#125; bool first = true; printf(\"Top sticks:\"); for (int i = 0; i &lt; n; ++i) &#123; if (!flag[i]) &#123; if (first) &#123; first = false; printf(\" \"); &#125; else &#123; printf(\", \"); &#125; printf(\"%d\", i + 1); &#125; &#125; printf(\".\\n\"); &#125; return 0;&#125;","tags":[{"name":"计算几何","slug":"geometry","permalink":"https://www.oyohyee.com/tags/geometry/"},{"name":"暴力","slug":"Violence","permalink":"https://www.oyohyee.com/tags/Violence/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"POJ 1269.Intersecting Lines","date":"2017-09-12T12:56:07.000Z","path":"/post/POJ/1269.html","text":"题目点击显/隐题目 We all know that a pair of distinct points on a plane defines a line and that a pair of lines on a plane will intersect in one of three ways: 1) no intersection because they are parallel, 2) intersect in a line because they are on top of one another (i.e. they are the same line), 3) intersect in a point. In this problem you will use your algebraic knowledge to create a program that determines how and where two lines intersect.Your program will repeatedly read in four points that define two lines in the x-y plane and determine how and where the lines intersect. All numbers required by this problem will be reasonable, say between -1000 and 1000.The first line contains an integer N between 1 and 10 describing how many pairs of lines are represented. The next N lines will each contain eight integers. These integers represent the coordinates of four points on the plane in the order x1y1x2y2x3y3x4y4. Thus each of these input lines represents two lines on the plane: the line through (x1,y1) and (x2,y2) and the line through (x3,y3) and (x4,y4). The point (x1,y1) is always distinct from (x2,y2). Likewise with (x3,y3) and (x4,y4).There should be N+2 lines of output. The first line of output should read INTERSECTING LINES OUTPUT. There will then be one line of output for each pair of planar lines represented by a line of input, describing how the lines intersect: none, line, or point. If the intersection is a point then your program should output the x and y coordinates of the point, correct to two decimal places. The final line of output should read “END OF OUTPUT”.50 0 4 4 0 4 4 05 0 7 6 1 0 2 35 0 7 6 3 -6 4 -32 0 2 27 1 5 18 50 3 4 0 1 2 2 5INTERSECTING LINES OUTPUTPOINT 2.00 2.00NONELINEPOINT 2.00 5.00POINT 1.07 2.20END OF OUTPUT 题解判断两条直线的关系关系有: 重合 相交 不相交其中,对于相交还需要求出交点 可以使用矩阵解交点方程根据不同情况返回不同值 代码点击显/隐代码 Intersecting Lines代码备份#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;complex&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;#define Log(format, ...) // printf(format, ##__VA_ARGS__)/* 计算几何模板 */const double eps = 1e-8;typedef complex&lt;double&gt; Vector;typedef Vector Point;struct Segment &#123; Point a, b; Segment() &#123;&#125; Segment(Point _a, Point _b) : a(_a), b(_b) &#123;&#125; Vector toVector() &#123; return b - a; &#125;&#125;;inline Point read_Point() &#123; double x, y; scanf(\"%lf%lf\", &amp;x, &amp;y); return Point(x, y);&#125;inline int sgn(const double &amp;x) &#123; if (fabs(x) &lt; eps) return 0; return x &gt; 0 ? 1 : -1;&#125;inline bool operator==(const Vector &amp;vec1, const Vector &amp;vec2) &#123; return sgn(vec1.real() - vec2.real()) == 0 &amp;&amp; sgn(vec1.imag() - vec2.imag()) == 0;&#125;inline bool operator!=(const Vector &amp;vec1, const Vector &amp;vec2) &#123; return !(vec1 == vec2);&#125;inline int Cross(const Vector &amp;a, const Vector &amp;b) &#123; return a.real() * b.imag() - a.imag() * b.real();&#125;inline int Dot(const Vector &amp;a, const Vector &amp;b) &#123; return a.real() * b.real() + a.imag() * b.imag();&#125;inline double Distance(const Point &amp;a, const Point &amp;b) &#123; return abs(a - b); &#125;inline int Point_Segment(const Vector &amp;p, const Segment &amp;L) &#123; return sgn(Cross(L.b - L.a, p - L.a));&#125;inline bool Segment_Segment(const Segment &amp;L1, const Segment &amp;L2) &#123; if (sgn(Distance(L1.a, L1.b)) == 0 || sgn(Distance(L2.a, L2.b)) == 0) return 0; return (Point_Segment(L1.a, L2) * Point_Segment(L1.b, L2) &lt;= 0) &amp;&amp; (Point_Segment(L2.a, L1) * Point_Segment(L2.b, L1) &lt;= 0);&#125;inline int Segment_Line(const Segment &amp;Seg, const Segment &amp;Line) &#123; Log(\"(%.f,%.f)-&gt;(%.f,%.f) (%.f,%.f)-&gt;(%.f,%.f)\\n\", Seg.a.real(), Seg.a.imag(), Seg.b.real(), Seg.b.imag(), Line.a.real(), Line.a.imag(), Line.b.real(), Line.b.imag()); if (sgn(Distance(Line.a, Line.b)) == 0) return 0; return Point_Segment(Seg.a, Line) * Point_Segment(Seg.b, Line) &lt;= 0;&#125;inline int getPoint(const Segment L1, const Segment L2, Point &amp;p) &#123; double a = L1.b.real() - L1.a.real(); double b = L2.b.real() - L2.a.real(); double c = L1.b.imag() - L1.a.imag(); double d = L2.b.imag() - L2.a.imag(); double f = a * d - b * c; // 平行或重叠 if (sgn(f) == 0) return -1; double g = L2.b.real() - L1.a.real(); double h = L2.b.imag() - L1.a.imag(); double t = (d * g - b * h) / f; double s = (-c * g + a * h) / f; p = Point(L1.a.real() + t * a, L1.a.imag() + t * c); // 在延长线上 if (t &lt; 0 || t &gt; 1 || s &lt; 0 || s &gt; 1) return 0; // 线段相交 return 1;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); printf(\"INTERSECTING LINES OUTPUT\\n\"); while (T--) &#123; Point L1a = read_Point(); Point L1b = read_Point(); Point L2a = read_Point(); Point L2b = read_Point(); Segment L1 = Segment(L1a, L1b); Segment L2 = Segment(L2a, L2b); Point p; int state = getPoint(L1, L2, p); if (state &gt;= 0) &#123; printf(\"POINT %.2f %.2f\\n\", p.real(), p.imag()); &#125; else if (Point_Segment(L1.a, L2) == 0) &#123; printf(\"LINE\\n\"); &#125; else &#123; printf(\"NONE\\n\"); &#125; &#125; printf(\"END OF OUTPUT\\n\"); return 0;&#125;","tags":[{"name":"计算几何","slug":"geometry","permalink":"https://www.oyohyee.com/tags/geometry/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"POJ 2398.Toy Storage","date":"2017-09-11T14:50:01.000Z","path":"/post/POJ/2398.html","text":"题目点击显/隐题目 Mom and dad have a problem: their child, Reza, never puts his toys away when he is finished playing with them. They gave Reza a rectangular box to put his toys in. Unfortunately, Reza is rebellious and obeys his parents by simply throwing his toys into the box. All the toys get mixed up, and it is impossible for Reza to find his favorite toys anymore.Reza’s parents came up with the following idea. They put cardboard partitions into the box. Even if Reza keeps throwing his toys into the box, at least toys that get thrown into different partitions stay separate. The box looks like this from the top:We want for each positive integer t, such that there exists a partition with t toys, determine how many partitions have t, toys.The input consists of a number of cases. The first line consists of six integers n, m, x1, y1, x2, y2. The number of cardboards to form the partitions is n (0 &lt; n &lt;= 1000) and the number of toys is given in m (0 &lt; m &lt;= 1000). The coordinates of the upper-left corner and the lower-right corner of the box are (x1, y1) and (x2, y2), respectively. The following n lines each consists of two integers Ui Li, indicating that the ends of the ith cardboard is at the coordinates (Ui, y1) and (Li, y2). You may assume that the cardboards do not intersect with each other. The next m lines each consists of two integers Xi Yi specifying where the ith toy has landed in the box. You may assume that no toy will land on a cardboard.A line consisting of a single 0 terminates the input.For each box, first provide a header stating “Box” on a line of its own. After that, there will be one line of output per count (t &gt; 0) of toys in a partition. The value t will be followed by a colon and a space, followed the number of partitions containing t toys. Output will be sorted in ascending order of t for each box.4 10 0 10 100 020 2080 8060 6040 405 1015 1095 1025 1065 1075 1035 1045 1055 1085 105 6 0 10 60 04 315 303 16 810 102 12 81 55 540 107 90Box2: 5Box1: 42: 1 题解和 POJ 2318.TOYS 一样区别如下: 木板线段需要排序 输出格式改变 代码点击显/隐代码 Toy Storage代码备份#include &lt;algorithm&gt;#include &lt;complex&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define Log(format, ...) printf(format, ##__VA_ARGS__)/* 向量模板 */typedef complex&lt;double&gt; Vector;int Cross(Vector a, Vector b) &#123; return a.real() * b.imag() - a.imag() * b.real();&#125;int Dot(Vector a, Vector b) &#123; return a.real() * b.real() + a.imag() * b.imag();&#125;const int maxn = 5005;Vector P1[maxn];Vector P2[maxn];int cnt[maxn], ans[maxn];bool Could(Vector p, Vector L) &#123; return (Cross(L, p) &gt;= 0); &#125;int Division(int l, int r, Vector p) &#123; // printf(\"%d %d (%.f,%.f)\\n\", l, r, p.real(), p.imag()); if (r - l == 1) return l; int mid = (l + r) &gt;&gt; 1; if (Could(p - P1[mid], P2[mid] - P1[mid])) return Division(l, mid, p); else return Division(mid, r, p);&#125;bool compare(Vector a, Vector b) &#123; return a.real() &lt; b.real(); &#125;int main() &#123; int n, m, x1, y1, x2, y2; while (scanf(\"%d%d%d%d%d%d\", &amp;n, &amp;m, &amp;x1, &amp;y1, &amp;x2, &amp;y2), n != 0) &#123; P1[0] = Vector(x1, y2); P2[0] = Vector(x1, y1); for (int i = 1; i &lt;= n; ++i) &#123; int u, l; scanf(\"%d%d\", &amp;u, &amp;l); P2[i] = Vector(u, y1); P1[i] = Vector(l, y2); &#125; P1[n + 1] = Vector(x2, y2); P2[n + 1] = Vector(x2, y1); sort(P1 + 1, P1 + 1 + n, compare); sort(P2 + 1, P2 + 1 + n, compare); // for (int i = 0; i &lt;= n + 1; ++i) &#123; // printf(\"%d : (%.f,%.f) -&gt; (%.f,%.f)\\n\", i, P1[i].real(), // P1[i].imag(), P2[i].real(), P2[i].imag()); // &#125; memset(cnt, 0, sizeof(int) * (n + 5)); for (int i = 0; i &lt; m; ++i) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); cnt[Division(0, n + 1, Vector(x, y))]++; &#125; memset(ans, 0, sizeof(ans)); for (int i = 0; i &lt;= n; ++i) ans[cnt[i]]++; printf(\"Box\\n\"); for (int i = 1; i &lt;= n; ++i) if (ans[i] != 0) printf(\"%d: %d\\n\", i, ans[i]); &#125; return 0;&#125;","tags":[{"name":"计算几何","slug":"geometry","permalink":"https://www.oyohyee.com/tags/geometry/"},{"name":"二分","slug":"Division","permalink":"https://www.oyohyee.com/tags/Division/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"POJ 2318.TOYS","date":"2017-09-11T14:16:12.000Z","path":"/post/POJ/2318.html","text":"题目点击显/隐题目 Calculate the number of toys that land in each bin of a partitioned toy box. Mom and dad have a problem - their child John never puts his toys away when he is finished playing with them. They gave John a rectangular box to put his toys in, but John is rebellious and obeys his parents by simply throwing his toys into the box. All the toys get mixed up, and it is impossible for John to find his favorite toys.John’s parents came up with the following idea. They put cardboard partitions into the box. Even if John keeps throwing his toys into the box, at least toys that get thrown into different bins stay separated. The following diagram shows a top view of an example toy box.For this problem, you are asked to determine how many toys fall into each partition as John throws them into the toy box.The input file contains one or more problems. The first line of a problem consists of six integers, n m x1 y1 x2 y2. The number of cardboard partitions is n (0 &lt; n &lt;= 5000) and the number of toys is m (0 &lt; m &lt;= 5000). The coordinates of the upper-left corner and the lower-right corner of the box are (x1,y1) and (x2,y2), respectively. The following n lines contain two integers per line, Ui Li, indicating that the ends of the i-th cardboard partition is at the coordinates (Ui,y1) and (Li,y2). You may assume that the cardboard partitions do not intersect each other and that they are specified in sorted order from left to right. The next m lines contain two integers per line, Xj Yj specifying where the j-th toy has landed in the box. The order of the toy locations is random. You may assume that no toy will land exactly on a cardboard partition or outside the boundary of the box. The input is terminated by a line consisting of a single 0.The output for each problem will be one line for each separate bin in the toy box. For each bin, print its bin number, followed by a colon and one space, followed by the number of toys thrown into that bin. Bins are numbered from 0 (the leftmost bin) to n (the rightmost bin). Separate the output of different problems by a single blank line.5 6 0 10 60 03 14 36 810 1015 301 52 12 85 540 107 94 10 0 10 100 020 2040 4060 6080 80 5 1015 1025 1035 1045 1055 1065 1075 1085 1095 1000: 21: 12: 13: 14: 05: 10: 21: 22: 23: 24: 2 题解使用向量判断点在直线哪一侧 如 判断点$P_0$在线段$P_1P_2$的哪一侧:$\\vec {P_1P_2} \\times \\vec {P_1P_0}$若该值大于$0$,则在顺时针方向,小于$0$在逆时针方向,等于$0$在线段上 注意判断的时候应该使用二分判断 写的时候初始化写错变量了,调了好久 代码点击显/隐代码 TOYS代码备份#include &lt;complex&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define Log(format, ...) printf(format, ##__VA_ARGS__)/* 向量模板 */typedef complex&lt;double&gt; Vector;int Cross(Vector a, Vector b) &#123; return a.real() * b.imag() - a.imag() * b.real();&#125;int Dot(Vector a, Vector b) &#123; return a.real() * b.real() + a.imag() * b.imag();&#125;const int maxn = 5005;Vector P1[maxn];Vector P2[maxn];int cnt[maxn];bool Could(Vector p, Vector L) &#123; return (Cross(L, p) &gt;= 0); &#125;int Division(int l, int r, Vector p) &#123; // printf(\"%d %d (%.f,%.f)\\n\", l, r, p.real(), p.imag()); if (r - l == 1) return l; int mid = (l + r) &gt;&gt; 1; if (Could(p - P1[mid], P2[mid] - P1[mid])) return Division(l, mid, p); else return Division(mid, r, p);&#125;int main() &#123; int n, m, x1, y1, x2, y2; while (scanf(\"%d%d%d%d%d%d\", &amp;n, &amp;m, &amp;x1, &amp;y1, &amp;x2, &amp;y2), n != 0) &#123; P1[0] = Vector(x1, y2); P2[0] = Vector(x1, y1); for (int i = 1; i &lt;= n; ++i) &#123; int u, l; scanf(\"%d%d\", &amp;u, &amp;l); P2[i] = Vector(u, y1); P1[i] = Vector(l, y2); &#125; P1[n + 1] = Vector(x2, y2); P2[n + 1] = Vector(x2, y1); // for (int i = 0; i &lt;= n + 1; ++i) &#123; // printf(\"%d : (%.f,%.f) -&gt; (%.f,%.f)\\n\", i, P1[i].real(), // P1[i].imag(), P2[i].real(), P2[i].imag()); // &#125; memset(cnt, 0, sizeof(int) * (n + 5)); for (int i = 0; i &lt; m; ++i) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); cnt[Division(0, n + 1, Vector(x, y))]++; &#125; for (int i = 0; i &lt;= n; ++i) printf(\"%d: %d\\n\", i, cnt[i]); printf(\"\\n\"); &#125; return 0;&#125;","tags":[{"name":"计算几何","slug":"geometry","permalink":"https://www.oyohyee.com/tags/geometry/"},{"name":"二分","slug":"Division","permalink":"https://www.oyohyee.com/tags/Division/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"HDU 4652.Dice","date":"2017-09-08T14:58:01.000Z","path":"/post/HDU/4652.html","text":"题目点击显/隐题目 You have a dice with m faces, each face contains a distinct number. We assume when we tossing the dice, each face will occur randomly and uniformly. Now you have T query to answer, each query has one of the following form: 0 m n: ask for the expected number of tosses until the last n times results are all same.1 m n: ask for the expected number of tosses until the last n consecutive results are pairwise different.The first line contains a number T.(1≤T≤100) The next T line each line contains a query as we mentioned above. (1≤m,n≤106) For second kind query, we guarantee n≤m. And in order to avoid potential precision issue, we guarantee the result for our query will not exceeding 109 in this problem.For each query, output the corresponding result. The answer will be considered correct if the absolute or relative error doesn’t exceed 10-6.60 6 10 6 30 6 51 6 21 6 41 6 6101 4534 251 1232 241 3213 151 4343 241 4343 91 65467 1231 43434 1001 34344 91 10001 151 1000000 20001.00000000043.0000000001555.0000000002.2000000007.60000000083.20000000025.58631582426.01599003715.17634116024.5410457699.027721917127.908330426103.9754552539.00349551515.0562044724731.706620396 题解 求m面骰子投出连续n次相同/不相同的数学期望 根据正向推概率,逆向推期望的原则来看,我们应该采取从后往前推得形式来计算这道题 首先先来分析dp的意义对于第一种情况而言,需要求连续n次相同的期望如果用dp[i]表示i个相同的期望对于任意一种情况,都有对于i有1/m的概率和前一数字相同,也有(m-1)/m的概率和前一数字不同也即: dp[i]可以转移至dp[1]和dp[i+1]该函数无后效性,并且我们只能得到 dp[i+1]=(1/m)*dp[i] 和 dp[1] += ((m-1)/m)*dp[i] 两个式子因此,应该换一种含义,使dp可以逆向推出答案 用dp[i]表示已经有i个连续,到n个连续的期望那么很显然 dp[n] = 0并且dp[0] = dp[1] + 1 (对于0个相同,显然随便投一个数字都可以满足要求)而且根据含义,有 $dp[i] = 1 + \\frac{1}{m} \\times dp[i+1] + \\frac{m-1}{m} \\times dp[1]$ 剩下就是数学化简过程了$ \\begin{align*} dp[i] &= 1 + \\frac{1}{m} \\times dp[i+1] + \\frac{m-1}{m} \\times dp[1] \\\\ dp[i] - dp[1] &= 1 + \\frac{1}{m} \\times (dp[i+1] - dp[1]) \\\\ dp[i] - dp[1] &= m \\times (dp[i-1] - dp[1] - 1) \\\\ 令 a_i &= dp[i]-dp[1] \\\\ a_i &= m \\times a_{i-1} - m \\\\ a_i &= m^2 \\times a_{i-2} - m^2 - m \\\\ &…… \\\\ a_i &= m^{i-1} \\times a_1 - \\frac{m^i-m}{1-m} \\\\ dp[i] - dp[1] &= - \\frac{m-m^i}{1-m} \\\\ dp[i] &= dp[1] + \\frac{m^i-m}{1-m} \\\\ \\\\ dp[1] &= dp[n] - \\frac{m^n-m}{1-m} \\\\ dp[0] &= dp[n] - \\frac{m^n-m}{1-m} + 1 \\\\ dp[0] &s= \\frac{m^n-m}{m-1} + 1 \\end{align*} $ 也即,对于第一种情况,答案就是 $\\frac{m^n-m}{m-1} + 1$ 第二种情况同理按照相同的概念可以推出$ \\begin{align*} dp[0] &= 1 + dp[1] \\\\ dp[i] &= \\frac {\\sum_{k=1}^{i}dp[k]}{m} + \\frac{m-i}{m}\\times dp[i+1] \\\\ dp[i-1] &= \\frac {\\sum_{k=1}^{i-1}dp[k]}{m} + \\frac{m-i+1}{m} \\times dp[i] \\\\ 则 dp[i] - dp[i-1] &= \\frac{1}{m} \\times dp[i] + \\frac{m-i}{m}\\times dp[i+1] - \\frac{m-i+1}{m} \\times dp[i]) \\\\ dp[i] - dp[i-1] &= \\frac{m-i}{m}\\times (dp[i+1] - dp[i]) \\\\ dp[i] - dp[i-1] &= \\frac{m}{m-i+1} \\times (dp[i-1]-dp[i-2]) \\\\ dp[i-1] - dp[i] &= \\frac{m}{m-i+1} \\times (dp[i-2]-dp[i-1]) \\\\ \\\\ dp[0] - dp[1] &= 1 \\\\ dp[1] - dp[2] &= \\frac{m}{m-1} \\times 1 \\\\ dp[2] - dp[3] &= \\frac{m}{m-2} \\times \\frac{m}{m-1} \\times 1 \\\\ &……\\\\ dp[n-1] - dp[n] &= \\prod_{j=0}^{n-1} \\frac{m}{m-j} \\\\ \\therefore dp[0] - dp[n] &= \\sum_{i=0}^{n-1} \\prod_{j=0}^{i} \\frac{m}{m-j} \\\\ dp[0] &= \\sum_{i=0}^{n-1} \\prod_{j=0}^{i} \\frac{m}{m-j} \\end{align*} $ 最后要计算的就是 $\\sum_{i=0}^{n-1} \\prod_{j=0}^{i} \\frac{m}{m-j}$O(n)的时间可以得到答案 代码点击显/隐代码 Dice代码备份#include &lt;cstdio&gt;double pow(double a, int n) &#123; if (n == 0) return 1.0; double ans = pow(a, n &gt;&gt; 1); return ans * ans * (n &amp; 1 ? a : 1);&#125;double calc1(int n, int m) &#123; return (pow(m, n) - m) / (m - 1) + 1; &#125;double calc2(int n, int m) &#123; double sum = 0.0; double p = 1.0; for (int i = 0; i &lt; n; ++i) &#123; p *= (double)m / (m - i); sum += p; &#125; return sum;&#125;int main() &#123; int T; int c, n, m; while (scanf(\"%d\", &amp;T) != EOF) &#123; while (T--) &#123; scanf(\"%d%d%d\", &amp;c, &amp;m, &amp;n); double (*calc)(int, int) = (!c ? &amp;calc1 : &amp;calc2); printf(\"%.16f\\n\", calc(n, m)); &#125; &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"概率dp","slug":"Probability-DP","permalink":"https://www.oyohyee.com/tags/Probability-DP/"}]},{"title":"把svg图片转换为图标","date":"2017-09-03T05:58:23.000Z","path":"/post/Note/svgfont.html","text":"图标可以用于页面的很多地方,通常来说,我们使用的是通过字体来实现小图标但是当我们需要使用自己的图片时,也可以将svg图片转换为字体,实现图标 在icoMoon网站,可以将svg转换为字体(这里需要注意不要给svg填充颜色,不然会按照颜色分成多块) 然后我们可以在css里写入@font-face &#123; font-family: 'icon-OhYee'; src: url('/fonts/icon-OhYee.eot?nz90s1'); src: url('/fonts/icon-OhYee.eot?nz90s1#iefix') format('embedded-opentype'), url('/fonts/icon-OhYee.ttf?nz90s1') format('truetype'), url('/fonts/icon-OhYee.woff?nz90s1') format('woff'), url('/fonts/icon-OhYee.svg?nz90s1#icon-OhYee') format('svg'); font-weight: normal; font-style: normal;&#125; .icon-OhYee &#123; /* use !important to prevent issues with browser extensions that change fonts */ font-family: 'icon-OhYee' !important; speak: none; font-style: normal; font-weight: normal; font-variant: normal; text-transform: none; line-height: 1; /* Better Font Rendering =========== */ -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;/* 这里按照具体生成的字符编码写 */.icon-OhYee::before&#123; content: \"\\e904\";&#125; 在使用时可以按照通常的字符图标一样使用,只需要把图标名改为OhYee就会显示我们自己的图标 效果 描述 源码 单独使用 &lt;i class=&quot;icon-OhYee&quot;&gt;&lt;/i&gt; 加上颜色 &lt;span style=&quot;color:pink&quot;&gt;&lt;i class=&quot;icon-OhYee&quot;&gt;&lt;/i&gt;&lt;/span&gt; 按照正常的font icon格式使用 &lt;i class=&quot;icon icon-OhYee&quot;&gt;&lt;/i&gt; indigo主题的1.5倍大小 &lt;i class=&quot;icon icon-OhYee icon-lg&quot;&gt;&lt;/i&gt; indigo主题的2倍大小 &lt;i class=&quot;icon icon-OhYee icon-2x&quot;&gt;&lt;/i&gt; indigo主题的3倍大小 &lt;i class=&quot;icon icon-OhYee icon-3x&quot;&gt;&lt;/i&gt; indigo主题的4倍大小 &lt;i class=&quot;icon icon-OhYee icon-4x&quot;&gt;&lt;/i&gt; indigo主题的5倍大小 &lt;i class=&quot;icon icon-OhYee icon-5x&quot;&gt;&lt;/i&gt; indigo主题的5px右边距 &lt;i class=&quot;icon icon-OhYee icon-pr&quot;&gt;&lt;/i&gt; indigo主题的5px左边距 &lt;i class=&quot;icon icon-OhYee icon-pl&quot;&gt;&lt;/i&gt;","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.oyohyee.com/tags/Hexo/"},{"name":"CSS","slug":"CSS","permalink":"https://www.oyohyee.com/tags/CSS/"}]},{"title":"AOJ 912.蕊蕊的后宫团","date":"2017-08-29T16:10:10.000Z","path":"/post/AOJ/912.html","text":"题目点击显/隐题目 蕊蕊有n部喜欢的番剧，每部番剧里面有m个妹子，每个妹子都有一个颜值。现在蕊蕊想从每部番剧里挑出一个妹子，总共挑出n个妹子，组成后宫团，后宫团的颜值是里面n个妹子的颜值和。显然，蕊蕊一共可以组成m^n个后宫团，现在她想知道这m^n个后宫团中，颜值和第K大的总颜值是多少。若K&gt;m^n，输出0蕊蕊一共可以组成3^2=9个后宫团，总颜值分别是：1+2=3,1+2=3,1+5=64+2=6,4+2=6,4+5=93+2=5,3+2=5,3+5=8其中第4大的是6第一行三个整数n,m,k(1&lt;=n&lt;=1000,1&lt;=m&lt;=500,1&lt;=k&lt;=1000)。接下来n行，每一行表示一部番剧的信息。每行m个整数，表示该番剧里m个妹子的颜值a(1&lt;=a&lt;=100000)。输出一个整数，表示颜值和第K大的后宫团总颜值。2 3 41 4 32 2 56 题解直接看的话很容易想到01背包第k大但是显然时间复杂度会爆炸这里应该使用多路归并 按照01背包的思路,我们可以一组一组来看给每一组从大到小排序然后将两组合并到一起这样,当将所有的都合并进来后,得到的数组就是前k大 问题转换为将 a b 两个数组按照a+b合并到一起如果枚举计算出所有的a+b显然时间复杂度太高而且当数组很大的时候,其实很多a+b的计算是完全没有意义的如图,对于前5大,只有绿色部分是有用的 但是,对于前k大,我们计算两个数组前√k个的和显然又是不行的可以通过使用优先队列来满足我们的要求 我们以任意一列为基准,记录下用这一列的数分别加上另一列最大的数,插入到优先队列中这时优先队列里的最大值(队列最前的值)必然是所有结果中最大的那一个值将其插入到我们的结果数组中,然后从优先队列中删除它对于第二大的值,可能是a[1]+b[0]也有可能是a[0]+b[1]因此我们还应该通过刚刚的a[0]+b[0]得到a[0]+b[1]插入到优先队列中…… 以此类推,当最大值是a[i]+b[j]时,我们要将a[i]+b[j+1]插入到队列中(由于a[i]+b[j]是最大值,那么可以得知a[m]+b[n] (m&lt;=i n&lt;=j)已经从队列中删除,也即a[m]+b[j]已经插入到队列中)此时优先队列中的最大值必然是下一个最大值 每次出队一个入队一个总共出队k次再加上优先队列本身的复杂度O(log(n))总复杂度是 O(klog(n)) 整道题复杂度为O(mklog(n)) 是一个可以接受的复杂度 代码点击显/隐代码 蕊蕊的后宫团代码备份#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn = 5005;const int maxm = 505;const int maxk = 2005;int a[maxn][maxm];int n, m, k;int len;bool compare(int a, int b) &#123; return a &gt; b; &#125;struct node &#123; int s, b; node(int _s, int _b) : s(_s), b(_b) &#123;&#125; bool operator&lt;(node a) const &#123; return a.s &gt; s; &#125;&#125;;void merge(int *a, int *b, int *c) &#123; priority_queue&lt;node&gt; Q; for (int i = 0; i &lt; len; i++) Q.push(node(a[i] + b[0], 0)); len = 0; for (int i = 0; i &lt; k &amp;&amp; !Q.empty(); i++) &#123; ++len; node r = Q.top(); Q.pop(); c[i] = r.s; int t = r.b; if (t + 1 &lt; m) Q.push(node(r.s - b[t] + b[t + 1], t + 1)); &#125;&#125;int main() &#123; while (~scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k)) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) scanf(\"%d\", &amp;a[i][j]); sort(a[i], a[i] + m, compare); &#125; len = m; for (int i = 1; i &lt; n; i++) merge(a[0], a[i], a[0]); // for(int i = 0;i &lt; max(m,k); i++) // printf(\"%d \",a[0][i]); // printf(\"\\n\"); printf(\"%d\\n\", a[0][k - 1]); &#125; return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"多路归并","slug":"Multiway-merge","permalink":"https://www.oyohyee.com/tags/Multiway-merge/"}]},{"title":"HDU 2586.How far away?","date":"2017-08-29T16:06:13.000Z","path":"/post/HDU/2586.html","text":"题目点击显/隐题目 There are n houses in the village and some bidirectional roads connecting them. Every day peole always like to ask like this “How far is it if I want to go from house A to house B”? Usually it hard to answer. But luckily int this village the answer is always unique, since the roads are built in the way that there is a unique simple path(“simple” means you can’t visit a place twice) between every two houses. Yout task is to answer all these curious people.First line is a single integer T(T&lt;=10), indicating the number of test cases.For each test case,in the first line there are two numbers n(2&lt;=n&lt;=40000) and m (1&lt;=m&lt;=200),the number of houses and the number of queries. The following n-1 lines each consisting three numbers i,j,k, separated bu a single space, meaning that there is a road connecting house i and house j,with length k(0&lt;k&lt;=40000).The houses are labeled from 1 to n.Next m lines each has distinct integers i and j, you areato answer the distance between house i and house j.For each test case,output m lines. Each line represents the answer of the query. Output a bland line after each test case.23 21 2 103 1 151 22 32 21 2 1001 22 11025100100 题解倍增最近公共祖先模板题 代码点击显/隐代码 How far away?代码备份#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;#define Log(format, ...) // printf(format, ##__VA_ARGS__)const int maxn = 40005;const int maxlog = 17;int n, m;struct Edge &#123; int c, w; Edge(int _c = 0, int _w = 0) : c(_c), w(_w) &#123;&#125;&#125;;vector&lt;Edge&gt; edges[maxn];void addEdge(int u, int v, int w) &#123; Log(\"addEdge(%d,%d,%d)\\n\", u, v, w); edges[u].push_back(Edge(v, w)); edges[v].push_back(Edge(u, w));&#125;int depth[maxn];int parent[maxn][maxlog];int weight[maxn][maxlog];void lca() &#123; for (int j = 1; j &lt; maxlog; ++j) &#123; for (int i = 1; i &lt;= n; ++i) &#123; parent[i][j] = parent[parent[i][j - 1]][j - 1]; weight[i][j] = weight[i][j - 1] + weight[parent[i][j - 1]][j - 1]; &#125; &#125;&#125;int query(int a, int b) &#123; Log(\"Log(%d,%d)\\n\", a, b); int ans = 0; if (depth[a] &lt; depth[b]) swap(a, b); while (depth[a] != depth[b]) &#123; int dis = depth[a] - depth[b]; int step = (int)(log(dis) / log(2)); Log(\"\\t%d-&gt;%d (%d)\\n\", a, parent[a][step], weight[a][step]); ans += weight[a][step]; // 由于这里还要用到a,因此a要在后面再赋值 a = parent[a][step]; &#125; Log(\"\\tthe same depth %d %d\\n\", a, b); while (a != b) &#123; int step = 0; for (int i = 0; i &lt; maxlog; ++i) &#123; if (parent[a][i] == parent[b][i]) &#123; step = i - (i ? 1 : 0); break; &#125; &#125; Log(\"\\tstep: %d a: %d-&gt;%d (%d) b: %d-&gt;%d (%d)\\n\", step, a, parent[a][step], weight[a][step], b, parent[b][step], weight[b][step]); ans += weight[a][step] + weight[b][step]; a = parent[a][step]; b = parent[b][step]; &#125; return ans;&#125;void dfs(int t, int deep) &#123; depth[t] = deep; for (auto edge : edges[t]) &#123; int child = edge.c; if (parent[t][0] != child) &#123; parent[child][0] = t; weight[child][0] = edge.w; dfs(child, deep + 1); &#125; &#125;&#125;void init() &#123; memset(parent, 0, sizeof(parent)); for (int i = 0; i &lt;= n; ++i) &#123; edges[i].clear(); &#125;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n &gt;&gt; m; init(); for (int i = 1; i &lt; n; ++i) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addEdge(u, v, w); &#125; dfs(1, 0); lca(); for (int i = 0; i &lt; m; ++i) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; query(a, b) &lt;&lt; endl; &#125; &#125; return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最近公共祖先","slug":"LCA","permalink":"https://www.oyohyee.com/tags/LCA/"},{"name":"树","slug":"Tree","permalink":"https://www.oyohyee.com/tags/Tree/"}]},{"title":"倍增最近公共祖先(LCA)","date":"2017-08-29T15:14:00.000Z","path":"/post/Algorithm/LCA.html","text":"对于有根树T的两个结点u、v，最近公共祖先LCA(T,u,v)表示一个结点x，满足x是u、v的祖先且x的深度尽可能大。 在树上,两点之间的最短路就是公共祖先分别到两个节点的路径,因此最近公共祖先非常重要 常规而言,求两个节点的公共祖先的思路是两个节点如果不在同一深度,首先将更深的往上调整到另一个节点的深度,然后两个节点在同步往上走,直到走到同一个节点 但是这样就有一个问题就是:一步一步走,最坏情况下时间复杂度是O(n)那么就有了另一个思路:倍增 用 f[i][j] 表示节点i的2j辈祖先(比如f[5][0]即使节点5的父节点)很容易得到递推式 f[i][j] = f[f[i][j-1][j-1] 需要特别注意的是,根据递推式,可以发现应该先循环j,再循环ifor (int j = 1; j &lt; maxlog; ++j) for (int i = 1; i &lt;= n; ++i) parent[i][j] = parent[parent[i][j - 1]][j - 1]; 这样可以在O(nlog(n))的时间预处理好 对于a和b,有b=a+2^(log(b-a))那么在将两个节点调成深度一致的时候,就可以直接使用log倍增而之后两个节点同步上升的时候,则可以让他们直接倍增到最后一个两者祖先不相同的幂数按照这样查询的时间复杂度是O(log(n)) 而对于任意两点之间的距离、路径上最小边之类的内容,只需要在更新节点的时候计算下即可 模板如下,其中function(a,b)是需要维护的值的函数,可以是max(),min(),add()等内容// function() 是需要维护的值的函数,可以是 max() , min() , add() 等内容 void dfs(int t, int deep) &#123; depth[t] = deep; for (auto edge : edges[t]) &#123; int child = edge.c; if (parent[t][0] != child) &#123; parent[child][0] = t; weight[child][0] = edge.w; dfs(child, deep + 1); &#125; &#125;&#125;void lca() &#123; for (int j = 1; j &lt; maxlog; ++j) &#123; for (int i = 1; i &lt;= n; ++i) &#123; parent[i][j] = parent[parent[i][j - 1]][j - 1]; weight[i][j] = function(weight[i][j - 1], weight[parent[i][j - 1]][j - 1]); &#125; &#125;&#125;int query(int a, int b) &#123; int ans = 0; if (depth[a] &lt; depth[b]) swap(a, b); while (depth[a] != depth[b]) &#123; int dis = depth[a] - depth[b]; int step = (int)(log(dis) / log(2)); // 由于这里还要用到a,因此a要在后面再赋值 ans = function(ans, weight[a][step]); a = parent[a][step]; &#125; while (a != b) &#123; int step = 0; for (int i = 0; i &lt; maxlog; ++i) &#123; if (parent[a][i] == parent[b][i]) &#123; step = i - (i ? 1 : 0); break; &#125; &#125; ans = function(ans, function(weight[a][step], weight[b][step])); a = parent[a][step]; b = parent[b][step]; &#125; return ans;&#125;","tags":[{"name":"最近公共祖先","slug":"LCA","permalink":"https://www.oyohyee.com/tags/LCA/"},{"name":"树","slug":"Tree","permalink":"https://www.oyohyee.com/tags/Tree/"}]},{"title":"AOJ 905.Ohyee的考验","date":"2017-08-29T15:06:46.000Z","path":"/post/AOJ/905.html","text":"题目点击显/隐题目 有一个n个点m条边的连通无向图（无重边、无自环），点的编号为1~n。每条边都有一个正的边权，并且每条边边权互不相同（即数据保证该图的最小生成树唯一）。如果只是求最小生成树，那么Ohyee觉得太简单了，于是他决定考考你。对于每条边(u,v)都进行询问：——如果该边在最小生成树上，那么输出“Ohyee”；——如果该边不在最小生成树上，那么输出最小生成树上u,v两点路径中边权的最小值。原图最小生成树中的边是(1,2,2) (2,3,5) (4,1,3)对于输入的第三条边(3,4,7)，树上3-&gt;4的路径是3-&gt;2-&gt;1-&gt;4，边权分别是5,2,3，最小值是2。第一行输入两个整数n,m(2&lt;=n&lt;=100000,n-1&lt;=m&lt;=200000)接下来m行，每行输入三个整数u,v,w。u,v表示该边连接点的编号，w是边权。(1&lt;=w&lt;=1000000000)输出一共m行，按照输入的边的顺序回答每条边的询问。4 41 2 22 3 53 4 74 1 3OhyeeOhyee2Ohyee 题解前半部分很容易理解,最小生成树后半部分要维护最小生成树上u到v的路上最短的边(由于是一颗树,必然只有一条路) 由于数据量较大,一步一步找公共祖先不现实,需要倍增LCA 代码点击显/隐代码 Ohyee的考验代码备份#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;#define Log(format, ...) // printf(format, ##__VA_ARGS__)const int INF = 1000000005;const int maxn = 1e5 + 5;const int maxm = 2e5 + 5;const int maxlog = 18;int n,m;int f[maxn];bool use[maxm];vector&lt;int&gt; edges[maxn];int parent[maxn][maxlog];int depth[maxn];int weight[maxn][maxlog];struct Edge &#123; int u, v; int w; int n; bool operator&lt;(const Edge rhs) const &#123; return w &lt; rhs.w; &#125;&#125; e[maxm];bool compare(Edge a, Edge b) &#123; return a.n &lt; b.n; &#125;int pos;int ufs(int x) &#123; return f[x] == x ? x : f[x] = ufs(f[x]); &#125;int Kruskal(int n, int m) &#123; int w = 0; for (int i = 0; i &lt;= n; i++) f[i] = i; sort(e, e + m); for (int i = 0; i &lt; m; i++) &#123; int x = ufs(e[i].u), y = ufs(e[i].v); // printf(\"%d %d\\n\", x, y); if (x != y) &#123; f[x] = y; w += e[i].w; use[e[i].n] = true; edges[e[i].u].push_back(i); edges[e[i].v].push_back(i); &#125; &#125; return w;&#125;void addEdge(int u, int v, int w, int number = 0) &#123; e[pos].u = u; e[pos].v = v; e[pos].w = w; e[pos].n = number; pos++;&#125;void dfs(int t, int deep) &#123; depth[t] = deep; for (auto edge : edges[t]) &#123; int child = e[edge].u ^ e[edge].v ^ t; if (parent[t][0] != child) &#123; parent[child][0] = t; weight[child][0] = e[edge].w; dfs(child, deep + 1); &#125; &#125;&#125;void lca() &#123; for (int j = 1; j &lt; maxlog; ++j) &#123; for (int i = 1; i &lt;= n; ++i) &#123; parent[i][j] = parent[parent[i][j - 1]][j - 1]; weight[i][j] = min(weight[i][j - 1], weight[parent[i][j - 1]][j - 1]); &#125; &#125;&#125;int query(int a, int b) &#123; Log(\"Log(%d,%d)\\n\", a, b); int ans = INF; if (depth[a] &lt; depth[b]) swap(a, b); while (depth[a] != depth[b]) &#123; int dis = depth[a] - depth[b]; int step = (int)(log(dis) / log(2)); Log(\"\\t%d-&gt;%d (%d)\\n\", a, parent[a][step], weight[a][step]); ans = min(ans, weight[a][step]); // 由于这里还要用到a,因此a要在后面再赋值 a = parent[a][step]; &#125; Log(\"\\tthe same depth %d %d\\n\", a, b); while (a != b) &#123; int step = 0; for (int i = 0; i &lt; maxlog; ++i) &#123; if (parent[a][i] == parent[b][i]) &#123; step = i - (i ? 1 : 0); break; &#125; &#125; Log(\"\\tstep: %d a: %d-&gt;%d (%d) b: %d-&gt;%d (%d)\\n\", step, a, parent[a][step], weight[a][step], b, parent[b][step], weight[b][step]); ans = min(ans, min(weight[a][step], weight[b][step])); a = parent[a][step]; b = parent[b][step]; &#125; return ans;&#125;/*void lca(int t, int deep) &#123; depth[t] = deep; vector&lt;int&gt;::iterator it = edges[t].begin(); while (it != edges[t].end()) &#123; int v = e[*it].u ^ e[*it].v ^ t; if (parent[t] != v) &#123; parent[v] = t; weight[v] = e[*it].w; lca(v, deep + 1); &#125; ++it; &#125;&#125;int query(int a, int b, int n) &#123; int ans = INF; // printf(\"%d %d\\n\", a, b); if (depth[a] &gt; depth[b]) swap(a, b); while (depth[b] != depth[a]) &#123; // printf(\"%d -&gt; %d (%d)\\n\", b, parent[b], weight[b]); ans = min(ans, weight[b]); b = parent[b]; &#125; // printf(\"%d %d\\n\", a, b); while (a != b) &#123; // printf(\"%d -&gt; %d (%d)\\n\", a, parent[a], weight[a]); ans = min(ans, weight[a]); a = parent[a]; // printf(\"%d -&gt; %d (%d)\\n\", b, parent[b], weight[b]); ans = min(ans, weight[b]); b = parent[b]; &#125; return ans;&#125;*/int main() &#123; // int size = 256 &lt;&lt; 20; // 256MB // char *p = (char *)malloc(size) + size; //__asm__(\"movl %0, %%esp\\n\" ::\"r\"(p)); // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%d%d\", &amp;n, &amp;m)) &#123; memset(use, false, (m + 5) * sizeof(bool)); for (int i = 0; i &lt;= n; ++i) edges[i].clear(); for (int i = 0; i &lt; m; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w, i); &#125; // printf(\"read finish\\n\"); // printf(\"%d\\n\", Kruskal(n, m)); Kruskal(n, m); // printf(\"build tree finish\\n\"); parent[1][0] = 0; weight[1][0] = INF; dfs(1, 0); lca(); sort(e, e + m, compare); for (int i = 0; i &lt; m; ++i) &#123; if (use[i]) &#123; printf(\"Ohyee\\n\"); &#125; else &#123; printf(\"%d\\n\", query(e[i].u, e[i].v)); &#125; &#125; &#125; return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"最近公共祖先","slug":"LCA","permalink":"https://www.oyohyee.com/tags/LCA/"},{"name":"最小生成树","slug":"MST","permalink":"https://www.oyohyee.com/tags/MST/"},{"name":"Kruskal","slug":"Kruskal","permalink":"https://www.oyohyee.com/tags/Kruskal/"}]},{"title":"AOJ 911.组队分配","date":"2017-08-29T07:26:16.000Z","path":"/post/AOJ/911.html","text":"题目点击显/隐题目 有一个n个节点n-1条边组成的树。每个点看成一个人，连接u和v的边看成是“中意关系”，即u和v两个人都想和对方组队。每个人希望组队的对象有可能有多个。一支队伍由且仅由两个人组成，并且如果u和v组队了，那么u、v将不能和其他人再组成一支队。现在问你，这n个人最多能组成多少支队伍。（允许某些人组不了队）一种可行的组队方案：1与3组队4与5组队最多组成2支队第一行输入一个整数n,m(1&lt;=n&lt;=200000)接下来n-1行，每行两个整数u,v，表示u和v两个人都想和对方组队。数据保证是一个合法的树。输出一个整数，表示最多能组成多少支队伍。51 21 32 44 52 题解下意识写了匈牙利算法,不过这道题会爆时间再仔细看一下题目可以发现其实求树上父节点和子节点配对能配多少对可以用动态规划求解 用dp[t][0]表示编号为t的节点往下并且不选取节点t能达到的最多对数用dp[t][1]表示编号为t的节点往下并且选取节点t能达到的最多对数 很容易就可以发现 dp[t][0] = sum{ max(dp[child][0], dp[child][1])) }而 dp[t][1] 则根据是否存在没有选取的子节点(上一步有使用dp[child][0])有dp[t][1] = dp[t][0] 和 dp[t][1] = dp[t][0] + 1 代码点击显/隐代码 组队分配代码备份#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 200005;vector&lt;int&gt; e[maxn];int n;int parent[maxn];int dp[maxn][2];void init() &#123; memset(parent, 0, (n + 5) * sizeof(int)); for (int i = 0; i &lt;= n; ++i) e[i].clear();&#125;void addEdge(int u, int v) &#123; e[u].push_back(v); e[v].push_back(u);&#125;void dfs(int t) &#123; // printf(\"dfs(%d)\\n\", t); dp[t][0] = dp[t][1] = 0; bool emptyChild = false; for (auto child : e[t]) &#123; if (parent[t] != child) &#123; parent[child] = t; dfs(child); if (dp[child][0] &lt; dp[child][1]) &#123; dp[t][0] += dp[child][1]; &#125; else &#123; emptyChild = true; dp[t][0] += dp[child][0]; &#125; &#125; &#125; dp[t][1] = dp[t][0] + emptyChild; // printf(\"dp[%d]=&#123;%d,%d&#125;\\n\", t, dp[t][0], dp[t][1]);&#125;int main() &#123; while (~scanf(\"%d\", &amp;n)) &#123; init(); for (int i = 1; i &lt; n; ++i) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); addEdge(a, b); &#125; dfs(1); printf(\"%d\\n\", max(dp[1][0], dp[1][1])); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"树形dp","slug":"Tree-dp","permalink":"https://www.oyohyee.com/tags/Tree-dp/"}]},{"title":"AOJ 907.进制转换","date":"2017-08-25T09:37:09.000Z","path":"/post/AOJ/907.html","text":"题目点击显/隐题目 给定一个十进制正整数a和一个数字d，你需要将a转换成d进制并输出。数字a转换成d进制后，每一个数位都是0~d-1之间的十进制整数。对于样例2：196=350^1 + 4650^0第一行一个十进制正整数a(a&lt;=10^3000)。第二行一个正整数d(2&lt;=d&lt;=100)将数字a转换成d进制从高位到低位依次输出（不要前导0），中间用空格隔开。样例一：532样例二：19650样例一：110101样例二：346 题解高精度下的进制转换 代码点击显/隐代码 进制转换代码备份#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;/** 完全大数模板 修改版* 输出cin&gt;&gt;a* 输出a.print();* 注意这个输入不能自动去掉前导0的，可以先读入到char数组，去掉前导0，再用构造函数。* by kuangbin GG.*/#define MAXN 9999#define MAXSIZE 1010#define DLEN 4class BigNum &#123; private: int a[5000]; //可以控制大数的位数 int len; public: BigNum() &#123; len = 1; memset(a, 0, sizeof(a)); &#125; //构造函数 BigNum(const long long); //将一个int类型的变量转化成大数 BigNum(const char *); //将一个字符串类型的变量转化为大数 BigNum(const BigNum &amp;); //拷贝构造函数 BigNum &amp;operator=(const BigNum &amp;); //重载赋值运算符，大数之间进行赋值运算 friend istream &amp;operator&gt;&gt;(istream &amp;, BigNum &amp;); //重载输入运算符 friend ostream &amp;operator&lt;&lt;(ostream &amp;, BigNum &amp;); //重载输出运算符 BigNum operator+(const BigNum &amp;) const; //重载加法运算符，两个大数之间的相加运算 BigNum operator-(const BigNum &amp;) const; //重载减法运算符，两个大数之间的相减运算 BigNum operator*(const BigNum &amp;)const; //重载乘法运算符，两个大数之间的相乘运算 BigNum operator/(const int &amp;) const; //重载除法运算符，大数对一个整数进行相除运算 BigNum operator^(const int &amp;) const; //大数的n次方运算 int operator%(const int &amp;) const; //大数对一个int类型的变量进行取模运算 bool operator&gt;(const BigNum &amp;T) const; //大数和另一个大数的大小比较 bool operator&gt;(const int &amp;t) const; //大数和一个int类型的变量的大小比较 void print(); //输出大数 void read(const char *s); //从字符串读入 void pre0(char *s); //取出字符串的前导0;&#125;;BigNum::BigNum(const long long b) //将一个int类型的变量转化为大数&#123; long long c, d = b; len = 0; memset(a, 0, sizeof(a)); while (d &gt; MAXN) &#123; c = d - (d / (MAXN + 1)) * (MAXN + 1); d = d / (MAXN + 1); a[len++] = c; &#125; a[len++] = d;&#125;BigNum::BigNum(const char *s) //将一个字符串类型的变量转化为大数&#123; int t, k, index, L, i; memset(a, 0, sizeof(a)); L = strlen(s); len = L / DLEN; if (L % DLEN) len++; index = 0; for (i = L - 1; i &gt;= 0; i -= DLEN) &#123; t = 0; k = i - DLEN + 1; if (k &lt; 0) k = 0; for (int j = k; j &lt;= i; j++) t = t * 10 + s[j] - '0'; a[index++] = t; &#125;&#125;BigNum::BigNum(const BigNum &amp;T) : len(T.len) //拷贝构造函数&#123; int i; memset(a, 0, sizeof(a)); for (i = 0; i &lt; len; i++) a[i] = T.a[i];&#125;BigNum &amp;BigNum::operator=(const BigNum &amp;n) //重载赋值运算符，大数之间赋值运算&#123; int i; len = n.len; memset(a, 0, sizeof(a)); for (i = 0; i &lt; len; i++) a[i] = n.a[i]; return *this;&#125;istream &amp;operator&gt;&gt;(istream &amp;in, BigNum &amp;b) &#123; char ch[MAXSIZE * 4]; int i = -1; in &gt;&gt; ch; int L = strlen(ch); int count = 0, sum = 0; for (i = L - 1; i &gt;= 0;) &#123; sum = 0; int t = 1; for (int j = 0; j &lt; 4 &amp;&amp; i &gt;= 0; j++, i--, t *= 10) &#123; sum += (ch[i] - '0') * t; &#125; b.a[count] = sum; count++; &#125; b.len = count++; return in;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;out, BigNum &amp;b) //重载输出运算符&#123; int i; cout &lt;&lt; b.a[b.len - 1]; for (i = b.len - 2; i &gt;= 0; i--) &#123; printf(\"%04d\", b.a[i]); &#125; return out;&#125;BigNum BigNum::operator+(const BigNum &amp;T) const //两个大数之间的相加运算&#123; BigNum t(*this); int i, big; big = T.len &gt; len ? T.len : len; for (i = 0; i &lt; big; i++) &#123; t.a[i] += T.a[i]; if (t.a[i] &gt; MAXN) &#123; t.a[i + 1]++; t.a[i] -= MAXN + 1; &#125; &#125; if (t.a[big] != 0) t.len = big + 1; else t.len = big; return t;&#125;BigNum BigNum::operator-(const BigNum &amp;T) const //两个大数之间的相减运算&#123; int i, j, big; bool flag; BigNum t1, t2; if (*this &gt; T) &#123; t1 = *this; t2 = T; flag = 0; &#125; else &#123; t1 = T; t2 = *this; flag = 1; &#125; big = t1.len; for (i = 0; i &lt; big; i++) &#123; if (t1.a[i] &lt; t2.a[i]) &#123; j = i + 1; while (t1.a[j] == 0) j++; t1.a[j--]--; while (j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; &#125; else t1.a[i] -= t2.a[i]; &#125; t1.len = big; while (t1.a[len - 1] == 0 &amp;&amp; t1.len &gt; 1) &#123; t1.len--; big--; &#125; if (flag) t1.a[big - 1] = 0 - t1.a[big - 1]; return t1;&#125;BigNum BigNum::operator*(const BigNum &amp;T) const //两个大数之间的相乘&#123; BigNum ret; int i, j=0, up; int temp, temp1; for (i = 0; i &lt; len; i++) &#123; up = 0; for (j = 0; j &lt; T.len; j++) &#123; temp = a[i] * T.a[j] + ret.a[i + j] + up; if (temp &gt; MAXN) &#123; temp1 = temp - temp / (MAXN + 1) * (MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; &#125; else &#123; up = 0; ret.a[i + j] = temp; &#125; &#125; if (up != 0) ret.a[i + j] = up; &#125; ret.len = i + j; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;BigNum BigNum::operator/(const int &amp;b) const //大数对一个整数进行相除运算&#123; BigNum ret; int i, down = 0; for (i = len - 1; i &gt;= 0; i--) &#123; ret.a[i] = (a[i] + down * (MAXN + 1)) / b; down = a[i] + down * (MAXN + 1) - ret.a[i] * b; &#125; ret.len = len; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;int BigNum::operator%(const int &amp;b) const //大数对一个 int类型的变量进行取模&#123; int i, d = 0; for (i = len - 1; i &gt;= 0; i--) d = ((d * (MAXN + 1)) % b + a[i]) % b; return d;&#125;BigNum BigNum::operator^(const int &amp;n) const //大数的n次方运算&#123; BigNum t, ret(1); int i; if (n &lt; 0) return -1; if (n == 0) return 1; if (n == 1) return *this; int m = n; while (m &gt; 1) &#123; t = *this; for (i = 1; (i &lt;&lt; 1) &lt;= m; i &lt;&lt;= 1) t = t * t; m -= i; ret = ret * t; if (m == 1) ret = ret * (*this); &#125; return ret;&#125;bool BigNum::operator&gt;(const BigNum &amp;T) const //大数和另一个大数的大小比较&#123; int ln; if (len &gt; T.len) return true; else if (len == T.len) &#123; ln = len - 1; while (a[ln] == T.a[ln] &amp;&amp; ln &gt;= 0) ln--; if (ln &gt;= 0 &amp;&amp; a[ln] &gt; T.a[ln]) return true; else return false; &#125; else return false;&#125;bool BigNum::operator&gt;(const int &amp;t) const //大数和一个int类型的变量的大小比较&#123; BigNum b(t); return *this &gt; b;&#125;void BigNum::print() //输出大数&#123; int i; printf(\"%d\", a[len - 1]); for (i = len - 2; i &gt;= 0; i--) printf(\"%04d\", a[i]); printf(\"\\n\");&#125;void BigNum::read(const char *s) &#123; int t, k, index, L, i; memset(a, 0, sizeof(a)); L = strlen(s); len = L / DLEN; if (L % DLEN) len++; index = 0; for (i = L - 1; i &gt;= 0; i -= DLEN) &#123; t = 0; k = i - DLEN + 1; if (k &lt; 0) k = 0; for (int j = k; j &lt;= i; j++) t = t * 10 + s[j] - '0'; a[index++] = t; &#125;&#125;void pre0(char *s) &#123; int pos = 0; int len = strlen(s); for (int i = 0; i &lt; len; i++) &#123; if (s[i] != '0') &#123; pos = i; break; &#125; &#125; for (int i = pos; i &lt; len; i++) s[i - pos] = s[i]; s[len - pos] = '\\0';&#125;char s[3005];BigNum n, zero;int ans[150000];int main() &#123; int d; while (~scanf(\"%s%d\", s, &amp;d)) &#123; pre0(s); n = BigNum(s); zero = BigNum(0LL); int pos = 0; while (n &gt; zero) &#123; ans[pos++] = n % d; n = n / d; &#125; for (int i = pos - 1; i &gt;= 0; --i) &#123; printf(\"%d\\n\", ans[i]); &#125; printf(\"\\n\"); &#125; return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"高精度算法","slug":"High-precision","permalink":"https://www.oyohyee.com/tags/High-precision/"}]},{"title":"HDU 6154.CaoHaha's staff","date":"2017-08-25T08:57:20.000Z","path":"/post/HDU/6154.html","text":"题目点击显/隐题目 “You shall not pass!”After shouted out that,the Force Staff appered in CaoHaha’s hand.As we all know,the Force Staff is a staff with infinity power.If you can use it skillful,it may help you to do whatever you want.But now,his new owner,CaoHaha,is a sorcerers apprentice.He can only use that staff to send things to other place.Today,Dreamwyy come to CaoHaha.Requesting him send a toy to his new girl friend.It was so far that Dreamwyy can only resort to CaoHaha.The first step to send something is draw a Magic array on a Magic place.The magic place looks like a coordinate system,and each time you can draw a segments either on cell sides or on cell diagonals.In additional,you need 1 minutes to draw a segments.If you want to send something ,you need to draw a Magic array which is not smaller than the that.You can make it any deformation,so what really matters is the size of the object.CaoHaha want to help dreamwyy but his time is valuable(to learn to be just like you),so he want to draw least segments.However,because of his bad math,he needs your help.The first line contains one integer T(T&lt;=300).The number of toys.Then T lines each contains one intetger S.The size of the toy(N&lt;=1e9).Out put T integer in each line ,the least time CaoHaha can send the toy.51234544667 题解 给你一个面积,在平面坐标系中最少用多少长度为1和√2的边能围出来 这种题基本上就是找规律的问题,首先画出来前几种的形状首先要明确的原则是: 周长越大围的面积也越大,也即尽可能多用√2 周长相同的情况下越圆面积越大 如下图:很容易发现,在7条边向8条边转换的时候,虽然正八边形更接近圆形,但是围出来正方形(菱形)面积更大 那么就可以看出来,其实只要是正好是4的倍数条边的时候能围成正方形面积最大剩下只剩下3种情况,分别是向外拓展1、2、3条边,也是有规律的 打表记录有i个边能最大围出来多大,然后二分查找即可 最大面积是1e9 围成正方形需要的边是 4*√(1e9/2)=1.2e5表只需要打到 1.5e5 即可 代码点击显/隐代码 CaoHaha's staff代码备份#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 150000;long long f[maxn];void calc() &#123; f[0] = f[1] = f[2] = f[3] = 0; f[4] = 2; f[5] = 2; f[6] = 4; f[7] = 5; for (long long i = 2; i &lt; (maxn / 4) - 1; ++i) &#123; f[i * 4] = i * i * 2; f[i * 4 + 1] = f[i * 4] + (i + i - 1) / 2; f[i * 4 + 2] = f[i * 4] + i * 2; f[i * 4 + 3] = f[i * 4 + 2] + (i + i + 1) / 2; &#125;&#125;int main() &#123; // freopen(\"out.txt\",\"w\",stdout); int T; scanf(\"%d\", &amp;T); calc(); /* for (int i = 1; i &lt; 100; ++i) &#123; printf(\"%d %d\\n\", i, lower_bound(f, f + maxn, i) - f); &#125; */ while (T--) &#123; long long n; scanf(\"%I64d\", &amp;n); printf(\"%d\\n\", lower_bound(f, f + maxn, n) - f); &#125; return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"递推","slug":"Recurrence","permalink":"https://www.oyohyee.com/tags/Recurrence/"}]},{"title":"HDU 6170.Two strings","date":"2017-08-22T15:07:09.000Z","path":"/post/HDU/6170.html","text":"题目点击显/隐题目 Giving two strings and you should judge if they are matched. The first string contains lowercase letters and uppercase letters. The second string contains lowercase letters, uppercase letters, and special symbols: “.” and “*”. . can match any letter, and means the front character can appear any times. For example, “a.b” can match “acb” or “abb”, “a\\” can match “a”, “aa” and even empty string. ( “*” will not appear in the front of the string, and there will not be two consecutive “*”.The first line contains an integer T implying the number of test cases. (T≤15)For each test case, there are two lines implying the two strings (The length of the two strings is less than 2500).For each test case, print “yes” if the two strings are matched, otherwise print “no”.3aaa*abba.*abbaabyesyesno 题解正则表达式基本上可以在读题都一半的时候确定是正则表达式的问题通常来说,这种问题一半会使用AC自动机来解答,不过其实可以试一下C++11的正则表达式库的 首先确定题意的时候可以发现,这里和标准的正则表达式语句存在一些不同.* 在标准的正则表达式中是匹配任意字符串,而这里是匹配任意的连续字符串相当于 (.)?\\1* 当然,还需要考虑*可以匹配0次,但是这是正则表达式本身就有的语法因此,简单思路就是先把 .* 替换成 (.)?\\1* (在源码里要写成(.)?\\\\1*)然后直接匹配即可相应部分的代码如下具体实现代码见正则表达式源码 需要特别注意的是,虽然同样是无脑用库,但是Java会超时另外C++11的Regex库存在的bug比较多,只有比较简单的匹配才能放心使用比如aba匹配abababa是无法得到3的,无法使用类似这样的(?=(aba))零宽断言语法来实现(其他语言可以) 动态规划按照动态规划的思路,很容易得到dp[i][j]表示字符串a的前i个字符和字符串b的前j的字符能否匹配假如我们要匹配 aaaaaa 和 ab*a* 对于第一个位置(最左上角),显然当两者相等的时候为true其同一行已经没有能够匹配的了第二行可以发现b不等于a全部都是false第三行的*可以将上一行的b匹配0次,这时,当前位置能否匹配成功取决于它上面的上面是否能匹配第四行有a和a相同,位置能否匹配取决于其左上角的能否匹配第五行的*可以匹配任意长度,匹配两个时候相当于该位置取决于上面能否匹配;匹配更多个的时候相当于只要其对应的a中的字符和它左面的相同,就可以将左面能否匹配的状态传递过来 另外,.可以看作一个普通字符,只是能和所有的字符都匹配综上所述,总共只包含很少的状态转移条件 串内容相同(或者存在’.’或者为第一个位置):dp[i][j] |= dp[i-1][j-1] 匹配到*:dp[i][j] |= dp[i][j-2] | dp[i][j-1] 匹配到*,并且当前位置和其左面的字符相同:dp[i][j] |= dp[i-1][j] 这样就可以写出基本的dp框架了然后就会发现我们漏掉了一个特殊情况bbbbbb匹配a*b*由于开始位置匹配失败,导致后面所有位置都无法为true只有b[1]==&#39;*&#39;的时候才会导致这个错误相当于特殊情况下的状态转移1其条件如下: 串内容相同或者存在.,同时i=0,b[1]=&#39;*&#39; 这样就可以写出完整的状态转移方程了 代码正则表达式点击显/隐代码 Two strings代码备份#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;regex&gt;using namespace std;void string_replace(string &amp;s1, const string &amp;s2, const string &amp;s3) &#123; string::size_type pos = 0; string::size_type a = s2.size(); string::size_type b = s3.size(); while ((pos = s1.find(s2, pos)) != string::npos) &#123; s1.replace(pos, a, s3); pos += b; &#125;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while (T--) &#123; string text, re; cin &gt;&gt; text &gt;&gt; re; //cout &lt;&lt; text &lt;&lt; endl &lt;&lt; re &lt;&lt; endl; string_replace(re, \".*\", \"(.)?\\\\1*\"); // cout &lt;&lt; text &lt;&lt;\" \"&lt;&lt; re &lt;&lt; endl; regex e(re); cout &lt;&lt; (regex_match(text, e) ? \"yes\" : \"no\") &lt;&lt; endl; &#125; return 0;&#125; 动态规划点击显/隐代码 Two strings代码备份#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 3505;char a[maxn], b[maxn];bool dp[maxn][maxn];int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; // scanf(\"%d\", &amp;T); // getchar(); while (T--) &#123; cin &gt;&gt; a &gt;&gt; b; // scanf(\"\\n%[^\\n]\\n%[^\\n]\", a, b); // fgets(a,maxn,stdin); // fgets(b,maxn,stdin); memset(dp, false, sizeof(dp)); // printf(\"%d\\na:%s\\nb:%s\\n\",T, a, b); int n = strlen(a); int m = strlen(b); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; m; ++j) &#123; // 第一个位置 if ((a[i] == b[j] || b[j] == '.') &amp;&amp; i == 0 &amp;&amp; j == 0) dp[i][j] |= true; // 从左上角转移过来 if ((a[i] == b[j] || b[j] == '.') &amp;&amp; i &gt; 0 &amp;&amp; j &gt; 0) dp[i][j] |= dp[i - 1][j - 1]; // 特判 if ((a[i] == b[j] || b[j] == '.') &amp;&amp; b[1] == '*' &amp;&amp; i == 0) dp[i][j] = true; // * 匹配 // 从上面的上面转移过来（匹配0个） //从上面转移过来（匹配1个） if (b[j] == '*') dp[i][j] |= (j &gt;= 2 ? dp[i][j - 2] : 0) | (j &gt;= 1 ? dp[i][j - 1] : 0); // 从左面转移过来（*往后续） if (b[j] == '*' &amp;&amp; i &gt;= 1 &amp;&amp; a[i - 1] == a[i]) dp[i][j] |= dp[i - 1][j]; &#125; // for (int i = 0; i &lt; n; ++i) &#123; // for (int j = 0; j &lt; m; ++j) // printf(\"%d \", dp[i][j]); // printf(\"\\n\"); // &#125; // printf(\"%s\\n\", (dp[n - 1][m - 1] ? \"yes\" : \"no\")); cout &lt;&lt; (dp[n - 1][m - 1] ? \"yes\" : \"no\") &lt;&lt; endl; &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"正则表达式","slug":"RegEx","permalink":"https://www.oyohyee.com/tags/RegEx/"}]},{"title":"HDU 1686.Oulipo","date":"2017-08-22T12:53:39.000Z","path":"/post/HDU/1686.html","text":"题目点击显/隐题目 The French author Georges Perec (1936–1982) once wrote a book, La disparition, without the letter ‘e’. He was a member of the Oulipo group. A quote from the book: Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais… Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given “word” as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of 500,000 consecutive ‘T’s is not unusual. And they never use spaces. So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet {‘A’, ‘B’, ‘C’, …, ‘Z’} and two finite strings over that alphabet, a word W and a text T, count the number of occurrences of W in T. All the consecutive characters of W must exactly match consecutive characters of T. Occurrences may overlap.The first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format:One line with the word W, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with 1 ≤ |W| ≤ 10,000 (here |W| denotes the length of the string W).One line with the text T, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with |W| ≤ |T| ≤ 1,000,000.For every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word W in the text T.3BAPCBAPCAZAAZAZAZAVERDIAVERDXIVYERDIAN130 题解KMP算法,需要理解next数组的意义 首先回顾一下KMP的步骤ABABABBABBAABBAABABBAAB 00011ABABABBABBAABBAABABBAAB00011ABABABBABBAABBAAB ABBAAB 00011ABABABBABBAABBAAB ABBAAB 00011ABABABBABBAABBAAB ABBAAB 00011 当遇到不匹配的时候,跳转到其对应的next指针位置(从开始位置到该位置之前的内容与当前位置前的内容相同) 当匹配结束后,我们可以”假装”匹配失败,这样就会紧接着往下匹配记一下数即可 与正常的kmp的区别仅在于++ans;--i;j = next[j - 1]; 代码点击显/隐代码 Oulipo代码备份#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 1000005;char s1[maxn], s2[maxn];int next[maxn];void getNext(char *s) &#123; int len = strlen(s); next[0] = -1; for (int i = 1; i &lt; len; ++i) &#123; int t = next[i - 1]; while (t != -1 &amp;&amp; s[t] != s[i - 1]) t = next[t]; next[i] = (s[i - 1] == s[t] ? t + 1 : 0); &#125; //for (int i = 0; i &lt;= len; ++i) // printf(\"next[%d]=%d\\n\", i, next[i]);&#125;int KMP(char *a, char *b) &#123; getNext(b); int alen = strlen(a); int blen = strlen(b); int i = 0, j = 0; int ans = 0; while (i != alen) &#123; //printf(\"judge a[%d](%c) b[%d](%c)\\n\", i, a[i], j, b[j]); while (j != -1 &amp;&amp; a[i] != b[j]) j = next[j]; ++i, ++j; if (j == blen) &#123; //printf(\"match at %d\\n\", i - blen); ++ans; --i; j = next[j - 1]; &#125; &#125; return ans;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%s%s\", s1, s2); printf(\"%d\\n\", KMP(s2, s1)); &#125; return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"KMP","slug":"KMP","permalink":"https://www.oyohyee.com/tags/KMP/"}]},{"title":"AOJ 902.最讨厌的“2”","date":"2017-08-21T16:44:48.000Z","path":"/post/AOJ/902.html","text":"题目点击显/隐题目 有一个长度为n的数组a。现有m组操作。操作1：将区间[l,r]内的所有数字都整除2。操作2：输出区间[l,r]内所有数字的和。第一行输入两个整数n,m(1&lt;=n&lt;=200000,1&lt;=m&lt;=200000)第二行n个整数，表示数组a (0&lt;=a[i]&lt;=10^9)接下来m行，每行三个整数op,l,r——若op=1，表示操作1，将[l,r]内所有数字整除2——若op=2，表示操作2，输出[l,r]内所有数字的和对于所有的操作2，输出结果。5 53 4 9 2 72 3 41 4 52 1 51 3 42 3 511207 题解线段树问题,需要注意的是,虽然查询次数多的情况下通常会使用lazy标记但是这道题除以2的操作使用lazy标记很难实现另外可以发现一个数即使达到输入范围的最大值 10^9 ,其也能在仅仅30次操作后变成 0 那么就可以想到,如果我们查询到一个节点的值已经是0,就没有必要往下查,直接返回 0 即可,更新同理这样其实查询的复杂度远远少于 O(log(n)) 另外由于数比较大,需要使用long long记录和 代码点击显/隐代码 最讨厌的“2”代码备份#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;ctime&gt;const int maxn = 2e5 + 5;typedef long long LL;int n, m;LL a[maxn];LL read_int() &#123; char c; LL ans = 0; while (c = getchar(), !(c &gt;= '0' &amp;&amp; c &lt;= '9')) ; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ans *= 10; ans += (int)c - '0'; c = getchar(); &#125; return ans;&#125;long long add(long long a, long long b) &#123; return a + b; &#125;class ST &#123; struct Tree &#123; int l, r; LL n; &#125;; Tree T[maxn * 8]; public: inline static int getLastRowBeginPosition(int n) &#123; int ans = 1 &lt;&lt; ((int)(log(n) / log(2))); if (ans &lt; n) ans &lt;&lt;= 1; return ans; &#125; LL BuildTree(int a, int b, LL (*compare)(LL, LL), LL *num, int pos = 1) &#123; // printf(\"build(%d,%d,%d)\\n\", a, b, pos); T[pos].l = a; T[pos].r = b; if (a == b) &#123; if (a &gt; n) return T[pos].n = 0; else return T[pos].n = num[a]; &#125; int mid = (a + b) &gt;&gt; 1; int leftchild = pos &lt;&lt; 1; int rightchild = (pos &lt;&lt; 1) + 1; return T[pos].n = compare(BuildTree(a, mid, compare, num, leftchild), BuildTree(mid + 1, b, compare, num, rightchild)); &#125; LL query(int a, int b, LL (*compare)(LL, LL), LL *num, int pos = 1) &#123; // printf(\"query(%d,%d,%d)\\n\", a, b, pos); if (a == b) return T[getLastRowBeginPosition(n) - 1 + a].n; if (T[pos].n == 0) return 0; int &amp;l = T[pos].l; int &amp;r = T[pos].r; if (a == l &amp;&amp; b == r) return T[pos].n; int mid = (l + r) &gt;&gt; 1; int leftchild = pos &lt;&lt; 1; int rightchild = (pos &lt;&lt; 1) + 1; if (b &lt;= mid) return query(a, b, compare, num, leftchild); if (a &gt; mid) return query(a, b, compare, num, rightchild); return compare(query(a, mid, compare, num, leftchild), query(mid + 1, b, compare, num, rightchild)); &#125; LL update(int a, int b, LL (*compare)(LL, LL), LL *num, int pos = 1) &#123; // printf(\" update(%d,%d,%d)\\n\", a, b, pos); int &amp;l = T[pos].l; int &amp;r = T[pos].r; if (l == r) return T[pos].n &gt;&gt;= 1; if (T[pos].n == 0) return 0; int mid = (l + r) &gt;&gt; 1; int leftchild = pos &lt;&lt; 1; int rightchild = (pos &lt;&lt; 1) + 1; if (b &lt;= mid) &#123; T[pos].n = compare(update(a, b, compare, num, leftchild), T[rightchild].n); &#125; else if (a &gt; mid) &#123; T[pos].n = compare(T[leftchild].n, update(a, b, compare, num, rightchild)); &#125; else &#123; T[pos].n = compare(update(a, mid, compare, num, leftchild), update(mid + 1, b, compare, num, rightchild)); &#125; return T[pos].n; &#125; void printTree() &#123; for (int i = 1; i &lt; getLastRowBeginPosition(n) &lt;&lt; 1; ++i) &#123; if ((i &gt; 0) &amp;&amp; (i &amp; (i - 1)) == 0) printf(\"\\n\"); printf(\"[%d (%d,%d) %I64d] \", i, T[i].l, T[i].r, T[i].n); &#125; printf(\"\\n\"); &#125;&#125;;ST tree;int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); //int START = clock(); while (~scanf(\"%d%d\", &amp;n, &amp;m)) &#123; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%I64d\", &amp;a[i]); // printf(\"%d\\n\",i); &#125; // printf(\"read finish\\n\"); tree.BuildTree(1, ST::getLastRowBeginPosition(n), add, a); // tree.printTree(); for (int i = 1; i &lt;= m; ++i) &#123; int c, l, r; scanf(\"%d%d%d\", &amp;c, &amp;l, &amp;r); if (c == 1) tree.update(l, r, add, a); else printf(\"%I64d\\n\", tree.query(l, r, add, a)); // tree.printTree(); &#125; &#125; //printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"线段树","slug":"Segment-tree","permalink":"https://www.oyohyee.com/tags/Segment-tree/"}]},{"title":"AOJ 901.snow halation","date":"2017-08-21T16:39:07.000Z","path":"/post/AOJ/901.html","text":"题目点击显/隐题目 《snow halation》是μ’s的第二张单曲，其歌曲第二段伴奏结束后主唱穗乃果唱出“届けて”的同时，全场应援棒瞬间从白色转换成橙色。由于高度的整齐和效果的震撼，被称为“橙色的奇迹”，这也是“如果奇迹有颜色，那么一定是XX色”的最早来源。 现在，到了你来应援的时候了！使用不同的应援形式有不同的效果（如里打、里跳、快挥、前挥、GT警报……），比如通常会GT警报后接着做里跳，这样能够让人更加沉迷到演唱会的气氛中。经过精密的计算，我们终于得到了不同的应援形式连着对活跃气氛的贡献值（增加气氛的活跃值）。现在给你一首歌的call表(记录应该如何应援)，里面有一部分是0（代表这个动作可以自己随意选择），另一部分是非0整数，表示这个时候有规定的动作要做。求这首歌能达到的最大气氛活跃值。初始的气氛活跃值为0，第一个应援动作对气氛无影响。样例解释：23 583 86 7715 93 3586 92 493 3 3 1 23 3 3 1 2没有可以自己随便选的,直接计算得到49+49+86+86=2705 1036 11 68 67 2982 30 62 23 6735 29 2 22 5869 67 93 56 1142 29 73 21 190 0 5 0 4 0 0 0 4 04 3 5 1 4 1 4 1 4 5按照这样的顺序来选可以达到最大值 93+58+42+67+69+67+69+67+93=625第1行：组数T（非负整数，1&lt;=T&lt;=10）第2行：应援动作数n，call表长度m（非负整数，0&lt;=n，m&lt;=100）第3~3+n行：每行n个整数，表示在第i个动作后接j的气氛贡献值，Wi,j表示当前行第j个。（|Wi,j|&lt;=100）第4+n行：m个非负整数a[i]，表示call表内容。（0&lt;=a[i]&lt;=n）……一行，一个整数，表示能达到的最大气氛活跃值。23 583 86 7715 93 3586 92 493 3 3 1 25 1036 11 68 67 2982 30 62 23 6735 29 2 22 5869 67 93 56 1142 29 73 21 190 0 5 0 4 0 0 0 4 0270625 题解修改自 HDU 5074.Hatsune Miku(2014 鞍山赛区现场赛 E) 需要额外考虑活跃贡献值为负数的情况 代码点击显/隐代码 snow halation代码备份#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 105;const int INF = 99999;int n, m;int a[maxn];int dp[maxn][maxn];int w[maxn][maxn];// 初始化void init() &#123; for (int i = 0; i &lt;= m; ++i) for (int j = 0; j &lt;= n; ++j) if (i == 1) dp[i][j] = 0; else dp[i][j] = -INF;&#125;// 进行 dpvoid f(int i, int l, int t) &#123; if (dp[i][t] == -INF) dp[i][t] = dp[i - 1][l] + w[l][t]; else dp[i][t] = max(dp[i][t], dp[i - 1][l] + w[l][t]);&#125;// 枚举 tvoid T(int i, int l) &#123; if (a[i] == 0) &#123; for (int t = 1; t &lt;= n; ++t) f(i, l, t); &#125; else &#123; f(i, l, a[i]); &#125;&#125;// 枚举 lvoid L(int i) &#123; if (a[i - 1] == 0) &#123; for (int l = 1; l &lt;= n; ++l) T(i, l); &#125; else &#123; T(i, a[i - 1]); &#125;&#125;int main() &#123; //freopen(\"in.txt\",\"r\",stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; // 读入数据 scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) scanf(\"%d\", &amp;w[i][j]); for (int i = 1; i &lt;= m; ++i) scanf(\"%d\", &amp;a[i]); // dp运算 init(); for (int i = 2; i &lt;= m; ++i) L(i); // for (int i = 0; i &lt;= m; ++i) &#123; // for (int j = 0; j &lt;= n; ++j) // printf(\"%d \", dp[i][j]); // printf(\"\\n\"); // &#125; //找出最优解 int ans = -INF; for (int i = 1; i &lt;= n; ++i) ans = max(ans, dp[m][i]); printf(\"%d\\n\", ans); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"LOVELIVE","slug":"LOVELIVE","permalink":"https://www.oyohyee.com/tags/LOVELIVE/"}]},{"title":"AOJ 884.奇数统计","date":"2017-08-21T16:35:47.000Z","path":"/post/AOJ/884.html","text":"题目点击显/隐题目 给出N个正整数，其中只有一个数出现了奇数次，其余的数都出现偶数次。你现在需要求出那个出现了奇数次的数。对于100%的数据，1≤n≤500000，n肯定是奇数。所有出现的数都不超过10000。输入共两行，第一行包含一个整数n，表示给出的正整数个数。第二行有n个正整数，每两个正整数之间用一个空格隔开，表示给出的正整数。输出共一行，包含一个整数，表示奇数次的那个数。93 1 2 2 17 1 3 17 33 题解根据 a^a^b = b 的原理将所有数求一遍异或即可 代码点击显/隐代码 奇数统计代码备份#include &lt;cstdio&gt;int read_int() &#123; char c; int ans = 0; while(c = getchar(),!(c &gt;= '0'&amp;&amp;c &lt;= '9')); while(c &gt;= '0'&amp;&amp;c &lt;= '9') &#123; ans *= 10; ans += (int)c - '0'; c = getchar(); &#125; return ans;&#125;int main()&#123; int n=read_int(); int ans = 0; while(n--)&#123; ans ^= read_int(); &#125; printf(\"%d\\n\",ans); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"位运算","slug":"Bit","permalink":"https://www.oyohyee.com/tags/Bit/"}]},{"title":"HDU 6152.Friend-Graph","date":"2017-08-19T14:41:21.000Z","path":"/post/HDU/6152.html","text":"题目点击显/隐题目 It is well known that small groups are not conducive of the development of a team. Therefore, there shouldn’t be any small groups in a good team. In a team with n members,if there are three or more members are not friends with each other or there are three or more members who are friends with each other. The team meeting the above conditions can be called a bad team.Otherwise,the team is a good team. A company is going to make an assessment of each team in this company. We have known the team with n members and all the friend relationship among these n individuals. Please judge whether it is a good team.The first line of the input gives the number of test cases T; T test cases follow.（T&lt;=15）The first line od each case should contain one integers n, representing the number of people of the team.($n \\leq 3000$)Then there are n-1 rows. The $i$th row should contain n-i numbers, in which number $a_{i j}$ represents the relationship between member i and member j+i. 0 means these two individuals are not friends. 1 means these two individuals are friends.Please output ”Great Team!” if this team is a good team, otherwise please output “Bad Team!”.141 1 00 01Great Team! 题解 判断一个无向图中是否存在3个点没有直接联通，或者3个点直接互联通 可以转换为是否有点有三个及三个以上的边,或者有三个以上的点与他没有边可以发现5个点按照正五边形连接是极端情况了,再多一个点,无论怎么连都无法满足要求因此,当 n&gt;=6 时必定是 Bad Team!对于 n&lt;6 的情况暴力求解即可 需要注意的是,数组开到 7*7 即可,开 1e5*1e5 会爆内存另外如果 n&gt;=6 ,读入仍然需要一个一个读,不能一次读一行(最后一行没有 \\n) 代码点击显/隐代码 Friend-Graph代码备份#include &lt;cstdio&gt;using namespace std;const int maxn = 10;int n;int r[maxn][maxn];bool judge() &#123; for (int i = 1; i &lt;= n; ++i) &#123; int friends = 0, notfriends = 0; for (int j = 1; j &lt;= n; ++j) &#123; if (i != j) &#123; if (r[i][j] == 1) ++friends; else ++notfriends; &#125; &#125; if (friends &gt;= 3 || notfriends &gt;= 3) return false; &#125; return true;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); bool ok; if (n &gt;= 6) &#123; for (int i = 1; i &lt; n; i++) scanf(\"%*[^\\n]\"); ok = false; &#125; else &#123; for (int i = 1; i &lt; n; i++) for (int j = 1; j &lt;= n - i; ++j) &#123; scanf(\"%d\", &amp;r[i][i + j]); r[i + j][i] = r[i][i + j]; &#125; ok = judge(); &#125; printf(\"%s\\n\", ok ? \"Great Team!\" : \"Bad Team!\"); &#125; return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"暴力","slug":"Violence","permalink":"https://www.oyohyee.com/tags/Violence/"}]},{"title":"ZOJ 3329.One Person Game","date":"2017-08-18T03:01:32.000Z","path":"/post/ZOJ/3329.html","text":"题目点击显/隐题目 There is a very simple and interesting one-person game. You have 3 dice, namely Die1, Die2 and Die3. Die1 has K1 faces. Die2 has K2 faces. Die3 has K3 faces. All the dice are fair dice, so the probability of rolling each value, 1 to K1, K2, K3 is exactly 1 / K1, 1 / K2 and 1 / K3. You have a counter, and the game is played as follow:Set the counter to 0 at first.Roll the 3 dice simultaneously. If the up-facing number of Die1 is a, the up-facing number of Die2 is b and the up-facing number of Die3 is c, set the counter to 0. Otherwise, add the counter by the total value of the 3 up-facing numbers.If the counter’s number is still not greater than n, go to step 2. Otherwise the game is ended.Calculate the expectation of the number of times that you cast dice before the end of the game.There are multiple test cases. The first line of input is an integer T (0 &lt; T &lt;= 300) indicating the number of test cases. Then T test cases follow. Each test case is a line contains 7 non-negative integers n, K1, K2, K3, a, b, c (0 &lt;= n &lt;= 500, 1 &lt; K1, K2, K3 &lt;= 6, 1 &lt;= a &lt;= K1, 1 &lt;= b &lt;= K2, 1 &lt;= c &lt;= K3).For each test case, output the answer in a single line. A relative error of 1e-8 will be accepted.20 2 2 2 1 1 10 6 6 6 1 1 11.1428571428571431.004651162790698 题解题目思维比较独特,需要一些数学技巧 如图,设 dp[i] 表示当前计数为 i 的时候结束游戏的期望值则在状态 i 的时候可以转移到状态 0 和 状态 i+j计算出当前骰子投出和为 j 的概率为 p[j](dp[0]是投出a,b,c的概率)则有 dp[i] = dp[0]p[0] + sum{ dp[i+j]p[j] } 然后会发现一个很重要的问题,状态同时向两侧转移也即无论是从大到小还是从小到大或者其他转移形式,这个式子都不满足无后效性但是这里可以看出,往小了转移只有 dp[0] 一个状态可以用数学重新推导一下 $ \\begin{align*} dp[i] &= \\sum (dp[i+j] \\times p[j]) + dp[0] \\times p[0] \\\\ 设: dp[i] &= A[i] \\times dp[0] + B[i] \\\\ 带入原式得: dp[i] &= \\sum((A[i+j] \\times dp[0] + B[i+j) \\times p[j]) + dp[0] \\times p[0] \\\\ 整理得: dp[i] &=\\sum ((p[j]*A[i+j]) + p[0]) \\times dp[0]) + \\sum(p[j] \\times B[i+j]) + 1 \\\\ \\\\ \\therefore A[i] &= \\sum(p[j] \\times A[i+j]) + p[0] \\\\ B[i] &= \\sum (p[j] \\times B[i+j]) + 1 \\\\ \\\\ 且: dp[0] &= \\frac{B[0]}{1-A[0]} \\\\ A[i] &= B[i] = 0,i>n \\end{align*} $ 这样只需要预先处理出 p[i] 然后用 O(n) 的时间求出 A[i],B[i] 即可最后结果就是 B[0]/(1-A[0]) 代码点击显/隐代码 One Person Game代码备份#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define Log(format, ...) //printf(format, ##__VA_ARGS__)const int maxk = 3;const int maxnum = 20;const int maxn = 550;int n, k[maxk], a[maxk];double A[maxn], B[maxn], p[maxnum];int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d%d%d%d%d%d\", &amp;n, &amp;k[0], &amp;k[1], &amp;k[2], &amp;a[0], &amp;a[1], &amp;a[2]); memset(p, 0, sizeof(p)); for (int i = 1; i &lt;= k[0]; ++i) for (int j = 1; j &lt;= k[1]; ++j) for (int l = 1; l &lt;= k[2]; ++l) &#123; if (i == a[0] &amp;&amp; j == a[1] &amp;&amp; l == a[2]) &#123; p[0] += 1; &#125; else &#123; p[i + j + l] += 1; &#125; &#125; int sum = k[0] * k[1] * k[2]; for (int i = 0; i &lt; maxnum; ++i) &#123; p[i] = p[i] / sum; Log(\"%d %f\\n\", i, p[i]); &#125; memset(A, 0, sizeof(A)); memset(B, 0, sizeof(B)); for (int i = n; i &gt;= 0; --i) &#123; for (int j = 3; j &lt; maxnum; ++j) &#123; Log(\"%d %d %f %f %f\\n\", i,j, p[j],A[i+j],B[i+j]); A[i] += p[j] * A[i + j]; B[i] += p[j] * B[i + j]; &#125; Log(\"%d %f %f\\n\", i, A[i],B[i]); A[i] += p[0]; B[i] += 1; Log(\"%d %f %f\\n\", i, A[i],B[i]); &#125; printf(\"%.15f\\n\", B[0] / (1 - A[0])); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"递推","slug":"Recurrence","permalink":"https://www.oyohyee.com/tags/Recurrence/"},{"name":"概率dp","slug":"Probability-DP","permalink":"https://www.oyohyee.com/tags/Probability-DP/"},{"name":"ZOJ","slug":"ZOJ","permalink":"https://www.oyohyee.com/tags/ZOJ/"}]},{"title":"HDU 4336.Card Collector","date":"2017-08-14T12:50:46.000Z","path":"/post/HDU/4336.html","text":"题目点击显/隐题目 In your childhood, do you crazy for collecting the beautiful cards in the snacks? They said that, for example, if you collect all the 108 people in the famous novel Water Margin, you will win an amazing award. As a smart boy, you notice that to win the award, you must buy much more snacks than it seems to be. To convince your friends not to waste money any more, you should find the expected number of snacks one should buy to collect a full suit of cards.The first line of each test case contains one integer N (1 &lt;= N &lt;= 20), indicating the number of different cards you need the collect. The second line contains N numbers p1, p2, …, pN, (p1 + p2 + … + pN &lt;= 1), indicating the possibility of each card to appear in a bag of snacks.Note there is at most one card in a bag of snacks. And it is possible that there is nothing in the bag.Output one number for each test case, indicating the expected number of bags to buy to collect all the N different cards.You will get accepted if the difference between your answer and the standard answer is no more that 10^-4.10.120.1 0.410.00010.500 题解这题需要用到容斥原理 在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。 对于样例(0.1 0.4)而言我们可以分别单独只看第一种卡片和第二种卡片得到第一种卡片的期望包数为1 / 0.1 = 10第二种卡片的期望包数为1 / 0.4 = 2.5那么需要的总天数为 10 + 2.5 = 12.5 显然,10天内我们直接认为第二种不会出现,2.5天直接认为第一种不会出现需要减去两种同时会出现的情况两种同时出现的概率是 0.1 + 0.5 = 0.5期望为 1 / 0.5 = 2减去得 12.5 - 2 = 10.5 而对于有更多种卡片呢? 如图,我们直接计算相当于重复计算了绿色区域而减去绿色区域时又发现多减了中间区域 因此,应该从所有组合中,选取k个概率相加,算出这个概率得期望如果k是奇数应该加到结果里,如果是偶数则应该减去也即奇加偶减 代码点击显/隐代码 Card Collector代码备份#include &lt;cstdio&gt;const int maxn = 25;double p[maxn];inline bool GetI(int num, int i) &#123; return (num &gt;&gt; i) &amp; 1; &#125;int main() &#123; int n; while (scanf(\"%d\", &amp;n) != EOF) &#123; for (int i = 0; i &lt; n; i++) scanf(\"%lf\", &amp;p[i]); double ans = 0.0; for (int state = (1 &lt;&lt; n) - 1; state &gt; 0; --state) &#123; bool cnt = false; double sump = 0.0; for (int i = 0; i &lt; n; i++) &#123; bool t = GetI(state, i); if (t) &#123; cnt = !cnt; sump += p[i]; &#125; &#125; if (cnt) &#123; ans += 1.0 / sump; &#125; else &#123; ans -= 1.0 / sump; &#125; &#125; printf(\"%f\\n\", ans); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"概率dp","slug":"Probability-DP","permalink":"https://www.oyohyee.com/tags/Probability-DP/"},{"name":"状压dp","slug":"State-compression-DP","permalink":"https://www.oyohyee.com/tags/State-compression-DP/"},{"name":"容斥原理","slug":"including-excluding-principle","permalink":"https://www.oyohyee.com/tags/including-excluding-principle/"}]},{"title":"HDU 2089.不要62","date":"2017-08-14T10:36:05.000Z","path":"/post/HDU/2089.html","text":"题目点击显/隐题目 杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。不吉利的数字为所有含有4或62的号码。例如：62315 73418 88914都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。1 1000 080 题解数位dp问题,当然这题可以暴力搞掉的,不过还是按照数位dp的写法写 一位一位分析这道题需要判断62,因此需要记录上一位数字 则有dp[i][j]表示前i位并且上一位为j的合法的数目有dp[i][j] = sum{ dp[i-1][k] } 其中 k 是满足条件的数 对于数位dp,有时候存在一个上限,不需要枚举到所有的数,用一个变量记录当前是否存在上限如果存在上限,就正常跑,如果不存在上限则可以使用记忆化搜索 代码点击显/隐代码 不要62代码备份#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;const int maxn = 10;int a[maxn];int dp[maxn][10];/* 第pos位 前一位状态为 pre 当前是否限制当前位(limit) */int dfs(int pos, int pre, bool limit) &#123; //for (int i = maxn; i &gt;= pos; i--) // printf(\"\\t\"); //printf(\"dfs(%d,%d,%d,%d)\\n\", pos, pre, limit); if (pos == -1) return 1; if (limit || dp[pos][pre] == -1) &#123; int up = limit ? a[pos] : 9; int ans = 0; for (int now = 0; now &lt;= up; now++) &#123; if (pre == 6 &amp;&amp; now == 2) continue; if (now == 4) continue; ans += dfs(pos - 1, now, limit &amp;&amp; now == a[pos]); &#125; if (!limit) dp[pos][pre] = ans; return ans; &#125; return dp[pos][pre];&#125;int solve(int x) &#123; int pos = 0; while (x) &#123; a[pos++] = x % 10; x /= 10; &#125; int ans = dfs(pos - 1, -1, true); //printf(\"solve(%d) = %d\\n\", x, ans); return ans;&#125;int main() &#123; int l, r; while (scanf(\"%d%d\", &amp;l, &amp;r) != EOF) &#123; if (l == 0 &amp;&amp; r == 0) break; memset(dp, -1, sizeof(dp)); printf(\"%d\\n\", solve(r) - solve(l - 1)); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"数位dp","slug":"Digital-DP","permalink":"https://www.oyohyee.com/tags/Digital-DP/"}]},{"title":"hihocoder 1055.刷油漆","date":"2017-08-12T04:15:01.000Z","path":"/post/hihocoder/1055.html","text":"题目点击显/隐题目 上回说到，小Ho有着一棵灰常好玩的树玩具！这棵树玩具是由N个小球和N-1根木棍拼凑而成，这N个小球都被小Ho标上了不同的数字，并且这些数字都是处于1..N的范围之内，每根木棍都连接着两个不同的小球，并且保证任意两个小球间都不存在两条不同的路径可以互相到达。没错，这次说的还是这棵树玩具的故事！小Ho的树玩具的质量似乎不是很好，短短玩了几个星期，便掉漆了！ “简直是一场噩梦！”小Ho拿着树玩具眼含热泪道。 “这有什么好忧伤的，自己买点油漆刷一刷不就行了？”小Hi表示不能理解。 “还可以这样？”小Ho顿时兴高采烈了起来，立马跑出去买回来了油漆，但是小Ho身上的钱却不够——于是他只买回了有限的油漆，这些油漆最多能给M个结点涂上颜色，这就意味着小Ho不能够将他心爱的树玩具中的每一个结点都涂上油漆！小Ho低头思索了半天——他既不想只选一部分结点补漆，也不想找小Hi借钱，但是很快，他想出了一个非常棒的主意：将包含1号结点的一部分连通的结点进行涂漆（这里的连通指的是这一些涂漆的结点可以互相到达并且不会经过没有涂漆的结点），然后将剩下的结点拆掉！那么究竟选择哪些结点进行涂漆呢？小Ho想了想给每个结点都评上了分——他希望最后留下来，也就是涂漆了的那些结点的评分之和可以尽可能的高！那么，小Ho该如何做呢？ 每个测试点（输入文件）有且仅有一组测试数据。 每组测试数据的第一行为两个整数N、M，意义如前文所述。 每组测试数据的第二行为N个整数，其中第i个整数Vi表示标号为i的结点的评分 每组测试数据的第3~N+1行，每行分别描述一根木棍，其中第i+1行为两个整数Ai，Bi，表示第i根木棍连接的两个小球的编号。 对于100%的数据，满足N&lt;=10^2，1&lt;=Ai&lt;=N, 1&lt;=Bi&lt;=N, 1&lt;=Vi&lt;=10^3, 1&lt;=M&lt;=N 小Hi的Tip：那些用数组存储树边的记得要开两倍大小哦！ 对于每组测试数据，输出一个整数Ans，表示使得涂漆结点的评分之和最高可能是多少。10 4370 328 750 930 604 732 159 167 945 2101 22 31 41 54 64 74 86 95 102977 题解可以用 dp[i][j] 表示包括节点 i 在内一共能涂 j 种颜色能达到的最大满意度 则有 dp[i][j] = max{ dp[child_1][m_1] + dp[child_2][m_2] + …… + dp[child_n][m_n] }其中 sum{m_1,m_2,……,m_n} = j 很不幸,m_i 的组合非常多,枚举出来肯定会超时那么我们应该怎么处理这里呢? 重新描述下现在面临的问题: 一个节点有多个子节点,每个按照不同的比例来给子节点分配权重,找出最大的和 对于每一个子节点,可以分配给它最多为 j 的权重在范围内可以看作无限分配 很像完全背包问题 可以将 j 作为背包容量,m_i 看作选取的个数(体积为1)而重量则是 dp[child_i][m_i] 首先来看完全背包的模板,这是已经维度压缩后的,而在树形dp中,由于计算顺序不是那么有规律,往往不能压缩 完全背包void CompletePack(int cost,int weight) &#123; for (int i = cost; i &lt;= v; i++) dp[i] = max(dp[i],dp[i - cost] + weight);&#125; 再看压缩前的算法完全背包dp[i][j] = max&#123; dp[i][j-c[i]]+w[i] , dp[i-1][j] &#125; 其中 dp[i][j] 表示前i个物品在最大体积为j的情况下的最大价值 dp[i][j] = dp[i][j-m_i]+dp[child][m_i]与通常的背包问题不同的是,这里由于选取的个数和价值之间不是单纯的线性关系(这就是《背包九讲》中提到的泛化物品),因此不能直接按照原有的方式递推 这里只能枚举m_im_i 是 1~m-1 的数,不为0是因为没有意义,不为m是因为根节点需要占用一个涂色名额 我们可以把每一种情况看作一个新的物品那么我们就获得了一群,价值为dp[child][m_i],体积(花费)为m_i的物品然后转变成了01背包问题 最外层循环按照01背包的形式,从大到小循环内层要从小到大循环因为01背包需要从大到小循环,而dp[x][i]需要用到dp[x][i-j],只有j从小到大才行 for (int i = m; i &gt; 1; --i) for (int j = 1; j &lt; i; ++j) dp[x][i] = max(dp[x][i], dp[x][i - j] + dp[*child][j]); 代码点击显/隐代码 刷油漆代码备份#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;#define Log(d, format, ...)const int maxn = 105;int w[maxn];vector&lt;int&gt; children[maxn];int dp[maxn][maxn];int n, m;void init() &#123; for (int i = 0; i &lt;= n; i++) children[i].clear(); memset(dp, 0, sizeof(dp));&#125;void addEdge(int u, int v) &#123; children[u].push_back(v); &#125;void dfs(int x) &#123; vector&lt;int&gt;::iterator child = children[x].begin(); while (child != children[x].end()) &#123; dfs(*child); for (int i = m; i &gt; 1; --i) &#123; for (int j = 1; j &lt; i; ++j) &#123; dp[x][i] = max(dp[x][i], dp[x][i - j] + dp[*child][j]); Log(0, \"dp[%d][%d]=%d\\n\", i, j, dp[i][j]); &#125; &#125; ++child; &#125;&#125;int main() &#123; while (scanf(\"%d%d\", &amp;n, &amp;m) != EOF) &#123; init(); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;dp[i][1]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); addEdge(u, v); &#125; dfs(1); printf(\"%d\\n\", dp[1][m]); &#125;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"树","slug":"Tree","permalink":"https://www.oyohyee.com/tags/Tree/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"},{"name":"树形dp","slug":"Tree-dp","permalink":"https://www.oyohyee.com/tags/Tree-dp/"},{"name":"hihocoder","slug":"hihocoder","permalink":"https://www.oyohyee.com/tags/hihocoder/"}]},{"title":"hihocoder 1098.最小生成树二·Kruscal算法","date":"2017-08-11T14:37:24.000Z","path":"/post/hihocoder/1098.html","text":"题目点击显/隐题目 随着小Hi拥有城市数目的增加，在之间所使用的Prim算法已经无法继续使用了——但是幸运的是，经过计算机的分析，小Hi已经筛选出了一些比较适合建造道路的路线，这个数量并没有特别的大。 所以问题变成了——小Hi现在手上拥有N座城市，且已知其中一些城市间建造道路的费用，小Hi希望知道，最少花费多少就可以使得任意两座城市都可以通过所建造的道路互相到达（假设有A、B、C三座城市，只需要在AB之间和BC之间建造道路，那么AC之间也是可以通过这两条道路连通的）。每个测试点（输入文件）有且仅有一组测试数据。 在一组测试数据中： 第1行为2个整数N、M，表示小Hi拥有的城市数量和小Hi筛选出路线的条数。 接下来的M行，每行描述一条路线，其中第i行为3个整数N1_i, N2_i, V_i，分别表示这条路线的两个端点和在这条路线上建造道路的费用。 对于100%的数据，满足N&lt;=10^5, M&lt;=10^6，于任意i满足1&lt;=N1_i, N2_i&lt;=N, N1_i≠N2_i, 1&lt;=V_i&lt;=10^3. 对于100%的数据，满足一定存在一种方案，使得任意两座城市都可以互相到达。对于每组测试数据，输出1个整数Ans，表示为了使任意两座城市都可以通过所建造的道路互相到达至少需要的建造费用。5 291 2 6742 3 2493 4 6724 5 9331 2 7883 4 1472 4 5043 4 381 3 653 5 61 5 8651 3 5901 4 6822 4 2272 4 6361 4 3121 3 1432 5 1582 3 5163 5 1021 5 6051 4 994 5 2242 4 1983 5 8941 5 8453 4 72 4 141 4 18592 题解模板题 代码点击显/隐代码 最小生成树二·Kruscal算法代码备份#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1e5 + 5;const int maxm = 1e6 + 5;int f[maxn];struct Edge &#123; int u, v; int w; bool operator&lt;(const Edge rhs) const &#123; return w &lt; rhs.w; &#125;&#125; e[maxm];int pos;int ufs(int x) &#123; return f[x] == x ? x : f[x] = ufs(f[x]); &#125;int Kruskal(int n, int m) &#123; int w = 0; for (int i = 0; i &lt;= n; i++) f[i] = i; sort(e, e + m); for (int i = 0; i &lt; m; i++) &#123; int x = ufs(e[i].u), y = ufs(e[i].v); if (x != y) &#123; f[x] = y; w += e[i].w; &#125; &#125; return w;&#125;void addEdge(int u, int v, int w) &#123; e[pos].u = u; e[pos].v = v; e[pos].w = w; pos++;&#125;int main() &#123; int n, m; while (scanf(\"%d%d\", &amp;n, &amp;m) != EOF) &#123; int u, v, w; pos = 0; for (int i = 0; i &lt; m; i++) &#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); &#125; printf(\"%d\\n\", Kruskal(n, m)); &#125;&#125;","tags":[{"name":"最小生成树","slug":"MST","permalink":"https://www.oyohyee.com/tags/MST/"},{"name":"Kruskal","slug":"Kruskal","permalink":"https://www.oyohyee.com/tags/Kruskal/"},{"name":"hihocoder","slug":"hihocoder","permalink":"https://www.oyohyee.com/tags/hihocoder/"}]},{"title":"hihocoder 1069.最近公共祖先·三","date":"2017-08-11T14:21:51.000Z","path":"/post/hihocoder/1069.html","text":"题目点击显/隐题目 上上回说到，小Hi和小Ho使用了Tarjan算法来优化了他们的“最近公共祖先”网站，但是很快这样一个离线算法就出现了问题：如果只有一个人提出了询问，那么小Hi和小Ho很难决定到底是针对这个询问就直接进行计算还是等待一定数量的询问一起计算。毕竟无论是一个询问还是很多个询问，使用离线算法都是只需要做一次深度优先搜索就可以了的。那么问题就来了，如果每次计算都只针对一个询问进行的话，那么这样的算法事实上还不如使用最开始的朴素算法呢！但是如果每次要等上很多人一起的话，因为说不准什么时候才能够凑够人——所以事实上有可能要等上很久很久才能够进行一次计算，实际上也是很慢的！“那到底要怎么办呢？在等到10分钟，或者凑够一定数量的人两个条件满足一个时就进行运算？”小Ho想出了一个折衷的办法。“哪有这么麻烦！别忘了和离线算法相对应的可是有一个叫做在线算法的东西呢！”小Hi笑道。小Ho面临的问题还是和之前一样：假设现在小Ho现在知道了N对父子关系——父亲和儿子的名字，并且这N对父子关系中涉及的所有人都拥有一个共同的祖先（这个祖先出现在这N对父子关系中），他需要对于小Hi的若干次提问——每次提问为两个人的名字（这两个人的名字在之前的父子关系中出现过），告诉小Hi这两个人的所有共同祖先中辈分最低的一个是谁？每个测试点（输入文件）有且仅有一组测试数据。每组测试数据的第1行为一个整数N，意义如前文所述。每组测试数据的第2~N+1行，每行分别描述一对父子关系，其中第i+1行为两个由大小写字母组成的字符串Father_i, Son_i，分别表示父亲的名字和儿子的名字。每组测试数据的第N+2行为一个整数M，表示小Hi总共询问的次数。每组测试数据的第N+3~N+M+2行，每行分别描述一个询问，其中第N+i+2行为两个由大小写字母组成的字符串Name1_i, Name2_i，分别表示小Hi询问中的两个名字。对于100%的数据，满足N&lt;=10^5，M&lt;=10^5, 且数据中所有涉及的人物中不存在两个名字相同的人（即姓名唯一的确定了一个人），所有询问中出现过的名字均在之前所描述的N对父子关系中出现过，且每个输入文件中第一个出现的名字所确定的人是其他所有人的公共祖先。对于每组测试数据，对于每个小Hi的询问，按照在输入中出现的顺序，各输出一行，表示查询的结果：他们的所有共同祖先中辈分最低的一个人的名字。4Adam SamSam JoeySam MichealAdam Kevin3Sam SamAdam SamMicheal KevinSamAdamAdam 题解维护下每个人的父亲询问时,从第一个询问的人开始向上标记第二个人向上查询,第一个访问到的带标记的就是公共祖先 时间复杂度 O(log n) 代码点击显/隐代码 最近公共祖先·三代码备份#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1e5+5;map&lt;string, int&gt; Hash;vector&lt;string&gt; HashList;int parent[maxn];bool vis[maxn];void init() &#123; Hash.clear(); HashList.clear(); memset(parent, -1, sizeof(parent));&#125;int getHash(string s) &#123; if (!Hash.count(s)) &#123; Hash.insert(make_pair(s, HashList.size())); HashList.push_back(s); &#125; return Hash[s];&#125;void addEdge(int u, int v) &#123; parent[v] = u; &#125;int find_parent(int n) &#123; if (n == -1) return -1; if (vis[n]) return n; vis[n] = true; return find_parent(parent[n]);&#125;int main() &#123; int n; while (cin &gt;&gt; n) &#123; init(); for (int i = 0; i &lt; n; i++) &#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; int u = getHash(s1); int v = getHash(s2); addEdge(u, v); &#125; int k; scanf(\"%d\", &amp;k); for (int i = 0; i &lt; k; i++) &#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; int u = getHash(s1); int v = getHash(s2); memset(vis, false, sizeof(vis)); find_parent(u); cout &lt;&lt; HashList[find_parent(v)] &lt;&lt; endl; &#125; &#125;&#125;","tags":[{"name":"最近公共祖先","slug":"LCA","permalink":"https://www.oyohyee.com/tags/LCA/"},{"name":"树","slug":"Tree","permalink":"https://www.oyohyee.com/tags/Tree/"},{"name":"hihocoder","slug":"hihocoder","permalink":"https://www.oyohyee.com/tags/hihocoder/"}]},{"title":"使用V2ray科学上网","date":"2017-08-11T13:41:36.000Z","path":"/post/Note/V2ray.html","text":"近来一段时间访问谷歌变得越来越难,SSR的作者因为人肉原因停止维护SSR国家开始严打各种VPN服务而近一段写安卓又需要大量使用墙外的资源(有时候github的网速也像是被墙了) 因此需要搞一个VPN来科学上网 近一段国家监控的就是之前号称防止个人信息泄露的VPN,通过算法”识别”是否访问了不应该访问的东西虽然国家不可能去管我们搜一些技术性的东西,但是还是需要一个加密的算法来对抗破解 一般个人搭VPN随便找一个国外的VPS就行了,反正自己用的也不过,自然是选便宜的了 购买VPN经过挑选选择了搬瓦工的中国直连服务器 SPECIAL 10G KVM PROMO V3 - LOS ANGELES - CHINA DIRECT ROUTESSD: 10 GB RAID-10RAM: 512 MBCPU: 1x Intel XeonTransfer: 1000 GB/moLink speed: 1 Gigabit Location: Los Angeles (no other locations available on this plan)Direct route via China Telecom and China Unicom VPS technology: KVM/KiwiVMOS: 32 or 64 bit Centos, Debian, UbuntuInstant OS reloadIPv4: 1 dedicated addressIPv6 support: NoFull root accessInstant RDNS update from control panelNo contract, anytime cancellationStrictly self-managed, no support99.5% uptime guarantee \\$2.99 USD Monthly\\$6.99 USD Quarterly\\$11.99 USD Semi-Annually\\$19.99 USD Annually 总体来说刚刚好,价格非常便宜,只搭VPN也足够了 直接使用支付宝购买即可买完之后进入后台即可 在后台最下面三项就是一键安装VPN、一键安装SS、一键安装SSR支付宝支付+一键科学上网可见搬瓦工这是有着预谋啊 安装V2ray不过这些现在已经没有人维护了,还是换一个更有前途的吧这里推荐使用V2ray 它支持SS和SSR的协议而且有人在持续维护这就足够了 跟着官方文档安装即可当然,也有更为容易理解的版本 首先要先重装系统到 Ubuntu ,搬瓦工默认的 CentOS 6 刚好不支持V2ray bash &lt;(curl -L -s https://install.direct/go.sh) 管理员权限下运行上面的指令即可 然后就可以正常使用了,下面是开启的指令service v2ray start 配置然后用桌面的客户端 V2rayN连接填好自己的服务器,填好地址即可端口按照自己喜欢的来,其他的都可以不管 确定后右键选择导出所选服务器为服务端配置 然后用任意方式把到处的文件替换掉服务器的/etc/v2ray/config.jsonservice v2ray restart 连接如果没问题的话,现在右键服务器测试延迟应该可以看到一个延迟的值了然后进入系统设置开全局代理就行了 ip: 127.0.0.1 端口: 1080 这个可以在V2rayN的参数设置那里更改(或者更改运行目录下的config.json) 如果只想对浏览器翻墙的话,可以不使用全局代理使用类似SwitchyOmega这样的插件,设置proxy模式,填好ip和端口即可 手机端的话推荐V2rayNG可以直接在电脑上选择分享配置,手机扫二维码导入 问题虽然能正常访问谷歌,但是速度有点慢,可以用一些黑科技来解决这个问题,有空去搞一下","tags":[{"name":"科学上网","slug":"VPN","permalink":"https://www.oyohyee.com/tags/VPN/"},{"name":"v2ray","slug":"v2ray","permalink":"https://www.oyohyee.com/tags/v2ray/"}]},{"title":"Git取消文件追踪","date":"2017-08-10T08:45:00.000Z","path":"/post/Note/git_rm_cached.html","text":"不知道为什么Git同时追踪了 Blog 和 blog虽然没有什么影响,但是看上去很难受想要解决也很简单,因为我的文件夹明明为 Blog因此应该取消对 blog 的追踪git rm --cached blog","tags":[{"name":"Git","slug":"Git","permalink":"https://www.oyohyee.com/tags/Git/"}]},{"title":"解封永久封禁的暴雪账号","date":"2017-08-10T06:02:19.000Z","path":"/post/Writing/blizzard-account.html","text":"总结起来,表单内容要诚恳表明对外挂和盗号的鄙视说明自己在这期间没有登陆,怀疑账号被盗取,别人异地登陆希望官方能够仔细审查各个时间点要具体失败了也不要放弃 具体步骤如下: 暑假放假回家一段时间,突然收到一封暴雪的邮件邮件的时间是 2017/7/18内容如下 然后自然是一脸懵逼,这几天压根没有登过游戏,7月16更是压根没玩,上一次玩都是一个多星期之前的事了而且原因是第三方工具,也就是开挂 赶快去看了一眼最新的“封神榜”果然…… 不仅仅是封禁,而且是永封 这就非常尴尬了,我应该是刚改的密码,理论上被盗号的概率不大而且开挂被封在贴吧、论坛、知乎等地方上全是”暴雪不会出错,就不要演了”的嘲讽语气所以估计大概率没救了…… 不过还是试着反馈了一下在暴雪官网提交了表单,表明了自己对封禁存在疑问 不得不说效率真的高,一分钟关闭表单,十分钟不到邮件就发回来了 当时几乎都决定放弃了,这很明显都没有到客服那一关,直接就被系统处理了看了下暴雪的反馈流程,里面有尽可能详尽地描述,本着最后试一下的想法,就提交了一份更为“诚恳”的表单 没几分钟,表单被关闭,说明进入处理流程了,不过一直没回邮件算是有了一线希望 第二天(2017/7/19)下午5点多的时候,暴雪终于回了邮件 这说明,基本上稳了,赶快去绑定了安全令当晚(第二天)12点多给出了解封通告 后来登游戏,发现竞技上了几百分,不过胜率也就没有意外高,估计是盗号把数据刷的比较好看吧 所以还是要相信暴雪爸爸的,只要自己是清白的,总是能证明出来的 不过我能申诉回来,也是因为运气较好账号登陆地非常集中,并且没有不良记录(开挂期间玩的也都是我不怎么玩的英雄)这应该是被认定是盗号的主要原因 当然,最重要的是一定要绑定安全令没错,这就是安全令的广告","tags":[{"name":"暴雪","slug":"blizzard","permalink":"https://www.oyohyee.com/tags/blizzard/"},{"name":"守望先锋","slug":"Overwatch","permalink":"https://www.oyohyee.com/tags/Overwatch/"}]},{"title":"SGU 495.Kids and Prizes","date":"2017-08-09T12:20:59.000Z","path":"/post/SGU/495.html","text":"题目点击显/隐题目 ICPC (International Cardboard Producing Company) is in the business of producing cardboard boxes. Recently the company organized a contest for kids for the best design of a cardboard box and selected M winners. There are N prizes for the winners, each one carefully packed in a cardboard box (made by the ICPC, of course). The awarding process will be as follows:- All the boxes with prizes will be stored in a separate room.- The winners will enter the room, one at a time.- Each winner selects one of the boxes.- The selected box is opened by a representative of the organizing committee.- If the box contains a prize, the winner takes it.- If the box is empty (because the same box has already been selected by one or more previous winners), the winner will instead get a certificate printed on a sheet of excellent cardboard (made by ICPC, of course).- Whether there is a prize or not, the box is re-sealed and returned to the room.The management of the company would like to know how many prizes will be given by the above process. It is assumed that each winner picks a box at random and that all boxes are equally likely to be picked. Compute the mathematical expectation of the number of prizes given (the certificates are not counted as prizes, of course).The first and only line of the input file contains the values of N and M (1 &lt;= N,M &lt;= 100000)The first and only line of the output file should contain a single real number: the expected number of prizes given out. The answer is accepted as correct if either the absolute or the relative error is less than or equal to 10-9.5 74 33.9514242.3125 题解可以很容易列出概率dp公式dp[i] = dp[i-1] / n * dp[i-1] + (n-dp[i]) / n * (dp[i-1] + 1) 由于 i 最大达到 100000使用递归会爆栈,并且没有必要开数组记录(每个都只计算一次)也没有必要去推通项公式(不会超时) 直接 for 循环一边算出答案即可当精度要求能达到全部取走的时候就不用往后算了 也可以从盒子的角度想： m个人是独立的对于每个礼物不被人选中的概率为 ((n-1)/n)^m那么不被选中的礼物数的期望就是 n*((n-1)/n)^m所以答案就是 n-n*((n-1)/n)^m 代码点击显/隐代码 Kids and Prizes代码备份#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const double eps = 1e-12;int main() &#123; int n, m; while (scanf(\"%d%d\", &amp;n, &amp;m) != EOF) &#123; double ans = 0; for (int i = 0; i &lt; m; i++) &#123; ans = ((ans * ans) + (n - ans) * (ans + 1)) / n; if (fabs(ans - n) &lt; eps) break; &#125; printf(\"%.11f\\n\", ans); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"概率dp","slug":"Probability-DP","permalink":"https://www.oyohyee.com/tags/Probability-DP/"},{"name":"SGU","slug":"SGU","permalink":"https://www.oyohyee.com/tags/SGU/"}]},{"title":"HDU 6076.Security Check","date":"2017-08-07T16:58:13.000Z","path":"/post/HDU/6076.html","text":"题目点击显/隐题目 In airport of Bytetown, there are two long queues waiting for security check. Checking a person needs one minute, and two queues can be checked at the same time. Two teams $A$ and $B$ are going to travel by plane. Each team has $n$ players, ranked from $1$ to $n$ according to their average performance. No two players in the same team share the same rank. Team $A$ is waiting in queue $1$ while team $B$ is waiting in queue $2$. Nobody else is waiting for security check. Little Q is the policeman who manages two queues. Every time he can check one person from one queue, or check one each person from both queues at the same time. He can’t change the order of the queue, because that will make someone unhappy. Besides, if two players $A_i$ and $B_j$ are being checked at the same time, satisfying $|A_i-B_j|\\leq k$, they will make a lot of noise because their rank are almost the same. Little Q should never let that happen. Please write a program to help Little Q find the best way costing the minimum time.The first line of the input contains an integer $T(1\\leq T\\leq15)$, denoting the number of test cases.In each test case, there are $2$ integers $n,k(1\\leq n\\leq 60000,1\\leq k\\leq 10)$ in the first line, denoting the number of players in a team and the parameter $k$.In the next line, there are $n$ distinct integers $A_1,A_2,…,A_n(1\\leq A_i\\leq n)$, denoting the queue $1$ from front to rear.Then in the next line, there are $n$ distinct integers $B_1,B_2,…,B_n(1\\leq B_i\\leq n)$, denoting the queue $2$ from front to rear.For each test case, print a single line containing an integer, denoting the minimum time to check all people.14 22 3 1 41 2 4 37 题解暴力思路很显然,用动态规划的思想,有如下递推式dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1其中 dp[i][j] 表示第一队前 i 个人和第二队前 j 个人,最小的检查时间 然后就会发现一个问题, n 最大能达到 60000 空间时间都会超过限制 首先来解决存储的问题很容易发现,这道题有个很关键的地方: k最大只到10 又因为每个数字在每个队伍里只出现一次,那么可以得知只有极少数的人没有办法一起检查也即只有极少数的 dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1 操作而大多数都是取 dp[i][j] = dp[i-1][j-1] + 1 那么就可以单独考虑两种情况针对前一种情况,可以用记忆化搜索来做这里有一个非常好的转换: 直接存储 dp[i][j] 显然是存不下的,但是我们可以发现,当前的前提是 abs(a[i]-b[j]) &lt;= k (需要特别注差值是指权值而不是位置)而 k 又是一个非常小的数字我们完全可以只记录 i 和 a[i]-a[j]+k 这样我们只需要一个 60000*20 的数组(这里 +k 是为了保证为正数) 这样,就能在 O(nk) 的时间处理好这一部分了 然后来看另一部分可以知道这一部分就是 dp[i][j] = dp[i-1][j-1] + 1看上去是 O(n2) 的操作,但是可以发现,它只需要取自己左上的数,也即不考虑差值小于 k 的情况下可以在 O(n) 的时间内找出答案而差值不小于 k 的情况我们已经计算完毕了因此完全可以用递归求出这一部分的内容(可以证明没有存在多次计算同一状态) 题解的思路关于题解的解法,前一部分是一样的不一样的是后一部分思路也比较独特 (i,j)表示第一队第i个人和第二队第j个人,当发现他们的差值大于k时我们可以给他们连一条线(表示一起检查),然后把线向左平移,直到线两端的人差值小于等于k此时记两个人的位置为(a,b)然后这两个线中间的位置显然是可以一起检查那么 dp[i][j] = dp[a][b] + i - a 问题就转换成如何找到最近的符合要求的平行线段了很明显,平行意味着 i-j 相等那么可以在读入的时候先预处理所有的线段间距由于只需要找间距小于等于 k 的,因此我们只需要对每一个 i 枚举 k 即可然后将数据存入 vector 二分查找即可 这里需要注意的是lower_bound() 找的是第一个小于等于的位置,与我们的要求不符我们应该让 vector 递增记录,然后给 lower_bound() 传入一个 max() 的比较函数 代码暴力思路点击显/隐代码 Security Check 暴力代码备份#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 60005;const int maxk = 11;int queue_a[maxn], queue_b[maxn];int DP[maxn][maxk &lt;&lt; 2];int n, k;void init() &#123; memset(DP, -1, sizeof(DP)); &#125;int dfs(int apos, int bpos) &#123; int RETURN = -1; if (!apos || !bpos) &#123; RETURN = apos | bpos; &#125; else &#123; if (abs(queue_a[apos] - queue_b[bpos]) &lt;= k) &#123; //暴力 int &amp;dp = DP[apos][queue_a[apos] - queue_b[bpos] + k]; if (dp == -1) dp = min(dfs(apos - 1, bpos), dfs(apos, bpos - 1)) + 1; RETURN = dp; &#125; else &#123; RETURN = dfs(apos - 1, bpos - 1) + 1; &#125; &#125; return RETURN;&#125;int main() &#123; // freopen(\"out.txt\", \"w\", stdout); int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;k); init(); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;queue_a[i]); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;queue_b[i]); printf(\"%d\\n\", dfs(n, n)); &#125; return 0;&#125; 题解思路点击显/隐代码 Security Check 题解思路代码备份#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 60005;const int maxk = 15;int queue_a[maxn], queue_b[maxn];int bposList[maxn];int DP[maxn][maxk &lt;&lt; 2];vector&lt;int&gt; DisList[maxn &lt;&lt; 2];int n, k;bool cmp(int a, int b) &#123; return a &gt; b; &#125;void init() &#123; memset(DP, -1, sizeof(DP)); for (int i = 0; i &lt;= n &lt;&lt; 2; ++i) DisList[i].clear();&#125;int dfs(int apos, int bpos, int deep) &#123; int RETURN = -1; if (!apos || !bpos) &#123; RETURN = apos | bpos; &#125; else &#123; if (abs(queue_a[apos] - queue_b[bpos]) &lt;= k) &#123; //暴力 int &amp;dp = DP[apos][queue_a[apos] - queue_b[bpos] + k]; if (dp == -1) &#123; dp = min(dfs(apos - 1, bpos, deep + 1), dfs(apos, bpos - 1, deep + 1)) + 1; &#125; RETURN = dp; &#125; else &#123; int dis = apos - bpos + n; vector&lt;int&gt; &amp;List = DisList[dis]; vector&lt;int&gt;::iterator it = lower_bound(List.begin(), List.end(), apos, cmp); if (it == List.end() || *it == apos) &#123; RETURN = max(apos, bpos); &#125; else &#123; int lastapos = *it; RETURN = dfs(lastapos, bpos - apos + lastapos, deep + 1) + apos - lastapos; &#125; &#125; &#125; return RETURN;&#125;int max(int a, int b) &#123; return a &gt; b ? a : b; &#125;int main() &#123; // freopen(\"out.txt\", \"w\", stdout); int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;k); init(); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;queue_a[i]); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;queue_b[i]); bposList[queue_b[i]] = i; &#125; for (int apos = n; apos &gt;= 1; --apos) &#123; int a = queue_a[apos]; for (int b = a - k; b &lt;= a + k; ++b) &#123; int bpos = bposList[b]; int dis = apos - bpos + n; DisList[dis].push_back(apos); &#125; &#125; printf(\"%d\\n\", dfs(n, n, 1)); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"暴力","slug":"Violence","permalink":"https://www.oyohyee.com/tags/Violence/"}]},{"title":"POJ 2151.Check the difficulty of problems","date":"2017-08-05T08:51:34.000Z","path":"/post/POJ/2151.html","text":"题目点击显/隐题目 Organizing a programming contest is not an easy job. To avoid making the problems too difficult, the organizer usually expect the contest result satisfy the following two terms:1. All of the teams solve at least one problem.2. The champion (One of those teams that solve the most problems) solves at least a certain number of problems.Now the organizer has studied out the contest problems, and through the result of preliminary contest, the organizer can estimate the probability that a certain team can successfully solve a certain problem.Given the number of contest problems M, the number of teams T, and the number of problems N that the organizer expect the champion solve at least. We also assume that team i solves problem j with the probability Pij (1 &lt;= i &lt;= T, 1&lt;= j &lt;= M). Well, can you calculate the probability that all of the teams solve at least one problem, and at the same time the champion team solves at least N problems?The input consists of several test cases. The first line of each test case contains three integers M (0 &lt; M &lt;= 30), T (1 &lt; T &lt;= 1000) and N (0 &lt; N &lt;= M). Each of the following T lines contains M floating-point numbers in the range of [0,1]. In these T lines, the j-th number in the i-th line is just Pij. A test case of M = T = N = 0 indicates the end of input, and should not be processed.For each test case, please output the answer in a separate line. The result should be rounded to three digits after the decimal point.2 2 20.9 0.91 0.90 0 00.972 题解dp[i][j][k] 表示第i个队伍在前j道题中做出k题 有递推式dp[i][j][k] += dp[i][j - 1][k - 1] * Prob[i][j] + dp[i][j - 1][k] * (1 - Prob[i][j]) 计算出来后,需要用概率的知识计算满足每一队都至少过一题,并且至少有一队过N题的概率 首先计算出所有队伍至少过一题的数量 代码点击显/隐代码 Check the difficulty of problems代码备份#include &lt;cstdio&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;using namespace std;const int maxT = 1005;const int maxM = 35;double Prob[maxT][maxM];double dp[maxT][maxM][maxM];int main() &#123; int M, T, N; while (scanf(\"%d%d%d\", &amp;M, &amp;T, &amp;N) != EOF) &#123; if (!(M | T | N)) break; for (int i = 1; i &lt;= T; ++i) for (int j = 1; j &lt;= M; ++j) scanf(\"%lf\", &amp;Prob[i][j]); for (int i = 1; i &lt;= T; ++i) dp[i][0][0] = 1.0; // dp[i][j][k] 第i个队伍在前j道题中做出k题 for (int i = 1; i &lt;= T; ++i) for (int j = 1; j &lt;= M; ++j) for (int k = 0; k &lt;= j; ++k) &#123; dp[i][j][k] = 0.0; if (k != 0) dp[i][j][k] += dp[i][j - 1][k - 1] * Prob[i][j]; // if (k != j) dp[i][j][k] += dp[i][j - 1][k] * (1 - Prob[i][j]); &#125; double P1 = 1.0; //有队伍达到N题 double P2 = 1.0; //有队伍未达到1题 for (int i = 1; i &lt;= T; ++i) &#123; double sum = 0.0; for (int j = 1; j &lt; N; ++j) sum += dp[i][M][j]; P1 *= sum; P2 *= 1 - dp[i][M][0]; &#125; // P1 = 1 - P1; // P2 = 1 - P2; // printf(\"%.3f\\n\", P1 - P2); cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; P2 - P1 &lt;&lt; endl; &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"概率dp","slug":"Probability-DP","permalink":"https://www.oyohyee.com/tags/Probability-DP/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"HDU 2094.产生冠军","date":"2017-08-05T03:59:57.000Z","path":"/post/HDU/2094.html","text":"题目点击显/隐题目 有一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。球赛的规则如下：如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。根据这个规则，无需循环较量，或许就能确定冠军。你的任务就是面对一群比赛选手，在经过了若干场撕杀之后，确定是否已经实际上产生了冠军。输入含有一些选手群，每群选手都以一个整数n(n&lt;1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。3Alice BobSmith JohnAlice Smith5a cc dd eb ea d0YesNo 题解不用想太复杂,直接判断入度为1的是否有且仅有一个即可 代码点击显/隐代码 产生冠军代码备份#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;const int maxn = 2005;map&lt;string, int&gt; M;bool vis[maxn];bool Edge[maxn][maxn];int num = 0;int getNum(string s) &#123; if (M.count(s) == 0) &#123; M.insert(make_pair(s, num++)); &#125; // cout &lt;&lt; s &lt;&lt; \":\" &lt;&lt; M[s] &lt;&lt; endl; return M[s];&#125;void init() &#123; memset(vis, false, sizeof(vis)); memset(Edge, false, sizeof(Edge)); num = 0; M.clear();&#125;void addEdge(int u, int v) &#123; Edge[u][v] = true; &#125;bool IsStart(int k) &#123; //判断是否入度为0 for (int i = 0; i &lt; num; i++) if (Edge[i][k]) return false; return true;&#125;bool dfs(int t) &#123; if (vis[t]) return false; vis[t] = true; bool OK = true; for (int i = 0; i &lt; num; i++) &#123; if (Edge[t][i]) OK &amp;= dfs(i); &#125; return OK;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int n; while (cin &gt;&gt; n) &#123; if (n == 0) break; init(); for (int i = 0; i &lt; n; i++) &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; int apos = getNum(a); int bpos = getNum(b); addEdge(apos, bpos); &#125; bool YES = true; int root = -1; for (int i = 0; i &lt; num; i++) &#123; if (IsStart(i)) &#123; if (root == -1) &#123; root = i; &#125;else&#123; YES = false; //printf(\"%d\\n\",i); break; &#125; &#125; &#125; if(root == -1) YES = false; if (YES) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"拓扑排序","slug":"TopoSort","permalink":"https://www.oyohyee.com/tags/TopoSort/"}]},{"title":"hihocoder 1297.扩展欧几里得","date":"2017-08-05T03:57:31.000Z","path":"/post/hihocoder/1297.html","text":"题目点击显/隐题目 小Hi和小Ho周末在公园溜达。公园有一堆围成环形的石板，小Hi和小Ho分别站在不同的石板上。已知石板总共有m块，编号为 0..m-1，小Hi一开始站在s1号石板上，小Ho一开始站在s2号石板上。小Hi：小Ho，你说我们俩如果从现在开始按照固定的间隔数同时同向移动，我们会不会在某个时间点站在同一块石板上呢？小Ho：我觉得可能吧，你每次移动v1块，我移动v2块，我们看能不能遇上好了。小Hi：好啊，那我们试试呗。一个小时过去了，然而小Hi和小Ho还是没有一次站在同一块石板上。小Ho：不行了，这样走下去不知道什么时候才汇合。小Hi，你有什么办法算算具体要多久才能汇合么？小Hi：让我想想啊。。提示：扩展欧几里德第1行：每行5个整数s1,s2,v1,v2,m，0≤v1,v2≤m≤1,000,000,000。0≤s1,s2&lt;m中间过程可能很大，最好使用64位整型第1行：每行1个整数，表示解，若该组数据无解则输出-10 1 1 2 65 题解模板题 代码点击显/隐代码 扩展欧几里得代码备份#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;// gcd(a,b)long long gcd(long long a, long long b) &#123; return b ? gcd(b, a % b) : a; &#125;// a*x + b*y = gcd(a,b)long long ex_gcd(long long a, long long b, long long &amp;x, long long &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; else &#123; long long d = ex_gcd(b, a % b, y, x); y -= x * (a / b); return d; &#125;&#125;// a*x + b*y = cbool solve(long long a, long long &amp;x, long long b, long long &amp;y, long long c, long long minx) &#123; long long d = ex_gcd(a, b, x, y); if (c % d) return false; long long m = b / d; if (m &lt; 0) m = -m; x *= c / d; x = (x % m + m) % m; y = (c - a * x) / b; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); long long s1, s2, v1, v2, m; while (cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; m) &#123; long long x, y; if (solve(v1 - v2, x, m, y, s2 - s1, 0)) cout &lt;&lt; x &lt;&lt; endl; else cout &lt;&lt; \"-1\" &lt;&lt; endl; &#125; return 0;&#125;","tags":[{"name":"欧几里得算法","slug":"Euclid","permalink":"https://www.oyohyee.com/tags/Euclid/"},{"name":"hihocoder","slug":"hihocoder","permalink":"https://www.oyohyee.com/tags/hihocoder/"}]},{"title":"hihocoder 1295.线性筛","date":"2017-08-05T03:52:06.000Z","path":"/post/hihocoder/1295.html","text":"题目点击显/隐题目 小Ho：小Hi，上次我学会了如何检测一个数是否是质数。于是我又有了一个新的问题，我如何去快速得求解[1,N]这个区间内素数的个数呢？小Hi：你自己有什么想法么？小Ho：有！我一开始的想法是，自然我们已经知道了如何快速判定一个数是否是质数，那么我就直接将[1,N]之间每一个数判定一次，就可以得到结果。但我发现这个方法太笨了。小Hi：确实呢，虽然我们已经通过快速素数检测将每一次判定的时间复杂度降低，但是N个数字的话，总的时间复杂度依旧很高。小Ho：是的，所以后来我改变了我的算法。我发现如果一个数p是质数的话，那么它的倍数一定都是质数。所以我建立了一个布尔类型的数组isPrime，初始化都为true。我从2开始枚举，当我找到一个isPrime[p]仍然为true时，可以确定p一定是一个质数。接着我再将N以内所有p的倍数全部设定为isPrime[p*i]=false。写成伪代码为：isPrime[] = trueprimeCount = 0For i = 2 .. NtrueIf isPrime[i] ThentruetrueprimeCount = primeCount + 1truetruemultiple = 2truetrueWhile (i * multiple ≤ N)truetruetrueisPrime[i * multiple] = falsetruetruetruemultiple = multiple + 1truetrueEnd While trueEnd IfEnd For小Hi：小Ho你用的这个算法叫做Eratosthenes筛法，是一种非常古老的质数筛选算法。其时间复杂度为O(n log log n)。但是这个算法有一个冗余的地方：比如合数10，在枚举2的时候我们判定了一次，在枚举5的时候我们又判定了一次。因此使得其时间复杂度比O(n)要高。小Ho：那有没有什么办法可以避免啊？小Hi：当然有了，一个改进的方法叫做Eular筛法，其时间复杂度是O(n)的。提示：Eular质数筛法第1行：1个正整数n，表示数字的个数，2≤n≤1,000,000。第1行：1个整数，表示从1到n中质数的个数94 题解模板题 代码点击显/隐代码 线性筛代码备份#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 1000005;int prime[maxn], num_prime;bool isNotPrime[maxn];void PRIME(int n) &#123; num_prime = 0; memset(prime, 0, sizeof(prime)); memset(isNotPrime, false, sizeof(isNotPrime)); isNotPrime[0] = isNotPrime[1] = true; for (long i = 2; i &lt; n; i++) &#123; if (!isNotPrime[i]) prime[num_prime++] = i; for (int j = 0; j &lt; num_prime &amp;&amp; i * prime[j] &lt; n; j++) &#123; isNotPrime[i * prime[j]] = true; if (!(i % prime[j])) break; &#125; &#125;&#125;int main() &#123; int n; PRIME(maxn-2); while (scanf(\"%d\", &amp;n) != EOF) printf(\"%d\\n\", upper_bound(prime, prime + num_prime, n) - prime); return 0;&#125;","tags":[{"name":"质数","slug":"Prime","permalink":"https://www.oyohyee.com/tags/Prime/"},{"name":"hihocoder","slug":"hihocoder","permalink":"https://www.oyohyee.com/tags/hihocoder/"}]},{"title":"HDU 5890.Eighty seven","date":"2017-08-05T03:23:17.000Z","path":"/post/HDU/5890.html","text":"题目点击显/隐题目 Mr. Fib is a mathematics teacher of a primary school. In the next lesson, he is planning to teach children how to add numbers up. Before the class, he will prepare N cards with numbers. The number on the i-th card is ai. In class, each turn he will remove no more than 3 cards and let students choose any ten cards, the sum of the numbers on which is 87. After each turn the removed cards will be put back to their position. Now, he wants to know if there is at least one solution of each turn. Can you help him?The first line of input contains an integer t(t≤5), the number of test cases. t test cases follow.For each test case, the first line consists an integer N(N≤50).The second line contains N non-negative integersa1,a2,…,aN. The i-th number represents the number on the i-th card. The third line consists an integer Q(Q≤100000). Each line of the next Q lines contains three integers i,j,k, representing Mr.Fib will remove the i-th, j-th, and k-th cards in this turn. A question may degenerate while i=j, i=k or j=k.For each turn of each case, output ‘Yes’ if there exists at least one solution, otherwise output ‘No’.1121 2 3 4 5 6 7 8 9 42 21 22101 2 33 4 52 3 210 10 1010 11 1110 1 11 2 101 11 121 10 1011 11 12NoNoNoYesNoYesNoNoYesYes 题解按照动态规划的思想,有：dp[i][j][k] = dp[i-1][j][k] | dp[i-1][j-1][k-num[i]]其中 dp[i][j][k] 表示前 i 个数中选择 j 个数能否达到 k 虽然这道题涉及到的 i j k 都比较小,但是由于查询次数达到 100000,还是不能直接动态规划做 对于动态规划部分,可以使用bitset压缩,能够省去 k 的枚举由于 dp[i][][] 的值取决于 dp[i-1][][] ,因此这一维是不需要单独记录的用 dp[i] 表示选取 i 个数的情况下,bitset的各位能否达到则可以得到转移方程 dp[t] |= dp[t-1] &lt;&lt; num[i]其中,&lt;&lt; num[i]表示把 dp[t-1] 整体左移 num[i] 位(相当于一次完成k维的工作) 需要特别注意的是,t 维的循环应该从大到小循环(因为省去了 i 的情况下,从小到大的运算顺序是错的) 另外,这道题的时限是比较紧的,各个部分都需要优化,输入也要用输入优化 代码点击显/隐代码 Eighty seven代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 51;int num[maxn];bitset&lt;90&gt; dp[11];int ans[maxn][maxn][maxn];int n;int read_int() &#123; char c; int ans = 0; while (c = getchar(), !(c &gt;= '0' &amp;&amp; c &lt;= '9')) ; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ans *= 10; ans += (int)c - '0'; c = getchar(); &#125; return ans;&#125;bool getAns(int a, int b, int c) &#123; if (ans[a][b][c] == -1) &#123; for (int i = 0; i &lt;= 10; i++) dp[i].reset(); dp[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; if (i != a &amp;&amp; i != b &amp;&amp; i != c) for (int t = 10; t &gt;= 1; --t) dp[t] |= dp[t - 1] &lt;&lt; num[i]; &#125; ans[a][b][c] = dp[10][87]; &#125; return ans[a][b][c] == 1;&#125;int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); int START = clock();#endif int T = read_int(); while (T--) &#123; memset(ans, -1, sizeof(ans)); n = read_int(); for (int i = 1; i &lt;= n; ++i) num[i] = read_int(); int Q = read_int(); int a[3]; for (int q = 0; q &lt; Q; ++q) &#123; a[0] = read_int(), a[1] = read_int(), a[2] = read_int(); sort(a, a + 3); printf(\"%s\\n\", (getAns(a[0], a[1], a[2]) ? \"Yes\" : \"No\")); &#125; &#125;#ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"记忆化搜索","slug":"Memory-Search","permalink":"https://www.oyohyee.com/tags/Memory-Search/"},{"name":"bitset","slug":"bitset","permalink":"https://www.oyohyee.com/tags/bitset/"}]},{"title":"Codeforces 148D.Bag of mice","date":"2017-08-03T07:48:23.000Z","path":"/post/Codeforces/148D.html","text":"题目点击显/隐题目 The dragon and the princess are arguing about what to do on the New Year’s Eve. The dragon suggests flying to the mountains to watch fairies dancing in the moonlight, while the princess thinks they should just go to bed early. They are desperate to come to an amicable agreement, so they decide to leave this up to chance.They take turns drawing a mouse from a bag which initially contains w white and b black mice. The person who is the first to draw a white mouse wins. After each mouse drawn by the dragon the rest of mice in the bag panic, and one of them jumps out of the bag itself (the princess draws her mice carefully and doesn’t scare other mice). Princess draws first. What is the probability of the princess winning?If there are no more mice in the bag and nobody has drawn a white mouse, the dragon wins. Mice which jump out of the bag themselves are not considered to be drawn (do not define the winner). Once a mouse has left the bag, it never returns to it. Every mouse is drawn from the bag with the same probability as every other one, and every mouse jumps out of the bag with the same probability as every other one.The only line of input data contains two integers w and b (0?≤?w,?b?≤?1000).the probability of the princess winning. The answer is considered to be correct if its absolute or relative error does not exceed 10?-?9.Example1 3 题解记忆化搜索即可注意初始值以及除以0的情况 代码点击显/隐代码 Bag of mice代码备份#include &lt;cstdio&gt;const int maxn = 1005;const double eps = 1e-12;double dp[maxn][maxn];void init(int w, int b) &#123; for (int i = 0; i &lt;= w; i++) for (int j = 0; j &lt;= b; j++) if (i == 0) dp[i][j] = 0; else if (j == 0) dp[i][j] = 1; else dp[i][j] = -1;&#125;double getAns(int w, int b, int deep) &#123; //for (int i = 0; i &lt; deep; i++) // printf(\"\\t\"); //printf(\"dp[%d][%d]:\\n\", w, b); if (w &lt; 0 || b &lt; 0) return 0; if (dp[w][b] &lt; 0) &#123; // get white directly dp[w][b] = (double)w / (w + b); if (w + b &gt;= 3) &#123; // white dp[w][b] += ((double)b / (w + b)) * ((double)(b - 1) / (w + b - 1)) * ((double)w / (w + b - 2)) * getAns(w - 1, b - 2, deep + 1); // black dp[w][b] += ((double)b / (w + b)) * ((double)(b - 1) / (w + b - 1)) * ((double)(b - 2) / (w + b - 2)) * getAns(w, b - 3, deep + 1); &#125; &#125; //for (int i = 0; i &lt; deep; i++) // printf(\"\\t\"); //printf(\"%.9f\\n\", dp[w][b]); return dp[w][b];&#125;int main() &#123; int w, b; while (scanf(\"%d%d\", &amp;w, &amp;b) != EOF) &#123; init(w, b); printf(\"%.10f\\n\", getAns(w, b, 1)); &#125; return 0;&#125;","tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.oyohyee.com/tags/DFS/"},{"name":"记忆化搜索","slug":"Memory-Search","permalink":"https://www.oyohyee.com/tags/Memory-Search/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"},{"name":"概率dp","slug":"Probability-DP","permalink":"https://www.oyohyee.com/tags/Probability-DP/"}]},{"title":"POJ 3071.Football","date":"2017-08-03T06:20:57.000Z","path":"/post/POJ/3071.html","text":"题目点击显/隐题目 Consider a single-elimination football tournament involving 2n teams, denoted 1, 2, …, 2n. In each round of the tournament, all teams still in the tournament are placed in a list in order of increasing index. Then, the first team in the list plays the second team, the third team plays the fourth team, etc. The winners of these matches advance to the next round, and the losers are eliminated. After n rounds, only one team remains undefeated; this team is declared the winner.Given a matrix P = [pij] such that pij is the probability that team i will beat team j in a match determine which team is most likely to win the tournament.The input test file will contain multiple test cases. Each test case will begin with a single line containing n (1 ≤ n ≤ 7). The next 2n lines each contain 2n values; here, the jth value on the ith line represents pij. The matrix P will satisfy the constraints that pij = 1.0 ? pji for all i ≠ j, and pii = 0.0 for all i. The end-of-file is denoted by a single line containing the number ?1. Note that each of the matrix entries in this problem is given as a floating-point value. To avoid precision problems, make sure that you use either the double data type instead of float.The output file should contain a single line for each test case indicating the number of the team most likely to win. To prevent floating-point precision issues, it is guaranteed that the difference in win probability for the top two teams will be at least 0.01.20.0 0.1 0.2 0.30.9 0.0 0.4 0.50.8 0.6 0.0 0.60.7 0.5 0.4 0.0-12 题解画出来比赛的流程图,可以发现能够用位运算方便表示出如何进行比赛如队伍i的第j场比赛的对手是对i的j位取反,后面的数为0到为1的范围内的数 然后使用dp[i][j]表示第i场比赛,队伍j获胜的概率计算出所有的值然后选出最大的即可 代码点击显/隐代码 Football代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 8;const int maxm = 2 &lt;&lt; 8;double Pro[maxm][maxm];double dp[maxn][maxm];int getTeam(int number, int bit, int flag) &#123; int ans = number ^ (1 &lt;&lt; bit); //把bit位取反 ans = (ans &gt;&gt; (bit)) &lt;&lt; (bit); if (flag) ans += (1 &lt;&lt; bit) - 1; return ans;&#125;int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock();#endif cin.tie(0); cin.sync_with_stdio(false); int n; while (cin &gt;&gt; n) &#123; if (n == -1) continue; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) for (int j = 0; j &lt; (1 &lt;&lt; n); j++) cin &gt;&gt; Pro[i][j]; for (int i = 0; i &lt; n; i++) &#123; // cout &lt;&lt; \"Game round\" &lt;&lt; i + 1 &lt;&lt; \": \" &lt;&lt; endl; for (int j = 0; j &lt; (1 &lt;&lt; n); j++) &#123; if (i == 0) &#123; // cout &lt;&lt; \"\\t\" &lt;&lt; j &lt;&lt; \" vs. \" &lt;&lt; getTeam(j, i, 1) &lt;&lt; endl; dp[i][j] = Pro[j][getTeam(j, i, 0)]; &#125; else &#123; dp[i][j] = 0; for (int k = getTeam(j, i, 0); k &lt;= getTeam(j, i, 1); k++) &#123; // cout &lt;&lt; \"\\t\" &lt;&lt; j &lt;&lt; \" vs. \" &lt;&lt; k &lt;&lt; endl; dp[i][j] += dp[i - 1][k] * Pro[j][k]; &#125; dp[i][j] *= dp[i - 1][j]; &#125; // cout &lt;&lt; \"\\t\\tdp[i][j]=\" &lt;&lt; dp[i][j] &lt;&lt; endl; &#125; &#125; int pos = 0; for (int i = 1; i &lt; (1 &lt;&lt; n); i++) &#123; // cout &lt;&lt; dp[n - 1][i] &lt;&lt; endl; if (dp[n - 1][i] &gt; dp[n - 1][pos]) pos = i; &#125; cout &lt;&lt; pos + 1 &lt;&lt; endl; &#125;#ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"位运算","slug":"Bit","permalink":"https://www.oyohyee.com/tags/Bit/"},{"name":"概率dp","slug":"Probability-DP","permalink":"https://www.oyohyee.com/tags/Probability-DP/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"POJ 3744.Scout YYF","date":"2017-08-02T06:22:23.000Z","path":"/post/POJ/3744.html","text":"题目点击显/隐题目 YYF is a couragous scout. Now he is on a dangerous mission which is to penetrate into the enemy’s base. After overcoming a series difficulties, YYF is now at the start of enemy’s famous “mine road”. This is a very long road, on which there are numbers of mines. At first, YYF is at step one. For each step after that, YYF will walk one step with a probability of p, or jump two step with a probality of 1- p. Here is the task, given the place of each mine, please calculate the probality that YYF can go through the “mine road” safely.The input contains many test cases ended with EOF.Each test case contains two lines.The First line of each test case is N (1 ≤ N ≤ 10) and p (0.25 ≤ p ≤ 0.75) seperated by a single blank, standing for the number of mines and the probability to walk one step.The Second line of each test case is N integer standing for the place of N mines. Each integer is in the range of [1, 100000000].For each test case, output the probabilty in a single line with the precision to 7 digits after the decimal point.1 0.522 0.52 40.50000000.2500000 题解不考虑地雷的情况下,可以很容易得到递推式:dp(i) = p*dp(i-1)+(1-p)*dp(i-2) 然而由于距离可以达到100000000,直接去计算需要非常多的内存 根据概率的知识,可以知道,能够通过每一个雷区的概率等于1-踩雷的概率而通过整个区域的概率就是通过每个雷区的概率的乘积 根据雷区的位置,可以把整个区域分成多段,每一段有且仅有一个地雷计算每一段的概率即可 不过每一段的长度也有可能是非常长的,要解决它有两种思路:高中数学优化和高等数学优化 对于 $a_n = p \\times a_{n-1}+(1-p) \\times a_{n-2}$ ,求其通项公式化简步骤如下: $$ \\begin{align*} a_n &= p \\times a_{n-1} + (1-p) \\times a_{n-2} \\\\ a_n &= (1-(1-p)) \\times a_{n-1} + (1-p) \\times a_{n-2} \\\\ a_n &= a_{n-1} - (1-p) \\times a_{n-1} + (1-p) \\times a_{n-2} \\\\ a_n - a_{n-1} &= -(1-p) (a_{n-1} - a_{n-2}) \\\\ \\end{align*} $$ 这时,已经可以看出等号两边的结构相等了设一个辅助数列 $$ \\begin{align*} 令 b_n &= a_{n+1}-a_{n} \\\\ \\\\ 有 b_n &= (p-1) \\times b_{n-1} \\\\ 可得 b_n &= b_1 \\times (p-1)^n-1 \\\\ b_{n-1} &= b_1 \\times (p-1)^{n-2} \\\\ b_{n-1} &= a_{n} - a_{n-1}\\\\ \\\\ a_{n} - a_{n-1} &= (a_2 - a_1) \\times (p-1)^{n-2} \\\\ a_{n-1} - a_{n-2} &= (a_2 - a_1) \\times (p-1)^{n-3} \\\\ & ...\\\\ a_{2} - a_{1} &= (a_2 - a_1) \\times (p-1)^{0} \\\\ \\\\ a_{n} - a_{1} &= \\sum_{i=0}^{n-2} ((a_2 - a_1) \\times (p-1)^i) \\\\ a_{n} - a_{1} &= (a_2 - a_1) \\times \\sum_{i=0}^{n-2} (p-1)^i) \\\\ a_{n} - a_{1} &= (a_2 - a_1) \\times \\frac {1 \\times (1-(p-1)^{n-1})} {1-(p-1)} \\\\ a_{n} &= a_{1} + (a_2 - a_1) \\times \\frac {1-(p-1)^{n-1}} {2-p} \\\\ \\\\ 其中 a_1 &= 1 , a_2 = p\\\\ a_{n} &= 1 + (p-1) \\times \\frac {1-(p-1)^{n-1}} {2-p} \\\\ \\end{align*} $$ 也即,我们有了dp的通项公式dp[i] = 1 + (p-1)*(1-(p-1)^(n-1)/(2-p)) 平方部分使用快速幂计算即可 当然,也可以使用高等数学部分的矩阵乘法 $ \\begin{pmatrix} p & 1-p\\\\ 1 & 0 \\end{pmatrix} \\times \\begin{pmatrix} dp[i] \\\\ dp[i-1] \\end{pmatrix} = \\begin{pmatrix} p \\times dp[i] + (1-p) \\times dp[i-1] \\\\ dp[i] \\end{pmatrix} = \\begin{pmatrix} dp[i+1] \\\\ dp[i] \\end{pmatrix} $ 那么可以推出dp[i]的表达式为$ \\begin{pmatrix} dp[i]\\\\ dp[i-1] \\end{pmatrix} = \\begin{pmatrix} p & 1-p\\\\ 1 & 0 \\end{pmatrix} ^ {n-2} \\times \\begin{pmatrix} p\\\\ 1 \\end{pmatrix} $ 使用快速矩阵幂计算即可,需要注意两个雷紧挨着的时候的情况 代码点击显/隐递推方法代码 Scout YYF递推代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;const int maxn = 15;double pow(double a, int n) &#123; if (n == 0) return 1.0; if (n == 1) return a; double ans = pow(a, n / 2); ans = ans * ans; if (n &amp; 1) ans *= a; return ans;&#125;double f(int n,double p)&#123; return 1 + (p - 1) * (1 - pow(p - 1, n - 1)) / (2 - p);&#125;int mines[maxn];int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock();#endif cin.tie(0); cin.sync_with_stdio(false); int n; double p; while (cin &gt;&gt; n &gt;&gt; p) &#123; mines[0] = 0; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; mines[i]; sort(mines + 1, mines + 1 + n); double ans = 1; for (int i = 1; i &lt;= n; i++) &#123; int dis = mines[i] - mines[i - 1]; double dp = f(dis,p); //cout &lt;&lt;\"\\t \"&lt;&lt;dis&lt;&lt;\" \"&lt;&lt; dp&lt;&lt;endl; ans *= (1 - dp); &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(7) &lt;&lt; ans &lt;&lt; endl; &#125;#ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125; 点击显/隐矩阵方法代码 Scout YYF矩阵代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;const int maxn = 15;class Matrix &#123; public: static const int LINE = 2; //行列数 double matrix[LINE][LINE]; Matrix() &#123; for (int i = 0; i &lt; LINE; i++) for (int j = 0; j &lt; LINE; j++) matrix[i][j] = 0; &#125; Matrix operator*(Matrix rhs) &#123; return mul(*this, rhs); &#125; Matrix operator^(int n) &#123; return pow(*this, n); &#125; static Matrix mul(Matrix a, Matrix b) &#123; Matrix ans; for (int i = 0; i &lt; LINE; i++) for (int j = 0; j &lt; LINE; j++) &#123; ans.matrix[i][j] = 0; for (int k = 0; k &lt; LINE; k++) ans.matrix[i][j] += a.matrix[i][k] * b.matrix[k][j]; &#125; return ans; &#125; static Matrix pow(Matrix a, int n) &#123; if (n == 0) &#123; Matrix E; for (int i = 0; i &lt; LINE; i++) E.matrix[i][i] = 1; return E; &#125; if (n == 1) return a; Matrix ans = pow(a, n / 2); ans = ans * ans; if (n &amp; 1) return ans * a; return ans; &#125; void print() &#123; for (int i = 0; i &lt; LINE; i++) &#123; printf(\"|\"); for (int j = 0; j &lt; LINE; j++) printf(\"%f \", matrix[i][j]); printf(\"|\\n\"); &#125; printf(\"\\n\"); &#125;&#125;;int mines[maxn];int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock();#endif cin.tie(0); cin.sync_with_stdio(false); int n; double p; while (cin &gt;&gt; n &gt;&gt; p) &#123; mines[0] = 0; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; mines[i]; sort(mines + 1, mines + 1 + n); double ans = 1; for (int i = 1; i &lt;= n; i++) &#123; int dis = mines[i] - mines[i - 1]; if (dis == 1) &#123; ans = 0; break; &#125; Matrix dp, pro; dp.matrix[0][0] = p; dp.matrix[1][0] = 1; pro.matrix[0][0] = p; pro.matrix[0][1] = 1 - p; pro.matrix[1][0] = 1; dp = Matrix::pow(pro, dis - 2) * dp; dp.print(); ans *= (1 - dp.matrix[0][0]); &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(7) &lt;&lt; ans &lt;&lt; endl; &#125;#ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"递推","slug":"Recurrence","permalink":"https://www.oyohyee.com/tags/Recurrence/"},{"name":"概率dp","slug":"Probability-DP","permalink":"https://www.oyohyee.com/tags/Probability-DP/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"},{"name":"矩阵","slug":"Matrix","permalink":"https://www.oyohyee.com/tags/Matrix/"},{"name":"快速矩阵幂","slug":"PowMatrix","permalink":"https://www.oyohyee.com/tags/PowMatrix/"}]},{"title":"AOJ 898.黑匣子","date":"2017-08-01T03:01:37.000Z","path":"/post/AOJ/898.html","text":"题目点击显/隐题目 Description我们使用黑匣子的一个简单模型。它能存放一个整数序列和一个特别的变量i。在初始时刻，黑匣子为空且i等于0。这个黑匣子能执行一系列的命令。有两类命令：ADD(x)：把元素x放入黑匣子；GET：把i加1的同时，输出黑匣子内所有整数中第i小的数。牢记第i小的数是当黑匣子中的元素已非降序排序后位于第i位的元素。下面的表是一个11个命令的例子：现需要一个有效的算法处理给定的一系列命令。ADD和GET命令的总数至多个有30000个。定义ADD命令的个数为M个，GET命令的个数为N个。我们用下面得两个整数序列描述命令序列：1．A(1),A(2),……,A(M)：加入黑匣子的元素序列。所有的数均为绝对值不超过2000000的整数。例如在上例中A=(3,1,-4,2,8,-1000,2)。2．u(1),u(2),……,u(N)：u(i)表示第i个GET命令在第u(i)个ADD命令之后，例如在上例中，u=(1,2,6,6)。你可以假定自然数序列u(1),u(2),……,u(N)以非降序排列，N≤M，且对于每一个p（1≤p≤N）有p≤u(p)≤M。第一行存放M和N的值,第二行存放 A(1),A(2),……,A(M) ,第三行存放u(1),u(2),……,u(N)。输出黑匣子的处理结果。7 43 1 -4 2 8 -1000 21 2 6 63312 题解用vector模拟所有操作即可,复杂度有点高不过能过 代码点击显/隐代码 黑匣子代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int maxn = 30005;int A[maxn];int U[maxn];int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock();#endif cin.tie(0); cin.sync_with_stdio(false); int m, n; while (cin &gt;&gt; m &gt;&gt; n) &#123; for (int i = 0; i &lt; m; i++) cin &gt;&gt; A[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; U[i]; sort(U, U + n); vector&lt;int&gt; v; int I = 0; int getNum = 0, addNum = 0; for (int i = 0; i &lt; n + m; i++) &#123; if (U[getNum] == addNum) &#123; //cout &lt;&lt; \"Get(\" &lt;&lt; I &lt;&lt; \")\" &lt;&lt; endl; cout &lt;&lt; v[I++] &lt;&lt; endl; getNum++; if (getNum &gt;= n) break; &#125; else &#123; //cout &lt;&lt; \"Add(\" &lt;&lt; A[addNum] &lt;&lt; \") \"; v.insert(lower_bound(v.begin(), v.end(), A[addNum]), A[addNum]); // for (size_t i = 0; i &lt; v.size(); i++) // cout &lt;&lt; v[i] &lt;&lt; \" \"; // cout &lt;&lt; endl; addNum++; &#125; &#125; &#125;#ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"向量(vector)","slug":"Vector","permalink":"https://www.oyohyee.com/tags/Vector/"}]},{"title":"AOJ 895.艰难取舍","date":"2017-08-01T02:48:09.000Z","path":"/post/AOJ/895.html","text":"题目点击显/隐题目 Description由于 lls 长得实在是太帅了，英俊潇洒，风流倜傥，人见人爱，花见花开，车见车载。有一群 MM 排队看 lls。每个 MM 都有自己独特的风格，由于 lls 有着一颗包容的心，所以，什么风格的 MM 他都喜欢……但是，lls 有一个特别的要求，他不希望总是看到风格得差不多的 MM，更加特别的是，如果两个 MM 风格完全一样， lls 不会有任何意见。现在， lls 希望从去看他的 MM 中，去掉一些 MM，从而使得相邻 2 个 MM 的风格值的差（绝对值）不为 1。自然地， lls 希望去掉的 MM 越少越好。第一行一个整数 N；第 2~N+1 行 N 个整数，第 i 个为 ci。表示第 i 个 MM 的风格值。一个数，表示最少要去掉的 MM 数。64221112HintN≤1000,0 ≤ ci ≤ 2000 题解从一群人中,删除最少的人,使相邻人的距离不为1可以等价为从一群人中,选择最多的人(子序列),使相邻人的距离不为1也即可以套用最长上升子序列的模板,改一下判断部分即可 代码点击显/隐代码 艰难取舍代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 1005;int a[maxn], dp[maxn];inline int abs(int a)&#123; return a&gt;0?a:-a;&#125;int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock();#endif cin.tie(0); cin.sync_with_stdio(false); int n; while (cin &gt;&gt; n) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; int Max = 0; for (int i = 1; i &lt;= n; i++) &#123; dp[i] = 0; for (int j = 0; j &lt; i; j++) &#123; if (abs(a[i] - a[j]) != 1) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; Max = max(Max, dp[i]); &#125; cout &lt;&lt; n-Max &lt;&lt; endl; &#125;#ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"最长上升子序列","slug":"LIS","permalink":"https://www.oyohyee.com/tags/LIS/"}]},{"title":"AOJ 894.种花","date":"2017-08-01T01:52:48.000Z","path":"/post/AOJ/894.html","text":"题目点击显/隐题目 Description花老师有一个农场，农场的花一共有 4 种颜色， 花老师不喜欢老旧的东西，所以，她希望每天种花的方案都不一样。特别地，她也觉得两种一样颜色的花种在相邻的位置会很无聊。现在，她想知道，一共有多少种花的方案。这里要注意的是，农场的种花的位置是不规则的。因此我们给出一对一对的相邻的位置的关系。第一行两个数 N 和 M，表示种花的位置的个数和相邻的位置的对数接下来 M 行，每行一组数 A， B 表示 A， B 相邻一个数表示染色方法数5 41 21 31 41 5324 题解直接暴力跑就行枚举所有的情况(使用递归),判断能否涂上特定的颜色,如果能成功枚举到终点就计数不需要想太复杂 代码点击显/隐代码 种花代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 15;const int maxm = 55;bool Edge[maxn][maxn];int color[maxn];int n, m;int sum;bool judge(int t, int c) &#123; for (int i = 1; i &lt;= n; i++) &#123; if (Edge[t][i]) &#123; //相邻 if (color[i] == c) //有重复的颜色 return false; &#125; &#125; return true;&#125;//给t涂上cvoid dfs(int t, int c, int deep) &#123; if (!judge(t, c)) return; // for (int i = 0; i &lt; deep; i++) // cout &lt;&lt; \"\\t\"; // cout &lt;&lt; \"fill \" &lt;&lt; t &lt;&lt; \" in color \" &lt;&lt; c &lt;&lt; endl; color[t] = c; if (t &lt; n) for (int k = 1; k &lt;= 4; k++) dfs(t + 1, k, deep + 1); else sum++; color[t] = 0;&#125;//从 s 开始给连通分量内的点涂色int begin(int s) &#123; sum = 0; for (int k = 1; k &lt;= 4; k++) &#123; dfs(s, k, 0); &#125; //cout &lt;&lt; s &lt;&lt; \" \" &lt;&lt; sum &lt;&lt; endl; return sum;&#125;int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); int START = clock();#endif cin.tie(0); cin.sync_with_stdio(false); while (cin &gt;&gt; n &gt;&gt; m) &#123; memset(Edge, false, sizeof(Edge)); for (int i = 0; i &lt; m; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; Edge[a][b] = Edge[b][a] = true; &#125; int ans = begin(1);/* for (int i = 2; i &lt;= n; i++) &#123; if (color[i] == 0) &#123; ans *= begin(i); &#125; &#125;*/ cout &lt;&lt; ans &lt;&lt; endl; &#125;#ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"暴力","slug":"Violence","permalink":"https://www.oyohyee.com/tags/Violence/"}]},{"title":"AOJ 890.修理牛棚","date":"2017-07-31T11:40:14.000Z","path":"/post/AOJ/890.html","text":"题目点击显/隐题目 Description在一个夜黑风高,下着暴风雨的夜晚,农民约翰的牛棚的屋顶、门被吹飞了。 好在许多牛正在度假，所以牛棚没有住满。 剩下的牛一个紧挨着另一个被排成一行来过夜。 有些牛棚里有牛，有些没有。 所有的牛棚有相同的宽度。 自门遗失以后,农民约翰必须尽快在牛棚之前竖立起新的木板。 他的新木材供应商将会供应他任何他想要的长度,但是供应商只能提供有限数目的木板。 农民约翰想将他购买的木板总长度减到最少。给出:可能买到的木板最大的数目M(1&lt;=M&lt;=50);牛棚的总数S(1&lt;=S&lt;=200); 牛棚里牛的总数C(1&lt;=C&lt;=S);和牛所在的牛棚的编号stall_number(1&lt;=stall_number&lt;=S),计算拦住所有有牛的牛棚所需木板的最小总长度。 输出所需木板的最小总长度作为答案。1行: M，S和C(用空格分开)2到C+1行:每行包含一个整数，表示牛所占的牛棚的编号。单独的一行包含一个整数表示所需木板的最小总长度。4 50 183468141516172125262730314041424325 题解这道题有多种不同的思路 贪心首先假定我们用一个木板拦住所有的牛,当我们有多于一个木板的时候,我们的任务就是选一个最大的区间,从这里把木板拆成两个 当有多个木板时同理,不停寻找最大的区间即可 细节比较多,可以把中间变量输出出来进行测试 需要特别注意的是: 牛所在的牛栏并不是有序输出的,同时存在没有牛和木板比牛的情况 动态规划动态规划最重要的是转移方程 可以看出自变量的应该是木板数和牛栏数,也即有:dp(i,j) 表示前i个牛栏使用j个木板所需要的最小木板总长度 那么就可以看出在已经有dp(i-1,j)的情况下,又加入一个新的牛栏(有牛),存在两种处理方案： 用一块新的木板 dp(i-1,j-1)+1 延长上一块木板 dp(i-1,j)+a[i]-a[i-1] 也即 dp(i,j) = min( dp(i-1,j-1)+1, dp(i-1,j)+a[i]-a[i-1] ) 然后需要处理的就是边界条件按照实际含义来想,dp(0,k) 表示0个牛栏需要的木板数,显然应该是0而 dp(k,0) (k!=0) 表示没有木板的情况下,拦住k个有牛的牛栏,应该是无穷大 综上:$ dp(i,j) = \\left\\{\\begin{matrix} 0 & i=0\\\\ INF & i \\neq 0,j=0\\\\ min(dp(i-1,j-1)+1,dp(i-1,j)+a[i]-a[i-1]) & 其他 \\end{matrix}\\right. $ 代码贪心点击显/隐代码 修理牛棚(贪心)代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 205;int a[maxn], b[maxn];int m, s, c;int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock();#endif cin.tie(0); cin.sync_with_stdio(false); while (cin &gt;&gt; m &gt;&gt; s &gt;&gt; c) &#123; for (int i = 0; i &lt; c; i++) cin &gt;&gt; a[i]; sort(a,a+c); if (c == 0 || m &gt;= c ) &#123; cout &lt;&lt; c &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt; c - 1; i++) b[i] = a[i + 1] - a[i] - 1; sort(b, b + c - 1); int ans = a[c - 1] - a[0] + 1; // cout&lt;&lt;ans&lt;&lt;endl; for (int i = 0; i &lt; m - 1; i++) &#123; // cout&lt;&lt;b[c-1-i]&lt;&lt;endl; ans -= b[c - 2 - i]; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125;#ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125; 动态规划点击显/隐代码 修理牛棚(dp)代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 205;const int INF = 0x3f3f3f;int a[maxn];int m, s, c;int dp[maxn][maxn];int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock();#endif cin.tie(0); cin.sync_with_stdio(false); a[0] = 0; while (cin &gt;&gt; m &gt;&gt; s &gt;&gt; c) &#123; for (int i = 1; i &lt;= c; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a + 1, a + 1 + c); for (int i = 0; i &lt;= c; i++) dp[i][0] = INF; memset(dp[0], 0, sizeof(dp[0])); for (int i = 1; i &lt;= c; i++) for (int j = 1; j &lt;= m; j++) dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + a[i] - a[i - 1]); cout &lt;&lt; dp[c][m] &lt;&lt; endl; // for (int i = 0; i &lt;= c; i++)&#123; // for (int j = 0; j &lt;= m; j++) // printf(\"%5d \",dp[i][j]); // printf(\"\\n\"); // &#125; &#125;#ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"}]},{"title":"AOJ 887.又是迷宫","date":"2017-07-31T11:29:55.000Z","path":"/post/AOJ/887.html","text":"题目点击显/隐题目 Description晚上，跑男们来了节目的最后一站：江苏省扬州中学，完成最后一项比赛：撕名牌。撕名牌的地点是一个由n*n房间组成的正方形，每个房间里都有一个数字，表示从这个房间可以通过地道向右或向下穿过几个房间。从左上角开始，如果谁能安全到达右下角就算胜利。 这里4*4的方格中每一格表示进入这个房间时，队员可以向右或向下穿过的房间数。郑恺是奔跑小王子，当他拿到这张地图时，脸都变绿了，速度再快，进了迷宫一样的房间也是没办法啊，还好参加JSOI2015夏令营的小伙伴都在，你能帮帮他算出从左上角可以到达右下角的路径数目吗？第一行为一个整数n，表示棋盘的大小。以下有n行，每行有n个数字（数字与数字之间有一个空格隔开），表示在相应的格子内，棋子可以向右或向下跳跃的格子数。输出共一行，包含一个数，表示从左上角可以到达右下角的路径数目。42 3 3 11 2 1 31 2 3 13 1 1 03 题解题意理解如下：每个方格的数字代表向右/下移动的格数（不能转向）因此有 f(x,y)=f(x+Map[x][y],y)+f(x,y+Map[x][y])采用记忆化搜索递推即可 代码点击显/隐代码 又是迷宫代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 105;int Map[maxn][maxn];int ans[maxn][maxn];bool vis[maxn][maxn];int n;int dfs(int x, int y) &#123; if (x &gt; n || y &gt; n) return 0; if (ans[x][y] == -1) &#123; ans[x][y] = 0; if (x + Map [x][y] &lt;= n) ans[x][y] += dfs(x + Map [x][y], y); if (y + Map [x][y] &lt;= n) ans[x][y] += dfs(x, y + Map [x][y]); &#125; return ans[x][y];&#125;int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock();#endif cin.tie(0); cin.sync_with_stdio(false); while (cin &gt;&gt; n) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; Map[i][j]; &#125; &#125; memset(ans, -1, sizeof(ans)); ans[n][n] = 1; cout &lt;&lt; dfs(1, 1) &lt;&lt; endl; // for (int i = 1; i &lt;= n; i++) &#123; // for (int j = 1; j &lt;= n; j++) &#123; // cout &lt;&lt; ans[i][j]; // &#125; // cout &lt;&lt; endl; // &#125; &#125;#ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"记忆化搜索","slug":"Memory-Search","permalink":"https://www.oyohyee.com/tags/Memory-Search/"}]},{"title":"AOJ 880.骨牌问题","date":"2017-07-31T11:03:42.000Z","path":"/post/AOJ/880.html","text":"题目点击显/隐题目 Description已知3×2n个棋盘格子，试求用火柴棒覆盖所有格子的方法（一根火柴棒可覆盖2个格子）。如n=1时，有如下3种覆盖方法： Hint最后结果需要高精度n，n&lt;1000。用火柴棒覆盖所有3×2n格子的方案数。13 题解画图找规律,可以发现:$F(1)=3$$F(2)=11$$F(3)=3f(2)+2f(1)+2$ $f(n)=3f(n-1)+2f(n-2)+2f(n-3)+2f(n-4)+2f(n-5)+……+2f(1)+2$$f(n)=3f(n-1)-f(n-2)+(3f(n-2)+2f(n-3)+2f(n-4)+2f(n-5)+……+2f(1)+2$$f(n)=3f(n-1)-f(n-2)+f(n-1)$$f(n)=4*f(n-1)-f(n-2)$ 使用高精度算法即可 高精度模板有问题，使用java 代码点击显/隐代码 骨牌问题代码备份import java.util.*;import java.io.*;import java.math.*;public class a &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); Integer n; BigDecimal x, y, z; while (in.hasNext()) &#123; n = in.nextInt(); if (n == 0) &#123; System.out.println(0); continue; &#125; BigInteger dp_1 = BigInteger.valueOf(3); BigInteger dp_2 = BigInteger.valueOf(1); BigInteger dp = BigInteger.valueOf(3); for (int i = 1; i &lt; n; i++) &#123; dp = dp_1.multiply(BigInteger.valueOf(4)).subtract(dp_2); dp_2 = dp_1; dp_1 = dp; &#125; System.out.println(dp); &#125; &#125;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"高精度算法","slug":"High-precision","permalink":"https://www.oyohyee.com/tags/High-precision/"}]},{"title":"The-One 仿真软件修改","date":"2017-07-07T16:39:12.000Z","path":"/post/Note/the-one.html","text":"The-ONE 是一个机会网络模拟仿真系统,使用该模拟可以方便地测试DTNs网络中各种不同的路由的效果. 背景知识什么是DTNDTN(Delay-Tolerant Network)是容滞网络. 现在的网络环境依托于高效的硬件设施,一个消息需要在短时间内得到回执,从而确保信息的正确传输.而显然,当网络的现实条件无法达到要求时,信息将完全无法正常传输. 而容滞网络就是为了解决这种问题而诞生的一种新的网络.它允许信息在发出的一天甚至更长时间后才到达,并且信息在网络中的失效时间更长. 举例而言,容滞网络就像在一个荒岛上,零零散散地居住着一些居民.居民们过着通信基本靠吼的生活.今天,岛东的A想要告诉岛西的B一件事.A把这个消息告诉了经常与自己见面的邻居岛民CDE,让他们帮自己传达.而CDE的活动范围也是有限的,他们把消息又传达给自己经常见到的人……就这样,消息最终传达到了B的耳朵里（当然,也有可能传达不到,或者消息已经没有意义的很久以后才传达到） 其中,又需要考虑如果一个人需要传达的消息太多,他可能会忘掉最早要传达的信息；信息如果弄得人尽皆知太兴师动众,希望尽可能少的人知道（每个人只告诉一个人）等具体要求.这就牵扯到了不同的路由. 在一种特定的情况下,如何制定一个满足以下要求的传递消息的协议（路由）,就是我们应该研究的. 尽可能保证信息能够传达到（递交率高） 尽可能让最少人知道（开效率低） 尽可能早点传递成功（延时率低） 容滞网络本身是架构于当前网络协议之上的,称之为聚束层.比如将上面的例子中的村民变为小岛,荒岛变为大海.岛A的居民a想把消息传达给岛B的居民b岛内的网络可能是我们当前使用的普通网络,而岛与岛之间信息的传递使用容滞网络. 在信息的传递过程中,有以下可能会涉及到的名词:信源:消息的产生者信束:消息的接受者副本:消息实体在传递过程中产生的复制版本 什么是The-ONEThe-ONE是一个使用Java写的DTN网络仿真软件.通过不同配置文件,可以设定结点的数目、移动方式、路由传递协议等各种信息其有GUI模式和终端模式,GUI模式更为直观,而终端模式则能更快得到仿真结果. 写出自己的The-ONE路由协议模拟环境在一个战场上,存在指挥、士官、士兵三种级别的军人.他们在战场区域内随机移动（检查战场区域）.而每一个人都有可能会发现不同的情报.情报分为三个等级:紧急,重要,一般显然,指挥官的发出的紧急情报最为重要,这可能会影响全局布防,而士官的紧急情报可能只会影响局部的胜负.因此需要给不同的情报设定不同的优先程度使用High、Middle、Low表示发出情报的人员的优先度,H、M、L代表情报的优先度.如:士官发出的紧急情报为MiddleH 很显然,优先度越高的情报应该更快送达目的地,如何实现更快呢？计算机中最常见的加快速度的方法就是:空间换时间也即放弃一部分开销率来换取更高的递交率和更小的延时率 我们选择使用二分散发等待路由（Spary and Wait）来实现消息的传递.二分散发等待路由类似发传单.信源把需要传递的信息印成特定份数的传单（当然,发出去前事实上并没有占用空间,也即发出去后才印制传单）.传递消息的时候会把一半的传单给遇到的人,让它帮自己发……这样,对于每个有传单的结点,都会把一半的传单发给遇到的人,让他们帮自己发.直到自己只剩下一张传单,这张就留着,等到遇到信束后直接给它. 同时,考虑到每名军人的存储装置的容量有限.因此消息是有可能被移除掉的.有两种针对缓存区的删除方式: 删除最早的消息 根据优先级按概率删除 分析The-ONE的相关代码The-ONE里本身就有一个散发等待的路由协议,我们可以直接从这里看起. src/routing/SprayAndWaitRouter.java 根据代码可以大概分析出以下内容: 该类继承与ActiveRouter 该类的成员函数只有简单的实现部分操作 所有使用散发等待模型的初始副本数是确定的 前两点说明了SprayAndWaitRouter大多数实现继承于父函数,并且路有部分在仿真时是由其它部分调用的最后一点则说明自带的散发等待不能满足我们的要求(根据不同的优先级产生不同的副本)其具体实现位于createNewMessage函数中的msg.addProperty(MSG_COUNT_PROPERTY, new Integer(initialNrofCopies)); 对于我们而言,路由部分需要实现不同优先级不同初始副本数以及按照优先级概率删除缓存区信息 不同优先级不同初始副本数实现不同副本数就在我们刚才看到的那段函数中,我们在新建消息的时候,根据不同的消息种类,初始化不同的副本数即可 、获取消息的名字可以用m.getId(),他返回的id是perfix+number,只需要消去数字部分即可 按照优先级概率删除缓存区信息这一部分也是路由的一部分,不过定义在src/routing/ActiveRouter.java的makeRoomForMessage函数中这个函数是结点空间不够的时候,释放原有信息的函数,其中的getNextMessageToRemove返回的就是下一个要删除的信息我们来看一下它的具体实现点击显/隐 protected Message getNextMessageToRemove(boolean excludeMsgBeingSent) &#123;truetrueCollection&lt;Message&gt; messages = this.getMessageCollection();truetrueMessage oldest = null;truetruefor (Message m : messages) &#123;truetruetrueif (excludeMsgBeingSent &amp;&amp; isSending(m.getId())) &#123;truetruetruetruecontinue; // skip the message(s) that router is sendingtruetruetrue&#125; truetruetrueif (oldest == null ) &#123;truetruetruetrueoldest = m;truetruetrue&#125; else if (oldest.getReceiveTime() &gt; m.getReceiveTime()) &#123;truetruetruetrueoldest = m;truetruetrue&#125;truetrue&#125;truetruereturn oldest;true&#125; 很容易看出来,这段代码返回的是buffer里最早的信息,也即按照时间删除而我们需要修改出另一个buffer管理策略:按照优先级概率删除 由于直接给定百分比删除存在较多的问题,难以计算,可以换一种策略进行随机选择定义一个值:删除率加入HighH到LowL的删除率分别为1、2、3、4、5、6、7、8、9,那么如果一个结点中有2个HighL、5个MiddleM、10个LowL我们将信息复制其删除率份到一个新的链表里,即新的链表里有6个HighL、25个MiddleM、90个LowL,在这121个消息中,随机选择一个消息,返回给上一层函数,实现删除功能,可以近似看做是按照概率删除.(当然,直接实现我们原本意义上的按照概率删除是其实是非常难的) 实现我们自己的代码要实现我们自己的代码,需要先知道如何读入配置信息可以不去看相关的代码实现部分,之间研究其它地方读入的代码Settings s = new Settings(namespace);s.getInt(key);s.getSetting(key); 通过这样的的方法获取指定的设置 因此只需要读入相应的设置,然后更改对应的函数即可 参数的设定如何设定一组靠谱的数据呢？首先要明确我们的要求 初步,我们设定为10000×10000的野外,每名军人是随机移动（随机路点模型）根据人类正常步行速度,将结点移动速度设定为(1,2)无线电通信范围为100米,传输速度为500k军人结点共三种,分别为High,Middle,Low分别代表三种优先级的军人而每种军人又能发出三种不同的消息,共9种,分别是’HighH’,HighM,HighL,MiddleH,MiddleM,MiddleL,LowH,LowM,LowL根据我们设定的路由,这9种消息的最大副本数分别为256,128,64,64,32,16,16,8,4而他们的删除率分别为2,4,8,3,6,12,4,8,16 这样我们可以通过不同的事件的结果对比得出不同参数的影响 再看消息的产生数量.首先,3种结点数目为5,75,900,体现了不同级别的军人的数量不同不同优先级的事件的产生时间间隔为480~600min,300~360min,120min~240min 由于the-one的产生频率是根据事件来确定的,与结点无关,因此事件产生需要两个参数结合计算可以得到 &nbsp; H M L High (3600,4320) (2160,2880) (720,1440) Middle (240,288) (144,192) (48,96) Low (20,24) (12,16) (4,8) 每种数据的大小为(50k,2M),而每个人能存储的最大信息量为50M,信息失效时间为1800(每次传递后重新计算)","tags":[{"name":"Java","slug":"Java","permalink":"https://www.oyohyee.com/tags/Java/"},{"name":"the-one","slug":"the-one","permalink":"https://www.oyohyee.com/tags/the-one/"},{"name":"DTN","slug":"DTN","permalink":"https://www.oyohyee.com/tags/DTN/"}]},{"title":"UPN第一个样例","date":"2017-07-05T08:55:09.000Z","path":"/post/Note/UPN/first_code.html","text":"一般情况下第一个样例都应该是简单并且容易让人产生兴趣的，但是UPN的第一个样例对于没有写过的人而言是第一个考验 由于官方代码大量使用 upn.h 头文件，经常会导致不知道函数从何而来因此建议还是自己徒手编译 本样例需要用到的头文件如下(包括简单的说明): #include &lt;arpa/inet.h&gt; //inet_ntop()、inet_ntoa()等#include &lt;memory.h&gt; //memset#include &lt;netinet/in.h&gt; //struct sockaddr_in、PROTO_ICMP、INADDR_ANY等#include &lt;stdio.h&gt; //printf#include &lt;stdlib.h&gt; //exit#include &lt;sys/socket.h&gt; //socket、bind、connect、struct sockaddr#include &lt;sys/types.h&gt; //类型定义#include &lt;time.h&gt; //time#include &lt;unistd.h&gt; //read 本样例由两部分组成:服务端和用户端尽管按照书上有 206.168.112.96 这个IP地址，不过在我的测试中并不能成功连接因此，可以使用P5的代码实现客户端，用P10的代码实现服务端 由于服务端需要监听端口，因此该部分需要root权限 另外，服务端和客户端都应该是 htons(13) (htons和htonl存在区别) 设计到的几个函数定义如下 函数定义 百度百科-socket点击显/隐 创建 函数原型：int socket(int domain, int type, int protocol); 参数说明： domain：协议域，又称协议族（family）。常用的协议族有AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域Socket）、AF_ROUTE等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。 type：指定Socket类型。常用的socket类型有SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等。流式Socket（SOCK_STREAM）是一种面向连接的Socket，针对于面向连接的TCP服务应用。数据报式Socket（SOCK_DGRAM）是一种无连接的Socket，对应于无连接的UDP服务应用。 protocol：指定协议。常用协议有IPPROTO_TCP、IPPROTO_UDP、IPPROTO_STCP、IPPROTO_TIPC等，分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。 注意： type和protocol不可以随意组合，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当第三个参数为0时，会自动选择第二个参数类型对应的默认协议。 WindowsSocket下protocol参数中不存在IPPROTO_STCP 返回值： 如果调用成功就返回新创建的套接字的描述符，如果失败就返回INVALID_SOCKET（Linux下失败返回-1）。 套接字描述符是一个整数类型的值。 每个进程的进程空间里都有一个套接字描述符表，该表中存放着套接字描述符和套接字数据结构的对应关系。该表中有一个字段存放新创建的套接字的描述符，另一个字段存放套接字数据结构的地址，因此根据套接字描述符就可以找到其对应的套接字数据结构。 每个进程在自己的进程空间里都有一个套接字描述符表但是套接字数据结构都是在操作系统的内核缓冲里。 绑定 函数原型： int bind(SOCKET socket, const struct sockaddr* address, socklen_t address_len); 参数说明： socket：是一个套接字描述符。 address：是一个sockaddr结构指针，该结构中包含了要结合的地址和端口号。 address_len：确定address缓冲区的长度。 返回值： 如果函数执行成功，返回值为0，否则为SOCKET_ERROR。 接收 函数原型： int recv(SOCKET socket, char FAR* buf, int len, int flags); 参数说明： socket：一个标识已连接套接口的描述字。 buf：用于接收数据的缓冲区。 len：缓冲区长度。 flags：指定调用方式。取值：MSG_PEEK 查看当前数据，数据将被复制到缓冲区中，但并不从输入队列中删除；MSG_OOB 处理带外数据。 返回值：若无错误发生，recv()返回读入的字节数。如果连接已中止，返回0。否则的话，返回SOCKET_ERROR错误，应用程序可通过WSAGetLastError()获取相应错误代码。 函数原型： ssize_t recvfrom(int sockfd, void buf, int len, unsigned int flags, struct socketaddr* from, socket_t* fromlen); 参数说明： sockfd：标识一个已连接套接口的描述字。 buf：接收数据缓冲区。 len：缓冲区长度。 flags：调用操作方式。是以下一个或者多个标志的组合体，可通过or操作连在一起： MSG_DONTWAIT：操作不会被阻塞； MSG_ERRQUEUE： 指示应该从套接字的错误队列上接收错误值，依据不同的协议，错误值以某种辅佐性消息的方式传递进来，使用者应该提供足够大的缓冲区。导致错误的原封包通过msg_iovec作为一般的数据来传递。导致错误的数据报原目标地址作为msg_name被提供。错误以sock_extended_err结构形态被使用。 MSG_PEEK：指示数据接收后，在接收队列中保留原数据，不将其删除，随后的读操作还可以接收相同的数据。 MSG_TRUNC：返回封包的实际长度，即使它比所提供的缓冲区更长， 只对packet套接字有效。 MSG_WAITALL：要求阻塞操作，直到请求得到完整的满足。然而，如果捕捉到信号，错误或者连接断开发生，或者下次被接收的数据类型不同，仍会返回少于请求量的数据。 MSG_EOR：指示记录的结束，返回的数据完成一个记录。 MSG_CTRUNC：指明由于缓冲区空间不足，一些控制数据已被丢弃。 MSG_OOB：指示接收到out-of-band数据(即需要优先处理的数据)。 MSG_ERRQUEUE：指示除了来自套接字错误队列的错误外，没有接收到其它数据。 from：（可选）指针，指向装有源地址的缓冲区。 fromlen：（可选）指针，指向from缓冲区长度值。发送 函数原型： int sendto( SOCKET s, const char FAR* buf, int size, int flags, const struct sockaddr FAR* to, int tolen); 参数说明： s：套接字 buf：待发送数据的缓冲区 size：缓冲区长度 flags：调用方式标志位, 一般为0, 改变Flags，将会改变Sendto发送的形式 addr：（可选）指针，指向目的套接字的地址 tolen：addr所指地址的长度 返回值： 如果成功，则返回发送的字节数，失败则返回SOCKET_ERROR。 接收连接请求 函数原型： int accept( int fd, struct socketaddr* addr, socklen_t* len); 参数说明： fd：套接字描述符。 addr：返回连接着的地址 len：接收返回地址的缓冲区长度 返回值： 成功返回客户端的文件描述符，失败返回-1。 代码服务端点击现/隐代码 服务端(需要管理员权限)#include &lt;arpa/inet.h&gt; //inet_ntop()、inet_ntoa()等#include &lt;memory.h&gt; //memset#include &lt;netinet/in.h&gt; //struct sockaddr_in、PROTO_ICMP、INADDR_ANY等#include &lt;stdio.h&gt; //printf#include &lt;stdlib.h&gt; //exit#include &lt;sys/socket.h&gt; //socket、bind、connect、struct sockaddr#include &lt;sys/types.h&gt; //类型定义#include &lt;time.h&gt; //time#include &lt;unistd.h&gt; //read#define MAXLINE 100#define LISTENQ 1024#define bzero(a, b) memset(a, 0, b)void err(const char *_information) &#123; printf(\"%s\\r\\n\", _information); exit(0);&#125;int main(int argc, char **argv) &#123; int listenfd, connfd; struct sockaddr_in servaddr; char buff[MAXLINE]; time_t ticks; if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) err(\"socket error.\"); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(13); if (bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) == -1) err(\"bind error.\"); if (listen(listenfd, LISTENQ) == -1) err(\"Listen error.\"); while (1) &#123; if ((connfd = accept(listenfd, (struct sockaddr *)NULL, NULL)) == -1) err(\"accept error.\"); ticks = time(NULL); snprintf(buff, sizeof(buff), \"%.24s\\r\\n\", ctime(&amp;ticks)); if (write(connfd, buff, strlen(buff)) == -1) err(\"write error.\"); if (close(connfd) == -1) err(\"close error.\"); &#125;&#125; 客户端点击现/隐代码 客户端#include &lt;arpa/inet.h&gt; //inet_ntop()、inet_ntoa()等#include &lt;memory.h&gt; //memset#include &lt;netinet/in.h&gt; //struct sockaddr_in、PROTO_ICMP、INADDR_ANY等#include &lt;stdio.h&gt; //printf#include &lt;stdlib.h&gt; //exit#include &lt;sys/socket.h&gt; //socket、bind、connect、struct sockaddr#include &lt;sys/types.h&gt; //类型定义#include &lt;time.h&gt; //time#include &lt;unistd.h&gt; //read#define MAXLINE 100#define bzero(a, b) memset(a, 0, b)void err(const char *_information) &#123; printf(\"%s\\r\\n\", _information); exit(0);&#125;int main(int argc, char **argv) &#123; int sockfd, n; char recvline[MAXLINE + 1]; struct sockaddr_in servaddr; //判断参数数目 if (argc != 2) err(\"usage: a.out &lt;IPaddress&gt;\"); //创建socket if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) err(\"socket error\"); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(13); //转换地址 if (inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;= 0) err(\"inet_pton error\"); //连接 if (connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) err(\"connect error\"); //读取 while ((n = read(sockfd, recvline, MAXLINE)) &gt; 0) &#123; recvline[n] = 0; if (fputs(recvline, stdout) == EOF) err(\"fputs error\"); &#125; if (n &lt; 0) err(\"read error\"); exit(0);&#125;","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.oyohyee.com/tags/Linux/"},{"name":"socket","slug":"socket","permalink":"https://www.oyohyee.com/tags/socket/"}]},{"title":"Codeforces 820B.Mister B and Angle in Polygon","date":"2017-06-27T17:57:13.000Z","path":"/post/Codeforces/820B.html","text":"题目点击显/隐题目 On one quiet day all of sudden Mister B decided to draw angle a on his field. Aliens have already visited his field and left many different geometric figures on it. One of the figures is regular convex n-gon (regular convex polygon with $n$ sides).That’s why Mister B decided to use this polygon. Now Mister B must find three distinct vertices v1, v2, v3 such that the angle $\\angle v_1 v_2 v_3$(where $v_2$ is the vertex of the angle, and $v_1$ and $v_3$ lie on its sides) is as close as possible to $a$. In other words, the value $\\left| \\angle v_1 v_2 v_3 - a \\right| $ should be minimum possible.If there are many optimal solutions, Mister B should be satisfied with any of them.First and only line contains two space-separated integers $n$ and $a$ ($3 \\leq n \\leq 10^5$, $1 \\leq a \\leq 180$) — the number of vertices in the polygon and the needed angle, in degrees.Print three space-separated integers: the vertices v1, v2, v3, which form . If there are multiple optimal solutions, print any of them. The vertices are numbered from 1 to n in clockwise order.3 154 674 681 2 32 1 34 1 2 题解 题意正 n 边形选3个顶点,使拼合成的角使所有角中最接近 a 的 需要的数学知识:正n边形内角和: $(n-2) \\times 180^{\\circ}$ 对于如图所示的角,其角度为 $((4-2) \\times 180 - 2 \\times (6-2)*180 \\div 6) \\div 2 = 60$ 同样,可以证明（数学归纳法）得到 $\\angle v_2 v_1 v_k ( 3 \\leq k \\leq n )$ 正好可以覆盖所有的可以取到的角度 所以,只要枚举 $(i \\times 180 - i \\times (n-2)*180 \\div n) \\div 2 \\:\\:\\: ( 1 \\leq i \\leq n-2 )$ 即可 代码点击显/隐代码 Mister B and Angle in Polygon代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const double eps = 1e-5;int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock();#endif cin.tie(0); cin.sync_with_stdio(false); double n, a; while (cin &gt;&gt; n &gt;&gt; a) &#123; double tot = 180 * (n - 2); double t = tot / n; double Min = 9e9; double pos = 0; for (int i = 1; i &lt;= n - 2; i++) &#123; double temp = (180 * i - t * i) / 2; //cout &lt;&lt; \"2 1 \" &lt;&lt; i + 2 &lt;&lt; \" \" &lt;&lt; temp &lt;&lt; \" \" &lt;&lt; fabs(temp - a) //&lt;&lt; \" \"&lt;&lt;Min&lt;&lt;endl; if (fabs(temp - a) &lt; Min) &#123; Min = fabs(temp - a); pos = i; &#125; &#125; cout &lt;&lt; \"2 1 \" &lt;&lt; pos + 2 &lt;&lt; endl; &#125;#ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125;","tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"Codeforces 820A.Mister B and Book Reading","date":"2017-06-27T17:24:48.000Z","path":"/post/Codeforces/820A.html","text":"题目点击显/隐题目 Mister B once received a gift: it was a book about aliens, which he started read immediately. This book had c pages.At first day Mister B read v0 pages, but after that he started to speed up. Every day, starting from the second, he read a pages more than on the previous day (at first day he read v0 pages, at second — v0?+?a pages, at third — v0?+?2a pages, and so on). But Mister B is just a human, so he physically wasn’t able to read more than v1 pages per day.Also, to refresh his memory, every day, starting from the second, Mister B had to reread last l pages he read on the previous day. Mister B finished the book when he read the last page for the first time.Help Mister B to calculate how many days he needed to finish the book.First and only line contains five space-separated integers: c, v0, v1, a and l (1?≤?c?≤?1000, 0?≤?l?&lt;?v0?≤?v1?≤?1000, 0?≤?a?≤?1000) — the length of the book in pages, the initial reading speed, the maximum reading speed, the acceleration in reading speed and the number of pages for rereading.Print one integer — the number of days Mister B needed to finish the book.5 5 10 5 412 4 12 4 115 1 100 0 01315 题解 题意一本有 c 页的书,第一天读 v0 页,每天比前一天多读 a 页(最多不超过 v1)同时每天需要复习前一天读过的 l 页问需要几天读完需要多久 需要注意的是第一天是不需要复习前一天的内容的 代码点击显/隐代码 Mister B and Book Reading代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock();#endif cin.tie(0); cin.sync_with_stdio(false); int c, v0, v1, a, l; while (cin &gt;&gt; c &gt;&gt; v0 &gt;&gt; v1 &gt;&gt; a &gt;&gt; l) &#123; int ans = 0; int hr = 0; while (hr &lt; c) &#123; if(ans) hr -= l; v0 = min(v0, v1); hr += v0; ans++; v0 += a; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;#ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"如何写好Makefile","date":"2017-06-25T16:18:21.000Z","path":"/post/Note/UPN/makefile.html","text":"对于一个项目而言,整体源码必然是分布在众多文件夹中的那么就出现了我们写简单的单个 cpp 文件不会遇到的问题: 哪些文件需要先编译?哪些文件需要后编译?哪些文件需要重新编译? Makefile就是一个帮你处理这些功能的文件,在 *nix 环境下,有 make 命令来读取 Makefile 文件并进行相应的操作 编译和链接首先,需要知道的是把源码编程我们能执行的二进制文件,有两步重要的操作: 编译(compile)和链接(link) 编译编译是针对每一个文件,把他们转换成二进制文件. 这是单纯的翻译过程,只要源码语法正确,就可以正常编译出中间文件(目标文件)对于每一个源码文件,编译后都会产生一个中间文件(.o或是.obj) 该部分对应了 g++ 的 g++ -c &lt;SourceCodeFilename&gt; 链接编译过后我们有了能够被执行的二进制文件,那么问题来了: 一个条例清晰的文件,可能其函数声明和定义并不在一个文件里,如何找到各个部分之间的关系就是链接部分要解决的问题了 该部分对应了 g++ 的 g++ &lt;ObjectFilename&gt; -o &lt;OutputFilename&gt; 库项目比较大的时候,自然不可能改一下就重新整体编译一次,那么就有了库(library)将一些目标文件(Object)打包成库文件,然后链接的时候直接链接库文件和改动部分的目标文件即可库文件在 Windows 下为 .lib 在UNIX下是 .a Makefile的使用首先我们要明白Makefile需要做什么: 如果这个工程没有编译过,那么所有C文件都要编译并被链接 如果这个工程的某几个C文件被修改,那么我们只编译被修改的C文件,并链接目标程序 如果这个工程的头文件被改变了,那么我们需要编译引用了这几个头文件的C文件,并链接目标程序 举例一个makefile的例子如下:test: a.o b.o c.o d.o / A.o B.o C.o D.o cc -o test a.o b.o c.o d.o / A.o B.o C.o D.oa.o: a.c F.h cc -c a.cb.o: b.c F.h c.h cc -c b.cc.o: c.c F.h c.h cc -c c.cd.o: d.c F.h E.h cc -c d.cA.o: A.c F.h E.h cc -c A.cB.o: B.c F.h E.h cc -c B.cC.o: C.c F.h E.h c.h cc -c C.cD.o: D.c F.h cc -c D.cclean: rm edit a.o b.o c.o d.o / A.o B.o C.o D.o 很容易可以看出来大概的含义:[要生成的文件]: [生成该文件所依赖的文件列表] [生成该文件的命令行] 其中,如果需要换行,就在末尾加 \\ 再正式一下,就是&lt;target&gt;: &lt;prerequisites&gt; &lt;command&gt; target是一个目标文件,可以是Object File,也可以是执行文件还可以是一个标签（Label） prerequisites就是,要生成那个target所需要的文件或是目标 command也就是make需要执行的命令（任意的Shell命令）需要注意的是,如同缩进一样,command部分必须由tab开头 当没有依赖文件的时候,这一条就会被识别为标签,例如上面的 clean当运行 make clean 时,就会清空所有生成的中间文件和最终输出文件 这样,对于上面的文件,make 命令会以第一个目标文件为最终输出,按照修改时间检查所有目标文件和依赖文件,如果依赖文件更新或者目标文件不存在就会运行相应的命令生成目标文件,最终得到一个输出文件 当文件大量重复时,就可以使用变量了v = a.o b.o使用时用 $(v) 就可以代替 a.o b.o 了 而根据习惯,我们生成的中间文件一般是与源文件同名的,也就是说 a.o 时通过 a.c 生成的并且对应的编译指令也是可以推测出的 那么完全可以简化成[中间文件]: [对应的头文件] 这样只要对应的头文件或者源文件有改动,中间文件就会自动通过相应的编译指令生成这叫做make的隐晦规则 对于清理命令,也有更为严谨的写法.PHONY : cleanclean :-rm edit $(objects) .PHONY 说明 clean 是一个伪目标而 rm 前面的 - 则告诉系统,当 rm 无视可能会出错的情况继续执行后面的(比如删除一个不存在的文件) 这时,clean即使是伪目标,也可以写依赖项了比如我的默认操作是生成许多文件,就可以写成all: a b c d.PHONY alla: ………… 如果项目中存在多个makefile时,可以使用include来引用其它的makefile文件如果需要忽略报错,可以使用-include或sinclude 当文件夹比较多时,就需要让makefile自己去找你要编译的文件到底在哪个文件夹里了 VPATH = src:../headersvpath %.c srcvpath %.h ../headers 前者是搜索目录先从当前目录开始,然后是src,最后是../headers(使用:分割)后者则是针对不同的文件,进行不同的搜索目录(vpath用小写) 参考目录Linux makefile 教程 非常详细，且易懂","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.oyohyee.com/tags/Linux/"}]},{"title":"自定义 li 前面的图标","date":"2017-06-18T08:17:22.000Z","path":"/post/Note/licss.html","text":"新主题的 li 前的图标挺好看的,但是存在缩进错误的小问题采用 ::before 的方式增加前面的图标,同时注意到了多行时缩进的问题(使用首行负值缩进整体缩进的方法)ul&#123; list-style: none&#125;ul li&#123; margin-left: 40px; text-indent: -20px;&#125;ul li::before&#123; content: \"\\f05d\"; font: normal normal normal 14px/1 FontAwesome; display: inline-block; margin: 0 10px; line-height: 28px;&#125;","tags":[{"name":"CSS","slug":"CSS","permalink":"https://www.oyohyee.com/tags/CSS/"},{"name":"spfk","slug":"spfk","permalink":"https://www.oyohyee.com/tags/spfk/"}]},{"title":"Git使用方法详解","date":"2017-06-18T06:13:09.000Z","path":"/post/Note/git.html","text":"Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 如果想正式一点做一个项目,还是需要系统学习一下 Git Git简介Git是一个版本管理工具,自然最重要的就是版本管理.在Git中,每一版本存为一个commit,以单向链表的形式存储,每一个结点都存储了一个版本,父结点存储的是它的前一个版本.显然,最前面的头指针指向的就是最新的版本结点. 而每个版本又存在不同的区域： working tree index(staged file) HEAD working tree就是我们正常在文件浏览器里能够看到的文件index是缓存区,标记了本版本和上一版本之间的差异HEAD则相当于在整个Git里的位置指针,记录了当前的位置 而文件则存在如下几种状态 Untracked files新建的文件 Changes not staged for commit(Changed but not updated)更改的文件 modified修改的文件 deleted删除文件 Changes to be committed(staged)已被add的文件(暂存状态) 文件的改动无非删除,修改,新建三种而这三种外还有暂存区(staged)这个就是当前版本记录下的改动 git 命令git init&lt;path&gt; 默认为当前目录 初始化git库(本地库)这个是本地库,能够在文件管理器里方便地操作文件git init &lt;path&gt; 初始化git库(服务器端)这个是远程库(remote),不能直接操作文件git init --bare &lt;path&gt; git clone这个指令可以将别人的库直接 clone 下来如果只需要最新版本,可以增加 --depth=1git clone &lt;url&gt; &lt;path&gt; git add将文件提交到暂存区 相应, git add 有如下用法 git add &lt;filename //提交指定文件git add . //提交untracked files和changes not staged for commitgit add -u &lt;filename//提交changes not staged for commit (tracked file)git add -A &lt;filename//提交所有的变化 其中,在Git version 1.x中, git add . 不包括删除的文件在Git version 2.x中, git add . 包括删除的文件,另加了 git add --ignore-removal . 替代原用法 另外可以使用 git status 查看当前三种状态的文件或者 git add -i 分类查看各个状态的文件 本地库操作git commitgit commit 是极为重要的一部分这里记录了你每次更改文件的意义因此保持一个比较好的格式非常重要 git commit //调用文本编辑器输入commit信息git commit -m &quot;&lt;message&gt;&quot; //直接输入信息git commit -a //自动add tracked files 然后调用编辑器输入commit Commit message 的格式点击显/隐 每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;body&gt;&lt;footer&gt; 其中，Header 是必需的，Body 和 Footer 可以省略。不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。HeaderHeader部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。（1）typetype用于说明 commit 的类别，只允许使用下面7个标识。 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。 （2）scopescope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 （3）subjectsubject是 commit 目的的简短描述，不超过50个字符。以动词开头，使用第一人称现在时，比如change，而不是changed或changes第一个字母小写结尾不加句号（.） BodyBody 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。 More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. Further paragraphs come after blank lines.- Bullet points are okay, too- Use a hanging indent有两个注意点。（1）使用第一人称现在时，比如使用change而不是changed或changes。（2）应该说明代码变动的动机，以及与以前行为的对比。 Footer Footer 部分只用于两种情况。（1）不兼容变动如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: &#123; myAttr: &apos;attribute&apos;, &#125; After: scope: &#123; myAttr: &apos;@&apos;, &#125; The removed `inject` wasn&apos;t generaly useful for directives so there should be no code using it. （2）关闭 Issue如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。 Closes #234也可以一次关闭多个 issue 。 Closes #123, #245, #992 revert还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。revert: feat(pencil): add &apos;graphiteWidth&apos; optionThis reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成This reverts commit .，其中的hash是被撤销 commit 的 SHA 标识符。如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。 git branch分支就类似平行宇宙,在这一刻你可以选择用python来解决一个问题,也可以选择用java解决这个问题于是开了两个分支,python和java,你可以随便更改任意一个分支的内容而不影响另一个分支的内容当你发现python能更好解决问题时,就可以删掉java那个分支,让python与主分支合并 查看分支当前分支前有*标记git branch //列出本地分支git branch -r //列出远程分支git branch -a //列出本地和远程分支 创建分支及切换分支默认情况下,我们是在主分支 master 里如果需要切换分支,需要 git checkout 指令 git branch &lt;branchName&gt; //创建分支(不切换)git checkout &lt;branchName&gt; //切换到已有分支git checkout -b &lt;branchName&gt; //创建分支并且切换到新分支 新建分支都是在当前所在的分支基础上克隆一份,commit只会影响当前分支的内容 并且分支是共用暂存区的,也就是说如果在分支1上仅 add 而不 commit，实际暂存区中已经记录该次修改哪怕后续切换到分支2上再进行 commit 也是有效的操作 因此,切换分支前一定要确保commit 重命名分支git branch -m &lt;OldName&gt; &lt;NewName&gt; //重命名分支git branch -M &lt;OldName&gt; &lt;NewName&gt; //强制重命名分支(忽略重名) 删除分支需要注意不能删除当前所在的分支(不能删除当前所在的世界) git branch -d &lt;branchName&gt; //删除分支git branch -D &lt;branchName&gt; //强制删除分支(忽略分支未merge部分)git branch -d -r &lt;branchName&gt; //删除远程branchname分支 通过分支进行多人协作master 分支作为最终发布的版本,只有在更新到最终版时,将各分支 merge 到该分支dev 作为大家个人分支的合并分支,用于代码合并而个人分支就是自己维护自己的部分即可 git checkout对于整个Git而言,他是一个有向链表,由于存在 branch 和 merge 操作,因此局部会存在有向无环图(DAG)链表的每一个结点都是一个 commit而 HEAD 指向的就是当前所在的 commit那么 HEAD^ 是上一个提交,HEAD^^ 是上上一次前十次提交可以用 HEAD^^^^^^^^^^ 也可以用 HEAD~10 checkout 的功能就是切换到任意一个 commit 去git checkout &lt;commit_HASH&gt; 当切换到某个分支时,默认时切换到该分支的最新状态 而对于想把某个文件恢复到上个 commit 后的状态,可以使用git checkout -- &lt;filename&gt; 这样可以清除该文件在工作区的修改 git merge合并两个分支合并分支是Git的一个重要功能可以直接使用改命令将一个分支合并当前分支 git merge &lt;branchName&gt; 其中有选项 --no-ff 三方合并并提交修改(默认) --ff-only 判断当前分支可否根据目标分支快速合并 冲突处理但是对于将待合并分支合并到当前分支的情况,需要注意有冲突的情况存在如果待合并分支是在当前分支的基础上修改而来的,那么显然直接将当前分支更新到待合并分支状态即可如果待合并分支和当前分支在某个时间点分开后各自有了更新,就会产生冲突这时使用 git merge 会提醒你存在冲突,需要手动解决 使用 git status 查看冲突的文件,然后手动进去修改需要注意的是,这时冲突文件是两个版本文件的综合体&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADaaaaa=======bbbbb&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 使用这样的方式来标记不同合并后就可以删除掉分支了 取消合并如果merge一半不想merge了,就用下面的代码来回滚merge操作git merge --abort git rebasegit rebase 也是将两个分支合并到一起的操作由名字可以看出来,rebase会将待合并分支记录加到当前分支前面,当作初始状态,然后再按照当前分支的提交进行合并(会丢失原本的commit) git merge 和 git rebase 和区别有以下几点 merge 是一个合并操作,会将两个分支的修改合并在一起,默认操作的情况下会提交合并中修改的内容 merge 的提交历史忠实地记录了实际发生过什么,关注点在真实的提交历史上面 rebase 并没有进行合并操作,只是提取了当前分支的修改,将其复制在了目标分支的最新提交后面 rebase 的提交历史反映了项目过程中发生了什么,关注点在开发过程上面 git revert该命令是指新建一个commit,内容撤销某个commit(中间的错误路线保留)git revert &lt;commit_HASH&gt; 如果log如下 commit 3 add ccommit 2 add bcommit 1 add a 现在我在3这个状态,当我 git revert 2 后记录变为 commit 4 revert bcommit 3 add ccommit 2 add bcommit 1 add a 同时文件变为 a c (撤销了生成 b 的操作) git reset该命令是直接回到指定commit,之前的错误commit全部舍弃(假装自己没有错过)git reset [--mixed] &lt;cimmit_HASH&gt; //只更改HEAD和indexgit reset --soft &lt;commit_HASH&gt; //只把HEAD回退回去,index和working tree都不变git reset --hard &lt;commit_HASH&gt; //修改index和working tree,忽略所有改动文件 看上去可能比较难以理解,举个例子如果使用 --mixed 那么还原后,会以目标commit为基础分析文件,这样你看到的就是一群改动等待被commit,可以把需要恢复的挑出来如果使用 --hard 那么就是原汁原味的目标commit的样子,文件全部都是当时的状态如果使用 --soft 那么目录内的文件没有被修改,也没有文件在暂存区但是这三种都有一个问题:HEAD回到了过去,并且之后的commit都扔掉了那么就有一个尴尬的问题了,--soft会导致有的文件在git里并没有生成的记录,但是它就是存在了 并且 git checkout 和 git reset --hard 可以看成是差不多的,唯一的区别就是后面的log是否还保留(事实上尽管reset后看上去记录没了,但是git还是会保留下来的,除非去运行清理指令)但是,如果你checkout回到之前的状态,但是当前分支仍然指向原来的commit,如果你在之前的状态又提交了commit,是不能算在该分支的,这个commit就游离在了git链表之外(因为每个commit只能指向它的前一个commit) 所以干什么的命令就是干什么的,虽然看上去可能能做一些自己职责之外的事情,但是还是不要作死乱用 git reflog使用reflog找到丢失的commit如果已经已经被删掉(合并)的 commit 有用怎么办？？？存在游离的 commit 怎么办？？？手贱 hard rebase 到了错误的地方把有用的记录删掉了怎么办？？？ git reflog 来救你！git非常机智地留了一个回收站,你所有删掉的 commit 都在这里！ 可以使用任意的方法重新拿到需要的数据(branch,checkout,rebase) 清除reflog那么如何清空这个“回收站”呢？运行下面的代码,你所有游离的commit都被释放掉了(这次再手误就真的没救了)git filter-branch --index-filter \"git rm -r --cached --ignore-unmatch path/to/your/file\" HEAD git push origin master --force rm -rf .git/refs/original/ git reflog expire --expire=now --all git gc --prune=now git gc --aggressive --prune=now git tag标签可以代替commit id,方便查找特殊的记录git tag //列出所有标签git tag [-a] &lt;tagName&gt; [-m \"&lt;Message&gt;\"] [&lt;commit_HASH&gt;] //给指定的commit(默认为当前状态)打标签,并附加说明 远程库操作git remoteremote是git的远程分支可以看做是把本地部分在网上的一个备份除了使用命令行外，也可以在 ‘.git/config’ 修改 remote对于每个远程库可以添加多个url(相当于多端备份) git remote //查看所有的remotegit remote -v //查看所有的remote详细信息git remote add &lt;remoteName&gt; &lt;url&gt; //增加新的remotegit remote rm &lt;name&gt; //删除指定的remotgit remote set-url --add [remoteName] [newUrl] //为指定remote增加链接git remote set-url --push &lt;remoteName&gt; &lt;newUrl&gt; [&lt;oldUrl&gt;] //修改远程分支的urlgit remote set-url --delete &lt;remoteName&gt; &lt;Url&gt; //删除远程分支的指定url git push将本地分支推送到远程分支 如果省略本地分支，就是把一个空的分支push到远程分支（也即删除远程分支） 另外如果使用 -u 参数，相当于同时把当前的设置记录为默认，下次如果省略相应参数的话，会优先按照本地的进行提交 git push [-u] &lt;remoteName&gt; &lt;localBranch&gt;:&lt;remoteBranch&gt; //将本地分支推送到远程分支 git push有两种模式 simple模式存在默认配置的情况下，按照默认配置提交git config --global push.default simple matching模式将远程分支对应的本地分支推送上去(以远程分支为主，不会新建远程分支)git config --global push.default matching 然后很自然就会想到能不能把本地所有分支都推送到远程主机自然是可以的git push --all &lt;remoteName&gt; 如果远程分支比本地分支还要新，就会产生冲突，需要先合并差异当然也可以用 --force 或者 -f 强制提交 默认情况下，push不会推送tag，需要增加--tags选项 git pullpull 是和 push 完全相反的操作(对应的指令也恰好对应相反) 会将远程分支合并到本地分支也即，pull是一个合并操作，那么自然就就存在merge和rebase的区别在pull里，默认是merge，可以使用--rebase使用rebase的形式合并 git pull [--rebase] &lt;remoteName&gt; &lt;remoteBranch&gt;:&lt;localBranch&gt; git fetchgit fetch 是拉取远程分支的更新 将远程分支拉取到本地的 &lt;remoteName&gt;/&lt;remoteBranch&gt; 分支然后就可以进行合并等操作了 其中如果指定远程分支名,则只会拉取指定的远程分支git fetch &lt;remoteName&gt; [&lt;remoteBranch&gt;] 对比fetch和pull可以发现 fetch + merge = pull git modoule当你的项目里需要用到别人的项目时,可能就会出项 git 嵌套 git 的情况这时就需要使用子模块来管理 git 自己项目的子模块git submodule add &lt;url&gt; &lt;path&gt; //新建子模块 新建后,目录下会生成一个 .gitmodules 记录该项目的所有子模块信息当子模块有更改时,只会有一个标记记录了模块有更改(没有具体更改内容)对于主项目来说,子项目只是一个 HEAD 标记子项目对应的时哪个 commit 状态 别人项目的子模块而对于 clone 别人的项目时,如果存在子模块,需要单独初始化子模块部分git submodule init //初始化子模块git submodule update //更新到该项目中记录的 `commit` 如果项目在远程分支有更新,除了要使用 pull 或者 fetch 更新项目外,还要单独使用 git submodule update 更新子模块 删除子项目git ls-files --stage | grep 160000git rm --cached &lt;path&gt; .gitignore这个是存在于项目根目录的文件,用于记录需要忽略的文件(编译生成的中间文件,有敏感信息的文件)一行一条需要忽略的文件路径信息 参考链接 git add -A 和 git add . 的区别 Git 提交的正确姿势：Commit message 编写指南 Git教程-廖雪峰的官方网站 git branch用法总结 git branch -D 大写的D 删除分支 git checkout 命令详解 git reset soft,hard,mixed之区别深解 git的reset和checkout的区别 彻底删除GIT中的文件，节省空间 Git怎样撤销一次分支的合并Merge Git代码合并Merge还是Rebase 闲谈 git merge 与 git rebase 的区别 Git –everything-is-local","tags":[{"name":"Git","slug":"Git","permalink":"https://www.oyohyee.com/tags/Git/"}]},{"title":"git submodule导致git无法追踪文件","date":"2017-06-17T16:50:56.000Z","path":"/post/Note/gitsubmodule.html","text":"Hexo里clone了别人的主题发现在博客的源码备份git里无法记录主题文件夹 查了下发现是子模块的问题 fatal: no submodule mapping found in .gitmodules for path &apos;Blog/themes/spfk&apos; 采用下面的代码删除子模块记录 git ls-files --stage | grep 160000git rm --cached Blog/themes/spfk","tags":[{"name":"Git","slug":"Git","permalink":"https://www.oyohyee.com/tags/Git/"}]},{"title":"代码框位置错误","date":"2017-06-17T04:55:14.000Z","path":"/post/Note/codeblock_postition.html","text":"spfk的代码框在代码长度较长的时候,会发生错位问题 看了下实现部分,使用 ::before 来自动生成上面的title,由于向右滑动时,整个元素会一起右移就导致了错位问题 而恰好 position: sticky 就是用来解决这个问题的, 设置好这个再加上 left: 0 就可以保证定位的正确不过由于本身代码框是通过 padding 导致旁边有一圈虽然有颜色,但是并不算元素内,所以这样做会使左侧有一点小问题修改 margin-left 和 margin-right 保证两边有同样的空隙,然后用border-radius 设置下面的两个角为圆角,这样看上去就好看了许多~ 好吧,我直接把上面去掉了,代码框多了上面真难看……","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.oyohyee.com/tags/Hexo/"},{"name":"CSS","slug":"CSS","permalink":"https://www.oyohyee.com/tags/CSS/"},{"name":"spfk","slug":"spfk","permalink":"https://www.oyohyee.com/tags/spfk/"}]},{"title":"主题bug修复及Javascript中判定undefined","date":"2017-06-16T17:32:34.000Z","path":"/post/Note/js_undefined.html","text":"在新换的 spfk 主题里的 main.js 中有这样一段代码点击显/隐代码 main.js//是否使用fancyboxif(yiliaConfig.fancybox === true)&#123; require([yiliaConfig.rootUrl + 'fancybox/jquery.fancybox.js'], function(pc)&#123; var isFancy = $(\".isFancy\"); if(isFancy.length != 0)&#123; var imgArr = $(\".article-inner img\"); for(var i=0,len=imgArr.length;i&lt;len;i++)&#123; var src = imgArr.eq(i).attr(\"src\"); var title = imgArr.eq(i).attr(\"alt\"); imgArr.eq(i).replaceWith(\"&lt;a href='\"+src+\"' title='\"+title+\"' rel='fancy-group' class='fancy-ctn fancybox'&gt;&lt;img src='\"+src+\"' title='\"+title+\"'&gt;&lt;/a&gt;\"); &#125; $(\".article-inner .fancy-ctn\").fancybox(); &#125; &#125;);&#125; 很容易明白,这是处理fancybox中,点击放大图片功能的代码检测到图片后会自动修改 img 为 &lt;a ...&gt;&lt;img ...&gt;&lt;/a&gt; 而 spfk 对 a 有单独的 css 样式因此当插入图片时,就会套用 a 的样式（有背景色） 显然,只需要将fancybox对应的a元素修改回默认值即可点击显/隐代码 a.fancy-ctn.fancybox &#123; background-color: transparent ; border: 0;&#125; 然后,对于上面转换的js,可以发现有比较大的bug假如我给img指定了width和height那么,这个转换程序并不会自动转换 因此需要增加对 id class width height 的识别而假如img不存在某个元素,相应的变量为 undefined可以使用下面的方法判断一个变量是否为 undefinedtypeof(a)==&quot;unfined&quot; 修改后代码如下点击显/隐代码 //是否使用fancyboxif(yiliaConfig.fancybox === true)&#123; require([yiliaConfig.rootUrl + 'fancybox/jquery.fancybox.js'], function(pc)&#123; var isFancy = $(\".isFancy\"); if(isFancy.length != 0)&#123; var imgArr = $(\".article-inner img\"); for(var i=0,len=imgArr.length;i&lt;len;i++)&#123; var flag = imgArr.eq(i).attr(\"no-fancybox\"); if(flag==\"true\") continue; var src = imgArr.eq(i).attr(\"src\"); var title = imgArr.eq(i).attr(\"alt\"); var width = imgArr.eq(i).attr(\"width\"); var height = imgArr.eq(i).attr(\"height\"); var id = imgArr.eq(i).attr(\"id\"); var clas = imgArr.eq(i).attr(\"class\"); var temp = \"&lt;a\"; if(typeof(src)!=\"undefined\") temp+=\" href='\"+src+\"'\"; if(typeof(title)!=\"undefined\") temp+=\" title='\"+title+\"'\"; temp+=\" rel='fancy-group' class='fancy-ctn fancybox'&gt;&lt;img\" if(typeof(id)!=\"undefined\") temp+=\" id='\"+id+\"'\"; if(typeof(clas)!=\"undefined\") temp+=\" class='\"+clas+\"'\"; if(typeof(src)!=\"undefined\") temp+=\" src='\"+src+\"'\"; if(typeof(alt)!=\"undefined\") temp+=\" alt='\"+title+\"' title='\"+title+\"'\"; if(typeof(width)!=\"undefined\") temp+=\" width='\"+width+\"'\"; if(typeof(height)!=\"undefined\") temp+=\" height='\"+height+\"'\"; temp+=\" /&gt;&lt;/a&gt;\" imgArr.eq(i).replaceWith(temp); &#125; $(\".article-inner .fancy-ctn\").fancybox(); &#125; &#125;);&#125;","tags":[{"name":"javascript","slug":"Javascript","permalink":"https://www.oyohyee.com/tags/Javascript/"},{"name":"spfk","slug":"spfk","permalink":"https://www.oyohyee.com/tags/spfk/"}]},{"title":"Hexo博客主题更换","date":"2017-06-16T13:15:24.000Z","path":"/post/Note/spfk_theme.html","text":"spfk是一个在电脑端和移动端都有着不错效果的网站由于之前Next已经修改了好多地方,所以迁移还是一个比较大的工程 修改部分如下： Keywords信息添加 &lt;!-- Keywords --&gt;&lt;meta name=\"keywords\" content=\"&#123;% if page.keywords %&#125;&#123;&#123; page.keywords &#125;&#125;,&#123;% endif %&#125;&#123;% if page.tags and page.tags.length %&#125;&#123;% for tag in page.tags %&#125;&#123;&#123; tag.name &#125;&#125;,&#123;% endfor %&#125;&#123;% endif %&#125;&#123;% if theme.keywords %&#125;&#123;&#123; theme.keywords &#125;&#125;&#123;% endif %&#125;&#123;% if config.keywords %&#125;&#123;&#123; config.keywords &#125;&#125;&#123;% endif %&#125;\" /&gt; 代码折叠等功能抑制 增加备案信息 修改了个别页面的显示问题 修改了在手机端标题和日期重叠的问题 将标签页的标签云的形式改成了符合主题风格的形式 删掉了许多不需要的东西 增加了手机端chrome的状态栏颜色","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.oyohyee.com/tags/Hexo/"},{"name":"spfk","slug":"spfk","permalink":"https://www.oyohyee.com/tags/spfk/"}]},{"title":"在 Linux 上安装 Node.js","date":"2017-05-20T15:44:45.000Z","path":"/post/Note/install_nodejs_on_linux.html","text":"原则上,直接从官网下载是没有问题的不过我这里一直安装不上apt-get 和 source 都安装失败 于是下载了编译好的 64 位包 下载后tar xvf &lt;filename&gt; 解压文件 然后放到了 /usr/share/node 目录 然后编辑 /etc/profile 把下面内容加到最后面(环境变量)export NODE_HOME=/alidata/node-v0.10.19-linux-x64export PATH=$PATH:$NODE_HOME/binexport NODE_PATH=$NODE_HOME/lib/node_modules 最后重载下source /etc/profile","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.oyohyee.com/tags/Linux/"},{"name":"nodejs","slug":"nodejs","permalink":"https://www.oyohyee.com/tags/nodejs/"}]},{"title":"oh_my_zsh 安装","date":"2017-05-20T15:44:45.000Z","path":"/post/Note/oh_my_zsh.html","text":"oh_my_zsh 是 Linux 上一款非常漂亮的终端界面 更新软件源 sudo apt-get update 安装zsh sudo apt-get install zsh 获取并安装 oh my zsh wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 替换bash为zsh chsh -s /bin/zsh 重启电脑 sudo reboot 安装分屏软件 sudo apt-get install terminator","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.oyohyee.com/tags/Linux/"}]},{"title":"Hexo的原理是什么？","date":"2017-05-12T15:20:42.000Z","path":"/post/Zhihu/Hexo_how.html","text":"https://www.zhihu.com/question/51588481/answer/126547622 Hexo的原理是什么？Hexo的原理是什么？为啥就能通过GitHub Pages弄一个博客了？ github pages支持静态页面的解析完全可以自己写 html push 到 gitpages 简单来说就是不支持动态页面，没办法就在本地写好网站，然后用程序生成静态页面 可以改名叫 markdown - 博客 一键转换器 下面是大概原理（不会 node.js ，主攻方向不是网络，非计算机专业的学生表示根据已有信息认为是以下解释，欢迎大神指正问题。不保证严谨，但是理解应该没问题）（其实自己实验下就能理解吧(ง •̀_•́)ง） 如果要做博客 wordpress 的思路是 php + MySql 而 gitpages 不支持动态语言，因此只能使用 html 拼合成博客 首先自己本地文件夹的 source 就是数据库，以 .md(markdown) 格式存储文章，theme 文件夹是主题文件，以 .yml 等类型，决定了页面如何“组装” 每次运行 hexo g 命令，hexo(node.js程序)会遍历你的 source 目录，建立索引，根据你 theme 文件夹的主题生成页面到 public 文件夹。这时 public 文件夹就是一个纯由 html javascript css 等内容制作的博客，而这些恰好能在 git pages 识别 最后 hexo d 将 public 文件夹的内容复制到临时目录，以 git 方式 push 到 github 的指定项目的指定分支，由 github 进行显示","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.oyohyee.com/tags/Hexo/"}]},{"title":"AOJ 859.地毯填补问题","date":"2017-05-08T12:32:04.000Z","path":"/post/AOJ/859.html","text":"题目点击显/隐题目 相传在一个古老的阿拉伯国家里，有一座宫殿。宫殿里有个四四方方的格子迷宫，国王选择驸马的方法非常特殊，也非常简单：公主就站在其中一个方格子上，只要谁能用地毯将除公主站立的地方外的所有地方盖上，美丽漂亮聪慧的公主就是他的人了。公主这一个方格不能用地毯盖住，毯子的形状有所规定，只能有四种选择(如图2)：并且每一方格只能用一层地毯，迷宫的大小为2的k次方见方的方形。当然，也不能让公主无限制的在那儿等，对吧？由于你使用的是计算机，所以实现时间为1秒。输入共2行。第一行：k，即给定被填补迷宫的大小为2^k（0第二行：x y，即给出公主所在方格的坐标（x为行坐标，y为列坐标），x和y之间有一个空格隔开。将迷宫填补完整的方案：每一补（行）为 x y c (x，y为毯子拐角的行坐标和列坐标，c为使用毯子的形状，具体见上面的图1，毯子形状分别用1、2、3、4表示，x、y、c之间用一个空格隔开)。33335 5 12 2 41 1 41 4 34 1 24 4 12 7 31 5 41 8 33 6 34 8 17 2 25 1 46 3 28 1 28 4 17 7 16 6 15 8 38 5 28 8 1 题解由于AOJ没有 Special Judge 因此下面的代码没有 AC 不管什么情况,显然 代码点击显/隐代码 地毯填补问题代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;inline bool between(int l, int m, int r) &#123; return l &lt;= m &amp;&amp; m &lt;= r; &#125;//int ID = 0;struct Point &#123; int x, y; Point(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125; bool operator==(const Point &amp;rhs) const &#123; return x == rhs.x &amp;&amp; y == rhs.y; &#125;&#125;;struct Area &#123; int x1, x2, y1, y2; //int id; Area(int _x1 = 0, int _x2 = 0, int _y1 = 0, int _y2 = 0) &#123; init(_x1, _x2, _y1, _y2); // printf(\"A %d %d %d %d id:%d\\n\", x1, x2, y1, y2, id); &#125; Area(int t[4]) &#123; init(t[0], t[1], t[2], t[3]); // printf(\"B %d %d %d %d id:%d\\n\", x1, x2, y1, y2, id); &#125; Area(const Area &amp;rhs) &#123; init(rhs.x1, rhs.x2, rhs.y1, rhs.y2); // printf(\"C %d %d %d %d id:%d\\n\", x1, x2, y1, y2, id); &#125; //~Area() &#123; printf(\"del %d %d %d %d id:%d\\n\", x1, x2, y1, y2, id); &#125; Area operator=(const Area rhs) &#123; init(rhs.x1, rhs.x2, rhs.y1, rhs.y2); // printf(\"D %d %d %d %d id:%d\\n\", x1, x2, y1, y2, id); return *this; &#125; void init(int _x1 = 0, int _x2 = 0, int _y1 = 0, int _y2 = 0) &#123; x1 = min(_x1, _x2); x2 = max(_x1, _x2); y1 = min(_y1, _y2); y2 = max(_y1, _y2); //id = ID++; &#125; inline bool In(const Point p) const &#123; return between(x1, p.x, x2) &amp;&amp; between(y1, p.y, y2); &#125; Area divide(int k) const &#123; int midx = (x1 + x2) / 2; int midy = (y1 + y2) / 2; int t[4] = &#123;x1, x2, y1, y2&#125;; if (k == 1) &#123; t[1] = midx; t[3] = midy; &#125; else if (k == 2) &#123; t[1] = midx; t[2] = midy + 1; &#125; else if (k == 3) &#123; t[0] = midx + 1; t[3] = midy; &#125; else &#123; // k == 4 t[0] = midx + 1; t[2] = midy + 1; &#125; Area area(t); return area; &#125; //获取区域方位角坐标 Point GetPoint(int k) const &#123; Point t; if (k == 1) t = Point(x1, y1); else if (k == 2) t = Point(x1, y2); else if (k == 3) t = Point(x2, y1); else // k == 4 t = Point(x2, y2); return t; &#125;&#125;;void show(const Point &amp;p, int k/*, int deep*/) &#123; // for (int i = 0; i &lt; deep; i++) // printf(\" \"); // printf(\"%d %d %d\\n\", p.x, p.y, k); printf(\"%d %d %d\\n\", p.x, p.y, k);&#125;//通过左上顶点和方向获取拐角Point GetCorner(const Point &amp;p, int k) &#123; Point t; if (k == 1) t = Point(p.x + 1, p.y + 1); else if (k == 2) t = Point(p.x + 1, p.y); else if (k == 3) t = Point(p.x, p.y + 1); else // k == 4 t = Point(p.x, p.y); return t;&#125;int pow(int a, int n) &#123; if (n == 0) return 1; if (n == 1) return a; return pow(a, n / 2) * pow(a, n - n / 2);&#125;void dfs(Area area, Point p/*, int deep*/) &#123; // getchar(); // for (int i = 0; i &lt; deep; i++) // printf(\" \"); // printf(\"Area: x1=%d x2=%d y1=%d y2=%d id=%d Point: (%d,%d)\\n\", area.x1, // area.x2, area.y1, area.y2, area.id, p.x, p.y); //递归终点 if (area.x2 - area.x1 == 1) &#123; for (int i = 1; i &lt;= 4; i++) &#123; if (area.GetPoint(i) == p) show(GetCorner(Point((area.x1 + area.x2) / 2, (area.y1 + area.y2) / 2), i), i/*, deep*/); &#125; return; &#125; Area t; for (int i = 1; i &lt;= 4; i++) &#123; t = area.divide(i); // printf(\"t %d %d %d %d id:%d\\n\", t.x1, t.x2, t.y1, t.y2, t.id); if (t.In(p)) &#123; dfs(t, p/*, deep + 1*/); show( GetCorner( Point((area.x1 + area.x2) / 2, (area.y1 + area.y2) / 2), i), i/*, deep*/); &#125; else &#123; dfs(t, t.GetPoint(5 - i)/*, deep + 1*/); &#125; &#125;&#125;int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock();#endif freopen(\"out.txt\", \"w\", stdout); cin.tie(0); cin.sync_with_stdio(false); int k, x, y; while (scanf(\"%d%d%d\", &amp;k, &amp;x, &amp;y) != EOF) &#123; Area area = Area(1, pow(2, k), 1, pow(2, k)); Point point = Point(x, y); dfs(area, point/*, 0*/); &#125;#ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"AOJ 866.飞跃原野","date":"2017-05-05T03:55:14.000Z","path":"/post/AOJ/866.html","text":"题目点击显/隐题目 在一片广阔的土地上，有一个鸟人，他需要从这里穿过原野，回到基地。这片原野上，有平地(P)、有湖泊(L)，因为鸟人可以飞，所以呢，有的时候，他可以飞越湖泊。现在，鸟人需要用最快的时间，回到基地。假设原野是一个mn的矩阵，有两种地形，用P和L表示。鸟人只能停留在平地上。他目前处在(1,1)这个位置，而目的地是(m,n)。他可以向上下左右四个方向移动，或者飞行。每移动一格需要1个单位时间。而飞行无论飞多远，都只需要1个单位时间。飞行的途中不可以变方向，也就是说飞行也只能是上下左右四个方向。并且一次飞行最终必须降落在平地上。当然，受到能量的限制，鸟人不能无限制的飞行，他总共最多可以飞行的距离为D。第一行是三个整数，m，n，D，三个数都不超过100，下面是一个mn的矩阵，表示原野一个整数，为最短时间，如果无法到达，则输出“impossible”Original Transformed4 4 2PLLPPPLPPPPPPLLPOriginal Transformed5 题解有两种移动方式的最短路问题 步行：上下左右移动一格，只能通过平原。时间-1s 飞行：上下左右移动任意格，可以穿越湖泊和平原，但是起点和终点必须是平原。能量减少移动的格数，时间-1s显然如果有足够的能量的情况下，应该尽可能多的采用飞行的方式(比较快，而且无视地形) 有一种情况需要考虑，如果终点被湖泊包围，而且能量不是那么充足的情况，需要前期尽可能步行，最后才飞行 由于是最短路问题，尝试用BFS(及其变形)解答 由于是不存在权值的最短路，因此不需要使用priority_queue，直接普通的先进先出即可 数组需要对x,y,d同时进行判重，也即 bool vis[101][101][101]; 判断是否访问过要在插入队列前，否则会导致 queue 过大 两种移动方式要分开写，步行就是通常bfs的那种拓展节点的方式，飞行需要在那个基础上加上一个循环变量 k (飞行距离)。k要满足 k&lt;d ，同时当发现已经飞到地图外时就可以直接break了。 整体而看，只是一个 vis 变量多了一维的普通 bfs ，不要想复杂了 代码点击显/隐代码 飞跃原野代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int delta[] = &#123;1, -1, 0, 0&#125;;const int maxn = 105;char Map[maxn][maxn];bool vis[maxn][maxn][maxn];int m, n, D;struct Point &#123; int x, y, d, t; Point(int _x = 0, int _y = 0, int _d = 0, int _t = 0) : x(_x), y(_y), d(_d), t(_t) &#123;&#125; bool operator&lt;(const Point &amp;rhs) const &#123; if (t == rhs.t) return d &gt; rhs.d; return t &gt; rhs.t; &#125;&#125;;//判断位置合法性bool judge(int x, int y) &#123; return (x &gt;= 1 &amp;&amp; x &lt;= m &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= n); &#125;queue&lt;Point&gt; Q;int bfs() &#123; while (!Q.empty()) Q.pop(); int ans = -1; memset(vis, false, sizeof(vis)); Q.push(Point(1, 1, D, 0)); vis[1][1][D] = true; while (!Q.empty()) &#123; int x = Q.front().x; int y = Q.front().y; int d = Q.front().d; int t = Q.front().t; Q.pop(); //printf(\"x=%d y=%d d=%d t=%d \\n\", x, y, d, t); if (x == m &amp;&amp; y == n) &#123; ans = t; break; &#125; //步行移动 for (int i = 0; i &lt; 4; i++) &#123; int xx = x + delta[i]; int yy = y + delta[3 - i]; if (!judge(xx, yy)) continue; if (Map[xx][yy] != 'P') continue; if (vis[xx][yy][d]) continue; vis[xx][yy][d] = true; Q.push(Point(xx, yy, d, t + 1)); &#125; //飞行移动 for (int i = 0; i &lt; 4; i++) &#123; for (int k = 1; k &lt;= d; k++) &#123; int xx = x + delta[i] * k; int yy = y + delta[3 - i] * k; if (!judge(xx, yy)) break; if (Map[xx][yy] != 'P') continue; if (vis[xx][yy][d - k]) continue; vis[xx][yy][d - k] = true; Q.push(Point(xx, yy, d - k, t + 1)); &#125; &#125; &#125; return ans;&#125;int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock();#endif cin.tie(0); cin.sync_with_stdio(false); scanf(\"%d%d%d\", &amp;m, &amp;n, &amp;D); for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; scanf(\"\\n%c\", &amp;Map[i][j]); // printf(\"%c\", Map[i][j]); &#125; // printf(\"\\n\"); &#125; int ans = bfs(); if (ans == -1) printf(\"impossible\\n\"); else printf(\"%d\\n\", ans);#ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"}]},{"title":"AOJ 865.青铜莲花池","date":"2017-05-05T03:42:03.000Z","path":"/post/AOJ/865.html","text":"题目点击显/隐题目 为了让奶牛们娱乐和锻炼，农夫约翰建造了一个美丽的池塘。这个长方形的池子被分成了M行N列个方格（1 ≤ M, N ≤ 30）。一些格子是坚固得令人惊讶的莲花，还有一些格子是岩石，其余的只是美丽、纯净、湛蓝的水。贝西正在练习芭蕾舞，她站在一朵莲花上，想跳到另一朵莲花上去，她只能从一朵莲花跳到另一朵莲花上，既不能跳到水里，也不能跳到岩石上。贝西的舞步很像象棋中的马步：每次总是先横向移动M1 （1 ≤ M1 ≤ 30）格，再纵向移动M2 （1 ≤ M2 ≤ 30, M1 M2）格，或先纵向移动M1格，再横向移动M2格。最多时，贝西会有八个移动方向可供选择。给定池塘的布局和贝西的跳跃长度，请计算贝西从起点出发，到达目的地的最小步数，我们保证输入数据中的目的地一定是可达的。第一行：四个用空格分开的整数：M，N，M1和M2第二行到M + 1行：第i + 1行有N个用空格分开的整数，描述了池塘第i行的状态：0 为水，1 为莲花，2 为岩石，3 为贝西所在的起点，4 为贝西想去的终点。第一行：从起点到终点的最少步数4 5 1 21 0 1 0 13 0 2 0 40 1 2 0 00 0 0 1 0 4 5 1 21 0 1 0 13 0 2 0 40 1 2 0 00 0 0 1 022 题解标准的BFS问题,节点的拓展方式比较多题意为每一步是先跳到一个荷叶,再跳到另一片荷叶实际操作不考虑中间的荷叶是否能走 代码点击显/隐代码 青铜莲花池代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn = 35;const int delta[4][2] = &#123;&#123;-1, -1&#125;, &#123;-1, 1&#125;, &#123;1, -1&#125;, &#123;1, 1&#125;&#125;;int Map[maxn][maxn];struct Point &#123; int x, y; Point(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125; bool operator==(const Point &amp;rhs) const &#123; return x == rhs.x &amp;&amp; y == rhs.y; &#125;&#125;;queue&lt;Point&gt; Q;int dis[maxn][maxn];int bfs(int m, int n, int d1, int d2, Point s, Point v) &#123; memset(dis, 0, sizeof(dis)); while (!Q.empty()) Q.pop(); Q.push(s); dis[s.x][s.y] = 0; while (!Q.empty()) &#123; Point t = Q.front(); Q.pop(); if (t == v) break; for (int i = 0; i &lt; 4; i++) &#123; int xx = t.x + delta[i][0] * d1; int yy = t.y + delta[i][1] * d2; if (xx &lt; 0 || xx &gt;= m || yy &lt; 0 || yy &gt;= n) continue; if (dis[xx][yy] || Map[xx][yy] == 0 || Map[xx][yy] == 2) continue; // if (!(Map[t.x][yy] == 1 || Map[xx][t.y] == 1 || Map[t.x][yy] == 4 || Map[xx][t.y] == 4)) // continue; dis[xx][yy] = dis[t.x][t.y] + 1; Q.push(Point(xx, yy)); &#125; for (int i = 0; i &lt;= 3; i++) &#123; int xx = t.x + delta[i][0] * d2; int yy = t.y + delta[i][1] * d1; if (xx &lt; 0 || xx &gt;= m || yy &lt; 0 || yy &gt;= n) continue; if (dis[xx][yy] || Map[xx][yy] == 0 || Map[xx][yy] == 2) continue; // if (!(Map[t.x][yy] == 1 || Map[xx][t.y] == 1 || Map[t.x][yy] == 4 || Map[xx][t.y] == 4)) // continue; dis[xx][yy] = dis[t.x][t.y] + 1; Q.push(Point(xx, yy)); &#125; &#125; return dis[v.x][v.y];&#125;int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock();#endif cin.tie(0); cin.sync_with_stdio(false); int M, N, M1, M2; Point s, v; while (scanf(\"%d%d%d%d\", &amp;M, &amp;N, &amp;M1, &amp;M2) != EOF) &#123; for (int i = 0; i &lt; M; i++) for (int j = 0; j &lt; N; j++) &#123; scanf(\"%d\", &amp;Map[i][j]); if (Map[i][j] == 3) &#123; s.x = i; s.y = j; &#125; if (Map[i][j] == 4) &#123; v.x = i; v.y = j; &#125; &#125; &#125; printf(\"%d\\n\", bfs(M, N, M1, M2, s, v)); // for (int i = 0; i &lt; M; i++) &#123; // for (int j = 0; j &lt; N; j++) // printf(\"%d \", dis[i][j]); // printf(\"\\n\"); // &#125;#ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"}]},{"title":"随身携带Ubuntu系统(非启动盘)","date":"2017-05-01T08:23:57.000Z","path":"/post/Note/Ubuntu_on_UDisk.html","text":"对这个问题期待好久了,之前由于没有找到响应的解决方案,用VS Code及一些批处理命令初步解决了在U盘随身带着环境的情况当然,如果能实现随身带着一个系统自然更好&lt;% note success %&gt;需要工具 USB 3.0 U盘 x1 电脑 x1 Ubuntu 安装镜像(官网下载链接) VMware&lt;% endnote %&gt; 备份U盘数据 在VMware里新建一个空的虚拟机系统那里选择稍后安装操作系统,其它默认即可 打开虚拟机,插入U盘,语言切换到中文,选择试用 进入临时系统后,点击桌面上的安装工具开始安装 如果分辨率存在问题,可以运行命令 xrandr选择一个长和宽都小于等于物理机分辨率的分辨率使用比如 xrandr -s 1680x1050_49.98 分区手动操作,满足我们的特殊需求其中,sdb就是我们的U盘如果U盘比较大,为了不浪费,还是要分出来一部分当正常U盘的重建sdb的分区表,按顺序建立 fat32 ext4 swap 三个分区其中 fat32 用来充当正常U盘部分,ext4挂在 \\ 目录用来安装系统,swap为交换分区(虚拟内存)具体大小可以根据自己的U盘情况,系统留15G,swap留1G就足够了 分好区后,选择U盘安装系统(必须选U盘的根分区,不然没法引导) 闭着眼点继续就行,漫长的等待后就好了","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.oyohyee.com/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://www.oyohyee.com/tags/Ubuntu/"}]},{"title":"制作手工精灵球","date":"2017-04-28T15:59:57.000Z","path":"/post/Writing/Pokemon_ball_DIY.html","text":"起因一切源自于@徐娇的微博 看到知乎上的提问如何制作一个精灵球？有好多人都自制除了非常漂亮的精灵球,于是就更加想自己做一个了~ 这简直是送妹子的首选礼物啊~ 准备徐娇的微博下有她制作的时候的淘宝店铺,看了下比较乱,就搜了一下,果然有店家做整合包选择了Lauren口袋妖怪DIY精灵球神奇宝贝手工精灵球皮卡丘材料包手作 店主挺不错的，发货速度还算比较快~ 开始制作第一天 第一步,检查装备一个球形展示框,一块白色粘土,一个三角底座,两个小精灵(我额外买了一个),草地、海洋地形包,树木、蘑菇、石头装饰,白乳胶,棉签,电工胶带,按钮,不明棒状物 洗手由于需要捏粘土,所以洗手是非常关键的一步 把粘土分为一大一小两部分取出小的粘土,用它涂满精灵球底座(连接处凹陷的半球)这里建议把粘土揪下来一点一点涂,尽量保证从球外看过去均匀覆盖 用大粘土填充整个下半球 将下半球单独拿出来晾干(一夜时间)这个时候可以先思考下怎么摆位置~ 第二天 向黏土表层涂白乳胶 用棉签把白乳胶均匀覆盖表面 覆盖一层草粉,不用太密,浅浅一层即可 把小精灵、装饰物都插上来(下面涂上适量白乳胶) 再把草粉不够茂密的地方涂上草粉 此时如果倒过来小精灵会掉下来,需要再晾干几天 第N天 盖上盖子 从送的按钮(扣子？)向两个方向引电工胶带 拍照发说说显摆一下","tags":[{"name":"DIY","slug":"DIY","permalink":"https://www.oyohyee.com/tags/DIY/"}]},{"title":"AOJ 863.分书问题","date":"2017-04-26T13:00:54.000Z","path":"/post/AOJ/863.html","text":"题目点击显/隐题目 已知有n本书（从1～n编号）和n个人（从1～n编号），每个人都有一个自己喜爱的书的列表，现在请你编写一个程序，设计一种分书方案，使得每个人都能获得一本书，且这本书一定要在他的喜爱列表中。输入数据共若干行，第一行为一个正整数n（n &lt;= 20），从第2行到第n+1行，每行有n个0或1组成，第k行表示编号为k-1的人对这n本书的喜好列表，0表示不喜欢，1表示喜欢。输出数据仅一个整数，表示符合条件的分配方案的总数。500110110010110000010010011 题解暴力DFS即可,最差情况 2020 个 1 是过不了的问题为二分图匹配方案数计数,为*NP问题,只能暴力解决因此可以不用考虑极端情况,尽量优化即可 发现有人分不到书直接返回. 代码点击显/隐代码 分书问题代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std; const int maxn = 25;char isLove[maxn][maxn];bool isUsed[maxn]; int n;int ans; void init()&#123; ans = 0; memset(isUsed,false,sizeof(isUsed));&#125; //第 t 个人void dfs(int t) &#123; if (t &gt; n) &#123; ans++; return; &#125; bool ok = false; for (int i = 1; i &lt;= n; i++) if (isLove[t][i]=='1' &amp;&amp; !isUsed[i]) &#123; //for(int k=0;k&lt;t;k++) // printf(\" \"); //printf(\"%d choose %d\\n\",t,i); ok = true; isUsed[i] = true; dfs(t + 1); isUsed[i] = false; &#125; if (!ok) return;&#125; int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock();#endif cin.tie(0); cin.sync_with_stdio(false); while (scanf(\"%d\",&amp;n) != EOF) &#123; init(); for (int i = 1; i &lt;= n; i++)&#123; scanf(\"%s\",isLove[i]+1); //printf(\"%c%c%c%c%c\\n\",isLove[i][1],isLove[i][2],isLove[i][3],isLove[i][4],isLove[i][5]); &#125; dfs(1); printf(\"%d\\n\",ans); &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"DFS","slug":"DFS","permalink":"https://www.oyohyee.com/tags/DFS/"},{"name":"剪枝","slug":"Pruning","permalink":"https://www.oyohyee.com/tags/Pruning/"}]},{"title":"AOJ 862.平面上最近点对","date":"2017-04-26T12:28:26.000Z","path":"/post/AOJ/862.html","text":"题目点击显/隐题目 给定平面上n个点，找出其中的一对点的距离，使得这n个点的所有点对中，该距离为所有点对中最小的。第一行：n；2≤n≤60000；接下来n行：每行两个整数：x y，表示一个点的行坐标和列坐标，中间用一个空格隔开。仅一行，一个实数，表示最短距离，精确到小数点后面4位。31 11 22 21.0000 题解正确思路好像要用主席树,然而不会,只能暴力写一发 首先可以知道如果按照 (x,y) 排序,可以发现离得近的点普遍距离较近存在反例,(1,1) (1,100) (2,1) 排序后显然第一个和第三个距离更近 但是在已经范围内我们可以近似认为没影响(比较的时候多比较几组就行了~) 那么我们尝试采用二分进行优化用 dfs(l,r) 来表示 [l,r) 的最近的两个点的距离 显然有: 最近的两个点可能全部在 mid 左侧的范围里,也即 dfs(l,mid) 最近的两个点可能全部在 mid 右侧的范围里,也即 dfs(mid,r) 最近的两个点一个在 mid 左侧,一个在 mid 右侧 前两种情况都比较容易解决,只需要考虑最后一种情况遍历两侧的所有点,计算他们的距离最小值 根据最上面的说明,可以得知横跨 mid 左右的距离最近的点必然距离 mid 距离不远可以将 x1-x2 近似看成距离,如果它已经大于之前已经获得最小距离,可以直接结束循环(存在极端情况导致答案错误) 另外,根据两点间距离公式 $\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$可以发现有一个非常浪费时间的 sqrt() 需要多次运算,可以在前面比较的时候直接比较距离的平方只要在最后输出的时候求一下平方就行(需要注意,如果这里比较距离的平方,上面遍历需要比较 (x1-x2)^2) 代码点击显/隐代码 平面上最近点对代码备份//*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 60005;const double INF = 9e9;const int K = 5;struct Point &#123; int x, y; Point(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125; bool operator&lt;(const Point &amp;rhs) const &#123; return x &lt; rhs.x; &#125;&#125;;Point point[maxn];inline double pow(double a, double n) &#123; if (n == 0) return 1.0; if (n == 1) return a; return pow(a, n / 2) * pow(a, n - n / 2);&#125;inline double dis(Point a, Point b) &#123; return pow(a.x - b.x, 2) + pow(a.y - b.y, 2);&#125;//[l,r)double dfs(int l, int r) &#123; int mid = (l + r) / 2; if (r - l &lt; 2) &#123; return INF; &#125; if (r - l == 2) &#123; return dis(point[l], point[l + 1]); &#125; double mm = min(dfs(l, mid), dfs(mid, r)); for (int i = mid - 1; i &gt;= l &amp;&amp; pow(point[mid].x - point[i].x,2) &lt; mm; i--) for (int j = mid; j &lt; r &amp;&amp; pow(point[r].x - point[mid-1].x,2) &lt; mm; j++) mm = min(mm, dis(point[i], point[j])); return mm;&#125;int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock();#endif cin.tie(0); cin.sync_with_stdio(false); int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) scanf(\"%d%d\", &amp;point[i].x, &amp;point[i].y); sort(point, point + n); printf(\"%.4f\\n\", sqrt(dfs(0, n)));#ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"二分","slug":"Division","permalink":"https://www.oyohyee.com/tags/Division/"},{"name":"递归与分治","slug":"Recursion","permalink":"https://www.oyohyee.com/tags/Recursion/"}]},{"title":"VPS gengrator 命令导致 hexo 被 killed 解决方案","date":"2017-04-07T13:31:50.000Z","path":"/post/Note/VPS_gengrator.html","text":"问题在 Segmentfault 上提问 Linux(CentOs)下hexo生成文章被killed 有解决方案: 内存不足，创建交互空间即可。见：https://www.qcloud.com/document/product/362/3597 该网页给出如下方案free -m dd if=/dev/zero of=/swap bs=4096 count=1572864mkswap /swapswapon /swapecho \"LABEL=SWAP-sda /swap swap swap defaults 0 0\" &gt;&gt; /etc/fstab 这样会在根目录建立一个 swap 文件,用于虚拟内存使用 dd if=/dev/zero of=/swap bs=4096 count=1572864 命令时,会卡一会,等待即可 然后就可以正常使用 hexo g 命令了","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.oyohyee.com/tags/Linux/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.oyohyee.com/tags/Hexo/"},{"name":"VPS","slug":"VPS","permalink":"https://www.oyohyee.com/tags/VPS/"}]},{"title":"jQuery 实现内容折叠功能","date":"2017-04-07T09:33:08.000Z","path":"/post/Note/fold.html","text":"代码折叠功能如下 点击折叠/展开 我是内容 其使用的是 jQuery 的基础功能 slideToggle 给所有的指定标签都绑定一个时间,点击后会 slideToggle 这些标签的父 div 为了保证能够绑定成功,要在页面全部加载后绑定 代码如下$(document).ready(function()&#123; $(document).on('click', '.fold_hider', function()&#123; $('&gt;.fold', this.parentNode).slideToggle(); $('&gt;:first', this).toggleClass('open'); &#125;); //默认情况下折叠 $(\"div.fold\").css(\"display\",\"none\");&#125;); 当然,该部分要在 读入 jquery 文件后 同时为了让文字更好看,加上一些符号另外由于在 iOS 上,要响应 click ,需要鼠标放上去显示手的符号因此还要改一下 css .hider_title&#123; font-family: \"Microsoft Yahei\"; cursor: pointer;&#125;.close:after&#123; content: \"▼\";&#125;.open:after&#123; content: \"▲\";&#125; 使用时这样即可&lt;div&gt; &lt;div class=\"fold_hider\"&gt; &lt;div class=\"close hider_title\"&gt;' + text + '&lt;/div&gt; &lt;/div&gt; &lt;div class=\"fold\"&gt; ...内容... &lt;/div&gt;&lt;/div&gt; 当然,在 Hexo 里可以使用 内建标签具体可以参考官方的文档 在博客根目录里的 scripts 的文件夹里,新建 fold.jsfold.jslink/* global hexo */// Usage: &#123;% fold ???? %&#125; Something &#123;% endfold %&#125;function fold (args, content) &#123; var text = args[0]; if(!text) text = \"点击显/隐\"; return '&lt;div&gt;&lt;div class=\"fold_hider\"&gt;&lt;div class=\"close hider_title\"&gt;' + text + '&lt;/div&gt;&lt;/div&gt;&lt;div class=\"fold\"&gt;\\n' + hexo.render.renderSync(&#123;text: content, engine: 'markdown'&#125;) + '\\n&lt;/div&gt;&lt;/div&gt;';&#125;hexo.extend.tag.register('fold', fold, &#123;ends: true&#125;); 这样就可以通过以下方式使用&#123;% note 点击显/隐内容 %&#125;内容&#123;% endnote %&#125; 如果你想折叠代码块,那么需要额外加一个 js 文件,实现对代码块的渲染详情参考 Hexo 自建标签渲染代码段的 Bug 解决方案 tags.jslink/* @haohuawu 修复 Nunjucks 的 tag 里写 ```代码块```，最终都会渲染成 undefined 的问题 https://github.com/hexojs/hexo/issues/2400*/const rEscapeContent = /&lt;escape(?:[^&gt;]*)&gt;([\\s\\S]*?)&lt;\\/escape&gt;/g;const placeholder = '\\uFFFD';const rPlaceholder = /(?:&lt;|&amp;lt;)\\!--\\uFFFD(\\d+)--(?:&gt;|&amp;gt;)/g;const cache = [];function escapeContent(str) &#123; return '&lt;!--' + placeholder + (cache.push(str) - 1) + '--&gt;';&#125;hexo.extend.filter.register('before_post_render', function(data) &#123; data.content = data.content.replace(rEscapeContent, function(match, content) &#123; return escapeContent(content); &#125;); return data;&#125;);hexo.extend.filter.register('after_post_render', function(data) &#123; data.content = data.content.replace(rPlaceholder, function() &#123; return cache[arguments[1]]; &#125;); return data;&#125;);","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.oyohyee.com/tags/Hexo/"},{"name":"javascript","slug":"Javascript","permalink":"https://www.oyohyee.com/tags/Javascript/"},{"name":"jquery","slug":"jquery","permalink":"https://www.oyohyee.com/tags/jquery/"}]},{"title":"hexo next主题二级分类中的分隔符如何设置成下图这样的格式？","date":"2017-04-01T15:41:08.000Z","path":"/post/Zhihu/Hexo_separator.html","text":"https://www.zhihu.com/question/57888214/answer/154699381 Hexo_separator_1 没有太理解你的具体意思,大概有两种理解吧 如何生成二级分类 如何显示 “&gt;” 这个符号 对于第一种理解 只需要---title: tdate: 2017-04-01 00:44:21categories: - 笔记- 题解- ttags:--- 就可以实现(要求没产生分类连成有向图没有回路) Hexo_separator_1 如果是第二种,以 NexT 主题为例 Blog\\themes\\next\\layout\\_macro\\post.swig文件里有 &#123;% if post.categories and post.categories.length and theme.post_meta.categories %&#125; &lt;span class=\"post-category\" &gt; &#123;% if theme.post_meta.created_at or theme.post_meta.updated_at %&#125; &lt;span class=\"post-meta-divider\"&gt;|&lt;/span&gt; &#123;% endif %&#125; &lt;span class=\"post-meta-item-icon\"&gt; &lt;i class=\"fa fa-folder-o\"&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_meta.item_text %&#125; &lt;span class=\"post-meta-item-text\"&gt;&#123;&#123; __('post.in') &#125;&#125;&lt;/span&gt; &#123;% endif %&#125; &#123;% for cat in post.categories %&#125; &lt;span itemprop=\"about\" itemscope itemtype=\"http://schema.org/Thing\"&gt; &lt;a href=\"&#123;&#123; url_for(cat.path) &#125;&#125;\" itemprop=\"url\" rel=\"index\"&gt; &lt;span itemprop=\"name\"&gt;&#123;&#123; cat.name &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;/span&gt; &#123;% set cat_length = post.categories.length %&#125; &#123;% if cat_length &gt; 1 and loop.index !== cat_length %&#125; &#123;&#123; __('symbol.comma') &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/span&gt;&#123;% endif %&#125; 这一段就是相应的代码 可以看出来&lt;span class=\"post-meta-item-icon\"&gt; &lt;i class=\"fa fa-folder-o\"&gt;&lt;/i&gt;&lt;/span&gt; 这一部分是分类的小图标 &lt;span itemprop=\"about\" itemscope itemtype=\"http://schema.org/Thing\"&gt; &lt;a href=\"&#123;&#123; url_for(cat.path) &#125;&#125;\" itemprop=\"url\" rel=\"index\"&gt; &lt;span itemprop=\"name\"&gt;&#123;&#123; cat.name &#125;&#125;&lt;/span&gt; &lt;/a&gt;&lt;/span&gt; 这一部分是生成链接 &#123;% if cat_length &gt; 1 and loop.index !== cat_length %&#125; &#123;&#123; __('symbol.comma') &#125;&#125;&#123;% endif %&#125; 这一部分就是产生分隔符号(如果多余一个分类并且当前循环不是最后一个) __(&#39;symbol.comma&#39;)这个就是 “,” 把它改成 “&gt;” 即可(直接写成文本就行)","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.oyohyee.com/tags/Hexo/"}]},{"title":"hexo next主题如何更改css使头像在手机端显示？","date":"2017-04-01T15:19:41.000Z","path":"/post/Zhihu/Hexo_avatar.html","text":"https://www.zhihu.com/question/57821305/answer/154688341这要看你想加到哪，想怎么加了(知乎不支持markdown真恶心,排版好难受) 以 NexT 主题为例(毕竟我也不知道你用的什么主题,就选用的人最多的吧) 官方文档如下如何更改内容区域的宽度？ NexT 对于内容的宽度的设定如下： 700px，当屏幕宽度 &lt; 1600px 900px，当屏幕宽度 &gt;= 1600px 移动设备下，宽度自适应 如果你需要修改内容的宽度，同样需要编辑样式文件。 编辑主题的 source/css/_variables/custom.styl 文件，新增变量：// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px 此方法不适用于 Pisces Scheme，关于如何修改 Pisces Scheme 的宽度请参看 这个 Issue 也即,如果你想让手机端和电脑端一样也显示边栏就修改这个值(很显然会很难看) 如果想在手机端比较好看地显示头像,显然不能指望 sidebar 了 那么就自己把头像加进去就行 &lt;img src=&quot;XXX&quot; class = &quot;touxiang&quot;&gt; 然后把 touxiang 的 css 设置一下放到你想放的位置 (比如标题栏下面放个比较小的头像应该是相对较美观的) (再或者放到标题前面或者后面也行) 关于如何加 html 到你相应的主题文件夹的 layout 目录,找到对应的部分的文件修改即可 在评论回下主题什么什么的如果有空可以给你写一下(可能要很久,拖延症晚期)","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.oyohyee.com/tags/Hexo/"}]},{"title":"U盘格式化 + 启动盘","date":"2017-04-01T12:53:42.000Z","path":"/post/Note/Udisk_formatting.html","text":"本身的U盘格式有问题,存在非常蛋疼的问题,抽时间重新格式化了一下U盘,发现还是有一些坑的 格式化U盘首先先来看下名词解释,常见的U盘格式有 FAT,FAT32,exFat,NTFS在现在这个年代, FAT 显然已经淘汰了,那么其他的有什么特点呢点击显/隐介绍 FAT32FAT32是分区格式的一种这种格式采用 32 位的文件分配表,使其对磁盘的管理能力大大增强,突破了FAT16对每一个分区的容量只有 2GB 的限制由于现在的硬盘生产成本下降,其容量越来越大,运用FAT32的分区格式后,我们可以将一个大硬盘定义成一个分区而不必分为几个分区使用,大大方便了对磁盘的管理但由于FAT32分区内无法存放大于4GB的单个文件,且性能不佳,易产生磁盘碎片目前已被性能更优异的NTFS分区格式所取代 exFATexFAT是Microsoft在Windows Embeded 5.0以上中引入的一种适合于闪存的文件系统,为了解决FAT32等不支持4G及其更大的文件而推出对于闪存,NTFS文件系统不适合使用,exFAT更为适用对于磁盘则不太适用 NTFSNTFS,是 WindowsNT 环境的文件系统新技术文件系统是Windows NT家族等的限制级专用的文件系统NTFS取代了老式的FAT文件系统NTFS对FAT和HPFS作了若干改进,例如,支持元数据,并且使用了高级数据结构,以便于改善性能、可靠性和磁盘空间利用率,并提供了若干附加扩展功能 该文件系统的详细定义属于商业秘密 ,微软已经将其注册为知识产权产品 划重点!!NTFS 格式是微软有版权的,所以这个不是随便就能用的,因此这个格式的U盘你在非 Windows 家族的系统上很可能不能使用这也就是许多手机OTG不能正确读取U盘的原因 因此应该把文件系统格式化成 exFAT这样即满足了能够存放4G以上的文件,同时还能保证手机能够通过OTG读取手机 再来看为什么文件的大小和占用空间不一样可以看到,在格式化的时候有一个 分配单元大小 ,这个就是你U盘的最小单位,如果一个文件小于这个大小,那么它将占用整个这个单元大小的空间显然,如果大文件比较多这个功能显然可以加快一些读取、处理的速度(被分割成较少块)而如果小文件比较多,显然会非常浪费空间(之前U盘就是11G的东西占了40G空间) 因此需要根据文件大小挑选更加合适的大小,比如我的U盘更多是一些ACM的代码,一般都是 1~2K那么就可以把空间大小设置成 1K 或者 4K 那么选项就选好了选择 exFAT 的文件系统,单元大小根据需要即可 PE系统显/隐概念 PEPE,Windows PE Windows Preinstallation Environment,Windows预安装环境,微软在2002年7月22日发布,带有限服务的最小Win32子系统,基于以保护模式运行的Windows XP Professional内核Windows预先安装环境是简化版的Windows XP、Windows Server 2003、Windows Vista、Windows 7 、Windows 8和Windows 10WinPE是以光盘或其他可携设备作媒介WinPE作用是方便大企业作出工作站和服务器的企划、给“原始设备制造商”制造自定义的Windows操作系统、取代MS-DOS的磁片Windows PE可理解为Windows的LiveCD PE不仅能在安装系统时有一个更友善的界面,还能在电脑出现故障时能够辅助维修而一个功能完善的PE不仅能够运行常见的软件,甚至还能联网因此一个比较全面的PE非常有用(虽然由于驱动的问题分辨率可能会比较诡异) 老毛桃、大白菜都是比较常见的PE系统,不过由于智能刷入他们整合好的系统,因此有时候不是那么符合我们的要求更好地选择是找一个更加适合自己的iso文件许多论坛上都有整合好的iso文件,但是要注意有的iso里有一些后门,因此选择一个可靠的来源非常关键 找好iso镜像后,把它解压到U盘根目录,然后使用 BOOTICE 把U盘的主引导记录设置成 Ultral USB-HDD+分区引导设置成 BOOTMGR引导程序这样开机时在 BIOS 里选择U盘启动即可进入到 PE 里","tags":[]},{"title":"Photoshop 安装错误解决","date":"2017-03-31T01:43:02.000Z","path":"/post/Note/photoshop_install.html","text":"安装 photoshop 时遇到错误应该是因为老版本没有卸载干净 Exit Code: 34Please see specific errors below for troubleshooting. For example, ERROR:-------------------------------------- Summary -------------------------------------- - 1 fatal error(s), 0 error(s) FATAL: Payload ‘Camera Profiles Installer 8.0.0.15 {3F023875-4A52-4605-9DB6-A88D4A813E8D}’ information not found in Media_db.------------------------------------------------------------------------------------- System Requirements 解决方案: 删掉 C:\\Program Files (x86)\\Common Files\\Adobe\\caps 目录下的3个 .db 文件","tags":[{"name":"Photoshop","slug":"Photoshop","permalink":"https://www.oyohyee.com/tags/Photoshop/"}]},{"title":"服务器权限设置出错及维护","date":"2017-03-28T15:46:53.000Z","path":"/post/Note/server_authority.html","text":"服务器上的网站除了首页，其他所有页面都打不开看了下数据库没问题，网站的 aspx 文件也没问题估计是权限的问题 看了下报错的信息&lt;!-- Web.Config Configuration File --&gt;&lt;configuration&gt; &lt;system.web&gt; &lt;customErrors mode=&quot;Off&quot;/&gt; &lt;/system.web&gt;&lt;/configuration&gt; 网站关了提示报错先去根目录的 web.config 修改下配置，打开报错改成 Off 后就可以看到报错信息了（注意大小写） 然后再看网页BC30138: 无法在路径“C:\\WINDOWS\\TEMP\\”中创建临时文件: 拒绝访问。 问题定位完毕 temp 目录权限问题进到 windosws 目录右键把 network service 的写入权限打开解决~","tags":[{"name":"服务器","slug":"server","permalink":"https://www.oyohyee.com/tags/server/"}]},{"title":"安徽大学第九届大学生程序设计竞赛决赛","date":"2017-03-27T16:13:13.000Z","path":"/post/Project/ACM2017_03_26.html","text":"编号 题目 题解 A AOJ.839.调酒师 题解 B AOJ.840.下一个幸运数 题解 C AOJ.841.最短路径和 题解 D AOJ.842.西瓜的编译原理作业 题解 E AOJ.843.晋级下一轮 题解 F AOJ.844.西瓜和病毒 题解 G AOJ.845.黑白棋 题解 H AOJ.846.勤劳的出题人 题解","tags":[]},{"title":"AOJ 846.勤劳的出题人","date":"2017-03-27T15:44:01.000Z","path":"/post/AOJ/846.html","text":"题目 点击显/隐题目 小蓝最近要办一场程序设计比赛, 要出一些题目.从无到有原创一道题是很难的一件事情, 好在小蓝平时积累了m道现成的题目, 记这m道题的编号为1到m, 这m道题的复杂度记为bi(1&lt;=i&lt;=m).另外为了保证比赛的质量, 小蓝指定了一个复杂度标准, 即, 小蓝至少需要出n道题, 复杂度分别恰好是ai(1&lt;=i&lt;=n).小蓝可以通过降低题目难度将现成的一道难度为c的题目改编成难度为d(d&lt;=c)的题目, 一道现成题最多使用一次; 也可以原创一道任意难度的题目, 鉴于原创的难度, 小蓝希望原创的题目越少越好.现在请你帮忙判断, 小蓝至少需要原创多少道题. 第一行: 两个数, n和m,(1 &lt;= n, m &lt;= 3000)第二行: n个数, 即a1, a2, …, an;第三行: m个数, 即b1, b2, …, bm(1 &lt;= ai, bi &lt;= 1000,000) 一个整数, 即小蓝至少需要原创的题目数 3 51 2 31 1 1 1 4 1 题解分别对 a 和 b 排序对于每个要求的 a ,都选择尽可能小的 b注意 a 比 b 还多的情况最后求还剩下的题目数 贪心跑一边即可 代码点击显/隐代码勤劳的出题人代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 3005;int a[maxn];int b[maxn];bool flag[maxn];typedef int LL;int upper_bound(LL *arr,int size, LL key) &#123; int mid; int first = 0; int half; while (size &gt; 0) &#123; half = size &gt;&gt; 1; mid = half + first; if (arr[mid] &gt; key) &#123; size = half; &#125; else &#123; first = mid + 1; size = size - half - 1; &#125; &#125; return first;&#125;int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int n,m; while(cin &gt;&gt; n &gt;&gt; m)&#123; memset(flag,false,sizeof(flag)); for(int i=0;i&lt;n;i++) cin &gt;&gt; a[i]; for(int i=0;i&lt;m;i++) cin &gt;&gt; b[i]; sort(a,a+n); sort(b,b+m); int ans=0; int bpos=0; for(int i=0;i&lt;n;i++)&#123; while(1)&#123; if(bpos&gt;=m)&#123; ans = n-i; break; &#125; if(b[bpos]&gt;=a[i])&#123; bpos++; break; &#125; bpos++; &#125; if(ans) break; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"}]},{"title":"AOJ 845.黑白棋","date":"2017-03-27T15:34:09.000Z","path":"/post/AOJ/845.html","text":"题目 点击显/隐题目 小红和小绿在玩一个摆棋子游戏.小红在桌上摆了12个棋子, 棋子分黑和白两个颜色. 小绿给出a, b两个正整数使得a和b的积为12, 然后依次取小红摆好的棋子中的前b个放到一列, 然后再取剩下来的棋子中的前b个放到第二列, …, 直到摆成一个a*b的棋子矩阵. 当矩阵中存在某一列或某些列全部为黑棋子时, 小绿成功完成这轮游戏, 否则失败. 现在小红已经把棋子摆好了, 请帮助小绿算出所有能让小绿成功完成游戏的a和b的选择方案. 第一行: 给出数据组数, t(1≤t≤100);接下来t行: 每行12个字符, 表示小红摆好的棋子序列, 字符’X’表示黑棋, ‘O’表示白棋. 一共t行, 一行对应一组输入数据的所有方案;对于一组数据, 先输出小绿可以成功完成游戏的方案数n, 接下来给出以’axb’的格式给出这n个方案, a值小的方案先输出. 方案之间用一个空格隔开. 4OXXXOXOOXOOXOXOXOXOXOXOXXXXXXXXXXXXXOOOOOOOOOOOO 3 1x12 2x6 4x34 1x12 2x6 3x4 6x26 1x12 2x6 3x4 4x3 6x2 12x10 题解模拟跑一下就行,按照指定的要求分成制定的行列,最后看有没有一行全是黑棋(题目应该是表达错了,不过可以根据样例自己推出来) 代码点击显/隐代码黑白棋代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int ans[][2] = &#123;&#123;1,12&#125;,&#123;2,6&#125;,&#123;3,4&#125;,&#123;4,3&#125;,&#123;6,2&#125;,&#123;12,1&#125;&#125;;bool answ[6];bool a[12];bool Map[12][12];int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--)&#123; for(int i=0;i&lt;12;i++)&#123; char t; cin &gt;&gt; t; a[i] = t=='X'; &#125; memset(answ,false,sizeof(answ)); for(int i=0;i&lt;6;i++)&#123; int pos=0; for(int x=0;x&lt;ans[i][0];x++)&#123; for(int y=0;y&lt;ans[i][1];y++)&#123; Map[x][y] = a[pos++]; &#125; &#125; bool OK = true; for(int y=0;y&lt;ans[i][1];y++)&#123; OK = true; for(int x=0;x&lt;ans[i][0];x++)&#123; if(!Map[x][y])&#123; OK = false; break; &#125; &#125; if(OK) break; &#125; if(OK) answ[i] = true; &#125; int cnt=0; for(int i=0;i&lt;6;i++) cnt+=(int)answ[i]; cout &lt;&lt; cnt; for(int i=0;i&lt;6;i++) if(answ[i]) cout &lt;&lt; \" \" &lt;&lt; ans[i][0] &lt;&lt; \"x\"&lt;&lt; ans[i][1]; cout &lt;&lt; endl; &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"AOJ 844.西瓜与病毒","date":"2017-03-27T15:32:11.000Z","path":"/post/AOJ/844.html","text":"题目 点击显/隐题目 西瓜在研究病毒的时候发现了下面的规律：病毒的特征码就是某些确定的二进制串。如果一个可执行文件中二进制代码中不存在任何一段病毒代码，那么这个可执行文件就是安全的。经过几天的努力，西瓜已经找出了所有的病毒特征码，西瓜突发奇想，这个世界上是否存在一个无限长的安全的二进制代码呢。例如如果{011, 11, 00000}为病毒特征码，那么一个可能的无限长安全代码就是010101…。如果{01, 11, 000000}为病毒特征码，那么就不存在一个无限长的安全代码。请写一个程序： 读入病毒特征码； 判断是否存在一个无限长的安全代码； 将结果输出。 第一行包括一个整数n，表示病毒特征码的数目。以下的n行每一行都包括一个非空的01字符串——就是一个病毒特征码。所有病毒特征码的总长度不超过30000。 第一行输出一个单词： TAK——假如存在这样的代码； NIE——如果不存在。 3011100000 NIE 题解代码点击显/隐代码西瓜与病毒代码备份","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"AOJ 843.晋级下一轮","date":"2017-03-27T15:28:16.000Z","path":"/post/AOJ/843.html","text":"题目 点击显/隐题目 比赛规定，N个人的比赛，分数为正数且分数大于等于第K名分数的人可以晋级下一轮。 现在给N个人的分数，问有多少个人可以晋级。注意，分数越高，排名越靠前。 第一行，一个整数t，表示测试数据组数（1&lt;=t&lt;=100）每组测试数据：第一行两个整数，n和k，（1&lt;=k&lt;=n&lt;=100）第二行n个整数，表示每个人的分数，已经从高到低排列，（0&lt;=每个人的分数&lt;=100） 每组测试数据，一个整数，表示有多少个人可以晋级下一轮。 28 510 9 8 7 7 7 5 54 20 0 0 0 60 题解找出所有比要求排名数分数高且分数不为 0 的人数 简单点写就是先找到排名为 k 的人,获取他的分数,大于 0 就找比他小的,等于 0 就找比他大的第一个不是 0 的用 lower_bound() 和 upper_bound() 虽然非常快,但是反而出错几率会变大 代码点击显/隐代码晋级下一轮代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 105;int a[maxn];typedef int LL;int lower_bound(LL *arr,int size, LL key) &#123; int half; int mid; int first = 0; while (size &gt; 0) &#123; half = size &gt;&gt; 1; mid = first + half; if (arr[mid] &gt; key) &#123; first = mid + 1; size = size - half - 1; &#125; else &#123; size = half; &#125; &#125; return first;&#125;int upper_bound(LL *arr,int size, LL key) &#123; int half; int mid; int first = 0; while (size &gt; 0) &#123; half = size &gt;&gt; 1; mid = first + half; if (arr[mid] &gt;= key) &#123; first = mid + 1; size = size - half - 1; &#125; else &#123; size = half; &#125; &#125; return first;&#125;int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--)&#123; int n,k; cin &gt;&gt; n &gt;&gt; k; for(int i=0;i&lt;n;i++) cin &gt;&gt; a[i]; k = a[k-1]; if(!k) cout &lt;&lt; lower_bound(a,n,k) &lt;&lt; endl; else cout &lt;&lt; upper_bound(a,n,k) &lt;&lt; endl; &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"AOJ 842.西瓜的编译原理","date":"2017-03-27T15:11:14.000Z","path":"/post/AOJ/842.html","text":"题目 点击显/隐题目 西瓜在写编译原理作业中的文法分析器的时候，通常需要检测一个单词是否在给定的单词列表里。为了提高查找和定位的速度，通常都要画出与单词列表所对应的单词查找树，其特点如下： 根节点不包含字母，除根节点外每一个节点都仅包含一个大写英文字母； 从根节点到某一节点，路径上经过的字母依次连起来所构成的字母序列，称为该节点对应的单词。单词列表中的每个词，都是该单词查找树某个节点所对应的单词； 在满足上述条件下，该单词查找树的节点数最少。例：图一的单词列表对应图二的单词查找树 对一个确定的单词列表，请统计对应的单词查找树的节点数（包括根节点） 输入一个单词列表，每一行仅包含一个单词和一个换行/回车符。每个单词仅由大写的英文字符组成，长度不超过63个字符，单词个数不超过5000。 输出仅包含一个整数和一个换行/回车符。该整数为单词列表对应的单词查找树的节点数。 AANASPASASCASCIIBASBASIC 13 题解首先对所有字符串进行 排序 按照要求把可以合并的圈在一起,可以发现,我们要找的就是每一个字符串与前一个不同的字符及其后面所有的字符数量和加上1这一切基于字典序天然的优势(先比较字符再比较大小) 然后计数即可 代码点击显/隐代码西瓜的编译原理代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 5005;string s[maxn];int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int n = 0; while(cin &gt;&gt; s[n++]); sort(s,s+n); int ans = s[0].size(); for(int i=1;i&lt;n;i++)&#123; int sz = s[i].size(); for(int j=0;j&lt;sz;j++)&#123; if(s[i-1][j] != s[i][j])&#123; ans+=sz-j; break; &#125; &#125; &#125; cout &lt;&lt; ans+1 &lt;&lt; endl; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"AOJ 841.最短路径和","date":"2017-03-27T15:08:37.000Z","path":"/post/AOJ/841.html","text":"题目 点击显/隐题目 小黄发明了一个图的游戏, 游戏在一个n个节点的有向有边权的完全图上进行: 游戏一共有n个步骤 在第i步, 小黄从图中移除掉一个节点以及与该节点相连的所有入边和出边(移除后的图仍然是一个完全图) 在每一步小黄移除一个节点之前, 他想知道所有节点对之间的最短路径的总和是多少 输入为小黄游戏之前的图:第一行: n(1&lt;=n&lt;=400), 表示图的节点个数;接下来一共n行为一个n*n的矩阵, 矩阵的每行n个数, 第i行的第j列的数字a(1≤a≤?50000表示从节点i到节点j的边的边权, 其中节点i到节点i自身的边权都是0;最后n行一行一个1到n之间的数, 其中的第i行表示第i步小黄要移除的节点编号. 输出一共一行n个数(一个空格隔开), 分别为第i步移除节点之前的所有节点对的最短路径总和. 40 3 1 16 0 400 12 4 0 11 1 1 04 1 2 3 17 23 404 0 题解很好的一道题,算法是很简单的算法,但是需要有一定的理解 Floyd 是一个很容易被忽视的算法,因为它实在是太简单了只需要三个循环就能完成多源最短路尽管时间复杂度较高,但是多源最短路也没有其他更好的算法了 其本质是动态规划以for(int k=0;k&lt;n;k++) for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) dis[i][j] = min(dis[i][j],dis[i][k] + dis[k][j]); 为例i 和 j 只是为了便利整个图,不属于动态规划的算法部分重点看 k这就是精华所在, k 的意义为,前 k 个点的最短路那么,答案已经出来了,将删点看作加点,按照删除的逆序把点加入到图中,每次都只需要计算已经加入到图中的点的最短路和 在 Floyd 上已经坑过两次了,最简单的反而最容易忽视比赛的时候已经想到了删点变为加点,不过没有细想 k 的意义,最后每加一个点都跑一次 Floyd 果断超时想了只更新新加的点可能影响到的部分,还是基础功不扎实的锅 代码点击显/隐代码最短路径和代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 405;const int INF = 0x3f3f3f;int del[maxn];int dis[maxn][maxn];int ans[maxn];int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int n; while(cin &gt;&gt; n)&#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin &gt;&gt; dis[i][j]; for(int p=0;p&lt;n;p++)&#123; cin &gt;&gt; del[p]; del[p]--; &#125; for(int p=n-1;p&gt;=0;p--)&#123; int k = del[p]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) dis[i][j] = min(dis[i][j],dis[i][k]+dis[k][j]); // cout &lt;&lt; endl; // for(int i = 0;i &lt; n;i++)&#123; // for(int j = 0;j &lt; n;j++) // cout &lt;&lt; dis[i][j] &lt;&lt;\" \"; // cout &lt;&lt; endl; // &#125; // cout &lt;&lt; endl; ans[p] = 0; for(int i=p;i&lt;n;i++) for(int j=p;j&lt;n;j++) ans[p] += dis[del[i]][del[j]]; &#125; for(int i=0;i&lt;n;i++)&#123; if(i) cout &lt;&lt; \" \"; cout &lt;&lt; ans[i]; &#125; cout &lt;&lt; endl; &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"Floyd","slug":"Floyd","permalink":"https://www.oyohyee.com/tags/Floyd/"}]},{"title":"AOJ 840.下一个幸运数","date":"2017-03-27T14:46:20.000Z","path":"/post/AOJ/840.html","text":"题目 点击显/隐题目 数字的每一位只可能是4或者7的称为幸运数，比如说4，7，44，474，7474都是幸运数，而54，40，444467777都不是幸运数。而数字A的下一个幸运数，表示的是大于等于A的最小的幸运数。比如4的下一个幸运数是4，而5的下一个幸运数是7。现在给出一个区间[L, R]，求出区间内每个数的下一个幸运数的和。 一个整数t，表示测试数据的组数(1&lt;=t&lt;=200)。每组测试数据，两个整数L和R，空格隔开(1&lt;=L&lt;=R&lt;=1000000000)。 区间内每个数的下一个幸运数的和 34 43 44 7 4825 题解找到 [l,r] 范围内所有的所有整数的 下一个幸运数很显然,幸运数是非常少的将 4 和 7 看作 0 和 1可以发现数量只有 $ log_2 1000000000 $ 个然后打个表,二分查找 l 和 r 两侧的幸运数,每两个幸运数为一个区间(最两侧端点是 l 和 r)然后计算求和即可不用一个一个加,区间端点相减乘以右端点即可 最后测试的时候,应该对于 l 和 r 都测试下比幸运数小 1 大 1 相等的情况也即最后测试 6 组即可顺便测试下极端值也行(为了保证极端值没问题,打表要打到比最大值大) 代码点击显/隐代码下一个幸运数代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long LL;const int maxn = 5000;LL L[maxn];int pos=0;void dfs(LL t)&#123; if(t &gt;= 7777777777LL) return; L[pos++] = t*10+4; L[pos++] = t*10+7; dfs(t*10+4); dfs(t*10+7);&#125;LL lower_bound(LL *arr,int size, LL key) &#123; int half; int mid; int first = 0; while (size &gt; 0) &#123; half = size &gt;&gt; 1; mid = first + half; if (arr[mid] &lt; key) &#123; first = mid + 1; size = size - half - 1; &#125; else &#123; size = half; &#125; &#125; return first;&#125;int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); dfs(0LL); sort(L,L+pos); /* for(int i=0;i&lt;pos;i++) cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; L[i]&lt;&lt; endl; */ int T; cin &gt;&gt; T; while(T--)&#123; int l,r; cin &gt;&gt; l &gt;&gt; r; LL pos1 = lower_bound(L,pos,l); LL pos2 = lower_bound(L,pos,r); LL ans1 = (L[pos1]-l+1)*L[pos1];//��һ���� LL ans2 = 0; for(int i=pos1;i&lt;pos2;i++) ans2 += (L[i+1] - L[i])*L[i+1]; LL ans3 = (r-L[pos2])*L[pos2]; //cout &lt;&lt;pos1&lt;&lt;\" \"&lt;&lt;pos2&lt;&lt;endl; //cout &lt;&lt; ans1 &lt;&lt; \" \" &lt;&lt; ans2 &lt;&lt; \" \" &lt;&lt; ans3 &lt;&lt; endl; cout &lt;&lt; ans1+ans2+ans3 &lt;&lt; endl; &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"二分","slug":"Division","permalink":"https://www.oyohyee.com/tags/Division/"},{"name":"打表","slug":"List","permalink":"https://www.oyohyee.com/tags/List/"}]},{"title":"AOJ 839.调酒师","date":"2017-03-27T14:44:22.000Z","path":"/post/AOJ/839.html","text":"题目 点击显/隐题目 作为调酒师的西瓜，在生日当天，请了N位好朋友来家中作客，当然免不了大展身手。西瓜在超市买了A瓶酒，每瓶酒有B毫升，买了C个柠檬，把每一个柠檬切成D片，还买了E克盐。西瓜要调的酒，每一杯需要F毫升的原味酒、一片柠檬以及G克盐。 西瓜希望每个朋友分到同样杯数的酒，同时西瓜又希望每个人分到的酒尽可能多。问每个朋友能分到几杯调好的酒。 一个整数t，表示测试数据组数(1&lt;=t&lt;=100)对于每一组数据，共一行，有8个整数，逗号隔开，分别为N,A,B,C,D,E,F,G，其中这7个整数都在[0, 1000]内，保证N不为0。 每一组测试数据，输出一个整数，表示每个朋友分到的酒的杯数。 22 4 7 3 4 10 2 11 1000 1000 1000 1000 1000 1 1 51000 题解首先根据每个原料的要求求出来最少能做出来多少杯酒然后用杯数除以人数得到答案 代码点击显/隐代码调酒师代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int a[8];int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--)&#123; for(int i=0;i&lt;8;i++) cin &gt;&gt; a[i]; int ans = min(min(a[1]*a[2]/a[6],a[3]*a[4]),a[5]/a[7]); //cout &lt;&lt; a[1]*a[2]/a[6] &lt;&lt; \" \" &lt;&lt; a[3]*a[4] &lt;&lt; \" \" &lt;&lt; a[5]/a[7] &lt;&lt; endl; cout &lt;&lt; ans/a[0] &lt;&lt; endl; &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"Hexo 自建标签渲染代码段的 Bug 解决方案","date":"2017-03-24T15:56:07.000Z","path":"/post/Note/hexo_tag.html","text":"解决自建标签渲染问题 Hexo 有一个非常方便的功能 - 自建标签 其使用如下{% raw %} 123 {% endraw %}这样 123 会以 HTML 的形式插入到网页里,而非 Markdown 许多主题也都加入了许多有用的 tag比如 {% cq %} blah blah blah {% endcq %} 而这个功能存在一个问题,由于渲染顺序的问题,导致如果你在自建的标签里使用 ` ` ` 的代码段,就会发现代码段部分被渲染成了 undefined 提了 Issue 后,有了如下解决方案{ % raw % }无法渲染 ``` 代码段 #2400 也即只需在 scripts 目录里新建一个 js 文件,贴入以下内容即可 点击显/隐 /* @haohuawu 修复 Nunjucks 的 tag 里写 ```代码块```，最终都会渲染成 undefined 的问题 https://github.com/hexojs/hexo/issues/2400*/const rEscapeContent = /&lt;escape(?:[^&gt;]*)&gt;([\\s\\S]*?)&lt;\\/escape&gt;/g;const placeholder = '\\uFFFD';const rPlaceholder = /(?:&lt;|&amp;lt;)\\!--\\uFFFD(\\d+)--(?:&gt;|&amp;gt;)/g;const cache = [];function escapeContent(str) &#123; return '&lt;!--' + placeholder + (cache.push(str) - 1) + '--&gt;';&#125;hexo.extend.filter.register('before_post_render', function(data) &#123; data.content = data.content.replace(rEscapeContent, function(match, content) &#123; return escapeContent(content); &#125;); return data;&#125;);hexo.extend.filter.register('after_post_render', function(data) &#123; data.content = data.content.replace(rPlaceholder, function() &#123; return cache[arguments[1]]; &#125;); return data;&#125;);","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.oyohyee.com/tags/Hexo/"}]},{"title":"安徽大学第九届大学生程序设计竞赛 网络预选赛","date":"2017-03-19T12:53:00.000Z","path":"/post/Project/ACM2017_03_19.html","text":"编号 题目 题解 A AOJ.831.成功人士 题解 B AOJ.832.迭代归一 题解 C AOJ.833.置换的魔术 题解 D AOJ.834.买买买 题解 E AOJ.835.FJ的旅行 题解 F AOJ.836.周末大法好 题解 G AOJ.837.交换大法好 题解 H AOJ.838.今年多少岁 题解","tags":[]},{"title":"AOJ 838.今年多少岁","date":"2017-03-19T12:49:32.000Z","path":"/post/AOJ/838.html","text":"题目 点击显/隐题目 小明出生于1937年7月7日，问对于给定的日期，小明几周岁了，不足一周年的部分可以忽略。 注意：1938年7月6日，小明0周岁，1938年7月7日小明1周岁，同理1939年7月6日，小明1周岁，1939年7月7日，小明2周岁。 一个整数t(1&lt;=t&lt;=100)，表示数据组数对于每组测试数据，三个整数，逗号隔开，分别表示给定日期的年、月、日。给定的日期保证合法， 而且一定是小明出生后的日期，且小明的岁数保证在100以内。 对于每一组数据，输出一个整数，表示小明的周岁数。 21938 7 61938 7 7 01 题解先计算去年到出生年份之间的年数,这一部分是无论有没有过今年生日都应该算上的然后再判断今年有没有过生日,先比较月份,月份一样看日期 代码点击显/隐代码今年多少岁代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--)&#123; int y,m,d; cin &gt;&gt; y &gt;&gt; m &gt;&gt; d; int ans = y - 1937 - 1; if(m &gt; 7 || (m == 7 &amp;&amp; d &gt;= 7)) ans++; cout &lt;&lt; ans &lt;&lt; endl; &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"AOJ 837.交换大法好","date":"2017-03-19T12:41:40.000Z","path":"/post/AOJ/837.html","text":"题目 点击显/隐题目 有一天，天上掉馅饼了。不过不是直接掉馅饼，是告诉你你将要得到的馅饼的数量a。聪明的你得到了一种魔法，可以在整数a中交换任意两个相邻的数字。而这种魔法，你最多只能使用k次。你使用魔法操作a，得到的最大的结果就是你最终获得的馅饼数量。 你最多可以获得的馅饼数量是多少呢？ 第一行，一个数字n(1&lt;=n&lt;=60)。代表测试数据数量。接下来n行，每行两个整数a和k（1&lt;=a&lt;=1,000,000,000; 0&lt;=k&lt;=100)。 输出n行，每行一个整数，代表你最多使用魔法k次，可以得到的最大的数字。 21990 11034 2 91903104 题解没有什么好的思路,暴力搜索下最多 10 位数,能交换 100 次而且只能交换相邻的,数据量并不是很大 首先写好交换某相邻两位的函数,让代码更简洁同时防止思路混乱 然后依次交换相邻的两位,如果新数没有出现过,就交换后插入到 vector 中待用(一方面是如果该数字已经查找过了,就不再查找了;另一方面是为了筛选出最大值) 然后 sort 后输出最大值即可 需要特别注意的是,虽然时间复杂度不大,但是查询和插入操作是一直在进行的,因此这里其实是主要耗费时间的地方,应该使用 lower_bound() 来 二分查找插入 ,这样能始终保证 vector 有序,节省插入和查找的时间 PS：用贪心更短,来自 Robin 的代码 点击显/隐来自dalao的代码来自dalao的代码#include&lt;bits/stdc++.h&gt;using namespace std;char s[15];int a[15], b[15], f[15];void swap(int *a, int *b) &#123; int temp = *a; *a = *b; *b = temp;&#125;int main() &#123; int T, k; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; s &gt;&gt; k; int len = strlen(s); if (len == 1) &#123; cout &lt;&lt; s &lt;&lt; endl; continue; &#125; for (int i = 0; i &lt; len; ++i) &#123; a[i] = s[i] - '0'; b[i] = a[i]; &#125; int maxnum = -1, maxid; for (int i = 0; i &lt; len; ++i) &#123; if (k &lt;= 0) break; maxnum = b[i]; maxid = i; for (int j = i; j &lt;= i + k &amp;&amp; j &lt; len; ++j) &#123; if (b[j] &gt; maxnum) &#123; maxnum = b[j]; maxid = j; &#125; &#125; k -= maxid - i; for (int x = maxid; x &gt; i; --x) swap(&amp;b[x], &amp;b[x-1]); &#125; for (int i = 0; i &lt; len; ++i) cout &lt;&lt; b[i]; cout &lt;&lt; endl; &#125; return 0;&#125; 代码点击显/隐代码交换大法好代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn = 12;struct Node&#123; LL n; int k; Node(LL a,int b):n(a),k(b)&#123;&#125;&#125;;LL POW(LL a,int n) &#123; LL t; if(n == 0) return 1; if(n == 1) return a; t = POW(a,n / 2); t = t * t; if((n &amp; 1) == 1)t = t * a; return t;&#125;LL swap(LL n,int a,int b)&#123; LL t1 = (n/POW(10,a-1)) % 10LL; LL t2 = (n/POW(10,b-1)) % 10LL; n = n - t1 * POW(10,a-1) - t2 * POW(10,b-1) + t1 * POW(10,b-1) + t2 * POW(10,a-1); return n;&#125;queue&lt;Node&gt; Q;vector&lt;LL&gt; v;LL bfs(LL n,int k)&#123; while(!Q.empty())Q.pop(); v.clear(); int size = 0; LL temp = n; while(temp)&#123; temp/=10; size++; &#125; Q.push(Node(n,0)); v.push_back(n); while(!Q.empty())&#123; LL tn = Q.front().n; int tk = Q.front().k; Q.pop(); if(tk &lt; k)&#123; for(int i=1;i&lt;size;i++)&#123; LL tt = swap(tn,i,i+1); if(lower_bound(v.begin(),v.end(),tt) == v.end())&#123; v.insert(lower_bound(v.begin(),v.end(),tt),tt); Q.push(Node(tt,tk+1)); &#125; &#125; &#125; &#125; sort(v.begin(),v.end()); for(size_t i=0;i&lt;v.size();i++) cout&lt;&lt;v[i]&lt;&lt;\" \"; cout&lt;&lt;endl; return v[v.size()-1];&#125;int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--)&#123; LL n; int k; cin &gt;&gt; n &gt;&gt; k; cout &lt;&lt; bfs(n,k) &lt;&lt; endl; &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"二分","slug":"Division","permalink":"https://www.oyohyee.com/tags/Division/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"}]},{"title":"AOJ 836.周末大法好","date":"2017-03-19T12:36:25.000Z","path":"/post/AOJ/836.html","text":"题目 点击显/隐题目 在火星上，每年有x天。惊奇的是，和地球上一样，火星上也是有星期的概念的，连续的5天工作日，然后连续的2天周末。他们只有周末放假。现在你的任务是，确定火星上每年可能的最少放假的天数和最多放假的天数。 第一行，一个数字n。代表测试数据数量。接下来n行，每行一个整数x (1&lt;=x&lt;=1,000,000),代表火星每年有x天。 输出n行，每行两个整数。代表火星上每年可能的最少放假的天数和最多放假的天数。 2142 4 40 2 题解纯模拟即可想要假期最多,这一年就从周六开始想要假期最少,这一年就从周一开始 先除以 7 算出一定要过的整星期然后乘上 2 这是必然要过的假期 在对 7 取余数对于最小值,多于 5 的话,就能过上下周的假期了对于最大值, 2 天以内,多一天赚一天 代码点击显/隐代码周末大法好代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--)&#123; int n; cin &gt;&gt; n; int mod = n % 7; int Min = 2 * (n / 7); if(mod &gt; 5) Min += mod - 5; int Max = 2 * (n / 7) + min(mod,2); cout &lt;&lt; Min &lt;&lt; \" \" &lt;&lt; Max &lt;&lt; endl; &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"AOJ 831.成功人士","date":"2017-03-19T12:13:19.000Z","path":"/post/AOJ/831.html","text":"题目 点击显/隐题目 学校里共有n个学生，m门课，如果某个学生在某门课中拿到了最高分（可以是并列），则这个学生是成功人士。现在给出n个学生的m门课的成绩，问有多少个成功人士。 第一行，一个整数t，表示测试数据组数，(1&lt;=t&lt;=100)对于每组测试数据，第一行两个整数，n和m，（1&lt;=n,m&lt;=50）接下来n行，每一行有m个数字（中间不分隔），表示这个学生每门课的成绩，其中成绩为1-9的整数。 每组测试数据，一个整数，表示有多少个成功人士。 23 32232321123 5917281182811111 23 题解取出每个人每门课的成绩,排序后找出最大的几个,然后将他们的编号插入到 set 里最后计算 set 的元素数量即可 代码点击显/隐代码成功人士代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 55;char score[maxn][maxn];set&lt;int&gt; ans;struct Node&#123; int n; int w; Node(int a=-1,int b=-1):n(a),w(b)&#123;&#125; bool operator &lt; (const Node &amp;rhs)const&#123; return w &gt; rhs.w; &#125;&#125;node[maxn];int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--)&#123; ans.clear(); int n,m; cin &gt;&gt; n &gt;&gt; m; for(int i=0;i&lt;n;i++) cin &gt;&gt; score[i]; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++) node[j] = Node(j,score[j][i]); sort(node,node+n); int t = node[0].w; for(int j=0;j&lt;n;j++)&#123; if(t == node[j].w) ans.insert(node[j].n); else break; &#125; &#125; cout &lt;&lt; ans.size() &lt;&lt; endl; &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"set","slug":"set","permalink":"https://www.oyohyee.com/tags/set/"}]},{"title":"AOJ 835.FJ的旅行","date":"2017-03-19T12:10:00.000Z","path":"/post/AOJ/835.html","text":"题目 点击显/隐题目 每当西瓜的朋友来西瓜家看他，西瓜总是喜欢带他们逛自己的豪宅。西瓜的豪宅有N幢楼（1&lt;=N&lt;=1000），用1到N的整数编号。1号楼是西瓜豪宅的大门，N号楼是西瓜的储藏室。西瓜的豪宅里总共有M条道路（1&lt;=M&lt;=10000）。每条道路连接两栋不同的楼房，道路的长度不超过35000。为了最好地炫耀他的豪宅，西瓜准备从大门出发，经过一些楼房到达储藏室，再经过一些楼房回到自己的大门。他要求他的路径越短越好，但是不能经过任意一条道路多于一次。请你计算这样的一条最短路径。西瓜保证这样的路径是存在的。 第一行：N和M第2..M+1行：每行三个整数表示一条道路（起点，终点，长度） 一个整数，表示最短路径长度 4 51 2 12 3 13 4 11 3 22 4 2 6 题解本次最难的一题要求是对于一个无向图,在每条路只走一次的情况下,从起点到终点再返回起点的最短路看到最短路,很容易就想到 BFS ,由于每条路有一定的权值,因此需要用 Dijkstra 很显然的思路,而且能通过样例但是如果仔细分析样例就能发现有很大的问题存在 可以很容易看出来,去的时候最短路是 3回来的时候最短路也是 3 但是,如果单纯只是删掉第一次最短路途径的边去跑第二次最短路,有可能就会出现问题比如,如果第一次最短路走的是 1-2-3-4 这条路,那么第二次时压根就无法返回起点 也就是说,存在有多个最短路有重边的情况这个问题导致了单纯的搜是不行的 图论问题,不会不如试下网络流 套用网络流的概念来分析下试试 最短路 = 最小费用 每个边一次 = 流量为1 看上去好像没有问题,再深入分析下最小费用的是 最小费用最大流它求的是在所有最大流中费用最小的 那么我们先要限定流量由于每个边只能走一次,边的流量显然是 1如何体现去回两次呢?可以在建一个源点,这个源点往外的流量为 2 ,将它连在起点或终点上,然后跑它到另一个点的最小费用最大流 由于其他点的流量都是 1 ,这个节点往外的流量是 2 ,因此只要有解,最大流必然为 2此时建的图已经和题意的图存在一些差别了可以看作从起点走两条完全不同的路(每条路的流量为 1 )到终点(汇点流量为 2 ) 建图完毕,套用模板 匡斌的模板里点的编号是 0~n-1因此加边的时候要把 u 和 v 分别减去 1初始化的时候记得加上汇点 输出最小的费用即可 代码点击显/隐代码FJ的旅行代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1005; const int MAXM = 10005; const int INF = 0x3f3f3f3f; struct Edge &#123; int to,next,cap,flow,cost; &#125;edge[MAXM]; int head[MAXN],tol; int pre[MAXN],dis[MAXN]; bool vis[MAXN]; int N;//节点总个数，节点编号从0~N-1 void init(int n)&#123; N = n; tol = 0; memset(head,-1,sizeof(head)); &#125; void addedge(int u,int v,int cap,int cost) &#123; edge[tol].to = v; edge[tol].cap = cap; edge[tol].cost = cost; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = 0; edge[tol].cost = -cost; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++; &#125; bool spfa(int s,int t) &#123; queue&lt;int&gt;q; for(int i = 0;i &lt; N;i++) &#123; dis[i] = INF; vis[i] = false; pre[i] = -1; &#125; dis[s] = 0; vis[s] = true; q.push(s); while(!q.empty())&#123; int u = q.front(); q.pop(); vis[u] = false; for(int i = head[u]; i != -1;i = edge[i].next)&#123; int v = edge[i].to; if(edge[i].cap &gt; edge[i].flow &amp;&amp; dis[v] &gt; dis[u] + edge[i].cost )&#123; dis[v] = dis[u] + edge[i].cost; pre[v] = i; if(!vis[v])&#123; vis[v] = true; q.push(v); &#125; &#125; &#125; &#125; if(pre[t] == -1)return false; else return true; &#125; //返回的是最大流，cost存的是最小费用 int minCostMaxflow(int s,int t,int &amp;cost) &#123; int flow = 0; cost = 0; while(spfa(s,t))&#123; int Min = INF; for(int i = pre[t];i != -1;i = pre[edge[i^1].to])&#123; if(Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; &#125; for(int i = pre[t];i != -1;i = pre[edge[i^1].to])&#123; edge[i].flow += Min; edge[i^1].flow -= Min; cost += edge[i].cost * Min; &#125; flow += Min; &#125; return flow; &#125; int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false);trueint n, m;truewhile(cin&gt;&gt;n&gt;&gt;m)&#123;truetrueinit(n+1);truetruefor(int i=0;i&lt;m;i++)&#123; int u,v,cost;truetruetruecin &gt;&gt; u &gt;&gt; v &gt;&gt; cost;truetruetrueaddedge(u-1,v-1,1,cost);truetruetrueaddedge(v-1,u-1,1,cost);truetrue&#125;truetrueaddedge(n-1,n,2,0);truetrueint ans=0;truetrueminCostMaxflow(0,n,ans);truetruecout &lt;&lt; ans &lt;&lt; endl;true&#125;true#ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"网络流","slug":"Network-Flow","permalink":"https://www.oyohyee.com/tags/Network-Flow/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"}]},{"title":"AOJ 834.买买买","date":"2017-03-19T11:29:29.000Z","path":"/post/AOJ/834.html","text":"题目 点击显/隐题目 一天Alice打开了她日常玩的游戏，发现她里面还有n个游戏币，她想把这些游戏币花光。现在可以买的一共三种道具，分别是房子（每一个价值1234567个游戏币），车子（每一个价值123456个游戏币），电脑（每一个价值1234个游戏币）。现在她想知道，通过买这三种道具是否可以把n个游戏币全部花光。 第一行，一个数字t(1&lt;=t&lt;=100)。代表测试数据数量。对于每一组测试数据，一个整数n（1&lt;=n&lt;=1000000000)，代表现在的游戏币。 输出n行，每行输出”YES”或者”NO”，表示她可以或者不可以把游戏币全部花光。 2135925717851817 YESNO 题解由于最大的值非常大,如果直接 dfs 会非常慢而且打表的文件会非常大 而看 1234567 和 1000000000 其实差别不是很大除一下发现最多也就能买 800 多套房子而即使全部买成汽车也就能买 8000 多辆乘起来的数据量只有 10e6 完全是可以遍历的也就是说,只需要枚举房子和车的数量,然后判断剩下的钱能不能整除电脑 这样做不超时的原因是房子和车的价格都非常大,可以将许多数据“跨越”掉如果这数都很小的话,就没有办法了 代码点击显/隐代码买买买代码备份//*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;int price[] = &#123;1234567,123456,1234&#125;;int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--)&#123; LL n; cin &gt;&gt; n; bool flag = false; int max_fz = n / price[0]; for(int i=0;i&lt;=max_fz;i++)&#123; int max_cz = (n-i*price[0]) / price[1]; for(int j=0;j&lt;=max_cz;j++) if(!((n-i*price[0]-j*price[1]) % price[2]))&#123; flag = true; break; &#125; &#125; cout &lt;&lt; (flag?\"YES\":\"NO\") &lt;&lt; endl; &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"枚举","slug":"enum","permalink":"https://www.oyohyee.com/tags/enum/"}]},{"title":"AOJ 833.置换的魔术","date":"2017-03-19T11:14:26.000Z","path":"/post/AOJ/833.html","text":"题目 点击显/隐题目 有n个正整数，其中1到n的正整数出现且只出现一次的序列，称为1-n的一个排列。如1，2，3和3，1，2都是1-3的排列，但是1，3，3不是1-3的排列。如今，给n个数，问最少修改几个数，可以使得序列成为1-n的一个排列。 一个整数t，表示测试数据的组数，(1&lt;=t&lt;=210)对于每一组测试数据，第一行为一个整数n，（1 &lt;= n &lt;= 500）第二行有n个整数a1,a2,……an，空格分隔，(ai为任意的32位有符号正整数)。 保证多组数据中的n的和不超过100000。 每组测试数据，输出一个整数，表示最少修改几个数。 251 3 2 4 561 1 1 1 1 1 05 题解思路应该很容易,不过数据比较坑用一个数组来记录 1-n 的数字哪个已经读入过了没有读入的就是要交换的 这道题数据量和题目给的不一样开大一点能解决 另外可以使用 set 来保存只要是 1-n 的数字,直接扔到 set 里最后 n-s.size() 即可 数字存在负数,因此读入的判断两侧都要判断 代码点击显/隐代码置换的魔术代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;set&gt;using namespace std;int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int T; scanf(\"%d\",&amp;T); while(T--)&#123; set&lt;int&gt; s; s.clear(); int n; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)&#123; int t; scanf(\"%d\",&amp;t); if(t &lt;= n &amp;&amp; t &gt;= 1) s.insert(t); &#125; printf(\"%d\\n\",n-s.size()); &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"AOJ 832.迭代归一","date":"2017-03-19T11:03:20.000Z","path":"/post/AOJ/832.html","text":"题目 点击显/隐题目 我们把一个正整数的每一位上的数字加起来，得到新的数字，我们把这样的一次操作称为一次迭代变换。直到这个数字只有一位数。如，9876经过一次变换成为9+8+7+6=30，经过第二次变换成为3+0=3，结束。那么9876就经过了两次迭代变换。如今给一个正整数，问需要迭代变换多少次后会停止。 一个整数t，表示测试数据组数(1&lt;=t&lt;=100)。对于每组测试数据，只有一行，表示一个正整数，正整数最多有100000位。 输出若干行，每行对应每组数据需要迭代变换的次数 321099999999 012 题解就是 数根 这一题加上计数要注意的是 正整数最多有100000位因此应该先用字符串读入,然后先加一次,然后再往下迭代 因此就有了第一个坑点第一次迭代的计数问题如果输入是 1显然第一次迭代只是将字符串转换为整数,不应该算上去而如果输入是 11那么第一次迭代应该算成一次迭代 因此转换时要先看是不是只有一位然后就牵扯到 前导0 的问题了如果输入为 00001 或者 0000 要能够正确的识别它是什么(具体解决办法可以看一下下面的代码) 代码点击显/隐代码迭代归一代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std; const int maxn = 100005;char s[100005];int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int T; scanf(\"%d\",&amp;T); while(T--)&#123; int ans = 0; scanf(\"%s\",s); int size = strlen(s); int n = 0; bool flag = false; for(int i = 0;i &lt; size;i++)&#123; n += s[i]-'0'; if(flag) ans=1; if(!flag &amp;&amp; s[i] - '0' &gt; 0) flag = true; &#125; while(n&gt;=10)&#123; ans++; int t = 0; while(n)&#123; t += n%10; n /= 10; &#125; n = t; &#125; printf(\"%d\\n\",ans); &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"安徽大学第九届大学生程序设计竞赛热身赛","date":"2017-03-18T16:25:18.000Z","path":"/post/Project/ACM2017_03_18.html","text":"题解 部分题目之前写过,就没重写(我是写题解的时候才发现……)所以代码风格可能差异较大 编号 题目 题解 A AOJ.480.分数序列求和 题解 B AOJ.483.求素数 题解 C AOJ.775.迷宫问题 题解 D AOJ.481.猴子摘桃 题解 E AOJ.776.马的走法 题解 F AOJ.482.二分法求方程的根 题解 G AOJ.781.素数环 题解 H AOJ.763.过河卒 题解 I AOJ.754.数根 题解 J AOJ.759.会绕圈的数 题解","tags":[]},{"title":"AOJ 754.数根","date":"2017-03-18T12:06:14.000Z","path":"/post/AOJ/754.html","text":"题目 点击显/隐题目 计算该整数的各位数字之和，如果结果值是单个数字的数，那么这个数就是所求数根；如果结果值是由两位数或两位以上的数字组成的数，则继续计算各位数字的和，直到结果值只有一位数字为止。24， 2+4=6, 则根是639， 3+9=12，1+2=3，根是3 输入包括多组数据，每组测试数据包括一个正整数，并且占一行，输入数据为0时，表示输入结束。 对于每组测试数据，给出对应输出，并且每组输出占一行 24390 63 题解模拟就行,把每一位都取出来然后加起来,如果不是一位的数就继续循环注意貌似 cin cout 会出错,换用 scanf 和 printf 吧 代码点击显/隐代码数根代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std; int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int n; while(scanf(\"%d\",&amp;n)!=EOF)&#123; if(n==0) break; while(n&gt;=10)&#123; int t = 0; while(n)&#123; t += n%10; n /= 10; &#125; n = t; &#125; printf(\"%d\\n\",n); &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"AOJ 781.素数环","date":"2017-03-18T11:46:51.000Z","path":"/post/AOJ/781.html","text":"题目 点击显/隐题目 把1-20这20个数摆成一个环，要求相邻的两个数的和是一个素数。编写程序，对给定的第一个数m,打印出满足条件的一种排列顺序。如果有多组解，输出字典序最小的一组。 包括多组测试数据，每组测试数据占一行，并且只有一个整数m，(0&lt;=m&lt;=20),当m=0时，表示输入结束。 对每组测试数据输出一行结果，结果为第一个整数为m的一种排列序列，序列中共有20个整数，各数之间用空格分隔。如果有多组解，输出字典序最小的一组。 150 1 2 3 4 7 6 5 8 9 10 13 16 15 14 17 20 11 12 19 185 2 1 4 3 8 9 10 7 6 11 20 17 12 19 18 13 16 15 14 题解相邻两个数(包括第一个数和最后一个数)的和为素数因此先筛法求素数打个素数表方便后面查询 然后 DFS 暴力搜索所有情况(按照字典序顺序)找到所有都满足的就输出出来即可 每一行最后一个数后面没有空格需要注意下 只有 20 组输入,可以打表 这道题最早数据没有考虑到首位两个数,所以没人 AC 中午找老师改了下数据 代码点击显/隐代码素数环代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.com かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std; const int maxn = 45; int prime[maxn] = &#123;0&#125;,num_prime = 0;bool isNotPrime[maxn] = &#123;1,1&#125;; void Prime() &#123; for(long i = 2;i &lt; maxn;i++) &#123; if(!isNotPrime[i])prime[num_prime++] = i; for(int j = 0;j &lt; num_prime&amp;&amp;i*prime[j] &lt; maxn;j++) &#123; isNotPrime[i*prime[j]] = true; if(!(i%prime[j]))break; &#125; &#125;&#125; bool vis[maxn / 2];int List[maxn / 2];int pos;bool dfs()&#123; if(pos == 20) &#123; if(isNotPrime[List[19] + List[0]]) return false; bool first = true; for(int i = 0;i &lt; 20;i++) &#123; if(!first) printf(\" \"); first = false; printf(\"%d\",List[i]); &#125; return true; &#125; for(int i = 1;i &lt;= 20;i++) &#123; if(vis[i]) continue; if(isNotPrime[List[pos - 1] + i]) continue; List[pos++] = i; vis[i] = true; if(dfs()) return true; vis[i] = false; pos--; &#125; return false;&#125; bool Do() &#123; int n; scanf(\"%d\",&amp;n); if(n == 0) return false; memset(vis,false,sizeof(vis)); pos = 0; List[pos++] = n; vis[n] = true; dfs(); printf(\"\\n\"); return true;&#125; int main() &#123; Prime(); while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"质数","slug":"Prime","permalink":"https://www.oyohyee.com/tags/Prime/"},{"name":"DFS","slug":"DFS","permalink":"https://www.oyohyee.com/tags/DFS/"},{"name":"打表","slug":"List","permalink":"https://www.oyohyee.com/tags/List/"},{"name":"暴力","slug":"Violence","permalink":"https://www.oyohyee.com/tags/Violence/"}]},{"title":"AOJ 482.二分法求方程的根","date":"2017-03-18T11:43:05.000Z","path":"/post/AOJ/482.html","text":"题目 点击显/隐题目 用二分法求方程f(x)=ax4+bx3+cx2+dx+e=0 在 (x1,x2) 之内的根本题保证f(x1)*f(x2)&lt;=0且(x1,x2)内只有一个根 行1：5个空格分隔的整数a,b,c,d,e，a,b,c,d,e∈[-9,9]行2：2个空格分隔的整数x1,x2，x1,x2∈[-10,10]，x1&lt;x2 行1：一个浮点数，代表根，精确到小数点后10位 0 2 -4 3 -6-10 10 2.0000000000 题解由于最后要输出 10 位,因此 eps 至少要是 1e-11然后就是模拟数学运算即可 为了防止错误,建议全部使用 double数学函数部分可以写成一个函数或者宏定义,简化代码 没什么要注意的细节,知道数学计算思路就行 代码点击显/隐代码二分法求方程的根代码备份//*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;const double eps = 1e-12;#define f(x) a*x*x*x*x + b*x*x*x+c*x*x+d*x+ebool equal(double a,double b) &#123; return fabs(a - b) &lt; eps;&#125;int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); double a,b,c,d,e,x1,x2; while(cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; x1 &gt;&gt; x2)&#123; double x = (x1+x2)/2; double y1 = f(x1); double y2 = f(x2); //cout &lt;&lt; \"y1 = \"&lt;&lt;y1&lt;&lt;\" y2 = \"&lt;&lt;y2&lt;&lt;endl; while(1)&#123; x = (x1+x2)/2; double y = f(x); //cout &lt;&lt; \"x = \"&lt;&lt;x&lt;&lt;\" y = \"&lt;&lt;y&lt;&lt;endl; getchar(); if(equal(0.0,y)) break; if(y*y1 &lt; 0) x2 = x; else x1 = x; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; x &lt;&lt; endl; &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"double","slug":"double","permalink":"https://www.oyohyee.com/tags/double/"}]},{"title":"AOJ 481.猴子摘桃","date":"2017-03-18T11:40:57.000Z","path":"/post/AOJ/481.html","text":"题目 点击显/隐题目 猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第n天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。 行1：一个整数n，n∈[2,20] 行1：一个整数，代表第一天桃子的总数 10 1534 题解小学数学题,不用考虑高精度计算,单纯 int 就足够了 代码点击显/隐代码猴子摘桃代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int n; while(cin&gt;&gt;n)&#123; int ans = 1; for(int i=0;i&lt;n-1;i++)&#123; ans += 1; ans *= 2; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"AOJ 483.求素数","date":"2017-03-18T11:32:42.000Z","path":"/post/AOJ/483.html","text":"题目 点击显/隐题目 用筛选法求(1,n]之内的全部素数 行1：一个整数n，n∈[2,100000] 每行输出一个素数，由小到大排列 20 235711131719 题解算法模板题 筛法求素数 直接套用模板即可 代码点击显/隐代码求素数代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 100005;bool is_prime[maxn+1];int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(0); int n; cin &gt;&gt; n; int m=sqrt(n+0.5); memset(is_prime,true,sizeof(is_prime)); for(int i=2;i&lt;=m;i++)&#123; if(is_prime[i])&#123; for(int j=i*i;j&lt;=n;j+=i)&#123; is_prime[j]=false; &#125; &#125; &#125; for(int i=2;i&lt;=n;i++)&#123; if(is_prime[i]==true)&#123; cout&lt;&lt;i&lt;&lt;endl; &#125; &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"质数","slug":"Prime","permalink":"https://www.oyohyee.com/tags/Prime/"}]},{"title":"AOJ 480.分数序列求和","date":"2017-03-18T11:19:24.000Z","path":"/post/AOJ/480.html","text":"题目 点击显/隐题目 有一个分数序列:2/1,3/2,5/3,8/5……求出这个数列的前n项之和. 行1：一个整数n，n∈[1,40] 行1：累加和，精确到小数点后6位 20 32.660261 题解最后只需要保留6位小数,因此如果使用double即使运算40次误差也不会很大因此可以直接用 double 存储每个加数,然后计算和 找到规律 新的分数的分子是上一个分子分母和,分母是上一个分子 直接模拟跑一下就行 代码点击显/隐代码分数序列求和代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int n; cin &gt;&gt; n; double a=1.0,b=2.0; double ans=0; for(int i=0;i&lt;n;i++)&#123; ans+=b/a; b = a + b; a = b - a; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; ans &lt;&lt; endl; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"double","slug":"double","permalink":"https://www.oyohyee.com/tags/double/"}]},{"title":"服务器 SQL 数据库还原","date":"2017-03-17T04:19:01.000Z","path":"/post/Note/SQL_Restore.html","text":"解决了两个问题： 未正常卸载 SQL 2005 的情况下重装 SQL 提示 “工作站组件、联机丛书和开发工具安装失败“ 在只有 MDF 和 LDF 文件情况下还原数据库 客服为了修自己的软件,把另两个公司软件的数据库给搞坏了服务器上装有 SQL 2000 和 SQL 2005其中,SQL 2000 上装的是网中网公司的软件,SQL 2005 则装的是世格和浙科公司的软件其中损坏的就是 SQL 2005 首先进入服务器检查文件,可以发现虽然 SQL 2005 的程序都没了,但是数据库还在因此只要重新安装上数据库文件,还是能够恢复的 那么就把还存在的数据库文件给复制出来就行直接运行 SQL 2005 的安装程序,设置成新的实例名,重新安装好理论上就能解决 到了最后一步,提示安装包出错,安装组件失败这就非常尴尬了,由于本来的 SQL 2005 不是正常卸载的,所以不知道哪里出了问题 理论上要解决这个只需要彻底卸载 2005 就行,但是 2005 文件装的很乱,如果想卸载干净还是挺麻烦的(需要自己去清注册表表)并且服务器上还有 SQL 2000 ,如果不小心有可能再把 2000 弄坏因此应该选择一个更为稳妥的解决方案 进入到安装光盘,找到 ./Tools/Setup/SqlRun_Tools.msi运行,选择卸载卸载完成后再运行一次,选上要安装的组件即可 然后就是重新导入数据库了如果有备份的话,直接选择好备份文件然后 还原 就行如果没有备份,只有 mdf 和 ldf 文件的话,可以选择 附加数据库 ,或者运行下面的 查询代码 下面是将 File.mdf 和 File_log.ldf 还原到 NewFile 数据库的查询代码先把文件拷贝到 SQL 的数据库文件夹里,然后把下面的路径改成你的文件夹路径USE master;GOCREATE DATABASE NewFileON (FILENAME = 'C:\\Program Files\\Microsoft SQL Server\\90\\MSSQL\\DATA\\File.mdf'),(FILENAME = 'C:\\Program Files\\Microsoft SQL Server\\90\\MSSQL\\DATA\\File_log.ldf')FOR ATTACH;GO 以上,就能还原数据库了","tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.oyohyee.com/tags/SQL/"},{"name":"数据库","slug":"Database","permalink":"https://www.oyohyee.com/tags/Database/"}]},{"title":"学习安卓开发","date":"2017-03-11T15:22:21.000Z","path":"/post/Note/LearnAndroid.html","text":"安卓又是一个大坑 IDE的选择安卓开发有两个 IDE 可供选择 eclipse Android Studio 虽然 eclipse 是 Java 的王者,但是自然是专为 Android 开发准备的 Android Studio 更适合我们 首先,Android的开发需要安装 Android SDK ,因此需要在安装 IDE 的同时顺便勾选上 Android SDK 运行第一个项目安装完成后,就可以开始自己的第一个项目了正常的新建等步骤然后可以什么都不管直接跑(Hello World)就会发现并不能直接编译 因为 Android 的软件自然是要在 Android 设备上跑的,直接在 Windows 显然跑不起来因此还需要 Android 虚拟机在 SDK Manage 里确保已经有个基础的 SDK (记得看下另一个选项卡的 SDK tool)然后在 AVD Manage 里新建一个设备这里就是管理你的安卓模拟器的地方,配置好(选择不同版本的系统需要下载对应版本的包)最后 Sync Project with Gradle Files 即可这时再点击运行就会启动安卓模拟器并且自动装上你的软件了 Grable通俗来说,Grable 就是一个帮你完成写完整体架构后的编译工作的工具不管你要针对不同的幸好编译多少的版本,也不管你需要依赖多少文件,全部交给它搞定即可 Gradle的配置包含以下方面 构建变量构建系统可以根据不同的配置为同一个项目生成多个APK。当你想建立不同版本的应用程序，而不必为每个人单独的项目，这是很有用的 依赖关系构建系统管理项目的依赖，并从本地文件系统和远程存储库支持的依赖。这可以防止你不必搜索，下载和复制二进制包为你的依赖到你的项目目录。 清单条目构建系统使您可以指定的值在生成配置清单文件中的某些元素。这些新的值将覆盖在manifest文件中的现有值。如果你想生成多个的APK为您的项目中，他们每个人都有不同的包名，最小的SDK版本，或目标SDK版本，这是很有用的。 签名构建系统使您可以指定生成配置签名设置，它可以在生成过程中签署您的APK。 Andriod Studio 的 Android 目录解释参考文章：1.Android Studio目录结构浅析 首先看一下一个简单的程序包含哪些文件 点击显隐内容│ build.gradle│ gradle.properties│ gradlew│ gradlew.bat│ local.properties│ SchoolNavigation.iml│ settings.gradle├─.gradle ├─.idea ├─app│ │ .gitignore│ │ app.iml│ │ build.gradle│ │ CMakeLists.txt│ │ proguard-rules.pro│ ├─libs │ └─src│ ├─androidTest │ ├─main│ │ │ AndroidManifest.xml│ │ ├─cpp │ │ ├─java │ │ └─res│ │ ├─anim │ │ ├─drawable │ │ ├─drawable-hdpi │ │ ├─drawable-mdpi │ │ ├─drawable-xhdpi │ │ ├─drawable-xxhdpi │ │ ├─layout │ │ ├─menu │ │ └─values│ │ │ └─test ├─build └─gradle 首先最显眼的就是 Gradle所有名字带有这个的自然就是 Gradle 需要的 .gradle 就是 Gradle 的编译系统gradlew 和 graldew.bat 分别是 *nix 和 windows下的 gradle wrapper 可执行文件build.gradle settings.gradle 和 gradle.properties 都是相关的设置gradle wrapper的jar和配置文件所在的位置 local.properties 则是记录了该项目的一些信息(key、sdk位置等).idea 是 Android Studio 需要的一些文件build 代码编译后生成的文件存放的位置 这些都是 ide 自己可以生成的,不是我们应该关系的内容 app 文件夹内才是我们需要特别关注的,我们写的代码、调用的资源全部都在这里bulid 同样是编译后生成的文件目录libs 则是项目依赖的库的目录,使用的外部的库都放在这个目录里src 就是我们接触最多的源码目录了 里面的 test 显然是测试代码main 就是主代码了进去后会有最关键的 AndroidManifest.xml 这个就是项目清单文件,这个文件列出了应用程序所提供的功能,所有开发好的各种组件需要在该文件中进行配置,如果应用使用到了系统内置的应用(如电话服务、互联网服务、短信服务、GPS服务等等),还需在该文件中声明使用权限.而其他的几个 java cpp 则是通过不同语言写的代码部分,也就是后端部分res 则是资源目录,每个页面的布局、使用的动画图片等前端部分放在这里","tags":[{"name":"Android","slug":"Android","permalink":"https://www.oyohyee.com/tags/Android/"}]},{"title":"COGS 185.挖水井","date":"2017-03-06T14:41:50.000Z","path":"/post/COGS/185.html","text":"题目 点击显/隐题目 农夫约翰决定给他的N（1&lt;=N&lt;=300）个牧场浇水，这些牧场被自然的命名为1..N。他可以给一个牧场引入水通过在这个牧场挖一口井或者修一条管道使这个牧场和一个已经有水的牧场连接。在牧场i挖一口井的花费是w_i（1&lt;=w_i&lt;=100000）。修建一条水管连接牧场i和牧场j的花费是p_ij（1&lt;=p_ij&lt;=100000;p_ij=p_ji;p_ii=0）。请确定农夫约翰为了完成浇灌所有的牧场所需的最小的总花费。 第1行：一个单独的整数n。第2..n+1行：第i+1行包含一个单独的整数w_i。第n+2..2n+1行：第n+1+i行包含n个用空可分开的整数；其中第j个数是p_ij。 第1行：一个单独的整数，表示花费。 454430 2 2 22 0 3 32 3 0 42 3 4 0 9 题解首先建成图,可以发现最终结果是把所有点都直接或间接与水相连因此可以再建立一个源点代表水流每个点挖井的花费就是各个点到水流的距离 这样只需要跑一遍最小生成树就行了 代码点击显/隐代码挖水井代码备份#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std; typedef long long LL;const int maxn = 305;int dis[maxn][maxn];int f[maxn];int pos; struct Edge&#123; int u,v,w; Edge(int a=0,int b=0,int c=0):u(a),v(b),w(c)&#123;&#125; bool operator &lt; (const Edge &amp;rhs)const&#123; return w &lt; rhs.w; &#125;&#125;e[maxn*maxn]; int ufs(int x)&#123; return f[x] == x ? x : f[x] = ufs(f[x]); &#125; LL Kruskal(int n,int m) &#123; LL w = 0; for(int i = 0; i &lt; n; i++) f[i] = i; sort(e,e + m); for(int i = 0; i &lt; m; i++) &#123; int x = ufs(e[i].u),y = ufs(e[i].v); if(x != y) &#123; f[x] = y; w += e[i].w; //cout &lt;&lt; e[i].u &lt;&lt; \" \"&lt;&lt;e[i].v&lt;&lt;\" \"&lt;&lt;e[i].w&lt;&lt;endl; &#125; &#125; return w;&#125; int main()&#123; freopen(\"water.in\",\"r\",stdin); freopen(\"water.out\",\"w\",stdout); cin.tie(0); cin.sync_with_stdio(0); pos=0; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; int t; cin&gt;&gt;t; e[pos++] = Edge(0,i,t); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; int t; cin&gt;&gt;t; if(i&lt;j) e[pos++] = Edge(i,j,t); &#125; cout &lt;&lt; Kruskal(1+n,pos) &lt;&lt; endl;&#125;","tags":[{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"最小生成树","slug":"MST","permalink":"https://www.oyohyee.com/tags/MST/"},{"name":"COGS","slug":"COGS","permalink":"https://www.oyohyee.com/tags/COGS/"}]},{"title":"安徽大学第八届程序设计竞赛 现场决赛","date":"2017-03-02T12:02:10.000Z","path":"/post/Project/AOJ8th.html","text":"题号 名称 题解 788 数方块 题解 789 买酒 题解 793 西瓜理发记（一） 题解 794 西瓜理发记（二） 题解 795 西瓜理发记（三） 题解 797 Roll不是处女座 题解 802 运输宝物 题解","tags":[]},{"title":"AOJ 795.西瓜理发记(三)","date":"2017-03-02T11:43:28.000Z","path":"/post/AOJ/795.html","text":"题目 点击显/隐题目 顺利潜入勺林寺几天后，方丈给了西瓜一个光荣而艰巨的任务——打扫寺庙中的道路。同时给了西瓜一张勺林寺的地图。西瓜这才知道，勺林寺中总共有n座房子，但道路只有n-1条，这n-1条道路连接了寺中的所有房子，即保证在任何两座房子都能沿着道路抵达。好在西瓜人缘不错，他知道每座房子中都有个自己的朋友，只要给他们每个人打个电话，让他到自己这里来，顺便把路也扫了，即给某座房子中的朋友打过电话后，可认为从该房子到西瓜所在的位置之间所有的道路都会被打扫干净。同时西瓜还知道，这n-1条道路中有一些路昨天已经被人打扫过了不需要再打扫一遍。现在西瓜想知道，自己最少要给多少个朋友打电话才能完成方丈给的任务。西瓜在编号为1的房子中。 输入包含多组数据每组数据第一行包含一个n(2?≤?n?≤?10^5)，表示有n座房子之后n-1行，每行三个数字a，b，c表示在房子a和房子b之间有一条路，c等于1表示路已被打扫，c等于2表示路未被打扫。 每组数据输出一个整数k，表示最少要给k个朋友打电话 51 2 21 3 21 4 21 5 2 4 题解根据题意画出图像,可以非常容易发现最终形成一棵以西瓜为树根的树朋友会一路清扫倒西瓜所在的房间,因此只有住在”树叶”的朋友有可能清扫 根据这个思路来分析每一个节点可以发现： 如果从一个节点的子节点已经有 a 个朋友清扫,那么从该节点到树根都不需要再找朋友清扫 如果该节点的所有子节点都没有朋友清扫,那么如果从该节点到树根有需要清扫的路,只需要找一个朋友清扫即可 因此可以发现,对于每一个节点,从树叶到该节点所需的最少朋友数只与其子节点有关,符合 动态规划 的特点,属于 树形dp 用 dp[i] 表示从叶子到第 i 个节点的所需要最少的朋友数, dp[1] 即为答案有 dp[i] = sum{ max(dp[j],Need_Clean) } 其中 j 为 i 的所有子节点, Need_Clean 为道路 (i,j) 是否需要清扫 只需要一个 DFS 即可解决 代码点击显/隐代码西瓜理发记(三)代码备份#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;list&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1e5+5;struct path&#123; int u,v; bool k; path(int a,int b,int c):u(a),v(b),k(c)&#123;&#125;&#125;;struct Node&#123; list&lt;path&gt; children; int father; &#125;;Node node[maxn];int dfs(int t)&#123; int ans=0; for(list&lt;path&gt;::iterator it=node[t].children.begin();it!=node[t].children.end();it++)&#123; int tt = it-&gt;v; if(tt == node[t].father) continue; node[tt].father = t; ans += max(dfs(tt),(int)it-&gt;k); &#125; return ans;&#125; int main()&#123; cin.tie(0); cin.sync_with_stdio(false); int n; while(cin &gt;&gt; n)&#123; for(int i=1;i&lt;=n;i++)&#123; node[i].father=-1; node[i].children.clear(); &#125; int a,b,c; for(int i=1;i&lt;n;i++)&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; node[a].children.push_back(path(a,b,c-1)); node[b].children.push_back(path(b,a,c-1)); &#125; cout &lt;&lt; dfs(1) &lt;&lt; endl; &#125;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"DFS","slug":"DFS","permalink":"https://www.oyohyee.com/tags/DFS/"},{"name":"树形dp","slug":"Tree-dp","permalink":"https://www.oyohyee.com/tags/Tree-dp/"}]},{"title":"AOJ 797.Roll不是处女座","date":"2017-03-02T11:36:58.000Z","path":"/post/AOJ/797.html","text":"题目 点击显/隐题目 一天Roll在codeforces网站上做ACM练习的时候，由于打开题目的顺序比较随性，他看到了他的浏览器标签页是这样的： 虽然Roll不是处女座，但他还是非常地不开心，于是他移动了标签页，就变成了这样: 由此想到了一个问题，对于一个乱序的不重复的数字序列，最少需要移动几个数字，能使它们从小到大排列。例如序列 4 2 3 1 5，只要把1放到第一个，4放到3和5之间，就变成了1 2 3 4 5 输入数据包含多组每组数据第一行一个数n (0﹤n≤?1000)，表示这个序列有n个数字。第二行包含n个数字Ai(0≤Ai≤10^9), 对于每组数据输出一个整数，表示最少需要移动几个数字。 54 2 3 1 521 2 20 题解求移动最少的数字使序列递增首先本身递增的自然就不必再移动了,要想让移动最少就应该先找到 最长上升子序列套用 dp 模板即可 然后剩下的数字都是需要移动的,要最少只需要一次将他们放到最终位置. 也即答案为 n - dp 代码点击显/隐代码Roll不是处女座代码备份#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std; const int maxn = 1005;int node[maxn];int ans[maxn]; int main()&#123; cin.tie(0); cin.sync_with_stdio(false); int n; while(cin&gt;&gt;n)&#123; for(int i=1;i&lt;=n;i++) cin&gt;&gt;node[i]; int len = 1; ans[1] = node[1]; for(int i = 2; i &lt;= n; ++i) &#123; if(node[i] &gt; ans[len]) ans[++len] = node[i]; else *lower_bound(ans + 1,ans + 1 + len,node[i]) = node[i]; &#125; cout&lt;&lt; n - len&lt;&lt;endl; &#125;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"最长上升子序列","slug":"LIS","permalink":"https://www.oyohyee.com/tags/LIS/"}]},{"title":"HDU 6015.Skip the Class","date":"2017-02-25T13:52:04.000Z","path":"/post/HDU/6015.html","text":"题目 点击显/隐题目 Finally term begins. luras loves school so much as she could skip the class happily again.(wtf?) Luras will take n lessons in sequence(in another word, to have a chance to skip xDDDD). For every lesson, it has its own type and value to skip. But the only thing to note here is that luras can’t skip the same type lesson more than twice. Which means if she have escaped the class type twice, she has to take all other lessons of this type. Now please answer the highest value luras can earn if she choose in the best way. The first line is an integer T which indicates the case number. And as for each case, the first line is an integer n which indicates the number of lessons luras will take in sequence. Then there are n lines, for each line, there is a string consists of letters from ‘a’ to ‘z’ which is within the length of 10,and there is also an integer which is the value of this lesson. The string indicates the lesson type and the same string stands for the same lesson type. It is guaranteed that—— T is about 1000 For 100% cases, 1 &lt;= n &lt;= 100，1 &lt;= |s| &lt;= 10, 1 &lt;= v &lt;= 1000 As for each case, you need to output a single line.there should be 1 integer in the line which represents the highest value luras can earn if she choose in the best way. 25english 1english 2english 3math 10cook 1002a 1a 2 1153 题解跳过一定数目的课程,使最后得到的总值最多同一门课最多跳过两次 因此,将每一门课 value 最高的两门选出来加起来即可 用一个结构体维护所有的课程,根据课程名称和 value 排序即可 代码点击显/隐代码Skip the Class代码备份/*/#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 105;struct Node&#123; string name; int value; bool operator &lt; (const Node rhs)const&#123; if(name == rhs.name) return value &gt; rhs.value; return name &lt; rhs.name; &#125;&#125;;Node node[maxn];int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--)&#123; int n; cin &gt;&gt; n; for(int i=0;i&lt;n;i++) cin &gt;&gt; node[i].name &gt;&gt; node[i].value; sort(node,node+n); string ls = \"\"; int cnt = 0; int ans = 0; for(int i=0;i&lt;n;i++)&#123; if(ls == node[i].name)&#123; if(cnt == 2)&#123; continue; &#125;else&#123; cnt++; ans += node[i].value; &#125; &#125;else&#123; ls = node[i].name; cnt = 1; ans += node[i].value; &#125; &#125; cout &lt;&lt; ans&lt;&lt;endl; &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"Miller_rabin 判断素数","date":"2017-02-10T12:08:37.000Z","path":"/post/Algorithm/Miller_rabin.html","text":"素数在数论里是一个非常常用的内容而且当数非常大时,即使是 O(n) 的筛法求素数有可能也无法满足要求(空间和时间都不允许) 因此,就有了该算法 Fermat定理: 若 $n$ 是奇素数，$a$ 是任意正整数$(1≤ a≤ n−1)$，则 $a^{n-1} ≡ 1 \\; mod \\; n$。 二次探测定理: 如果n是一个奇素数，将 $n−1$ 表示成 $2^s*r$ 的形式，$r$ 是奇数，$a$ 与 $n$ 是互素的任何随机整数，那么 $a^r ≡ 1 \\; mod \\; n$ 或者对某个 $j (0 ≤ j≤ s−1, j∈Z)$ 等式 $a^{2jr} ≡ −1 \\; mod \\; n $ 成立。 最后可知,当对于任意数 $a$,有 $a^r ≡ 1 \\; mod \\; n$ 或者对某个 $j (0 ≤ j≤ s−1, j∈Z)$ 等式 $a^(2jr) ≡ −1 \\; mod \\; n$ 则可得知 $a$ 为素数 实际使用时,只需要随机出几个 $a$ ,只要这些情况下都满足,则可以近似认为待判断数为素数 大概这个意思,反正会不会证明都不影响使用 模板如下记得包含 #include&lt;ctime&gt; 和初始化随机数种子 点击显/隐代码Miller_rabin判断素数// Miller_rabin 判断素数const int times = 20; //测试次数LL Random(LL n )&#123;//生成[ 0 , n ]的随机数 return ((double)rand() / RAND_MAX*n + 0.5); &#125; //快速计算 (a*b) % mod/*LL mul_mod(LL a, LL b, LL mod)&#123; LL ans = 0; while(b)&#123; if(b &amp; 1)&#123; b--; ans =(ans+ a)%mod; &#125; b /= 2; a = (a + a) % mod; &#125; return ans; &#125;*/inline LL mul_mod(LL a,LL b,LL mod)&#123; a=(a % mod + mod) % mod; b=(b % mod + mod) % mod; return ((a*b-(LL)((long double)a/mod*b+.5L)*mod)%mod+mod)%mod;&#125; LL exp_mod(LL a, LL b, LL mod )&#123; //快速计算 (a^b) % mod LL ans = 1; while(b)&#123; if(b &amp; 1) ans = mul_mod(ans,a,mod); b /= 2; a = mul_mod(a,a,mod); &#125; return ans; &#125; bool witness( LL a, LL n )&#123; //miller_rabin算法的精华 //用检验算子a来检验n是不是素数 //a^r ≡ 1 mod n或者对某个j (0 ≤ j≤ s−1, j∈Z) 等式a^(2jr) ≡ −1 mod n LL tem = n - 1; int j = 0; while(tem % 2 == 0)&#123; tem /= 2; j++; &#125; //将n-1拆分为a^r * s LL x = exp_mod( a, tem, n ); //得到a^r mod n if(x == 1 || x == n - 1) return true; //余数为1则为素数 while(j--)&#123; //否则试验条件2看是否有满足的 j x = mul_mod( x, x, n ); if(x == n - 1) return true; &#125; return false; &#125; bool miller_rabin( LL n )&#123; //检验n是否是素数 if(n == 2) return true; if(n &lt; 2 || n % 2 == 0) //如果是2则是素数，如果&lt;2或者是&gt;2的偶数则不是素数 return false; for(int i = 1; i &lt;= times; i++)&#123; //做times次随机检验 LL a = Random(n - 2) + 1; //得到随机检验算子 a if(!witness(a, n)) //用a检验n是否是素数 return false; &#125; return true; &#125; int solve(ll n)&#123; ll p = 2; while(n&gt;1)&#123; cout&lt;&lt;\"\\t\"&lt;&lt;n&lt;&lt;\" \"&lt;&lt;p&lt;&lt;endl; if(n%p) p++; else n/=p; &#125; return p;&#125;","tags":[{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"质数","slug":"Prime","permalink":"https://www.oyohyee.com/tags/Prime/"},{"name":"Miller_rabin","slug":"Miller-rabin","permalink":"https://www.oyohyee.com/tags/Miller-rabin/"}]},{"title":"使用 Termux 在手机上运行 linux 黑科技","date":"2017-02-09T08:42:58.000Z","path":"/post/Note/Termux.html","text":"非常棒的神器不同于其他终端,这个终端是一个寄居在安卓系统中的阉割版 Linux手机里的 /data/data/com.termux/files/ 目录对应的就是 Linux 的根目录 / 在自己的这一块地方里, Termux 拥有绝对权限,但是出去后需要 root 权限才能进行操作 这篇博客介绍Termux的基础配置及在手机上写Hexo博客(是不是很激动[滑稽]) 基础环境的配置建议翻墙操作,部分内容在墙外面下载比较慢Termux第一次启动会下载系统,需要等待安装,如果太慢可以试试翻墙 安装好后,执行apt update 先更新下 apt(一开始不能下载的话有可能更新下就好了,不行可以换用清华的源 Termux 镜像使用帮助) 然后执行你需要的命令即可,如apt install screenfetch 然后使用 screenfetch 查看设备信息 美化termux有人做了一键美化,可以试下termux-ohmyzsh hexo博客首先,Hexo需要的环境要配置好 apt install nodejsapt install git npm install -g hexo 然后就是正常的博客生成Termux root 账户(root权限),而 root 账户无法使用 Termux 的命令,这就造成一个很尴尬的问题 下面的方法可以一定程度上解决这个问题 tsu命令使用 tsu 代替 su 获取 root 权限,在 root 的情况下使用 Termux 命令 经过测试, hexo g hexo s 都能正常使用其中 hexo g 可能会稍慢,不过还是能生成的,比用最便宜的 VPS 好多了(最便宜的vps跑不起来 generate) 如图 剩下的 deploy 和正常的一样就行 PS: 应群主要求点击链接加入群【Termux】：https://jq.qq.com/?_wv=1027&amp;k=44mL4Xt PS2: 有个 linux deploy 能安装发行版的 linux 可以有空试下","tags":[{"name":"Termux","slug":"Termux","permalink":"https://www.oyohyee.com/tags/Termux/"}]},{"title":"Hexo本地搜索及部分SEO优化","date":"2017-02-08T13:01:42.000Z","path":"/post/Note/LocalSearch.html","text":"解决本地搜索问题,并且修改了 Next 主题的部分SEO内容,写了一个小插件用于生成 urls.txt 用来给百度主动推送 百度的站内搜索好久没有收录新的页面,站内搜索这个功能还是掌控在自己手里好一点Next主题本身自带的有 Local Search 功能当安装 search.xml 生成插件后,可以自动开启搜索功能 试了下发现点搜索后没有用,找了以下发现生成的xml有错误,有的页面内存在 &amp; 等字符,导致 xml 无法正常解析想了下还是自己修改下吧有 hexo-generator-searchdb 是一个比较完善的插件可以做到提取摘要部分不过我还想把 tags 部分和 keywords 部分也提取出来用来增强搜索功能 同时这个插件生成的链接存在一些小bug,不知道是不是我哪里设置有问题 自己修改了下search.ejs&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;search&gt; &lt;% if(posts)&#123; %&gt; &lt;% posts.slice(0,limit).each(function(post)&#123; %&gt; &lt;entry&gt; &lt;% var dd = \"\"; if(post.keywords)&#123; post.keywords.forEach(function(keyword)&#123; dd += keyword.name + '|'; &#125;); &#125; if(post.categories)&#123; post.categories.forEach(function(category)&#123; dd += category.name + '|'; &#125;); &#125; if(post.tags)&#123; post.tags.forEach(function(tag)&#123; dd += tag.name + '|'; &#125;); &#125; %&gt; &lt;title&gt;&lt;%-: post.title | cdata %&gt;&lt;/title&gt; &lt;url&gt;&lt;%- encodeURIComponent(post.path) %&gt;&lt;/url&gt; &lt;content type=\"text\"&gt;&lt;%-: dd + (raw ? post[raw] : post.content) | cdata %&gt;&lt;/content&gt; &lt;/entry&gt; &lt;% &#125;) %&gt; &lt;% &#125; %&gt; &lt;% if(pages)&#123; %&gt; &lt;% pages.each(function(page)&#123; %&gt; &lt;entry&gt; &lt;title&gt;&lt;%-: page.title | cdata %&gt;&lt;/title&gt; &lt;url&gt;&lt;%- encodeURIComponent(post.path) %&gt;&lt;/url&gt; &lt;content type=\"text\"&gt;&lt;%-: raw ? page[raw] : page.content | cdata %&gt;&lt;/content&gt; &lt;/entry&gt; &lt;% &#125;) %&gt; &lt;% &#125; %&gt;&lt;/search&gt; 本地优化主要在于 &lt;title&gt;&lt;/title&gt; 和 &lt;meta name=&quot;keywords&quot; /&gt; _layout.swig&lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125; - &#123;&#123; config.description &#125;&#125; |&#123;% if page.keywords %&#125;&#123;% for keyword in page.keywords %&#125;&#123;&#123; keyword &#125;&#125;|&#123;% endfor %&#125;&#123;% endif %&#125;&#123;% if page.tags and page.tags.length %&#125;&#123;% for tag in page.tags %&#125;&#123;&#123; tag.name &#125;&#125;|&#123;% endfor %&#125;&#123;% endif %&#125;&lt;/title&gt; head.swig&lt;meta name=\"keywords\" content=\"&#123;% if page.keywords %&#125;&#123;&#123; page.keywords &#125;&#125;,&#123;% endif %&#125;&#123;% if page.tags and page.tags.length %&#125;&#123;% for tag in page.tags %&#125;&#123;&#123; tag.name &#125;&#125;,&#123;% endfor %&#125;&#123;% endif %&#125;&#123;% if theme.keywords %&#125;&#123;&#123; theme.keywords &#125;&#125;&#123;% endif %&#125;&#123;% if config.keywords %&#125;&#123;&#123; config.keywords &#125;&#125;&#123;% endif %&#125;\" /&gt;","tags":[{"name":"SEO","slug":"SEO","permalink":"https://www.oyohyee.com/tags/SEO/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.oyohyee.com/tags/Hexo/"}]},{"title":"三星 C5 Google(港版) + root + Xposed + 其他设置","date":"2017-02-04T13:32:47.000Z","path":"/post/Writing/samsung_c5_root.html","text":"== 刷机前注意！！ ==刷机有风险,会失去保修、失去 Knox 、失去 SAMSUNG PAY 、失去指纹支付(支付宝、微信) ============ update 2016-11-30 ================从贴吧和群里有挺多人都挺想刷机,许多人都加好友问了一些具体的操作.本来只是提供下刷机思路,帮助有刷机经验的人少踩些不必要的坑既然问的人比较多,就把步骤再完善下.============ update 2017-02-04 ================找到了国行的方案,港版的方案直接扔掉吧,国行比港版好了不止一个档次 概述该刷机思路为先线刷官方包到港版固件,再刷入港版对应的 recovery ,而后通过 recovery 卡刷完成设备 root 该刷机思路为先线刷官方包到国行固件 ZCU1API2版本,再刷入API2对应的 recovery ,而后通过 recovery 卡刷完成设备 root,最后通过 Go谷歌安装器 等软件刷入谷歌 变砖等各种刷机造成的问题,不予负责 再次警告Root 会失去 保修、指纹支付、固件升级 等功能且有一定几率刷机出现问题,导致(不限于)以下问题: 信号网络无法连接, wifi 功能无法使用, 手机话筒失灵, 无法发送短信尽管以上内容基本都能够通过重新刷机解决,但是对于没有刷机经验的人来说,不建议以目前状态(没有第三方 ROM ,没有大神帮助解决问题)下的 C5 为入门 刷机前请 完整看完所有步骤 ,有整体思路后再开始刷机如果有地方看不懂,建议 停止刷机 行为即使刷成功,获取 Root 权限后使用某些软件造成各种奇怪的后果仍然会 极大影响你正常使用手机 由于没有人整合 ROM 和 Root 包,导致能找到的 Samsung C5 root 包 和recovery包 比较少因此,想要 root C5 不能像别的机型那样直接线刷或者卡刷root包解决.因此,刷机后,手机会比 恢复出厂设置 更干净 自行备份 联系人、短信、相册 ！！！可以使用百度云、XXX手机助手等任意软件备份 当某一步手机发现不正常行为,从头开始重新刷机理论可以解决大部分问题,如果还不行,基本上就只能换新手机了 无论卡到哪一个界面,同时按下 下音量键 + Home键 + 电源键 可以强制重启 自行学习以下内容 ,里面有详细的图文解释: 三星C5解锁教程_三星C5000解锁bootloader教程 三星C5(C5000)刷入recovery教程 三星C5(C5000)root权限获取教程 由于固件版本问题,上面教程里的给的部分文件会造成奇怪的问题,但是其他操作一模一样！跟着走就行 有问题可以 QQ 看有没有时间回答,苦逼大二狗要忙着上课、考试、陪女票、写代码当然,如果发个几百的红包,说不定我就不管其他事先来帮忙回答问题了 (✿◡‿◡) 港版教程(不推荐了,建议刷国行)需要的程序先下载好以下软件,做好准备工作 百度云链接 CROM (CROM Service.7z) Odin3 (Odin3.7z) 港版官方固件 (SM-C5000ZHU1API2四件套（含一体包）.zip) TWRP Recovery (C5000ZCU1API2版本可用recovery.zip) SuperSu 二进制包 (BETA-SuperSU-v2.74-2-20160519174328.zip) xposed 下载器 (xposed.apk) xposed 框架 (xposed-v86.0-sdk23-arm-custom-build-by-wanam-20160709.zip) 解除手机锁进入三星商店,下载 CROM (上面链接里也有,建议在三星商店下) 安装完成后, 认真阅读警告 ,如果仍然确定要刷,点击 确定 解锁完成 刷入港版包( SM-C5000ZCU1API2 )关机,同时按下 下音量键 + HOME 键 + 电源键 进入 DOWNLOAD 模式(挖煤模式) 手机连接电脑,进入 Odin ,显示设备插入(蓝色) 选择刷机包内的文件,对应名字选择(选择时会略卡)其中 csc 有两个文件,建议用不带 HOME 的刷入(清除设备刷入) BL BL_C5000ZHU1API2_CL8450604_QB11041581_REV00_user_low_ship_MULTI_CERT.tar.md5 AP AP_C5000ZHU1API2_CL8450604_QB11041581_REV00_user_low_ship_MULTI_CERT.tar.md5 CP CP_C5000ZHU1API2_CL8450604_QB11041581_REV00_user_low_ship_MULTI_CERT.tar.md5 CSC CSC_ZZH_C5000ZZH1API2_CL8450604_QB11041581_REV00_user_low_ship_MULTI_CERT.tar.md5 (会清除所有数据) HOME_CSC_ZZH_C5000ZZH1API2_CL8450604_QB11041581_REV00_user_low_ship_MULTI_CERT.tar (可能不会清除所有数据) 取消选择 自动重启 ,开始刷机 当显示绿色的 pass 时,同时按下 下音量键 + HOME 键 + 电源键 强制关机 正常启动,进入系统,检查是否成功(wifi、蓝牙、信号是否正常) 刷入 Recovery(TWRP) 解压 C5000ZCU1API2版本可用recovery.zip 找到里面的 C5000-recovery.tar 同上,手机连接电脑,在 Odin 中,将 C5000-recovery.tar 选在 AP 里,同样取消 自动启动 同上,刷入 Recovery , 关机后同时按下 上音量键 + HOME 键 + 电源键 ,进入 Recovery 模式 进入TWRP替换官方 Recovery (中文操作,按提示就行) 此时,你可以选择备份,进入后备份 EFS 分区,该分区至关重要 ！！！ Root (SuperSu) 将 BETA-SuperSU-v2.74-2-20160519174328.zip 传输到手机里(最好放在根目录里,好找) 进入 TWRP 选择安装,找到 BETA-SuperSU-v2.74-2-20160519174328.zip 重启手机 此时你的手机已经 Root 完成,开机检查是否有问题,如果没有 SuperSU 权限管理工具,自己上网找一个下载安装 安装 xposed 同 Root 部分,将 xposed-v86.0-sdk23-arm-custom-build-by-wanam-20160709.zip 卡刷入系统 刷入后重启会 非常慢 ,如果无限卡三星logo,强制重启即可 进入系统后,打开 xposed 已经可以看到框架安装成功,无视他的不兼容警告 安装模块 关闭相机快门音原帖 http://www.linuxidc.com/Linux/2013-07/87304.htm 三星i9100怎么才能取消拍照声音呢，在默认情况下即使静音状态下拍照还是有声音的。 手机需 root，且需要 TC、RE、ES 等文件管理器，自己下载吧。 当然，也可以修改 SamsungCamera.apk 内 res-raw 来达到完全达到完全无声的效果，但是，万一需要拍照有声音，还是要替换 SamsungCamera.apk，很是麻烦。 其实，拍照软件本来就有个“快门音”的选项菜单的，只是系统默认是隐藏的。 而我的方法，就是让你的i9308手机系统拍照软件显示该菜单，见图，只需修改一次，以后无需替换文件，直接在照相时候选择是否需要拍照音（包括单拍、连拍、聚焦等） 文本形式打开 /system/csc/feature.xml 若有 &lt;!--Camera--&gt;这段，就在下面新增&lt;CscFeature_Camera_ShutterSoundMenu&gt;true&lt;/CscFeature_Camera_ShutterSoundMenu&gt;若已有该行则把 false 改为 true 没有 &lt;!--Camera--&gt;这段，把这段也新增，&lt;!--Camera--&gt; 只是用来解释说明的行，说明下面的命令是关于 Camera 的，本身不是命令注意 xml 的嵌套关系,不要放错嵌套 &lt;!--Camera--&gt;&lt;CscFeature_Camera_ShutterSoundMenu&gt;true&lt;/CscFeature_Camera_ShutterSoundMenu&gt; 保存退出 这个命令就是让系统拍照软件显示“快门音”菜单，但此时菜单有了，但是关闭选项仍然是无效的，因为系统强制拍照有声音 文本形式打开 /system/build.prop 在中间的位置可以看到 ro.camera.sound.forced=1 ，把 1 改成 0若没有这行就新增保存退出 这个命令就是系统强制拍照声音的根源，改成 0关闭后，系统就不强制拍照带声音了，让“快门音”菜单“关”生效 进入相机关闭快门音 国行教程具体哪一步不清楚可以参考上面的港版教程,懒得写了 如果熟练的话,刷完大概半个小时(包括等待开机)[重启一次,能一起干的就一起干] 百度云链接 CROM (CROM Service.7z) Odin3 (Odin3.7z) 国行ZCU1API2官方固件 (SM-C5000ZCU1API2四件套（含一体包）.zip) TWRP Recovery (C5000ZCU1API2版本可用recovery.zip) SuperSu 二进制包 (BETA-SuperSU-v2.74-2-20160519174328.zip) xposed 下载器 (xposed.apk) xposed 框架 (xposed-v86.0-sdk23-arm-custom-build-by-wanam-20160709.zip) 解除手机锁进入三星商店,下载 CROM (上面链接里也有,建议在三星商店下) 安装完成后, 认真阅读警告 ,如果仍然确定要刷,点击 确定 解锁完成 刷入国行ZCU1API2版本固件如果你的版本已经是 ZCU1API2 跳过该步骤 关机,同时按下 下音量键 + HOME 键 + 电源键 进入 DOWNLOAD 模式(挖煤模式)手机连接电脑(建议使用台式机主机背面的 USB 口,电流更稳定)打开 Odin 对应右侧的名字选择 SM-C5000ZCU1API2四件套（含一体包）.zip 里的文件等待加载完成后开始刷机 自动重启貌似选不选都没关系 刷入TWRPreset 清除下加载的四件套,在AP里选择 C5000ZCU1API2版本可用recovery.zip 里的 Recovery 文件同上刷机 刷入 Root 和 Xposed把 xposed-v86.0-sdk23-arm-custom-build-by-wanam-20160709.zip 和 BETA-SuperSU-v2.74-2-20160519174328.zip 通过任意方式放到手机里关机,同时按下 上音量键 + HOME 键 + 电源键 进入 Recovery 模式选择覆盖官方 Recovery进入 Recovery 后,分别安装 SuperSU 和 Xposed框架 检查刷机成功与否 + 安装谷歌正常开机,刷入 Xposed 后第一次开机会卡三星logo,同时按下 下音量键 + HOME 键 + 电源键强制重启就行等待加载默认程序跟随引导进入系统检查能否打电话检查是否存在 SuperSU应用安装 Xposed应用 检查是否Xposed是否成功刷入(会提示不兼容不用管它) 全都没问题后可以下载酷安,安装 Go谷歌安装器一键安装后点击下面的修复工具,安装修复工具 推荐 Go Host 通过 Host 翻墙 以上全部工作完成 可能会出现的问题绿色守护后台被杀在三星的智能管理器里把绿色守护的自启打开其他所有软件有类似问题都这样解决这个自启包括 自启 + 后台白名单 两部分 指纹支付支付宝进入指纹支付设置后会一直提示错误,反正就是不能用了 推荐应用 Go谷歌安装器(安装谷歌全家桶(其实就市场和框架)) Go Host(Host翻墙) 绿色守护(杀后台) 阻止运行(禁止国内流氓软件相互唤醒) GravityBox[MM](重力工具箱,美化 + 连续触摸指纹返回桌面) FooView(单手操作辅助) Flynx(悬浮浏览器) good lock(修改下拉菜单为正常 Android 该有的样子,三星官方出的,最近任务栏有点卡顿,其他挺好的) Android N-ify(配合good lock,完美模拟 Android N 风格,设置不好 非常容易变砖, 建议备份好数据,准备好刷机,然后愉快地瞎搞)","tags":[{"name":"Android","slug":"Android","permalink":"https://www.oyohyee.com/tags/Android/"},{"name":"三星(SAMSUNG)","slug":"SAMSUNG","permalink":"https://www.oyohyee.com/tags/SAMSUNG/"},{"name":"C5","slug":"C5","permalink":"https://www.oyohyee.com/tags/C5/"},{"name":"root","slug":"root","permalink":"https://www.oyohyee.com/tags/root/"}]},{"title":"2017安徽省程序设计竞赛培训笔记","date":"2017-01-16T05:39:20.000Z","path":"/post/Note/2017_Winter_Coding_Training.html","text":"2017-1-16 ~ 2017-1-19内容: 数学(数论 &amp; 组合数学) 数据结构 图论 动态规划 数学(数论 &amp; 组合数学)唯一分解定理每个正整数都可以唯一地表示成素数的乘积.即有唯一的分解质因数的方案:$x=a_1^{p_1}a_2^{p_2}...a_n^{p_n}$根据上面的式子,可以推知 x 共有 $(p_1+1)(p_2+1)…(p_n+1)$ 个约数 最大公因数和最小公倍数若有$x=a_1^{p_1}a_2^{p_2}…a_n^{p_n}$$y=a_1^{q_1}a_2^{q_2}…a_n^{q_n}$ 则$gcd(x,y) = a_1^{min(p_1,q_1)}a_2^{min(p_2,q_2)}…a_n^{min(p_n,q_n)}$$lcm(x,y) = a_1^{max(p_1,q_1)}a_2^{max(p_2,q_2)}…a_n^{max(p_n,q_n)}$ 同时可以很容易得到$x \\times y = gcd(x,y) \\times lcm(x,y)$ 若$x = p \\times gcd(x,y)$$y = q \\times gcd(x,y)$ 那么 $x + y = (p+q) \\times gcd(x,y)$可以得到 $gcd(x,y) = gcd(x,x+y)$ 欧几里得算法gcd(a,b) = gcd(b,a mod b) 证明如下:若 $a = p \\times c$$b = q \\times c$$a \\; mod \\; b = a - \\left \\lfloor \\frac{a}{b} \\right \\rfloor \\times b$$a \\; mod \\; b = p \\times c - k \\times q \\times c$$a \\; mod \\; b = (p-kq)c$$\\therefore gcd(a,b) = gcd(b,a \\; mod \\; b)$ 之所以要不断交换 a b 的位置,是为了保证两边都要逐渐减小 根据这个算法,就可以写出求最小公倍数的算法欧几里得算法int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125; 拓展欧几里得算法对于方程 ax + by = c有两种情况 gcd(a,b) 是 c 的因子这种情况下,有 $ \\frac{a}{gcd(a,b)}x + \\frac{b}{gcd(a.b)}= \\frac{c}{gcd(a,b)}$有可能存在整数解 gcd(a,b) 不是 c 的因子这种情况下,两边同时除以 gcd(a,b) 左侧为整数,右侧为小数,不可能存在整数解 先考虑 ax+by=gcd(a,b) 的情况当 $b=0$ 时,有 gcd(a,b)=a 即 x=1,y=0当 $b \\neq 0$,有 ax+by=gcd(a,b)根据欧几里得算法 $gcd(a,b) = gcd(b,a \\; mod \\; b)$有 $ax+by = gcd(a,b) = gcd(b,a \\; mod \\; b)$$bx′+(a−b∗\\left \\lfloor \\frac{a}{b} \\right \\rfloor)y′ = gcd(b,a \\; mod \\; b)$可化得 $ax+by = bx’ + (a \\; mod \\; b)y’ = ay’+b(x’- \\lfloor \\frac{a}{b} \\rfloor y’)$因此 $\\begin{cases}x=y’\\y=x’- \\lfloor \\frac{a}{b} \\rfloor y’\\end{cases}$ 由于已经知道递归到 b=0 时的解,因此可以一步一步得出 ax+by=gcd(a,b) 的解而对于 ax+by=kgcd(a,b) 只需要将 x , y 同乘 k 即可 下面是对于 ax+by=gcd(a,b) 的解拓展gcdint exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b==0)&#123; x=1; y=0; return a; &#125; int r=exgcd(b,a%b,x,y); int t=x; x=y; y=t-a/b*y; return r;&#125; 同余方程中国剩余定理对于一元线性同余方程组$ \\begin{cases} x \\equiv \u0011a_1 (mod \\; m_1)\\\\ x \\equiv \u0011a_2 (mod \\; m_2)\\\\ ...\\\\ x \\equiv \u0011a_n (mod \\; m_n)\\\\ \\end{cases} $ 其中 $m_1$ 、$m_1$ …. $m_n$ 两两互质则对任意整数 $a_1$ 、$a_1$ …. $a_n$ 方程组有解 求解方法如下令$M=m_1m_2m_3…m_n$$M_i=\\frac{M}{m_i}$$t_i$为$M_i$模$m_i$下的逆元,也即$M_it_i \\equiv 1(mod \\; m_i)$ 则有$x = a_1t_1M_1 + a_2t_2M_2 + \u0001 …\u0001 \u0001 + a_nt_nM_n + kM \\; \\; k \\in Z$ Lucas定理若 p 为素数$n = nkp^k + n{k-1}p^{k-1} + …+n_1p + n_0$$m = mkp^k + m{k-1}p^{k-1} + …+m_1p + m_0$ 则有$C(n,m) = \\prod_{i=0}^{k} C(n_i,m_i)(mod \\; p)$ \u0005 数论的函数 $\\phi (n)$ : 不大于 n 且与 n 互素的数的个数 $\\mu (n)$ : 如果 $n=kd^2$, $\\mu (n)= 0$, 否则 $\\mu(n) = (-1)^k $,其中 k 是 n 的素因子数 特别地 $\\sum_{d|n} \\phi\u001e(d) = n$ $\\sum_{d|n} \\mu\u001e(d) = [n=1]$ 积性函数$\\forall x,y$ 若 $gcd(x,y)=1$ ,则$f(xy)=f(x)f(y)$$\\phi (x)$和$\\mu (x)$都是积性函数 完全积性函数$\\forall x,y$ ,则$f(xy)=f(x)f(y)$ Euler筛法对于积性函数 f(x) 可以用 Euler 筛法在 O(n) 的时间复杂度内预处理 f(1) f(2) … f(n) 的值若 t 是 x 的最小质因子,那么 f(x) 将在枚举到 x/t 时用 f(x/t) 与 f(t) 求出 Mobius反演Dirichlet卷积$(f \\times g)(n) = \\sum_{d|n}f(d)g(\\frac{n}{d})$ 如果 f , g 是积性函数,那么 f × g 也是积性函数且当 $g(n) = \\sum_{d|n}f(d)$ 时有 $f(n) = \\sum_{d|n} \\mu (d) g(\\frac{n}{d})$ 最大公约数和$ \\begin{align*} &\\sum_{i=1}^{n}gcd(n,i) \\\\ = &\\sum_{i=1}^{n} \\sum_{d|i\\&d|n}\\phi(d) \\\\ = &\\sum_{d|n}\\left \\lfloor \\frac{n}{d} \\right \\rfloor\\phi(d) \\end{align*} $ $ \\begin{align*} &\\sum_{i=1}^{n}\\sum_{j=1}^{m}gcd(i,j) \\\\ = &\\sum_{i=1}^{n}\\sum_{j=1}^{m} \\sum_{d|i\\&d|n}\\phi(d) \\\\ = &\\sum_{d=1}^{min(n,m)}\\left \\lfloor \\frac{n}{d} \\right \\rfloor \\left \\lfloor \\frac{m}{d} \\right \\rfloor\\phi(d) \\end{align*} $ 组合数从 n 个数中选 m 个数,每个数最多选一次$C(n,m) = \\frac{n!}{m!(n-m)!}$ 特别地, C(n,0) = C(n,n) = 1 C(n,m) = C(n,n-m) C(n,m) = C(n-1,m-1) + C(n-1,m) 二项式展开$(x + y)^n = \\sum_{i=0}^{n} C(n,i)x^iy^{n-i}$ 置换置换群置换作为元素的群可以用来描述等价关系 Burnside引理对于一个置换 f ,若方案 s 变回它自己,称它为 f 的不动点f 的不动点数目记为 C(f)等价类数目为所有 C(f) 的平均值 Polya定理给 n 种颜色着 k 种颜色,设置换 f 的循环节为 m(f) ,则它的不动点数目为 $C(f) = k^{m(f)}$ 数据结构RMQ问题RMQ问题 是范围最小值查询问题 稀疏表(ST算法)ST算法ST算法是一种解决 RMQ 问题的效率较高的方法在不需要更改节点的情况下,可以优先使用ST算法 线段树线段树当需要更新节点的时候,就需要使用线段树这种数据结构在修改节点时,只需要改变其所在分支上的节点在修改区间时,给区间加上tag,在以后用到该区间时,将tag传递给其子节点(O(log n)) 如果线段树上的修改为 取模 操作,可以将其化为 最大值查询+单点修改 左式堆又称左偏树、左倾堆 外部节点（external node）：左子树或右子树为空的节点 左偏树节点距离（dis）属性：该节点到最它的后代中最近的外部节点经过的距离特别地，外部节点dist = 0 左偏树key值满足堆性，左儿子dist&gt;=右儿子dist 整个树呈现一种左倾的形态,根据这种特性,可以将插入、修改、删除全部以合并不同的左式堆代替合并时,优先合并到右支mergeint merge(int u, int v)&#123; if (!u) return v; if (!v) return u; if (key[u] &lt; key[v]) swap(u,v); r[u] = merge(r[u],v); if (dist[r[u]] &gt; dist[l[u]]) swap(r[u], l[u]); dist[u] = r[u] &gt; 0 ? dist[r[u]] + 1 : 0; return u;&#125; 并查集并查集在一些有N个元素的集合应用问题中,我们通常是在开始时让每个元素构成一个单元素的集合然后按一定顺序将属于同一组的元素所在的集合合并,其间要反复查找一个元素在哪个集合中这一类问题数据量极大,若用正常的数据结构来描述的话,计算机无法承受只能采用一种全新的抽象的特殊数据结构——并查集来描述 带权并查集顾名思义，就是在维护元素所属集合的同时记录集合的一些信息： 维护集合的最大最小值 维护集合的和 维护其它的信息 KMP算法KMP算法KMP算法是一种字符串匹配算法可以快速地找出一个字符串在另一个字符串中第一次出现的位置 字典树(Trie)字典树是一个26叉树，每次插入一个单词的话就是按照树的插入操作进行将每个字母看作一个节点 AC自动机AC 自动机是一种多模匹配算法可以简单地将其看作 字典树+KMP算法 失败指针：AC自动机即在字典树上添加失败指针,这个失败指针与 KMP 的 next 数组类似 对应关系: KMP AC自动机 单串 多串 原字符串 字典树 Next数组 失败指针 可持久化数据结构所谓的可持久化数据结构,就是保存这个数据结构的历史版本,同时他们之间公用数据减少时间和空间的消耗可用持久化的数据结构：线段树(常见),平衡树,块状链表,块状数组(较少见)等 对于线段树的可持久化 可持久化线段树常见应用：有修改的区间第k大 单点修改： 修改一个叶子节点我们只需要新建一个新的叶子节点就能得到一个当前版本 修改一个非叶子节点.两个孩子中最多有一个会被修改,于是递归调用.然后将当前版本复制一遍,另外一个孩子不变,当前孩子为修改后的版本. 查询.与线段树一样 tag标记.遇到一个打了标记的节点,直接下传标记即可,下传的时候新建两个打了标记的节点. 图论 动态规划","tags":[]},{"title":"HDU 5984.Pocky(2016 CCPC 青岛 C)","date":"2017-01-14T09:23:15.000Z","path":"/post/HDU/5984.html","text":"题目 点击显/隐题目 Let’s talking about something of eating a pocky. Here is a Decorer Pocky, with colorful decorative stripes in the coating, of length L.While the length of remaining pocky is longer than d, we perform the following procedure.We break the pocky at any point on it in an equal possibility and this will divide the remaining pocky into two parts.Take the left part and eat it. When it is not longer than d, we do not repeat this procedure.Now we want to know the expected number of times we should repeat the procedure above.Round it to 6 decimal places behind the decimal point. The first line of input contains an integer N which is the number of test cases. Each of the N lines contains two float-numbers L and d respectively with at most 5 decimal places behind the decimal point where 1 ≤ d, L ≤ 150. For each test case, output the expected number of times rounded to 6 decimal places behind the decimal point in a line. 61.0 1.02.0 1.04.0 1.08.0 1.016.0 1.07.00 3.00 0.0000001.6931472.3862943.0794423.7725891.847298 题解题意相对比较容易理解对于一根长度为 L 的木棍,每次等概率的取一个点将其分成两半,然后吃掉左边一半,直到剩下的长度小于 d,计算需要吃(分割)次数的数学期望 显然,如果 L/d 相同,则结果必定相同根据 ln2 = 0.693147 可以推测出结果应该是 ln(L/d) + 1再单独考虑不需要分割的情况( d&gt;=L ) 证明定义 f(x) 为长度为 x 时,的数学期望如图,对于 f(x) 若 x&lt;=d 这时已经满足条件,有 f(x)=0而对于 x&gt;d 其结果应该是从上面任选一点后求其右半部份的数学期望再加上本次分割的 1 用 $\\varphi$ 表示从长度为 x 的线段上取到一个点的概率,有 $\\int_{0}^{x} \\varphi dt = 1$也即 $\\varphi=\\frac{1}{x}$ 也即 $ \\begin{align*} f(x) &= \\begin{cases} 0 && ,x\\leq d\\\\ 1+ \\int_{0}^{d} \\varphi f(t)dt + \\int_{d}^{x}\\varphi f(t)dt && ,x > d \\end{cases} \\\\ &= \\begin{cases} 0 && ,x\\leq d\\\\ 1+ \\frac{\\int_{0}^{d} f(t)dt}{x} + \\frac{\\int_{d}^{x} f(t)dt}{x} && ,x > d \\end{cases} \\\\ &= \\begin{cases} 0 && ,x\\leq d\\\\ 1+ \\frac{\\int_{d}^{x} f(t)dt}{x} && ,x > d \\end{cases} \\end{align*} $ 其中,特别要注意的是$\\lim_{x->d_-} f(x) = 0$ $\\lim_{x->d_+} f(x) = 1$ 因此可以得知 f(x) 不是一个连续函数但是我们迭代运算的部分都是 x &gt; d 部分 $ \\begin{align*} \\because f(x) &= 1 + \\frac{\\int_{d}^{x}f(t)dt}{x} \\\\ &= 1 + \\frac{F(x) - F(d)}{x} \\end{align*} $ $ \\begin{align*} \\therefore f{}'(x) &= \\frac{xF{}'(x) - F(x) + F(d)}{x^2} \\\\ &= \\frac{xf(x) - \\int_{d}^{x}f(t)dt}{x^2} \\\\ &= \\frac{xf(x) - x(f(x)-1)}{x^2} \\\\ &= \\frac{1}{x} \\end{align*} $ $ \\therefore f(x)=ln(x)+C $ $ \\because \\lim_{x->d_+} f(x) = 1 $ $ \\therefore f(d) = ln(d) + C = 1 $ $ \\therefore C = 1 - ln(d) $ $ \\therefore f(x) = ln(x) + 1 - ln(d) $ $ \\therefore f(x) = ln(\\frac{x}{d}) + 1 $ 综上所述 $ \\begin{align*} f(x) = \\begin{cases} 0 && ,x\\leq d\\\\ ln(\\frac{x}{d})+1 && ,x > d \\end{cases} \\end{align*} $ 代码点击显/隐代码Pocky代码备份/*//#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iomanip&gt;using namespace std;int main() &#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while (T--) &#123; double a, b; cin &gt;&gt; a &gt;&gt; b; if (a &lt;= b) cout &lt;&lt; \"0.000000\" &lt;&lt; endl; else cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; 1.0 + log(a / b) &lt;&lt; endl; &#125; #ifdef debug printf(\"Time:%.3fs.\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"CCPC","slug":"CCPC","permalink":"https://www.oyohyee.com/tags/CCPC/"}]},{"title":"HDU 5983.Pocket Cube(2016 CCPC 青岛 B)","date":"2017-01-13T13:46:54.000Z","path":"/post/HDU/5983.html","text":"题目 点击显/隐题目 The Pocket Cube, also known as the Mini Cube or the Ice Cube, is the 2 × 2 × 2 equivalence of a Rubik’s Cube.The cube consists of 8 pieces, all corners.Each piece is labeled by a three dimensional coordinate (h, k, l) where h, k, l ∈ {0, 1}. Each of the six faces owns four small faces filled with a positive integer.For each step, you can choose a certain face and turn the face ninety degrees clockwise or counterclockwise.You should judge that if one can restore the pocket cube in one step. We say a pocket cube has been restored if each face owns four same integers. The first line of input contains one integer N(N ≤ 30) which is the number of test cases.For each test case, the first line describes the top face of the pocket cube, which is the common 2 × 2 face of pieceslabelled by (0, 0, 1),(0, 1, 1),(1, 0, 1),(1, 1, 1). Four integers are given corresponding to the above pieces.The second line describes the front face, the common face of (1, 0, 1),(1, 1, 1),(1, 0, 0),(1, 1, 0). Four integers aregiven corresponding to the above pieces.The third line describes the bottom face, the common face of (1, 0, 0),(1, 1, 0),(0, 0, 0),(0, 1, 0). Four integers aregiven corresponding to the above pieces.The fourth line describes the back face, the common face of (0, 0, 0),(0, 1, 0),(0, 0, 1),(0, 1, 1). Four integers aregiven corresponding to the above pieces.The fifth line describes the left face, the common face of (0, 0, 0),(0, 0, 1),(1, 0, 0),(1, 0, 1). Four integers are givencorresponding to the above pieces.The six line describes the right face, the common face of (0, 1, 1),(0, 1, 0),(1, 1, 1),(1, 1, 0). Four integers are givencorresponding to the above pieces.In other words, each test case contains 24 integers a, b, c to x. You can flat the surface to get the surface developmentas follows. + - + - + - + - + - + - + | q | r | a | b | u | v | + - + - + - + - + - + - + | s | t | c | d | w | x | + - + - + - + - + - + - + | e | f | + - + - + | g | h | + - + - + | i | j | + - + - + | k | l | + - + - + | m | n | + - + - + | o | p | + - + - + For each test case, output YES if can be restored in one step, otherwise output NO. 41 1 1 12 2 2 23 3 3 34 4 4 45 5 5 56 6 6 66 6 6 61 1 1 12 2 2 23 3 3 35 5 5 54 4 4 41 4 1 42 1 2 13 2 3 24 3 4 35 5 5 56 6 6 61 3 1 32 4 2 43 1 3 14 2 4 25 5 5 56 6 6 6 YESYESYESNO 题解题意很容易理解,就是对一个二阶魔方,判断其是否能在一步内还原.如果会还原三阶魔方,应该很容易就能理解.经过分析,其实只有7种情况1种是初始情况就是还原的,另外对于每一面分别向两个方向转一次. 比较稳妥的写法是直接把转后的位置顺序写出来,然后按照这个顺序查询是否存在不合法的情况.(一定要注意不要写错!!!) 另外,需要额外注意,必须要满足6种颜色每种颜色4个 代码点击显/隐Pocket Cube代码备份/*//#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;map&gt;using namespace std;int cube[24];int list[7][24] = &#123; &#123;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23&#125;, &#123;0,5,2,7,4,9,6,11,8,13,10,15,12,1,14,3,16,17,18,19,22,20,23,21&#125;, &#123;0,13,2,15,4,1,6,3,8,5,10,7,12,9,14,11,16,17,18,19,21,23,20,22&#125;, &#123;20,21,2,3,4,5,6,7,8,9,16,17,12,13,14,15,0,1,18,19,10,11,22,23&#125;, &#123;16,17,2,3,4,5,6,7,8,9,20,21,12,13,14,15,10,11,18,19,0,1,22,23&#125;, &#123;2,0,3,1,22,20,6,7,8,9,10,11,12,13,19,17,16,4,18,5,14,21,15,23&#125;, &#123;1,3,0,2,17,19,6,7,8,9,10,11,12,13,20,22,16,15,18,14,4,21,5,23&#125;&#125;;int check[24]=&#123;16,17,0,1,20,21,18,19,2,3,22,23,4,5,6,7,8,9,10,11,12,13,14,15&#125;;map&lt;int,int&gt; m;void solve() &#123; m.clear(); int pos = 0; int num[24]; memset(num, 0, sizeof(num)); for (int i = 0; i &lt; 6; i++)&#123; for (int j = 0; j &lt; 4; j++) &#123; int t; cin &gt;&gt; t; cube[i * 4 + j] = t; if (!m.count(t)) m.insert(make_pair(t, pos++)); num[m[t]]++; &#125; &#125; // cout&lt;&lt;\"Cube:\"&lt;&lt;endl; // for(int i=0;i&lt;24;i++) // cout&lt;&lt;cube[i]&lt;&lt;\" \"; // cout&lt;&lt;endl; //必须是6种颜色,并且每种4个 bool ok = true; for (int i = 0; i &lt; 6 &amp;&amp; ok; i++) if (num[i] != 4) ok = false; if (ok) &#123; ok = false; for (int i = 0; i &lt; 7 &amp;&amp; !ok; i++) &#123; //分别按照7种情况判断是否能够还原 // cout &lt;&lt; \"Case\" &lt;&lt; i &lt;&lt; endl; // for(int j=0;j&lt;6;j++) // printf(\"%3d\",cube[list[i][check[j]]]); // cout&lt;&lt;endl; // for(int j=6;j&lt;12;j++) // printf(\"%3d\",cube[list[i][check[j]]]); // cout&lt;&lt;endl; // for(int j=0;j&lt;6;j++) // printf(\" %3d%3d\\n\",cube[list[i][check[12+j*2]]],cube[list[i][check[12+j*2+1]]]); // cout&lt;&lt;endl; bool flag = true; for (int j = 0; j &lt; 6 &amp;&amp; flag; j++) &#123; if (cube[list[i][4 * j + 0]] != cube[list[i][4 * j + 1]] || cube[list[i][4 * j + 0]] != cube[list[i][4 * j + 2]] || cube[list[i][4 * j + 0]] != cube[list[i][4 * j + 3]]) flag = false; &#125; if (flag) ok = true; &#125; &#125; cout &lt;&lt; (ok ? \"YES\" : \"NO\") &lt;&lt; endl;&#125;int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock();#endif int T; cin &gt;&gt; T; while (T--) solve();#ifdef debug printf(\"Time:%.3f s.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"CCPC","slug":"CCPC","permalink":"https://www.oyohyee.com/tags/CCPC/"}]},{"title":"遗传算法解决TSP问题","date":"2016-12-25T06:58:37.000Z","path":"/post/Algorithm/Genetic_Algorithm.html","text":"写了下遗传算法的TSP问题 要求如下: N&gt;=8。 随即生成N个城市间的连接矩阵。 指定起始城市。 给出每一代的最优路线和总路线长度。 以代数T作为结束条件，T&gt;=50。 巡回旅行商问题给定一组n个城市和俩俩之间的直达距离，寻找一条闭合的旅程，使得每个城市刚好经过一次且总的旅行距离最短。TSP问题也称为货郎担问题，是一个古老的问题。最早可以追溯到1759年Euler提出的骑士旅行的问题。1948年，由美国兰德公司推动，TSP成为近代组合优化领域的典型难题。 遗传算法遗传算法大概就是用自然进化中的生物来模拟数据,寻找最优解的一种算法.根据生物知识可以知道进化的原因是 物竞天择,适者生存 生物基因会不停地进行变异,有的变异适合环境被保留下来,有的不适合环境被抛弃掉.这个过程会不断筛选生物个体,最终导致种群里留存的都是最适合环境的个体 需要明确的是,遗传算法是完全随机的,很有可能无法找到 最优解 但是在运算范围内,能够找到的必然是一个非常好的解因此遗传算法是一个很好兼顾了时间和准确率的算法(运算范围选取合理的情况下,可以认为找到的就是最优解) 例如 TSP问题,将解看成每个生物个体.我们的任务就是在题目要求的环境里找到最适宜的生物个体 每一个个体都是一个解,例如染色体为 123456 的个体表示按照 “1 - 2 - 3 - 4 - 5 - 6 - 1” 的顺序访问所有城市 要判断哪一个更加适宜环境,就需要一个函数进行计算.因此要定义一个适应度函数来计算每一个染色体对于环境的适应度情况.对于TSP问题而言,就是计算当前解的距离和 生物的进化需要个体的繁衍、变异将两个生物体的染色体片段(基因)进行交叉互换(交换个别片段)可以得到一个新的生物个体,这个个体可能会优于其父母,也有可能劣于其父母.子代可能会发生变异,产生一个全新的染色体.因此可采用随机数的方法模拟染色体的交叉互换和变异.使用一个函数来判断某个生物体是否会被消灭(随机出不合法的染色体)每代都把最适合环境的个体留下来(包括父代的个体),这样迭代下去,找到的结果会越来越接近最优解 要找到最优解,首先要确保能够尽可能广的覆盖到各种基因组合(染色体),然后要让种群数量尽可能大(以防由于最优解的一部分适应度较低直接被舍弃掉),繁衍代数尽可能高 实现旅行商问题对于 n 个城市的TSP问题,记录城市编号 0 ~ n-1然后用 n 个连续数字记录访问顺序(数组存储),如 (1)(2)(3)(4)(5) 表示 1 - 2 - 3 - 4 - 5 - 1 首先初始化祖宗染色体,交配需要两个个体,因此我们可以分别正序和逆序生成两个祖宗个体.然后循环 T 代,每一代让种群里的个体两两结合交叉互换,插入到种群里.接着对每一个个体进行基因突变(按照一定得突变概率),突变后个体如果能够存活就把它插入到种群里.最后按照种群适应度排序,只留下前面的一部分个体.这样就完成了一代的生物进化. 关于各部分的实现,根据 TSP 问题,可以采用以下办法 交叉互换取染色体的随机片段,两段片段分别映射并交换,然后对于每个染色体的未交换部分按照映射更改 例如，对下面两个父个体的表示，随机地选择两个交叉点“/” P1：（1 2 3 / 4 5 6 7 / 8 9） P2：（4 5 2 / 1 8 7 6 / 9 3）首先，两个交叉点之间的中间段交换，得到： o1：（x x x / 1 8 7 6 / x x） o2：（x x x / 4 5 6 7 / x x ）其中x表示暂时未定义码，得到中间段的映射关系。，有： 1—-4，8—-5，7—-6，6—-7对子个体1，2中的x部分，分别保留从其父个体中继承未选定城市码，得到 o1：（ x 2 3 / 1 8 7 6 / x 9 ） o2：（ x x 2 / 4 5 6 7 / 9 3 ）最后，根据中间段的映射关系，对于上面子个体1的第一个x，使用最初父码1，由1—-4交换得到第一个x为4，类似地子个体1的第二个x，使用最初父码8，由8—-5交换得到子个体1的第二个x为5。类似地进行操作，最终得到的子个体为： o1：（ 4 2 3 / 1 8 7 6 / 5 9 ） o2：（ 1 8 2 / 4 5 6 7 / 9 3 ） 基因突变随机取两个基因,交换他们的值 适应度计算相邻基因的距离(如果相同则逐位比较大小,确保相同的相邻) 适者生存种群排序后,去除掉相同的个体,然后删除掉超出最大种群个数的个体其中,删除重复个体可以采用如下代码 删除重复个体sort(P.begin(),P.end());P.erase(unique(P.begin(),P.end()),P.end()); 完整代码遗传算法解决TSP问题#include &lt;cstdio&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100;const double eps = 1e-10; //浮点误差/* ================= */int N; //城市数量int M; //开始城市int Distance[maxn][maxn]; //各城市之间的距离int T = 100; //循环代数unsigned int P_SIZE = 50; //种群大小double Mutation_Probability = 0.6; //变异的概率//随机//生成0~n的随机数int Random(int n) &#123; if(n == 0) return 0; else return rand() % (n + 1);&#125;//生成概率double Probability() &#123; double ans = (double)Random(100) / 100.0; //cout &lt;&lt; ans &lt;&lt; endl; return ans;&#125;//适应度//计算一条染色体的适应度 距离越短,适应度越高int Fitness(int *gene) &#123; int dis = Distance[gene[N - 1]][gene[0]]; for(int i = 0; i &lt; N - 1; i++) dis += Distance[gene[i]][gene[i + 1]]; return dis;&#125;//长度为N个基因的染色体struct Chromosome &#123; int *Gene; //基因序列 int fitness; //该染色体的适应度 Chromosome(int *gene = NULL) &#123; Gene = new int[N]; if(gene != NULL) &#123; memcpy(Gene,gene,sizeof(int) * N); fitness = Fitness(Gene); //cout &lt;&lt; \"New Chromosome \"; //p(); &#125; &#125; bool operator&lt;(const Chromosome &amp;rhs) const &#123; //适应度好的保留下来 if(fitness == rhs.fitness) for(int i = 0;i &lt; N;i++) if(Gene[i] != rhs.Gene[i]) return Gene[i]&lt;rhs.Gene[i]; return fitness &lt; rhs.fitness; &#125; bool operator==(const Chromosome &amp;rhs)const &#123; return memcmp(Gene,rhs.Gene,sizeof(int)*N)==0; &#125; //变异 返回变异后的染色体 Chromosome Mutation() &#123; //随机交换两个基因 int t1 = Random(N - 1); int t2 = Random(N - 1); int *gene = new int[N]; memcpy(gene,Gene,sizeof(int)*N); swap(gene[t1],gene[t2]); Chromosome Chrom = Chromosome(gene); delete gene; //cout &lt;&lt; \"Mutation\" &lt;&lt; endl; //p(); //Chrom.p(); return Chrom; &#125; //交叉 交叉两个染色体 static void Crossover(Chromosome chrom1,Chromosome chrom2, Chromosome &amp;child1,Chromosome &amp;child2) &#123; // 选取交叉区间 0 [1-x) [x,y] (y,N-1] int y = Random(N - 1) + 1; int x = Random(y - 1) + 1; //cout &lt;&lt; \"[0,0] [1,\" &lt;&lt; x &lt;&lt; \") [\" &lt;&lt; x &lt;&lt; \",\" &lt;&lt; y &lt;&lt; \"] (\" &lt;&lt; y &lt;&lt; \",\" &lt;&lt; N - 1 &lt;&lt; \"]\" &lt;&lt; endl; int *gene1 = new int[N]; int *gene2 = new int[N]; memcpy(gene1,chrom1.Gene,sizeof(int)*N); memcpy(gene2,chrom2.Gene,sizeof(int)*N); map&lt;int,int&gt; m1; map&lt;int,int&gt; m2; for(int i = x; i &lt;= y; i++) &#123; m1.insert(make_pair(gene1[i],gene2[i])); m1.insert(make_pair(gene2[i],gene1[i])); int temp = gene1[i]; gene1[i] = gene2[i]; gene2[i] = temp; &#125; for(int i = 0; i &lt;= N - 1; i++) &#123; if(i &lt; x || i &gt; y) &#123; if(m2.count(gene1[i])) gene1[i] = m2[gene1[i]]; if(m1.count(gene2[i])) gene2[i] = m1[gene2[i]]; &#125; &#125; child1 = Chromosome(gene1); child2 = Chromosome(gene2); delete gene1; delete gene2; //cout &lt;&lt; \"Crossover:\" &lt;&lt; endl; //chrom1.p(); //chrom2.p(); //child1.p(); //child2.p(); //cout &lt;&lt; endl; &#125; //该个体是否能存活 bool Alive() &#123; if(Gene[0] != M) return false; bool *flag = new bool[N]; memset(flag,false,sizeof(bool)*N); for(int i = 0; i &lt; N; i++) if(flag[Gene[i]]) return false; else flag[Gene[i]] = true; delete flag; return true; &#125; //输出 void p() &#123; for(int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; Gene[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; \": \" &lt;&lt; \" Dis:\"&lt;&lt;fitness&lt;&lt;endl; &#125;&#125;;//初始化void Init() &#123; srand((int)time(NULL));&#125;Chromosome GA() &#123; //初始化 Init(); vector&lt;Chromosome&gt; P; //种群 P.clear(); //生成初始种群(两个祖宗) int *gene = new int[N]; for(int i = 0; i &lt; N; i++) gene[i] = i; swap(gene[M],gene[0]); P.push_back(Chromosome(gene)); for(int i = 0; i &lt; N; i++) gene[i] = N - i - 1; swap(gene[N - M - 1],gene[0]); P.push_back(Chromosome(gene)); sort(P.begin(),P.end()); for(int i = 0; i &lt;= T; i++) &#123; //第i代 cout &lt;&lt; \"T:\" &lt;&lt; i &lt;&lt; endl; //输出该代信息 int size = P.size(); for(int j = 0; j &lt; size; j++) P[j].p(); cout &lt;&lt; \"Output finish\" &lt;&lt; endl; if(i!=T)&#123; //本代个体交配 for(int x = 0; x &lt; size; x++) for(int y = x + 1; y &lt; size; y++) &#123; Chromosome child1; Chromosome child2; Chromosome::Crossover(P[x],P[y],child1,child2); if(child1.Alive()) P.push_back(child1); if(child2.Alive()) P.push_back(child2); &#125; cout &lt;&lt; \"Crossover Finish\" &lt;&lt; endl; //变异 size = P.size(); for(int x = 0; x &lt; size; x++) &#123; if(Probability() &lt;= eps + Mutation_Probability) &#123; Chromosome temp; temp = P[x].Mutation(); if(temp.Alive() ) P.push_back(temp); &#125; &#125; //适者生存 sort(P.begin(),P.end()); P.erase(unique(P.begin(),P.end()),P.end()); if(P.size() &gt; P_SIZE) cout &lt;&lt; \"Kill \" &lt;&lt; P.size() - P_SIZE &lt;&lt; endl; while(P.size() &gt; P_SIZE) P.pop_back(); cout &lt;&lt; endl; &#125; &#125; delete gene; return P[0];&#125;int main() &#123; freopen(\"in.txt\",\"r\",stdin); //freopen(\"out.txt\",\"w\",stdout); /* Sample Input 3 0 0 17 81 17 0 62 81 62 0 8 3 0 17 81 21 43 12 56 76 17 0 62 22 67 45 78 13 81 62 0 98 11 65 27 62 21 22 98 0 27 88 52 18 43 67 11 27 0 76 13 72 12 45 65 88 76 0 47 33 56 78 27 52 13 47 0 11 76 13 62 18 72 33 11 0 */ cout &lt;&lt; \"Input the number of the cities:\"; cin &gt;&gt; N; cout &lt;&lt; \"Input the begin city(0~n-1):\"; cin &gt;&gt; M; cout &lt;&lt; \"Input the distance between two city(include city x with x):\" &lt;&lt; endl; for(int i = 0; i &lt; N; i++) for(int j = 0; j &lt; N; j++) cin &gt;&gt; Distance[i][j]; cout &lt;&lt; \"Distance:\" &lt;&lt; endl; for(int i = 0; i &lt; N; i++) &#123; for(int j = 0; j &lt; N; j++) cout &lt;&lt; Distance[i][j] &lt;&lt; \" \"; cout &lt;&lt; endl; &#125; Chromosome Chrom = GA(); cout &lt;&lt; \"The best answer is:\"; for(int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; Chrom.Gene[i] &lt;&lt; \" \"; &#125; int dis = Distance[Chrom.Gene[N - 1]][Chrom.Gene[0]]; for(int i = 0; i &lt; N - 1; i++) dis += Distance[Chrom.Gene[i]][Chrom.Gene[i + 1]]; cout &lt;&lt; \" Distance: \" &lt;&lt; dis &lt;&lt; endl; return 0;&#125;","tags":[{"name":"遗传算法","slug":"Genetic-Algorithm","permalink":"https://www.oyohyee.com/tags/Genetic-Algorithm/"},{"name":"TSP","slug":"TSP","permalink":"https://www.oyohyee.com/tags/TSP/"}]},{"title":"使用 Python 写 OJ 题目格式生成工具","date":"2016-12-10T12:20:52.000Z","path":"/post/Note/python_problem_format.html","text":"使用正则表达式将文本分割开,然后拼接成应该的格式 转码成 utf-8 输出出来 算是第一次学 Python 吧学习了下一些基本的语法 格式转换#coding:utf-8# -*- coding: utf-8 -*-import reimport timeimport urllib.request# 格式str1=\"\"\"&#123;% raw %&#125;&lt;div&gt; &lt;div class=\"oj\"&gt; &lt;div class=\"part\" title=\"Description\"&gt;&#123;% endraw %&#125; $&#123;% raw %&#125; &lt;/div&gt; &lt;div class=\"part\" title=\"Input\"&gt;&#123;% endraw %&#125; $&#123;% raw %&#125; &lt;/div&gt; &lt;div class=\"part\" title=\"Output\"&gt;&#123;% endraw %&#125; $&#123;% raw %&#125; &lt;/div&gt; &lt;div class=\"samp\"&gt; &lt;div class=\"clear\"&gt;&lt;/div&gt; &lt;div class=\"input part\" title=\"Sample Input\"&gt;&#123;% endraw %&#125; $&#123;% raw %&#125; &lt;/div&gt; &lt;div class=\"output part\" title=\"Sample Output\"&gt;&#123;% endraw %&#125; $&#123;% raw %&#125; &lt;/div&gt; &lt;div class=\"clear\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endraw %&#125;\"\"\"# 删除空行def d1(str): str=str.replace('\\n\\n','') return strdef d2(str): str=str.replace('\\n\\n','\\n') return str# 末尾加两个空格def k(str): p = re.compile(r'\\n') line = p.split(str) str='' for i in range(0,len(line)): str+=line[i]+' \\n' return str# 获取时间def GetNowTime(): return time.strftime(\"%Y-%m-%d %H:%M:%S\",time.localtime(time.time()))#====================================## main ##====================================## 读入内容str2 = ''f = open('in.txt')while True: line = f.readline() if len(line) == 0: break str2 += line+'\\n'f.close()p = re.compile(r'\\$')p2 = re.compile(r'Input|Output|Sample Input|Sample Output')ss=p.split(str1)ss2 = p2.split(str2)str0=''for i in range(0,5): if i &lt; 3: ss2[i] = k(d1(ss2[i])) else: ss2[i] = k(d2(ss2[i]))for i in range(0, 5): str0 += ss[i] + ss2[i]str0 += ss[5]oj = input(\"输入OJ名称:\")num = input(\"输入题目编号:\")name = input(\"输入题目名称:\")title = '---\\ntitle: '+oj+\" \"+num+\".\"+name+\"\\ndate: \"+GetNowTime()+\"\\ncategories: \"+'题解'+\"\\ntags:\\n - \"+oj+\"\\n---\\n\\n# \"+'题目'+\"\\n\"url = \"https://github.com/OhYee/sourcecode.io/blob/master/\"+oj+\"/\"+num+\".\"+name+\".cpp\"url = urllib.request.quote(url)code = \"\\n\\n# 题解\\n\\n\\n\\n# 代码\\n```cpp \"+ name + url+\" 代码备份\\n\\n```\"# 强制转换为 utf8ans = title + str0 +codeans = ans.encode('UTF-8').decode('GBK')f = open('in.txt', 'w')f.write(ans) f.close()","tags":[{"name":"Python","slug":"Python","permalink":"https://www.oyohyee.com/tags/Python/"}]},{"title":"HDU 5982.Relic Discovery(2016 CCPC 青岛 A)","date":"2016-12-10T08:58:07.000Z","path":"/post/HDU/5982.html","text":"题目 点击显/隐题目 Recently, paleoanthropologists have found historical remains on an island in the Atlantic Ocean. The most inspiring thing is that they excavated in a magnificent cave and found that it was a huge tomb. Inside the construction,researchers identified a large number of skeletons, and funeral objects including stone axe, livestock bones and murals. Now, all items have been sorted, and they can be divided into N types. After they were checked attentively, you are told that there are Ai items of the i-th type. Further more, each item of the i-th type requires Bi million dollars for transportation, analysis, and preservation averagely. As your job, you need to calculate the total expenditure. The first line of input contains an integer T which is the number of test cases. For each test case, the first line contains an integer N which is the number of types. In the next N lines, the i-th line contains two numbers Ai and Bi as described above. All numbers are positive integers and less than 101. For each case, output one integer, the total expenditure in million dollars. 121 23 4 14 题解看样例基本就是对于 T 组数据每组数据有 n 组 A 和 B求这 n 组 A * B 读题验证思路无误 代码点击显/隐Relic Discovery代码备份/**#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123;#ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock();#endif int T; cin &gt;&gt; T; while (T--) &#123; int n, sum = 0; cin &gt;&gt; n; while (n--) &#123; int A, B; cin &gt;&gt; A &gt;&gt; B; sum += A * B; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125;#ifdef debug printf(\"Time:%.3f s.\\n\", double(clock() - START) / CLOCKS_PER_SEC);#endif return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"CCPC","slug":"CCPC","permalink":"https://www.oyohyee.com/tags/CCPC/"}]},{"title":"VS Code 便携环境配置","date":"2016-12-10T07:08:26.000Z","path":"/post/Note/vscode.html","text":"关键词: U盘写Hexo博客 | U盘编译C/C++ | U盘编译Python支持 node.jsHexoGitPythonMinGW 在 Hexo + C++ 便携套装 里,介绍了将 VS Code portable 化的基础思路经过改进,将该功能改的更加完美 Github 准备工作由于需要的文件过大,不提供直接下载,请根据思路自行配置自己需要的部分 获取需要的文件首先,可以得知,类似 Git、MinGW 安装后,都是通过加入到环境变量里后,通过命令行调用的,因此我们完全可以通过将U盘路径加入到命令行里来实现在U盘配置自己的环境从各个官网获取需要的程序,正常安装,然后将安装文件夹整个拷贝到U盘里,卸载电脑上的程序,我们就获得了文件的主体(当然,如果能够直接下载 zip 更好,不过有个功能不太全) 目录结构取得需要的文件后,目录如下: Portable //主目录 Code //代码文件夹,一般可以将该文件夹整个备份到git上 Blog //博客文件夹 node_modules //hexo 主文件 Support //需要加到环境变量里的文件 Git //用来给VS Code提供git 同时Hexo也用得到 nodejs //Hexo需要 MinGW //编译C/C++需要 Python //写Python需要 ssh //备份的ssh,用来在其他电脑上连接git VS Code //编辑器 resources app extensions //VS Code 插件文件夹 具体操作Hexo的配置需要node.js和Git编译C/C++需要MinGW 关于配置环境方面,各个部分是一样的,只举一种例子.以 Hexo 为例,按照上面的部分下载完成后,放到该放的地方上. Hexo在 Portable\\Code\\Blog 文件夹里初始化 Hexo (如果没有安装 Hexo 组件,安装到这个文件夹里)或者将自己已经有的博客文件拷贝进来也行 在博客主目录下写文件 portable\\run.batrun.batset path=%path%;%cd%\\Support\\git\\set path=%path%;%cd%\\Support\\git\\bin\\set path=%path%;%cd%\\Support\\nodejs\\set path=%path%;%cd%\\Support\\node_modules\\npm\\set path=%path%;%cd%\\Support\\node_modules\\npm\\bin\\set path=%path%;%cd%\\Support\\MinGW\\bin\\set path=%path%;%cd%\\Support\\MinGW\\lib\\set path=%path%;%cd%\\Support\\MinGW\\include\\set path=%path%;%cd%\\Support\\Python\\set path=%path%;%cd%\\Support\\cmder\\cd VS Codestart Code.exe ../Codeexit 这样u盘里的文件对于 VS Code 就被加到环境变量里了(仅对于VSCode和从VSCode启动的程序)那么,理论上而言,剩下的就和正常的一样了Ctrl + `调用VS Code里的控制台,通过这个控制台来写hexo的那些命令,或者通过这个控制台启动外部的控制台也行 编译编译需要安装相应的插件,先在VS Code里下好插件,到{USER}\\.vscode\\extensions里将插件移动到 \\portable\\VS Code\\resources\\app\\extensions即可(插件列表里会消失,不过不影响使用) Python的不需要配置C/C++需要配置下 我这里用了两个不同的C/C++编译方式,使用VS Code的Debug和自己写的bat在 tasks.json 里写了多个不同指令的任务,目测没有bug以下给出配置 launch.json&#123; \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"C++ Launch (GDB)\", // 配置名称，将会在启动配置的下拉菜单中显示 \"type\": \"cppdbg\", // 配置类型，这里只能为cppdbg \"request\": \"launch\", // 请求配置类型，可以为launch（启动）或attach（附加） \"launchOptionType\": \"Local\", // 调试器启动类型，这里只能为Local \"targetArchitecture\": \"x86\", // 生成目标架构，一般为x86或x64，可以为x86, arm, arm64, mips, x64, amd64, x86_64 \"program\": \"$&#123;file&#125;.exe\", // 将要进行调试的程序的路径 \"miDebuggerPath\":\"$&#123;cwd&#125;\\\\..\\\\support\\\\MinGW\\\\bin\\\\gdb.exe\", // miDebugger的路径，注意这里要与MinGw的路径对应 \"args\": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 \"stopAtEntry\": false, // 设为true时程序将暂停在程序入口处，一般设置为false \"cwd\": \"$&#123;workspaceRoot&#125;\", // 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125;即代码所在目录 \"externalConsole\": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 \"preLaunchTask\": \"g++\" // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc &#125;, &#123; \"name\": \"Python\", \"type\": \"python\", \"request\": \"launch\", \"stopOnEntry\": true, \"program\": \"$&#123;file&#125;\", \"debugOptions\": [ \"WaitOnAbnormalExit\", \"WaitOnNormalExit\", \"RedirectOutput\" ] &#125;, &#123; \"name\": \"Python Console App\", \"type\": \"python\", \"request\": \"launch\", \"stopOnEntry\": true, \"program\": \"$&#123;file&#125;\", \"externalConsole\": true, \"debugOptions\": [ \"WaitOnAbnormalExit\", \"WaitOnNormalExit\" ] &#125;, &#123; \"name\": \"Django\", \"type\": \"python\", \"request\": \"launch\", \"stopOnEntry\": true, \"program\": \"$&#123;workspaceRoot&#125;/manage.py\", \"args\": [ \"runserver\", \"--noreload\" ], \"debugOptions\": [ \"WaitOnAbnormalExit\", \"WaitOnNormalExit\", \"RedirectOutput\", \"DjangoDebugging\" ] &#125;, &#123; \"name\": \"Watson\", \"type\": \"python\", \"request\": \"launch\", \"stopOnEntry\": true, \"program\": \"$&#123;workspaceRoot&#125;/console.py\", \"args\": [ \"dev\", \"runserver\", \"--noreload=True\" ], \"debugOptions\": [ \"WaitOnAbnormalExit\", \"WaitOnNormalExit\", \"RedirectOutput\" ] &#125; ]&#125; tasks.json&#123; \"version\": \"0.1.0\", \"command\": \" \",//需要多个指令 因此留空 以下面的参数为指令 \"isShellCommand\": true, \"showOutput\": \"always\", \"echoCommand\": false, \"suppressTaskName\": true, \"tasks\": [ &#123; \"taskName\": \"g++\", //\"command\": \"g++\", \"args\": [\"g++\",\"-g\",\"$&#123;file&#125;\",\"-o\",\"$&#123;file&#125;.exe\"], // 编译命令参数 \"problemMatcher\": &#123; \"owner\": \"cpp\", \"fileLocation\": [\"relative\", \"$&#123;workspaceRoot&#125;\"], \"pattern\": &#123; \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\", \"file\": 1, \"line\": 2, \"column\": 3, \"severity\": 4, \"message\": 5 &#125; &#125; &#125;, &#123; \"taskName\": \"compile\", //\"command\": \"compile.bat\", \"args\": [\"compile.bat\",\"$&#123;file&#125;\"], // 编译命令参数 \"problemMatcher\": &#123; \"owner\": \"cpp\", \"fileLocation\": [\"relative\", \"$&#123;workspaceRoot&#125;\"], \"pattern\": &#123; \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\", \"file\": 1, \"line\": 2, \"column\": 3, \"severity\": 4, \"message\": 5 &#125; &#125; &#125;, &#123; \"taskName\": \"echo\", \"args\": [\"echo\",\"$&#123;workspaceRoot&#125;/.vscode/.clang-format\"] // 编译命令参数 &#125; ]&#125; 下面两个是我自己写的通过bat编译,运行完会自己暂停,并且会自动删除生成的exe放在 code 文件夹里 compile.bat@Echo offecho Beginset path=%path%;%cd%\\..\\Support\\MinGW\\bin\\;%cd%\\..\\Support\\MinGW\\lib\\;%cd%\\..\\Support\\MinGW\\include\\if exist %1.exe del %1.exe g++ -g -Wall -std=c++11 %1 -o %1.exe ::if exist %1.exe %1.exeif exist %1.exe start run.bat %1 /B /cecho Finished run.bat@Echo off%1.exepausedel %1.exe exit 另外 .vscode 里的 setting.json 是对该工作区有效的,因此相当于我们直接把配置文件放到了U盘里不过键盘映射必须要在 {USER}\\.vscode 目录可以自己写一个bat自动拷贝键盘映射文件另外ssh文件也可以这样实现 放在portable文件夹里 如下keybindings_copy.batcopy /D /Y %cd%\\Code\\.vscode\\keybindings.json %USERPROFILE%\\AppData\\Roaming\\Code\\User\\keybindings.jsonexit keybindings_delete.batcopy /D /Y %USERPROFILE%\\AppData\\Roaming\\Code\\User\\keybindings.json %cd%\\Code\\.vscode\\keybindings.jsondel %USERPROFILE%\\AppData\\Roaming\\Code\\User\\keybindings.jsonexit ssh_backup.batcopy /D /Y %USERPROFILE%\\.ssh\\id_rsa %USERPROFILE%\\.ssh\\id_rsa.backupcopy /D /Y %USERPROFILE%\\.ssh\\id_rsa.pub %USERPROFILE%\\.ssh\\id_rsa.pub.backupcopy /D /Y %cd%\\ssh\\id_rsa %USERPROFILE%\\.ssh\\id_rsacopy /D /Y %cd%\\ssh\\id_rsa.pub %USERPROFILE%\\.ssh\\id_rsa.pub ssh_del.batcopy /D /Y %USERPROFILE%\\.ssh\\id_rsa.backup %USERPROFILE%\\.ssh\\id_rsacopy /D /Y %USERPROFILE%\\.ssh\\id_rsa.pub.backup %USERPROFILE%\\.ssh\\id_rsa.pub del %USERPROFILE%\\.ssh\\id_rsa.backupdel %USERPROFILE%\\.ssh\\id_rsa.pub.backup Git在有些电脑上,Git可能会由于ssh证书的问题无法连接 提示 error setting certificate verify locations 可以使用 git config --system http.sslverify false 解决","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.oyohyee.com/tags/Hexo/"},{"name":"vscode","slug":"vscode","permalink":"https://www.oyohyee.com/tags/vscode/"},{"name":"Python","slug":"Python","permalink":"https://www.oyohyee.com/tags/Python/"},{"name":"MinGW","slug":"MinGW","permalink":"https://www.oyohyee.com/tags/MinGW/"}]},{"title":"给 Hexo 加上 bootstrap 的一些特效 &amp;&amp; jquery 实现隐藏功能","date":"2016-12-08T16:57:29.000Z","path":"/post/Note/New_function.html","text":"查东西的时候看到了 Bootstrap 的特效,觉得非常好看,就像把里面的一些功能加到 Hexo 的 Next 主题里(有别的主题是自带 Bootstrap 的,不过 Next 已经被修改了好多,不想在折腾了【虽然有折腾了一晚上】) 加了一些好看的标签,同时修改了 Next 自带的 code 标签 效果展示效果如下： 各种颜色的标签: red sky orange blue green 单行代码框: int num; 按键框 Ctrl + A 并且新版的 Next 主题内建标签有了这种 note deafult - primary success - info warning - danger 然后又顺手重新弄了下 OJ 题目的 CSS (稍微好看了那么一点)美化完又增加了按键隐藏功能(毕竟题目和代码真长……) 效果如下： 点击显/隐 There is a kindom of obsession, so people in this kingdom do things very strictly. They name themselves in integer, and there are n people with their id continuous (s+1,s+2, ,s+n) standing in a line in arbitrary order, be more obsessively, people with id x wants to stand at yth position which satisfy x mod y=0 Is there any way to satisfy everyone’s requirement First line contains an integer T, which indicates the number of test cases. Every test case contains one line with two integers n, s. Limits1≤T≤100.1≤n≤109.0≤s≤109. For every test case, you should output ‘Case #x: y’, where x indicates the case number and counts from 1 and y is the result string. If there is any way to satisfy everyone’s requirement, y equals ‘Yes’, otherwise y equals ‘No’. 25 144 11 Case #1: NoCase #2: Yes 点击显/隐 There is a kindom of obsession, so people in this kingdom do things very strictly. They name themselves in integer, and there are n people with their id continuous (s+1,s+2, ,s+n) standing in a line in arbitrary order, be more obsessively, people with id x wants to stand at yth position which satisfy x mod y=0 Is there any way to satisfy everyone’s requirement First line contains an integer T, which indicates the number of test cases. Every test case contains one line with two integers n, s. Limits1≤T≤100.1≤n≤109.0≤s≤109. For every test case, you should output ‘Case #x: y’, where x indicates the case number and counts from 1 and y is the result string. If there is any way to satisfy everyone’s requirement, y equals ‘Yes’, otherwise y equals ‘No’. 25 144 11 Case #1: NoCase #2: Yes 点击显/隐123123#include &lt;cstdio&gt;#include &lt;cstdio&gt;#include &lt;cstdio&gt;#include &lt;cstdio&gt;#include &lt;cstdio&gt; 点击显/隐123123#include &lt;cstdio&gt;#include &lt;cstdio&gt;#include &lt;cstdio&gt;#include &lt;cstdio&gt;#include &lt;cstdio&gt; 思路CSS 部分就是简单的 CSS 代码只不过是想练下 :after 和 :before(觉得每次写浮动,都要蛋疼好久)隐藏和显示则是使用了jquery的一些功能仔细想一下,其实好久之前就写过这些功能,只不过好久没有碰过,忘完了…… 其实就是一个非常简单的选择器的一些操作而已不过又踩了关于 js 文件加载顺序的坑如果写jquery函数的话,一定要确保加载完毕(可以在新的文件里写jquery部分) 具体代码具体代码见文件/js/My.js/js/after_jquery.js/css/My.css OJ 题目格式使用如下:OJ题目&#123;% raw %&#125;&lt;div&gt; &lt;div class=\"oj\"&gt; &lt;div class=\"part\" title=\"Description\"&gt;&#123;% endraw %&#125; &lt;!--题面--&gt;&#123;% raw %&#125; &lt;/div&gt; &lt;div class=\"part\" title=\"Input\"&gt;&#123;% endraw %&#125; &lt;!--输入解释--&gt;&#123;% raw %&#125; &lt;/div&gt; &lt;div class=\"part\" title=\"Output\"&gt;&#123;% endraw %&#125; &lt;!--输出解释--&gt;&#123;% raw %&#125; &lt;/div&gt; &lt;div class=\"samp\"&gt; &lt;div class=\"clear\"&gt;&lt;/div&gt; &lt;div class=\"input part\" title=\"Sample Input\"&gt;&#123;% endraw %&#125; &lt;!--样例输入部分--&gt;&#123;% raw %&#125; &lt;/div&gt; &lt;div class=\"output part\" title=\"Sample Output\"&gt;&#123;% endraw %&#125; &lt;!--样例输出--&gt;&#123;% raw %&#125; &lt;/div&gt; &lt;div class=\"clear\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endraw %&#125;","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.oyohyee.com/tags/Hexo/"},{"name":"javascript","slug":"Javascript","permalink":"https://www.oyohyee.com/tags/Javascript/"},{"name":"jquery","slug":"jquery","permalink":"https://www.oyohyee.com/tags/jquery/"},{"name":"CSS","slug":"CSS","permalink":"https://www.oyohyee.com/tags/CSS/"},{"name":"bootstrap","slug":"bootstrap","permalink":"https://www.oyohyee.com/tags/bootstrap/"}]},{"title":"HDU 5943.Kingdom of Obsession(2016 CCPC 杭州 K)","date":"2016-12-05T17:28:58.000Z","path":"/post/HDU/5943.html","text":"题目 点击显/隐题目 There is a kindom of obsession, so people in this kingdom do things very strictly. They name themselves in integer, and there are n people with their id continuous (s+1,s+2, ,s+n) standing in a line in arbitrary order, be more obsessively, people with id x wants to stand at yth position which satisfy x mod y=0 Is there any way to satisfy everyone’s requirement First line contains an integer T, which indicates the number of test cases. Every test case contains one line with two integers n, s. Limits 1≤T≤100.1≤n≤109.0≤s≤109. For every test case, you should output ‘Case #x: y’, where x indicates the case number and counts from 1 and y is the result string. If there is any way to satisfy everyone’s requirement, y equals ‘Yes’, otherwise y equals ‘No’. 25 144 11 Case #1: NoCase #2: Yes 题解题意比较容易理解,对于 [s+1,s+n] 这 n 个人,将他们放置在 [1,n] 这些位置上其中 编号为 x 的人 只能放在位置 y 上,有 x mod y = 0 按照样例自己在纸上花出来,可以发现就是 二分图匹配对于一组数据判断是否能够做到 最佳完美匹配 看数据量可以发现数据高达 109然而,根据经验可知,随着数的增大,两个素数之间的距离会变大,但对于 109 的数据量,间距仍然是一个确定的值当需要运算的区间 有多个素数时,显然可以直接输出 “No”(都要放在 1 的位置上) 因此,一个比较可行的思路是先判断下是否有多个素数,如果有可能有解的情况下,使用 匈牙利算法 进行计算 关于判断是否有多个思路,有两种思路: 对于一组数据的每一个数据都进行判断是否为素数,当找到 2 个以上时,直接跳出循环 找到 109 素数间隔的最大值,只在小于时计算 首先假设最大的间隔为 Max对于第一种思路,采用 费马小定理 每次判断的时间复杂度为 log(n)^2一组数据最坏要查询 Max 次而直接判断显然可以忽略这个时间 而由于匈牙利算法的时间复杂度为 O(nm) 显然,只有 Max 较大的情况下,方案 1 更好(已经可以预知,不管怎么样,如果方案 2 都超时,方案 1 必定超时) 根据查表, 109 的素数最大间隔还不到 300 因此大于 300 直接输出 “No” 即可对于小于 300 的情况直接使用是匈牙利算法即可 有一点需要特别注意: [s+1,s+n] 和 [1,n] 有可能存在重合区间对于重合部分,无论有多少素数,都没关系(自己对自己取余为 0 ) 因此,二分图处理的部分应该是不重合的部分(找因子的时候,直接使用本身比使用它的一个因子更“划算”)假设有重合区域,则重合区域应该为 [s+1,n]因此应该对 [1,s+1) 和 (n,s+n] 区域求二分图匹配也即对 [1,s] 和 [n+1,n+s] 区域求二分图匹配,恰好就是交换 s 和 n也就是说,当 n&gt;=s+1 (s&lt;n) 时交换两者,就可以避过重合问题(当然,通过其他的判断也可以解决) 代码点击显/隐代码Kingdom of Obsession代码备份/*#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;using namespace std;typedef long long LL;/* * 匈牙利算法邻接表形式 * 使用前用init()进行初始化，给uN赋值* 加边使用函数addedge(u,v) */ const int MAXN = 2005;//点数的最大值 const int MAXM = MAXN*MAXN;//边数的最大值 struct Edge &#123; int to,next; &#125;edge[MAXM]; int head[MAXN],tot,uN; void init(int un) &#123; uN = un; tot = 0; memset(head,-1,sizeof(head)); &#125; void addedge(int u,int v) &#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++; &#125; int linker[MAXN]; bool used[MAXN]; bool dfs(int u) &#123; for(int i = head[u]; i != -1;i = edge[i].next)&#123; int v = edge[i].to; if(!used[v])&#123; used[v] = true; if(linker[v] == -1 || dfs(linker[v]))&#123; linker[v] = u; return true; &#125; &#125; &#125; return false;&#125;int hungary()&#123; int res = 0; memset(linker,-1,sizeof(linker)); for(int u = 0; u &lt; uN;u++)&#123;//点的编号0~uN-1 memset(used,false,sizeof(used)); if(dfs(u)) res++; &#125; return res;&#125; bool Solve(int n,int s)&#123; if(s&lt;n) swap(s,n); if(n&gt;1000) return false; //匈牙利算法 求解二分图 init(n); for(int i=1;i&lt;=n;i++)&#123; LL t = (LL)i+(LL)s; for(int j=1;j&lt;=n;j++)&#123; if(t%j==0) addedge(j-1,i-1); &#125; &#125; //cout&lt;&lt;hungary()&lt;&lt;endl; return hungary()==n;&#125;int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif int T; cin&gt;&gt;T; for(int kase=1;kase&lt;=T;kase++)&#123; int n,s; cin&gt;&gt;n&gt;&gt;s; cout&lt;&lt;\"Case #\"&lt;&lt;kase&lt;&lt;\": \"&lt;&lt;(Solve(n,s)?\"Yes\":\"No\")&lt;&lt;endl; &#125; #ifdef debug printf(\"Time:%.3lfs\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"质数","slug":"Prime","permalink":"https://www.oyohyee.com/tags/Prime/"},{"name":"二分图匹配","slug":"Bipartite-Matching","permalink":"https://www.oyohyee.com/tags/Bipartite-Matching/"},{"name":"匈牙利算法","slug":"Hungary","permalink":"https://www.oyohyee.com/tags/Hungary/"},{"name":"CCPC","slug":"CCPC","permalink":"https://www.oyohyee.com/tags/CCPC/"}]},{"title":"HDU 2063.过山车","date":"2016-12-05T16:55:51.000Z","path":"/post/HDU/2063.html","text":"题目 Description RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？ Input 输入数据的第一行是三个整数K , M , N，分别表示可能的组合数目，女生的人数，男生的人数。0&lt;K&lt;=10001&lt;=N 和M&lt;=500.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个0结束输入。 Output 对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。 Sample Input 6 3 31 11 21 32 12 33 10 Sample Output 3 题解二分图匹配模板题.测试模板的使用方法 代码过山车代码备份/*#define debug#include &lt;ctime&gt;//*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;/* * 匈牙利算法邻接表形式 * 使用前用init()进行初始化，给uN赋值* 加边使用函数addedge(u,v) */ const int MAXN = 1005;//点数的最大值 const int MAXM = 1005;//边数的最大值 struct Edge &#123; int to,next; &#125;edge[MAXM]; int head[MAXN],tot,uN; void init(int un) &#123; uN = un; tot = 0; memset(head,-1,sizeof(head)); &#125; void addedge(int u,int v) &#123; //cout&lt;&lt;\"add\"&lt;&lt;u&lt;&lt;\" \"&lt;&lt;v&lt;&lt;endl; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++; &#125; int linker[MAXN]; bool used[MAXN]; bool dfs(int u) &#123; for(int i = head[u]; i != -1;i = edge[i].next)&#123; int v = edge[i].to; if(!used[v])&#123; used[v] = true; if(linker[v] == -1 || dfs(linker[v]))&#123; linker[v] = u; return true; &#125; &#125; &#125; return false;&#125;int hungary()&#123; int res = 0; memset(linker,-1,sizeof(linker)); for(int u = 0; u &lt; uN;u++)&#123;//点的编号0~uN-1 memset(used,false,sizeof(used)); if(dfs(u)) res++; &#125; return res;&#125; int Solve(int n,int girl,int boy)&#123; init(girl); for(int i=0;i&lt;n;i++)&#123; int u,v; cin&gt;&gt;u&gt;&gt;v; addedge(u-1,v-1); &#125; return hungary();&#125;int main()&#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif int n,girl,boy; while(cin&gt;&gt;n&gt;&gt;girl&gt;&gt;boy,n!=0) cout&lt;&lt;Solve(n,girl,boy)&lt;&lt;endl; #ifdef debug printf(\"Time:%.3lfs\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"二分图匹配","slug":"Bipartite-Matching","permalink":"https://www.oyohyee.com/tags/Bipartite-Matching/"},{"name":"匈牙利算法","slug":"Hungary","permalink":"https://www.oyohyee.com/tags/Hungary/"}]},{"title":"Hexo 黑色主题","date":"2016-12-05T11:57:06.000Z","path":"/post/Note/BlackTheme.html","text":"想搭下黑色主题的 Next然而都说不好看哭记录下改动: black.css","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.oyohyee.com/tags/Hexo/"}]},{"title":"HDU 5937.Equation(2016 CCPC 杭州 E)","date":"2016-11-28T13:07:01.000Z","path":"/post/HDU/5937.html","text":"题目 Description Little Ruins is a studious boy, recently he learned addition operation! He was rewarded some number bricks of 1 to 9 and infinity bricks of addition mark ‘+’ and equal mark ‘=’. Now little Ruins is puzzled by those bricks because he wants to put those bricks into as many different addition equations form x+y=z as possible. Each brick can be used at most once and x, y, z are one digit integer. As Ruins is a beginer of addition operation, x, y and z will be single digit number. Two addition equations are different if any number of x, y and z is different. Please help little Ruins to calculate the maximum number of different addition equations. Input First line contains an integer T, which indicates the number of test cases. Every test case contains one line with nine integers, the ith integer indicates the number of bricks of i. Limits1≤T≤300≤bricks number of each type≤100 Output For every test case, you should output ‘Case #x: y’, where x indicates the case number and counts from 1 and y is the result. Sample Input 31 1 1 1 1 1 1 1 12 2 2 2 2 2 2 2 20 3 3 0 3 0 0 0 0 Sample Output Case #1: 2Case #2: 6Case #3: 2 题解有技巧的暴力,就不算暴力了 历时超长的一道题,如果不是知道思路没问题,估计中途就想办法用其他方法了 题目的意思就是给任意数目的 1-9 9个数字,使尽可能多的凑 a+b=c 的式子其中 a、b、c 必须是 1-9 的数字,并且 a+b=c 和 b+a=c 被看成是两个不同的式子 首先,很容易发现,总共只有 36 种选择,因此可以尝试使用搜索解决 不考虑时间,思路如下:暴力 DFS 搜索,遍历所有的情况,判断所有情况中递归的最大深度时间复杂度 O(236) 优化:显然,这样写超时会非常严重 对于遍历次数的优化仔细跟着思路模拟一下,会发现,对于 a+b=c 和 b+a=c 的情况,他们属于可以把 a+b=c 选择两次的情况而直接遍历 36 种可能显然把 a+b=c 只选一次的情况 遍历了两次因此,这里可以先标记下然后再进行判断,如果 a+b=c 不在 DFS 递归的栈里(已经遍历过只选一次的分支),那么不再遍历 b+a=c 剪枝 当深度大于等于 36 的时候,显然已经找到答案了,可以直接返回 如果把现在所有的数字除以 3 (每个式子有 3 个数字) 再加上已经遍历的深度都不可能比已有答案大,显然可以直接返回 如果把当前已经遍历的深度(已选择的式子数目),和剩下能遍历的深度加起来都没有已有答案大,可以直接返回 预处理预处理到每个深度,其以后所有式子需要的每个数字的个数.当发现数字足够时,直接返回返回答案 这样处理后,不管是数字总体比较少(直接爆搜也很快)还是数字数目比较多(由于数字数目多,所以预处理可以解决许多情况,并且剪枝可以进一步减少搜索量),都可以较快地搜到答案 对于这道题,其数据量处于爆搜能够解决的边缘范围,因此采用一定的搜索技巧可以达到时间要求而搜索的技巧就是上面的三种而其中剪枝分为 可行性剪枝 和 最优性剪枝 注释比较详细 代码Equation代码备份//#define debug//#include &lt;ctime&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int Left[37][10];int lis[36][3];//记录对应的等式是否在这支dfs树枝上//0 (1,2) (1,3) (1,4) (1,5) (1,6) (1,7) (1,8)//7 (2,3) (2,4) (2,5) (2,6) (2,7) //12 (3,4) (3,5) (3,6)//15 (4,5)bool vis[16];#define Flag(a,b) (vis[(8*(a-1)-(a-1)*(a-1))+(b-a-1)])int num[10];int deep;void Debug(int n, int m) &#123; return; for (int i = 0; i &lt; n; i++) cout &lt;&lt; \" \"; cout&lt;&lt;n&lt;&lt;\" \"&lt;&lt;lis[m][0]&lt;&lt;\"+\"&lt;&lt;lis[m][1]&lt;&lt;\"=\"&lt;&lt;lis[m][2]; cout&lt;&lt;\"\\t\\t\\t\\t\\t deep:\"&lt;&lt;n&lt;&lt;\" p:\"&lt;&lt;m&lt;&lt;\"\\t\"; for(int i=1;i&lt;=9;i++) cout&lt;&lt;num[i]&lt;&lt;\" \"; cout&lt;&lt;endl;&#125;void dfs(int p, int d, int cnt) &#123; // 剪枝 if (d == 36 || deep ==36) return;// 不可能有更优情况 if (cnt/3+d &lt;= deep) return;// 所有数字全用上也无法最优 if (d+36-p &lt;= deep) return;//剩下的组合都能用上都不可能更优 //如果有预处理能解决的问题,直接返回答案 bool Ok = true; for(int i=1;i&lt;=9;i++)&#123; if(num[i] &lt; Left[p][i])&#123; Ok = false; break; &#125; &#125; if(Ok)&#123; deep = max(deep,d+36-p); return; &#125; deep = max(d,deep); for (int i = p; i &lt; 36; i++) &#123; num[lis[i][0]]--; num[lis[i][1]]--; num[lis[i][2]]--; if (num[lis[i][0]]&gt;=0 &amp;&amp; num[lis[i][1]]&gt;=0 &amp;&amp; num[lis[i][2]]&gt;=0)&#123; Debug(d + 1, i); if(lis[i][0] &lt; lis[i][1])&#123; Flag(lis[i][0],lis[i][1]) = true; dfs(i + 1, d + 1, cnt - 3); Flag(lis[i][0],lis[i][1]) = false; &#125;else&#123; if(lis[i][0] == lis[i][1] || (lis[i][0] &gt; lis[i][1] &amp;&amp; Flag(lis[i][1],lis[i][0]) == true) ) dfs(i + 1, d + 1, cnt - 3); &#125; &#125; num[lis[i][0]]++; num[lis[i][1]]++; num[lis[i][2]]++; &#125;&#125;//预处理void Pre()&#123; //init memset(vis,false,sizeof(vis)); //预处理表 int pos = 0; for(int i=1;i&lt;=9;i++) for(int j=1;j&lt;=9;j++) if(i+j&lt;10)&#123; lis[pos][0] = i; lis[pos][1] = j; lis[pos++][2] = i+j; &#125;else&#123; break; &#125; //预处理结果 memset(Left[36],0,sizeof(Left[36])); for(int i=35;i&gt;=0;i--)&#123; for(int j=1;j&lt;=9;j++)&#123; Left[i][j] = Left[i+1][j]; &#125; for(int j=0;j&lt;3;j++) Left[i][lis[i][j]]++; &#125; //预处理显示 /* cout&lt;&lt;\"lis\"&lt;&lt;endl; for(int i=0;i&lt;pos;i++)&#123; cout&lt;&lt;i&lt;&lt;\": \"&lt;&lt;lis[i][0]&lt;&lt;\" + \"&lt;&lt;lis[i][1]&lt;&lt;\" = \"&lt;&lt;lis[i][2]&lt;&lt;endl; &#125; cout&lt;&lt;endl; cout&lt;&lt;\"Left\"&lt;&lt;endl; for(int i=0;i&lt;pos;i++)&#123; cout&lt;&lt;i&lt;&lt;\": \"; for(int j=1;j&lt;=9;j++) cout&lt;&lt;Left[i][j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; cout&lt;&lt;\"===============\"&lt;&lt;endl; //*/&#125;int main() &#123; #ifdef debug freopen(\"in.txt\", \"r\", stdin); int START = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); Pre(); int T; cin &gt;&gt; T; for (int kase = 1; kase &lt;= T; kase++) &#123; int cnt = 0; for (int i = 1; i &lt;= 9; i++) &#123; cin &gt;&gt; num[i]; num[i]=min(num[i],17-i); cnt += num[i]; &#125; deep = 0; dfs(0, 0, cnt); cout &lt;&lt; \"Case #\" &lt;&lt; kase &lt;&lt; \": \" &lt;&lt; deep &lt;&lt; endl; &#125; #ifdef debug printf(\"Time:%.3lfs\\n\", double(clock() - START) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"DFS","slug":"DFS","permalink":"https://www.oyohyee.com/tags/DFS/"},{"name":"暴力","slug":"Violence","permalink":"https://www.oyohyee.com/tags/Violence/"},{"name":"剪枝","slug":"Pruning","permalink":"https://www.oyohyee.com/tags/Pruning/"},{"name":"CCPC","slug":"CCPC","permalink":"https://www.oyohyee.com/tags/CCPC/"},{"name":"搜索","slug":"Search","permalink":"https://www.oyohyee.com/tags/Search/"}]},{"title":"HDU 5936.Difference(2016 CCPC 杭州 D)","date":"2016-11-21T15:38:35.000Z","path":"/post/HDU/5936.html","text":"题目 Description Little Ruins is playing a number game, first he chooses two positive integers y and K and calculates f(y,K), here f(y,K) = ∑in every digits of y zK (f(233,2) = 22+32+32=22) then he gets the result x=f(y,K)-y As Ruins is forgetful, a few seconds later, he only remembers K, x and forgets y. please help him find how many y satisfy x=f(y,K)-y. Input First line contains an integer T, which indicates the number of test cases. Every test case contains one line with two integers x, K. Limits1≤T≤1000≤x≤1091≤K≤9 Output For every test case, you should output ‘Case #x: y’, where x indicates the case number and counts from 1 and y is the result. Sample Input 22 23 2 Sample Output Case #1: 1Case #2: 2 题解求所有满足 x=f(y,K)-y 的数量计算一下,可以发现 y 最多为 10 位 (计算下极端情况)而暴力搜索 10 位的数字显然会超时可以采用 中途相遇法 的思路,将 10 位数字分成两个 5 位然后分别计算两部分,再对两部分进行比较即可 首先可以知道, f(y,K) 函数是一个有确定的函数,因此可以打表直接查询结果而每次需要求的 zK 也是有确切结果的,也可以打表(对于这道题,不打表时间会多很多) 将 x=f(y,K)-y 化成 x=f(a,K)+f(b,K)-a*100000-b 其中 a b 分别是 y 的前 5 位和后 5 位可以看出, f(a,K)-a*100000 和 f(b,K)-b 可以分别在自己的循环里计算 用一个数组来记录第一个循环能得到的结果,在第二个循环里累计其结果在第一个循环里的数量(用 map 会超时,可以用 lower_bound() 和 upper_bound() 快速求个数) 特别注意,如果 x=0 在两个循环会被重复计算 1 次,因此要额外 -1 代码量不大,思路也比较容易理解,注意各种打表优化即可 代码Difference代码备份//#include &lt;ctime&gt;//#define debug#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;LL List[100005][10];LL Pre[100005];int pw[10][10];int Pow(int a,int n) &#123; if(pw[a][n] == -1)&#123; if(n == 1) pw[a][n] = a; else if(n == 0) pw[a][n] = 1; else pw[a][n] = Pow(a,n / 2) * Pow(a,n - n / 2); &#125; return pw[a][n];&#125;inline LL f(LL y,int k) &#123; // if(List[y][k] == -1) &#123; // LL sum = 0; // while(y) &#123; // sum += Pow((int)(y % 10),k); // y /= 10; // &#125; // List[y][k] = sum; // &#125; return List[y][k];&#125;int lower_bound(LL *arr,int size, LL key) &#123; int half; int mid; int first = 0; while (size &gt; 0) &#123; half = size &gt;&gt; 1; mid = first + half; if (arr[mid] &lt; key) &#123; first = mid + 1; size = size - half - 1; &#125; else &#123; size = half; &#125; &#125; return first;&#125;int upper_bound(LL *arr,int size, LL key) &#123; int mid; int first = 0; int half; while (size &gt; 0) &#123; half = size &gt;&gt; 1; mid = half + first; if (arr[mid] &gt; key) &#123; size = half; &#125; else &#123; first = mid + 1; size = size - half - 1; &#125; &#125; return first;&#125;inline int Count(LL pre) &#123; return upper_bound(Pre,100000,pre) - lower_bound(Pre,100000,pre);&#125;int main() &#123; #ifdef debug freopen(\"in.txt\",\"r\",stdin); int start = clock(); #endif cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; //scanf(\"%d\",&amp;T); memset(pw,-1,sizeof(pw)); for(int i=0;i&lt;100000;i++)&#123; for(int j=1;j&lt;=9;j++)&#123; LL sum = 0; int y = i; while(y) &#123; sum += Pow((int)(y % 10),j); y /= 10; &#125; List[i][j] = sum; &#125; &#125; //memset(List,-1,sizeof(List)); for(int kase = 1;kase &lt;= T;kase++) &#123; LL x; int k; cin &gt;&gt; x &gt;&gt; k; //scanf(\"%d%d\",&amp;x,&amp;k); //前5位的各位k次方 - 前五位数据 for(int i = 0;i &lt; 100000;i++) &#123; LL pre = f(i,k) - (LL)i * 100000; Pre[i] = pre; &#125; sort(Pre,Pre + 100000); LL cnt = 0; //后5位的各位k次方 - 后五位数据 for(int i = 0;i &lt; 100000;i++) &#123; LL post = f(i,k) - (LL)i; LL pre = x - post; cnt += Count(pre); &#125; cout &lt;&lt; \"Case #\" &lt;&lt; kase &lt;&lt; \": \" &lt;&lt; cnt-(x==0) &lt;&lt; endl; // printf(\"Case #%d: %d\\n\",kase,cnt); &#125; #ifdef debug printf(\"Time:%.3lfs\\n\",double(clock() - start) / CLOCKS_PER_SEC); #endif return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"记忆化搜索","slug":"Memory-Search","permalink":"https://www.oyohyee.com/tags/Memory-Search/"},{"name":"暴力","slug":"Violence","permalink":"https://www.oyohyee.com/tags/Violence/"},{"name":"CCPC","slug":"CCPC","permalink":"https://www.oyohyee.com/tags/CCPC/"},{"name":"中途相遇法","slug":"Midway-encounter-method","permalink":"https://www.oyohyee.com/tags/Midway-encounter-method/"}]},{"title":"Hexo + C++ 便携套装","date":"2016-11-07T06:54:41.000Z","path":"/post/Note/Portable.html","text":"Hexo 相比于其他博客系统,最大的问题就是发布博客需要大量的前置工作:安装 Nodejs,安装 Git,安装一个靠谱的 Markdown 编辑器……因此,将 环境装到U盘 里是一个非常好的解决方案 后台环境首先确定大致思路,U盘的组件必然是无法加入到环境变量的,只能采用批处理的形式临时加入到环境变量里,然后在这个控制台中调用相应的功能 OK,先准备好 Nodejs 和 Git 将他们放到同一个文件夹里,然后在博客的源文件目录写上批处理即可 @echo offclscd Blogset path=%path%;%cd%\\..\\..\\Support\\git\\bin\\;%cd%\\..\\..\\Support\\npm\\bin\\;%cd%\\..\\..\\Support\\nodejs\\;%cd%\\..\\..\\Support\\npm\\;%cd%\\..\\..\\Support\\git\\hexo %1 %2 %3cd ..\\ 编辑器后台实现之后,还需要一个编辑器来写 Markdown能选择的有 Vim,Atom,VS Code毫无疑问选择了 VS Code 颜值过关,并且还自带 Markdown 解压 portable 版本的 VS Code然后同样使用批处理来解决文件配置的问题(键盘映射必须要在系统目录里,因此要写一个批处理一键复制过去) 顺便编译下 cpp有了上面的经验,再搞编译器就简单了,同样把 MinGW 复制到U盘里,然后在 VS Code 里使用 tasks 来调用批处理编译运行即可(没法逐步调试,不过应该可以使用控制台的逐步调试来解决这个问题,但是意义不大)","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.oyohyee.com/tags/Hexo/"},{"name":"portable","slug":"portable","permalink":"https://www.oyohyee.com/tags/portable/"},{"name":"Git","slug":"Git","permalink":"https://www.oyohyee.com/tags/Git/"},{"name":"nodejs","slug":"nodejs","permalink":"https://www.oyohyee.com/tags/nodejs/"},{"name":"vscode","slug":"vscode","permalink":"https://www.oyohyee.com/tags/vscode/"}]},{"title":"HDU 1269.迷宫城堡","date":"2016-11-05T18:56:42.000Z","path":"/post/HDU/1269.html","text":"题目 Description 为了训练小希的方向感，Gardon建立了一座大城堡，里面有N个房间(N&lt;=10000)和M条通道(M&lt;=100000)，每个通道都是单向的，就是说若称某通道连通了A房间和B房间，只说明可以通过这个通道由A房间到达B房间，但并不说明通过它可以由B房间到达A房间。Gardon需要请你写个程序确认一下是否任意两个房间都是相互连通的，即：对于任意的i和j，至少存在一条路径可以从房间i到房间j，也存在一条路径可以从房间j到房间i。 Input 输入包含多组数据，输入的第一行有两个数：N和M，接下来的M行每行有两个数a和b，表示了一条通道可以从A房间来到B房间。文件最后以两个0结束。 Output 对于输入的每组数据，如果任意两个房间都是相互连接的，输出”Yes”，否则输出”No”。 Sample Input 3 31 22 33 13 31 22 33 20 0 Sample Output YesNo 题解强连通分量模板题用来测试自己写的模板具体思路看 强连通分量 代码迷宫城堡 Kosaraju代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxn = 10005;//Kosarajuconst int maxm = 100005;struct Edge &#123; int u,v; Edge():u(0),v(0) &#123;&#125; Edge(int a,int b):u(a),v(b) &#123;&#125;&#125;;int pos;Edge edge[maxm];list&lt;int&gt; L[maxn];list&lt;int&gt; L2[maxn];stack&lt;int&gt; s;bool vis[maxn];vector&lt;int&gt; SCC[maxn];//得到的强连通分量链表inline void add(int u,int v) &#123; edge[pos] = Edge(u,v); L[u].push_back(pos); L2[v].push_back(pos);//逆图 pos++;&#125;void DFS1(int t) &#123; if(!vis[t]) &#123; vis[t] = true; for(list&lt;int&gt;::iterator i = L[t].begin();i != L[t].end();i++) DFS1(edge[*i].v); s.push(t); &#125; return;&#125;void DFS2(int p,int t) &#123; if(vis[t]) &#123; vis[t] = false; SCC[p].push_back(t); for(list&lt;int&gt;::iterator i = L2[t].begin();i != L2[t].end();i++) DFS2(p,edge[*i].u); &#125; return;&#125;int Kosaraju(int n) &#123; //第一次DFS for(int i = 0;i &lt; n;i++) DFS1(i); //第二次DFS int p = 0; while(!s.empty()) &#123; int t = s.top(); s.pop(); list&lt; list&lt;int&gt; &gt;::iterator it; if(vis[t]) DFS2(p++,t); &#125; return p;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int n,m; while(cin &gt;&gt; n &gt;&gt; m,!(n == 0 &amp;&amp; m == 0)) &#123; for(int i = 0;i &lt; n;i++) &#123; L[i].clear(); L2[i].clear(); SCC[i].clear(); vis[i] = false; &#125; while(!s.empty())s.pop(); pos = 0; for(int i = 0;i &lt; m;i++) &#123; int a,b; cin &gt;&gt; a &gt;&gt; b; add(a - 1,b - 1); &#125; cout &lt;&lt; (Kosaraju(n) == 1 ? \"Yes\" : \"No\") &lt;&lt; endl; &#125; return 0;&#125; 迷宫城堡 Kosaraju代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxn = 10005;//Tarjanconst int maxm = 100005;struct Edge &#123; int u,v; Edge():u(0),v(0) &#123;&#125; Edge(int a,int b):u(a),v(b) &#123;&#125;&#125;;int pos;Edge edge[maxm];list&lt;int&gt; L[maxn];stack&lt;int&gt; s;bool inStack[maxn];vector&lt;int&gt; SCC[maxn];//得到的强连通分量链表int cnt,Index;int DFN[maxn],Low[maxn];inline void add(int u,int v) &#123; edge[pos] = Edge(u,v); L[u].push_back(pos); pos++;&#125;void tarjan(int u) &#123; if(DFN[u] != -1) return; DFN[u] = Low[u] = ++Index; s.push(u); inStack[u] = true; for(list&lt;int&gt;::iterator it = L[u].begin();it != L[u].end();it++) &#123; int v = edge[*it].v; if(DFN[v] == -1) &#123; tarjan(v); Low[u] = min(Low[u],Low[v]); &#125; else if(inStack[v]) &#123; Low[u] = min(Low[u],DFN[v]); &#125; &#125; if(DFN[u] == Low[u]) &#123; int v = s.top(); s.pop(); inStack[v] = false; SCC[cnt++].push_back(v); while(u != v) &#123; v = s.top(); s.pop(); inStack[v] = false; SCC[cnt - 1].push_back(v); &#125; &#125;&#125;int Tarjan(int n) &#123; cnt = 0; Index = 0; while(!s.empty())s.pop(); memset(inStack,false,sizeof(inStack)); memset(DFN,-1,sizeof(DFN)); memset(Low,-1,sizeof(Low)); for(int i = 0;i &lt; n;i++) tarjan(i); return cnt;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int n,m; while(cin &gt;&gt; n &gt;&gt; m,!(n == 0 &amp;&amp; m == 0)) &#123; for(int i = 0;i &lt; n;i++) &#123; L[i].clear(); SCC[i].clear(); &#125; while(!s.empty())s.pop(); pos = 0; for(int i = 0;i &lt; m;i++) &#123; int a,b; cin &gt;&gt; a &gt;&gt; b; add(a - 1,b - 1); &#125; cout &lt;&lt; (Tarjan(n) == 1 ? \"Yes\" : \"No\") &lt;&lt; endl; &#125; return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"强连通分量","slug":"Strongly-connected-components","permalink":"https://www.oyohyee.com/tags/Strongly-connected-components/"},{"name":"kosaraju","slug":"kosaraju","permalink":"https://www.oyohyee.com/tags/kosaraju/"},{"name":"tarjan","slug":"tarjan","permalink":"https://www.oyohyee.com/tags/tarjan/"},{"name":"gabow","slug":"gabow","permalink":"https://www.oyohyee.com/tags/gabow/"}]},{"title":"强连通分量缩点 — Kosaraju | Tarjan | Gabow","date":"2016-11-05T17:01:07.000Z","path":"/post/Algorithm/Strongly_connected_components.html","text":"强连通分量如果两个点能够互相到达,那么说明两个点在一个 强连通分量 (成 环 )里其概念与 并查集 相似 不同点在于并查集为无向图,直接遍历,只要能访问到就在一个并查集里而强连通分量操作的是无向图,需要考虑边的方向 如图,最左侧的分支不是一个强连通分量,而右两个是 在许多图的题目里,需要对节点进行 强连通分量缩点 从而简化后续操作的复杂度缩点后,新的图是一个 有向无环图(DAG) ,因此可以使用其他算法进行其他的操作 强连通分量的算法有 kosaraju tarjan gabow 找了模板题 HDU 1269.迷宫城堡 测试写的模板有没有问题 KosarajuKosaraju 采用两次 DFS 及一次对逆图的操作从而求解的 首先 DFS 遍历所有节点,当到头后,将节点入栈,返回 DFS遍历完后在逆图(所有边反向)里按照栈的顺序进行 DFS ,将所有能访问到的点删除,加入到当前连通分量里直到所有点都被删除 由于强连通是环,无论图的边如何反向,应该都是能够互相访问的,而不在环里的点是无法访问到的.要考虑的额外情况就是逆图里是否会有一个点能访问到和它不是强连通的点假设存在这种情况,那么有以下条件: 这两个点单向连通(不连通逆图无法访问) 单向连通的子节点后入栈(这样能在父节点被删除前访问到父节点) 如果两个节点单向连通,有两种情况: 先访问到父节点父节点能遍历到子节点,父节点会后入栈 先访问子节点子节点在第一次遍历时,无法遍历到父节点,子节点先入栈,同上 因此,该算法可以实现强连通分量缩点的功能 步骤如下: DFS 遍历所有节点,当到达终点后入栈 在逆图里按照栈的顺序 DFS 所有节点,将所有能够访问到的点连为一个强连通分量并从图里删除 重复 2 直到所有点被删除 代码如下: Kosaraju//Kosarajuconst int maxm = 100005;struct Edge &#123; int u,v; Edge():u(0),v(0) &#123;&#125; Edge(int a,int b):u(a),v(b) &#123;&#125;&#125;;int pos;Edge edge[maxm];list&lt;int&gt; L[maxn];list&lt;int&gt; L2[maxn];stack&lt;int&gt; s;bool vis[maxn];vector&lt;int&gt; SCC[maxn];//得到的强连通分量链表inline void add(int u,int v) &#123; edge[pos] = Edge(u,v); L[u].push_back(pos); L2[v].push_back(pos);//逆图 pos++;&#125;void DFS1(int t) &#123; if(!vis[t]) &#123; vis[t] = true; for(list&lt;int&gt;::iterator i = L[t].begin();i != L[t].end();i++) DFS1(edge[*i].v); s.push(t); &#125; return;&#125;void DFS2(int p,int t) &#123; if(vis[t]) &#123; vis[t] = false; SCC[p].push_back(t); for(list&lt;int&gt;::iterator i = L2[t].begin();i != L2[t].end();i++) DFS2(p,edge[*i].u); &#125; return;&#125;int Kosaraju(int n) &#123; //第一次DFS for(int i = 0;i &lt; n;i++) DFS1(i); //第二次DFS int p = 0; while(!s.empty()) &#123; int t = s.top(); s.pop(); list&lt; list&lt;int&gt; &gt;::iterator it; if(vis[t]) DFS2(p++,t); &#125; return p;&#125; TarjanTarjan 是求强连通分量的一种非常常用的方法,其依据是 DFS 的遍历的顺序 不难得出,一个含环有向图,从一个节点开始遍历,环必然存在在第一个被遍历的环的子树上如最前面的图里,每一个环都存在于一个子树中而环的这棵树的最大的不同就是他能够回到已经访问过的节点上 首先看一颗有向的树,首先对树进行遍历,并且记录下访问该节点(u)的时间(次序)将节点(u)压入栈内,然后开始遍历它的子节点(v)找到该节点(u)到树根上尽可能上的节点(更早遍历)(下面所有重新标记节点的行为都是为了这一步) 有以下情况: 子节点(v)已访问过,并且在栈里非常显然,该节点(u)可以回到他的某一祖宗(v)处,从祖宗节点(v)到该节点(u)中间的所有节点可以连成环将该节点(u)的访问时间标记为 重新标记为该环最小的时间(缩点) 子节点(v)已访问过,不在栈里无法连成环,一个节点的两棵子树间的单向边(图中 3 和 4 的关系) 子节点(v)未访问过继续 DFS 遍历该子节点(v)遍历完该子节点(v)的所有子节点后,尝试缩点将该节点(u)的时间标记 重新标记为该节点(u)与子节点(v)时间标记的最小值(如果需要修改就证明它的 某个后代节点和它的祖宗节点有连接 ) 遍历完该节点(u)的子节点,就可以判断该节点是否在环里了如果该节点的标记被修改过,那么显然这个节点不可能是含环子树最顶部的节点而如果没有被修改过,那么就说明这个节点是环顶部的节点(有可能只有它一个,单独的强连通分量)由于 DFS 在树上有着天然的顺序,因此栈顶一直到该节点中间所有的节点都在这个环里直接记录即可 其中需要考虑的特殊情况有如图的两种情况 2,3之间是双向箭头(互相指向)根据上面的思路,这时两个点已经缩成一个点, 3 不会出栈(时间标记改变) 2,3之间是单向箭头不存在环的关系,因此不会改变时间节点,3 访问后出栈 这样,无论如何,都不会影响后面的结果,不过 4 和 1,2 等祖宗节点是否成环,都不会影响结果因此,该算法成立 最后要考虑的就是所有节点分成了多棵树的情况,遍历下所有点全部进行 DFS 即可(已经访问过自然不用再管了) Tarjan//Tarjan 返回强连通分量个数//节点从0开始,记得初始化变量struct Edge &#123; int u,v; Edge():u(0),v(0) &#123;&#125; Edge(int a,int b):u(a),v(b) &#123;&#125;&#125;;int pos;Edge edge[maxm];list&lt;int&gt; L[maxn];stack&lt;int&gt; s;bool inStack[maxn];vector&lt;int&gt; SCC[maxn];//得到的强连通分量链表int cnt,Index;int DFN[maxn],Low[maxn];inline void add(int u,int v) &#123; edge[pos] = Edge(u,v); L[u].push_back(pos); pos++;&#125;void tarjan(int u) &#123; if(DFN[u] != -1) return; DFN[u] = Low[u] = ++Index; s.push(u); inStack[u] = true; for(list&lt;int&gt;::iterator it = L[u].begin();it != L[u].end();it++) &#123; int v = edge[*it].v; if(DFN[v] == -1) &#123; tarjan(v); Low[u] = min(Low[u],Low[v]); &#125; else if(inStack[v]) &#123; Low[u] = min(Low[u],DFN[v]); &#125; &#125; if(DFN[u] == Low[u]) &#123; int v = s.top(); s.pop(); inStack[v] = false; SCC[cnt++].push_back(v); while(u != v) &#123; v = s.top(); s.pop(); inStack[v] = false; SCC[cnt - 1].push_back(v); &#125; &#125;&#125;int Tarjan(int n) &#123; cnt = 0; Index = 0; while(!s.empty())s.pop(); memset(inStack,false,sizeof(inStack)); memset(DFN,-1,sizeof(DFN)); memset(Low,-1,sizeof(Low)); for(int i = 0;i &lt; n;i++) tarjan(i); return cnt;&#125; GabowGabow 算法可以理解成是 Tarjan 算法的改良,将 stack 改成数组,其他思路一样只错了常量的时间,不再看了","tags":[{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"强连通分量","slug":"Strongly-connected-components","permalink":"https://www.oyohyee.com/tags/Strongly-connected-components/"},{"name":"kosaraju","slug":"kosaraju","permalink":"https://www.oyohyee.com/tags/kosaraju/"},{"name":"tarjan","slug":"tarjan","permalink":"https://www.oyohyee.com/tags/tarjan/"},{"name":"gabow","slug":"gabow","permalink":"https://www.oyohyee.com/tags/gabow/"}]},{"title":"HDU 5934.Bomb(2016 CCPC 杭州 B)","date":"2016-11-05T14:53:05.000Z","path":"/post/HDU/5934.html","text":"题目 Description There are N bombs needing exploding. Each bomb has three attributes: exploding radius ri, position (xi,yi) and lighting-cost ci which means you need to pay ci cost making it explode. If a un-lighting bomb is in or on the border the exploding area of another exploding one, the un-lighting bomb also will explode. Now you know the attributes of all bombs, please use the minimum cost to explode all bombs. Input First line contains an integer T, which indicates the number of test cases. Every test case begins with an integers N, which indicates the numbers of bombs. In the following N lines, the ith line contains four intergers xi, yi, ri and ci, indicating the coordinate of ith bomb is (xi,yi), exploding radius is ri and lighting-cost is ci. Limits 1≤T≤20 1≤N≤1000 108≤xi,yi,ri≤108 1≤ci≤104 Output For every test case, you should output ‘Case #x: y’, where x indicates the case number and counts from 1 and y is the minimum cost. Sample Input 150 0 1 51 1 1 60 1 1 73 0 2 105 0 1 4 Sample Output Case #1: 15 题解平面内有一些炸弹,每个炸弹有一定得爆炸范围,炸弹爆炸时会引爆爆炸范围内的炸弹,花费最少的能量使所有炸弹被引爆 显然,是一道有向图的题目 作图如下: 转为有向图关系有: 节点被分为多个连通分量.如果两个点属于一个 强连通分量 那么可以将他们看作一个点(用最小点燃能量作为代价)然后将新的图建成 有向图此时,图中 不存在强连通的结点(无环) 因此只需要找到 入度为0 的点点燃即可(无环,所以从任何入度不为0的点往回走,必然终止于一个入度为0的点) 那么任务也即: 强连通分量缩点 建有向图图 查找所有入度为 0 的点 强连通分量缩点 套用模板即可 处理时,要注意坐标可能会溢出 int因此使用 long long 存储坐标 代码Bomb代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;/* * Tarjan算法 * 复杂度O(N+M)*/const int MAXN = 1005;//点数 const int MAXM = 2*MAXN*MAXN;//边数 struct Edge &#123; int to,next;&#125;edge[MAXM];int head[MAXN],tot;int Low[MAXN],DFN[MAXN],Stack[MAXN],Belong[MAXN];//Belong数组的值是1~scc int Index,top;int scc;//强连通分量的个数 bool Instack[MAXN];int num[MAXN];//各个强连通分量包含点的个数，数组编号1~scc //num数组不一定需要，结合实际情况 void addedge(int u,int v) &#123; edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;&#125;void Tarjan(int u) &#123; int v; Low[u] = DFN[u] = ++Index; Stack[top++] = u; Instack[u] = true; for(int i = head[u];i != -1;i = edge[i].next) &#123; v = edge[i].to; if(!DFN[v]) &#123; Tarjan(v); if(Low[u] &gt; Low[v]) Low[u] = Low[v]; &#125; else if(Instack[v] &amp;&amp; Low[u] &gt; DFN[v]) Low[u] = DFN[v]; &#125; if(Low[u] == DFN[u]) &#123; scc++; do &#123; v = Stack[--top]; Instack[v] = false; Belong[v] = scc; num[scc]++; &#125; while(v != u); &#125;&#125;void solve(int N) &#123; memset(DFN,0,sizeof(DFN)); memset(Instack,false,sizeof(Instack)); memset(num,0,sizeof(num)); Index = scc = top = 0; for(int i = 1;i &lt;= N;i++) if(!DFN[i]) Tarjan(i);&#125;void init() &#123; tot = 0; memset(head,-1,sizeof(head));&#125;struct Point &#123; long long x,y; long long r; int w; Point(long long a = 0,long long b = 0,long long c = 0,int d = 0):x(a),y(b),r(c),w(d) &#123;&#125; static long long distanceSqure(const Point &amp;a,const Point &amp;b) &#123; return (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y); &#125;&#125;;Point p[MAXN];int Min[MAXN];int main() &#123; //freopen(\"in.txt\",\"r\",stdin); cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; int kase = 1; while(T--) &#123; int n; cin &gt;&gt; n; for(int i = 1;i &lt;= n;i++) &#123; Point &amp;t = p[i]; cin &gt;&gt; t.x &gt;&gt; t.y &gt;&gt; t.r &gt;&gt; t.w; &#125; init(); //建图 for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= n;j++) if(i != j) &#123; long long dis = Point::distanceSqure(p[i],p[j]); if((long long)p[i].r * (long long)p[i].r - dis &gt;= 0) addedge(i,j); &#125; //Tarjan + 缩点 solve(n); //寻找入度为0的点 memset(Instack,false,sizeof(Instack)); for(int i = 1;i &lt;= n;i++) for(int j = head[i];j != -1;j = edge[j].next) if(Belong[i] != Belong[edge[j].to]) Instack[Belong[edge[j].to]] = true; for(int i = 1;i &lt;= scc;i++) Min[i] = 10005; for(int i = 1;i &lt;= n;i++) &#123; int tscc = Belong[i]; Min[tscc] = min(Min[tscc],p[i].w); &#125; int ans = 0; for(int i = 1;i &lt;= scc;i++) &#123; if(Instack[i] == false) ans += Min[i]; &#125; cout &lt;&lt; \"Case #\" &lt;&lt; kase++ &lt;&lt; \": \" &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"强连通分量","slug":"Strongly-connected-components","permalink":"https://www.oyohyee.com/tags/Strongly-connected-components/"},{"name":"tarjan","slug":"tarjan","permalink":"https://www.oyohyee.com/tags/tarjan/"},{"name":"CCPC","slug":"CCPC","permalink":"https://www.oyohyee.com/tags/CCPC/"}]},{"title":"HDU 5938.Four Operations(2016 CCPC 杭州 F)","date":"2016-10-31T16:38:44.000Z","path":"/post/HDU/5938.html","text":"题目 Description Little Ruins is a studious boy, recently he learned the four operations! Now he want to use four operations to generate a number, he takes a string which only contains digits ‘1’ - ‘9’, and split it into 5 intervals and add the four operations ‘+’, ‘-‘, ‘*’ and ‘/‘ in order, then calculate the result(/ used as integer division). Now please help him to get the largest result. Input First line contains an integer T, which indicates the number of test cases. Every test contains one line with a string only contains digits ‘1’-‘9’. Limits1≤T≤1055≤length of string≤20 Output For every test case, you should output ‘Case #x: y’, where x indicates the case number and counts from 1 and y is the result. Sample Input 112345 Sample Output Case #1: 1 题解在一串数中 按顺序 插入 + - * / 使结果最大 由于运算顺序,可知 - 后面越小越好,因此应该让 + 左右的一端尽可能大(位数越多越大) 大概是这样一个思路,不过会有一些特例,于是用随机数强行 O(n4) 模拟,测试数据然后就能发现规律:/ 后有可能是 2 位数(除完是0,然后促使 - 后是 0 ),也可能是 1 位数- * 后都是 1 位数+ 左右一边是 1 位,剩下的位数在另一边 然后,就是比较四个情况的大小即可如果只有5个数要单独直接输出！！！ 不是很难,但是很容易卡进去的题 代码Four Operations代码备份#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;functional&gt;using namespace std;const int maxn = 25;int kase = 1;char s[maxn];long long toInt(const char *s,int u,int v) &#123; long long t = 0; for(int i = u;i &lt;= v;i++) &#123; t *= 10; t += s[i] - '0'; &#125; return t;&#125;int vs_main() &#123; cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; s; long long ans = 0; int n = strlen(s); if(n == 5) &#123; ans = toInt(s,0,0) + toInt(s,1,1) - toInt(s,2,2) * toInt(s,3,3) / toInt(s,4,4); &#125; else &#123; long long a = toInt(s,0,n - 5) + toInt(s,n - 4,n - 4) - toInt(s,n - 3,n - 3)*toInt(s,n - 2,n - 2) / toInt(s,n - 1,n - 1); long long b = toInt(s,0,0) + toInt(s,1,n - 4) - toInt(s,n - 3,n - 3)*toInt(s,n - 2,n - 2) / toInt(s,n - 1,n - 1); long long c = toInt(s,0,n - 6) + toInt(s,n - 5,n - 5) - toInt(s,n - 4,n - 4)*toInt(s,n - 3,n - 3) / toInt(s,n - 2,n - 1); long long d = toInt(s,0,0) + toInt(s,1,n - 5) - toInt(s,n - 4,n - 4)*toInt(s,n - 3,n - 3) / toInt(s,n - 2,n - 1); ans = max(max(a,b),max(c,d)); &#125; cout &lt;&lt; \"Case #\" &lt;&lt; kase++ &lt;&lt; \": \" &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"CCPC","slug":"CCPC","permalink":"https://www.oyohyee.com/tags/CCPC/"}]},{"title":"HDU 5935.Car(2016 CCPC 杭州 C)","date":"2016-10-31T16:28:32.000Z","path":"/post/HDU/5935.html","text":"题目 Description Ruins is driving a car to participating in a programming contest. As on a very tight schedule, he will drive the car without any slow down, so the speed of the car is non-decrease real number. Of course, his speeding caught the attention of the traffic police. Police record N positions of Ruins without time mark, the only thing they know is every position is recorded at an integer time point and Ruins started at 0. Now they want to know the minimum time that Ruins used to pass the last position. Input First line contains an integer T, which indicates the number of test cases. Every test case begins with an integers N, which is the number of the recorded positions. The second line contains N numbers a1, a2, , aN, indicating the recorded positions. Limits1≤T≤1001≤N≤1050&lt;ai≤105ai&lt;ai+1 Output For every test case, you should output ‘Case #x: y’, where x indicates the case number and counts from 1 and y is the minimum time. Sample Input 136 11 21 Sample Output Case #1: 4 题解对于一群坐标数据,不知道每一个数据的时间,并且可知速度是递增的,求可能的最小时间 要使时间最小,尽可能使速度最大即可对于最后一个区间,显然 1s 是最优解,这样就确定了最后一个区间的速度 然后对于前一个区间,就是求在不超过这个速度的情况下的最大速度(最小时间),直接用区间除以最大速度向下取整即可然后递推可算出所有区间 也即: 求出各个区间除以该区间限制条件(向下取整)的和 严格证明的贪心算法,应该能秒出思路一遍 A 代码Car代码备份#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;functional&gt;using namespace std;const int maxn = 100005;int kase = 1;int a[maxn];int vs_main() &#123; cin.tie(0); cin.sync_with_stdio(false); a[0] = 0; int T; cin &gt;&gt; T; while(T--) &#123; int n; cin &gt;&gt; n; long long sum = 0; for(int i = 1;i &lt;= n;i++) cin &gt;&gt; a[i]; double maxv = 99999999; int ans = 0; for(int i = n;i&gt;0;i--) &#123; int dis = a[i] - a[i - 1]; double tt = (double)dis / maxv; int t = (int)(tt + 0.001); if((double)dis / (double)t &gt; maxv) t++; maxv = (double)dis / (double)t; ans += t; &#125; cout &lt;&lt; \"Case #\" &lt;&lt; kase++ &lt;&lt; \": \" &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"},{"name":"CCPC","slug":"CCPC","permalink":"https://www.oyohyee.com/tags/CCPC/"}]},{"title":"HDU 5933.ArcSoft's Office Rearrangement(2016 CCPC 杭州 A)","date":"2016-10-31T16:05:38.000Z","path":"/post/HDU/5933.html","text":"题目 Description ArcSoft, Inc. is a leading global professional computer photography and computer vision technology company. There are N working blocks in ArcSoft company, which form a straight line. The CEO of ArcSoft thinks that every block should have equal number of employees, so he wants to re-arrange the current blocks into K new blocks by the following two operations: merge two neighbor blocks into a new block, and the new block’s size is the sum of two old blocks’. split one block into two new blocks, and you can assign the size of each block, but the sum should be equal to the old block. Now the CEO wants to know the minimum operations to re-arrange current blocks into K block with equal size, please help him. Input First line contains an integer T, which indicates the number of test cases. Every test case begins with one line which two integers N and K, which is the number of old blocks and new blocks. The second line contains N numbers a1, a2, , aN, indicating the size of current blocks. Limits1≤T≤1001≤N≤1051≤K≤1051≤ai≤105 Output For every test case, you should output ‘Case #x: y’, where x indicates the case number and counts from 1 and y is the minimum operations. If the CEO can’t re-arrange K new blocks with equal size, y equals -1. Sample Input 31 3143 12 3 43 61 2 3 Sample Output Case #1: -1Case #2: 2Case #3: 3 题解比较直观的思路题 有多个不同大小的方块有以下操作: 对于 相邻 的方块,可以将他们融合成一个 对于一个方块,可以将它拆成任意大小的两个 然后将所有方块分成等大小的 k 个方块,求最少的操作步数 首先,显然: 如果平均数不是整数肯定是不可能有结果的同理,平均数是整数,最终必定能得到结果 由于操作必然是相邻的方块,因此如果要求最短的步数,应该把多出来的部分传到尽可能近的位置 由于方块本身是等价的,因此对于不同的方块,只需要将其往后传递即可只需要将判断当前方块与平均值大小,如果大于就拆成平均值和多余部分,继续这一操作;如果小于就和下一个方块融为一个 上面的思路其实瞬间就能得到,但是第一次写 WA 了 有一点要特别注意,由于方块体积和数量最大都是 105因此,极端情况会有 1010int 存不下！！！ 换了 long long 就 A 了 代码ArcSoft's Office Rearrangement代码备份#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;functional&gt;using namespace std;const int maxn = 100005;int kase = 1;long long a[maxn];int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--) &#123; int n,m; cin &gt;&gt; n &gt;&gt; m; long long sum = 0; for(int i = 0;i&lt;n;i++) &#123; cin &gt;&gt; a[i]; sum += a[i]; &#125; cout &lt;&lt; \"Case #\" &lt;&lt; kase++ &lt;&lt; \": \"; if(sum%m) &#123; cout &lt;&lt; \"-1\"; &#125; else &#123; long long t = sum / m; long long ans = 0; for(int i = 0;i&lt;n;i++) &#123; while(a[i]&gt;t) &#123; a[i] -= t; ans++; &#125; if(a[i]&lt;t) &#123; a[i + 1] += a[i]; ans++; &#125; &#125; cout &lt;&lt; ans; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"CCPC","slug":"CCPC","permalink":"https://www.oyohyee.com/tags/CCPC/"}]},{"title":"第一个 Qt 程序","date":"2016-10-31T10:25:35.000Z","path":"/post/Note/First_qt.html","text":"帮忙写数据结构的课程设计,要用到界面,就顺便入门了下 Qt (算不上入门,只是能跑起来而已) 安装 Qt 安装目录里 \\Qt\\Tools\\QtCreator\\bin\\qtcreator.exe 就是 Qt 的编辑器打开后新建项目就可以像 VS 里一样写代码 如图, 编辑 是代码界面 设计 就是 UI 界面 编译编译项目需要有调试器(不然会提示 qt 调试器未设置 ),可以下载 Microsoft 的调试器 dbg 在 工具-&gt;选项-&gt;构建和运行-&gt;构建套件(Kit) 设置好 dbg.exe 即可然后就能点左下角的绿色箭头编译并运行了 项目结构一个标准的项目包括头文件 mainwindow.h源文件 main.cpp mainwindow.cpp界面文件 mainwindow.ui 其中 mainwindow 就是默认的窗口名称ui 就是其界面布局h 是其布局结构的定义(有哪些控件)cpp 则是页面对应的各种功能的实现(按下按钮等) 每一个窗口都是一个类,因此如果想要写一个函数对一个窗口操作,就要在头文件里添加声明 最后并没有在界面上卡很久,和 VB 易语言的界面类似,还是比较容易入手的然而最后在 C++ 上卡了好久……","tags":[{"name":"Qt","slug":"Qt","permalink":"https://www.oyohyee.com/tags/Qt/"}]},{"title":"ACM 2016级新生赛题解(2)","date":"2016-10-23T15:24:02.000Z","path":"/post/Project/ACM2016-10-22.html","text":"题号 题目 Problem A A + B Problem Problem B 求绝对值 Problem C 成绩转换 Problem D 水仙花数 Problem E 数据的交换输出 Problem F 字符串统计 Problem G 多项式求和 Problem H 求数列的和 Problem I 折线分割平面 Problem J Choosing Teams 本题解采用 C++ ,大概思路与 C 一样cin 对应 scanfcout 对应 printf 如果还有问题群里问即可,有余力的同学可以看群公告里上一次比赛那一套题更难,群文件有上次的题解 A + B Problem计算 A + B多组数据,以 EOF 结尾/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int maxn = 105;const int INF = 0x7FFFFFFF;const double eps = 1e-10;bool Do() &#123; int a,b; if(cin &gt;&gt; a &gt;&gt; b) &#123; cout &lt;&lt; a + b &lt;&lt; endl; return true; &#125; else &#123; return false; &#125;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125; 求绝对值求一个实数的绝对值使用 cmath 头文件(math.h)里的 fabs() 函数输出记得保留小数 /*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int maxn = 105;const int INF = 0x7FFFFFFF;const double eps = 1e-10;bool Do() &#123; double a; if(cin &gt;&gt; a) &#123; cout &lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt; fabs(a) &lt;&lt; endl; return true; &#125; else &#123; return false; &#125;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125; 成绩转换针对不同的输入,有不同的输出/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int maxn = 105;const int INF = 0x7FFFFFFF;const double eps = 1e-10;inline bool compare(int n,int a,int b) &#123; return n &gt;= a&amp;&amp;n &lt;= b;&#125;bool Do() &#123; int a; if(cin &gt;&gt; a) &#123; if(compare(a,0,59)) cout &lt;&lt; \"E\" &lt;&lt; endl; else if(compare(a,60,69)) cout &lt;&lt; \"D\" &lt;&lt; endl; else if(compare(a,70,79)) cout &lt;&lt; \"C\" &lt;&lt; endl; else if(compare(a,80,89)) cout &lt;&lt; \"B\" &lt;&lt; endl; else if(compare(a,90,100)) cout &lt;&lt; \"A\" &lt;&lt; endl; else cout &lt;&lt; \"Score is error!\" &lt;&lt; endl; return true; &#125; else &#123; return false; &#125;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125; 水仙花数先写一个函数判断一个数是不是水仙花数模拟定义即可 可以先把所有数筛选一遍,打个表,可以节省时间 输出的时候记得输出空格,并且只有两个数字中间有,最后不要有多余的 /*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int maxn = 105;const int INF = 0x7FFFFFFF;const double eps = 1e-10;bool sxh[1005];inline int Cube(int a) &#123; return a*a*a;&#125;inline bool issxh(int n) &#123; int m = n; int sum = 0; while(m) &#123; sum += Cube(m % 10); m /= 10; &#125; return sum == n;&#125;bool Do() &#123; int a,b; if(!(cin &gt;&gt; a &gt;&gt; b)) return false; int has = false; for(int i = a;i &lt;= b;i++) &#123; if(sxh[i]) &#123; if(has) cout &lt;&lt; \" \"; cout &lt;&lt; i; has = true; &#125; &#125; if(!has) cout &lt;&lt; \"no\"; cout &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); for(int i = 100;i &lt;= 999;i++) sxh[i] = issxh(i); while(Do()); return 0;&#125; 数据的交换输出遍历所有数,找到最小数的位置,交换它和第一个 /*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxn = 105;int a[maxn];bool Do() &#123; int n; cin &gt;&gt; n; if(n==0) return false; int pos = 0; for(int i = 0;i &lt; n;i++) &#123; cin &gt;&gt; a[i]; if(a[i] &lt; a[pos]) pos = i; &#125; int t = a[pos]; a[pos] = a[0]; a[0] = t; for(int i = 0;i &lt; n;i++) &#123; if(i) cout &lt;&lt; \" \"; cout &lt;&lt; a[i]; &#125; cout &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125; 字符串统计遍历一行字符,统计数字的个数 By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const double eps = 1e-10;string s;bool Do() &#123; cin &gt;&gt; s; int cnt = 0; for(size_t i = 0;i &lt; s.size();i++) &#123; if(s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;) cnt++; &#125; cout &lt;&lt; cnt &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--) &#123; Do(); &#125;; return 0;&#125; 多项式求和计算多项式 可以先计算好所有的结果,然后查表输出需要使用 double /*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxn = 1005;double ans[maxn];bool Do() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; ans[n] &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); cout &lt;&lt; fixed &lt;&lt; setprecision(2); ans[0] = 0; for(int i = 1;i &lt;= 1000;i++) &#123; ans[i] = ans[i - 1] + ((double)1 / i) * ((i % 2) ? 1 : -1); &#125; int T; cin &gt;&gt; T; while(T--) &#123; Do(); &#125;; return 0;&#125; 求数列的和使用 cmath 头文件(math.h)的 sqrt() 函数 /*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxm = 1005;bool Do() &#123; double n,m; if(!(cin &gt;&gt; n&gt;&gt;m)) return false; double ans = 0; while(m--) &#123; ans += n; n = sqrt(n); &#125; cout &lt;&lt; ans &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); cout &lt;&lt; fixed &lt;&lt; setprecision(2); while(Do()); return 0;&#125; 折线分割平面可推出公式：2n2 - n + 1 /*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const double eps = 1e-10;bool Do() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; 2 * n*n - n + 1 &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); cout &lt;&lt; fixed &lt;&lt; setprecision(2); int T; cin &gt;&gt; T; while(T--) Do(); return 0;&#125; Choosing Teams给出 n 个人参加过比赛的次数,需要组参加 k 场比赛的 3 人队伍,每个人最多只能参加 5 次比赛求能组的最多队伍数量 求大于等于 5-k 的人的数量,然后除以 3 即可 /*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const double eps = 1e-10;bool Do() &#123; int n,k; if(!(cin &gt;&gt; n&gt;&gt;k)) return false; int ans = 0; for(int i = 0;i &lt; n;i++) &#123; int t; cin &gt;&gt; t; if(t + k &lt;= 5) ans++; &#125; cout &lt;&lt; ans / 3 &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[]},{"title":"hihocoder 1385.A Simple Job(ACM-ICPC国际大学生程序设计竞赛北京赛区(2016)网络赛)","date":"2016-09-24T13:22:00.000Z","path":"/post/hihocoder/1385.html","text":"题目 描述 Institute of Computational Linguistics (ICL), Peking University is an interdisciplinary institute of science and liberal arts, it focuses primarily on the fundamental researches and applications of language information processing. The research of ICL covers a wide range of areas, including Chinese syntax, language parsing, computational lexicography, semantic dictionaries, computational semantics and application systems. Professor X is working for ICL. His little daughter Jane is 9 years old and has learned something about programming. She is always very interested in her daddy’s research. During this summer vacation, she took a free programming and algorithm course for kids provided by the School of EECS, Peking University. When the course was finished, she said to Professor X: “Daddy, I just learned a lot of fancy algorithms. Now I can help you! Please give me something to research on!” Professor X laughed and said:”Ok, let’s start from a simple job. I will give you a lot of text, you should tell me which phrase is most frequently used in the text.” Please help Jane to write a program to do the job. 输入 There are no more than 20 test cases. In each case, there are one or more lines of text ended by a line of “####”. The text includes words, spaces, ‘,’s and ‘.’s. A word consists of only lowercase letters. Two adjacent words make a “phrase”. Two words which there are just one or more spaces between them are considered adjacent. No word is split across two lines and two words which belong to different lines can’t form a phrase. Two phrases which the only difference between them is the number of spaces, are considered the same. Please note that the maximum length of a line is 500 characters, and there are at most 50 lines in a test case. It’s guaranteed that there are at least 1 phrase in each test case. 输出 For each test case, print the most frequently used phrase and the number of times it appears, separated by a ‘:’ . If there are more than one choice, print the one which has the smallest dictionary order. Please note that if there are more than one spaces between the two words of a phrase, just keep one space. 样例输入 above,all ,above all good at good at goodat good at above all me this is####world hello ok####样例输出at good:3hello ok:1 题解统计词组的频率,输出频率最高的词组中字典序最小的一个 首先要进行的是处理字符串,换行、 , 、 . 都会截断词组而空格不会对词组造成影响,为了方便使用自己写的读入函数 读入后要做的就是根据不同的读入情况,组合前后两个词(如果可以称为词组)然后计数,直接使用 map 即可 由于 map 本身的存储形式是二叉树存储(采用二分查找,因此速度很快)因此 map 本身就是按照字典序存储的所以直接用 迭代器(iterator) 从前遍历第一个计数是最大值的就是要输出的 代码A Simple Job代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const double eps = 1e-10;int kase = 1;map&lt;string,int&gt; mp;int read_string(string &amp;s) &#123; char c; s = \"\"; while(c=getchar(),!((c &gt;= 'a'&amp;&amp;c &lt;= 'z')||c=='#')) &#123; if(c == '\\n' || c == ',' || c == '.') return 0; if(c == EOF) return -1; &#125; while(((c &gt;= 'a'&amp;&amp;c &lt;= 'z')||c=='#')) &#123; s += c; c = getchar(); &#125; if(c == '\\n' || c == ',' || c == '.') return 2; return 1;&#125;int MapPush(string s) &#123; if(mp.count(s) == 0) mp.insert(pair&lt;string,int&gt;(s,0)); mp[s]++; return mp[s];&#125;bool Do() &#123; int Max = 0; mp.clear(); string a=\"\",b=\"\"; while(1) &#123; int res = read_string(b); if(b == \"####\") break; if(res == -1) return false; if(res == 0) &#123; a = b; b = \"\"; &#125; if(res == 2) &#123; if(a != \"\") &#123; string Add = a + \" \" + b; Max = max(Max,MapPush(Add)); &#125; a = \"\"; b = \"\"; &#125; if(res==1)&#123; if(a != \"\") &#123; string Add = a + \" \" + b; Max = max(Max,MapPush(Add)); &#125; a = b; b = \"\"; &#125; &#125; map&lt;string,int&gt;::iterator it = mp.begin(); while(it != mp.end()) &#123; if(it-&gt;second == Max) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; \":\" &lt;&lt; Max &lt;&lt; endl; break; &#125; ++it; &#125; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"映射(map)","slug":"Map","permalink":"https://www.oyohyee.com/tags/Map/"},{"name":"hihocoder","slug":"hihocoder","permalink":"https://www.oyohyee.com/tags/hihocoder/"}]},{"title":"hihocoder 1383.The Book List(ACM-ICPC国际大学生程序设计竞赛北京赛区(2016)网络赛)","date":"2016-09-24T13:07:45.000Z","path":"/post/hihocoder/1383.html","text":"题目 描述 The history of Peking University Library is as long as the history of Peking University. It was build in 1898. At the end of year 2015, it had about 11,000 thousand volumes of books, among which 8,000 thousand volumes were paper books and the others were digital ones. Chairman Mao Zedong worked in Peking University Library for a few months as an assistant during 1918 to 1919. He earned 8 Dayang per month there, while the salary of top professors in Peking University is about 280 Dayang per month. Now Han Meimei just takes the position which Chairman Mao used to be in Peking University Library. Her first job is to rearrange a list of books. Every entry in the list is in the format shown below: CATEGORY 1/CATEGORY 2/…./CATEGORY n/BOOKNAME It means that the book BOOKNAME belongs to CATEGORY n, and CATEGORY n belongs to CATEGORY n-1, and CATEGORY n-1 belongs to CATEGORY n-2…… Each book belongs to some categories. Let’s call CATEGORY1 “first class category”, and CATEGORY 2 “second class category”, …ect. This is an example: MATH/GRAPH THEORYART/HISTORY/JAPANESE HISTORY/JAPANESE ACIENT HISTORYART/HISTORY/CHINESE HISTORY/THREE KINDOM/RESEARCHES ON LIUBEIART/HISTORY/CHINESE HISTORY/CHINESE MORDEN HISTORYART/HISTORY/CHINESE HISTORY/THREE KINDOM/RESEARCHES ON CAOCAO Han Meimei needs to make a new list on which the relationship between books and the categories is shown by indents. The rules are: 1) The n-th class category has an indent of 4×(n-1) spaces before it.2) The book directly belongs to the n-th class category has an indent of 4×n spaces before it.3) The categories and books which directly belong to a category X should be list below X in dictionary order. But all categories go before all books.4) All first class categories are also list by dictionary order. For example, the book list above should be changed into the new list shown below: ART HISTORY CHINESE HISTORY THREE KINDOM RESEARCHES ON CAOCAO RESEARCHES ON LIUBEI CHINESE MORDEN HISTORY JAPANESE HISTORY JAPANESE ACIENT HISTORYMATH GRAPH THEORYPlease help Han Meimei to write a program to deal with her job. 输入 There are no more than 10 test cases.Each case is a list of no more than 30 books, ending by a line of “0”.The ## Description of a book contains only uppercase letters, digits, ‘/‘ and spaces, and it’s no more than 100 characters.Please note that, a same book may be listed more than once in the original list, but in the new list, each book only can be listed once. If two books have the same name but belong to different categories, they are different books. 输出 For each test case, print “Case n:” first(n starts from 1), then print the new list as required. 样例输入 B/AB/AB/B0A1/B1/B32/B7A1/B/B2/B4/C5A1/B1/B2/B6/C5A1/B1/B2/B5A1/B1/B2/B1A1/B3/B2A3/B1A0/A10 样例输出 Case 1:B A BCase 2:A0 A1A1 B B2 B4 C5 B1 B2 B6 C5 B1 B5 B32 B7 B3 B2A3 B1 题解纯模拟即可,可以用树存储,也可以用链表存储,任意一种方法都行 使用 链表 纯模拟即可,需要注意一些细节的处理优先输出书库,再输出书本,同时应该按照字典序输出 因此,可以用两个不同的链表分别维护子书库和书本 直接使用 STL 即可,单纯考验 STL 的熟练度 代码The Book List代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const double eps = 1e-10;int kase = 1;struct CATEGORY &#123; list&lt;CATEGORY&gt; *child; list&lt;CATEGORY&gt; *book; string s; CATEGORY(string b) &#123; list&lt;CATEGORY&gt; *p = new list&lt;CATEGORY&gt;; p-&gt;clear(); child = p; p = new list&lt;CATEGORY&gt;; p-&gt;clear(); book = p; s = b; &#125; bool operator &lt; (string rhs) &#123; return s &lt; rhs; &#125;&#125;;list&lt;CATEGORY&gt; L;list&lt;CATEGORY&gt;::iterator pushsk(list&lt;CATEGORY&gt;::iterator t,string s) &#123; list&lt;CATEGORY&gt;::iterator it = t-&gt;child-&gt;begin(); it = lower_bound(t-&gt;child-&gt;begin(),t-&gt;child-&gt;end(),s); if(it == t-&gt;child-&gt;end() || it-&gt;s != s) &#123; t-&gt;child-&gt;insert(it,CATEGORY(s)); it--; &#125; return it;&#125;void pushs(list&lt;CATEGORY&gt;::iterator t,string s) &#123; list&lt;CATEGORY&gt;::iterator it = t-&gt;book-&gt;begin(); it = lower_bound(t-&gt;book-&gt;begin(),t-&gt;book-&gt;end(),s); if(it == t-&gt;book-&gt;end() || it-&gt;s != s) &#123; t-&gt;book-&gt;insert(it,CATEGORY(s)); it--; &#125;&#125;void DFS(list&lt;CATEGORY&gt; *L,int n) &#123; if(L == NULL) return; list&lt;CATEGORY&gt;::iterator it = L-&gt;begin(); while(it != L-&gt;end()) &#123; for(int i = 0;i &lt; n;i++) cout &lt;&lt; \" \"; if(n != -1) cout &lt;&lt; it-&gt;s &lt;&lt; endl; DFS(it-&gt;child,n + 1); DFS(it-&gt;book,n + 1); delete it-&gt;child; delete it-&gt;book;//处理内存泄露问题 ++it; &#125;&#125;bool Do() &#123; L.clear(); L.push_back(CATEGORY(\"MAIN\"));//主书库 string s; while(1) &#123; if(!(getline(cin,s))) return false; if(s == \"0\") break; size_t len = s.size(); string t = \"\"; list&lt;CATEGORY&gt;::iterator it = L.begin(); for(size_t i = 0;i &lt; len;i++) &#123; if(s[i] == '/') &#123; it = pushsk(it,t); t = \"\"; &#125; else &#123; t += s[i]; &#125; &#125; pushs(it,t); &#125; cout &lt;&lt; \"Case \" &lt;&lt; kase++ &lt;&lt; \":\" &lt;&lt; endl; DFS(&amp;L,-1); return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"链表(list)","slug":"List","permalink":"https://www.oyohyee.com/tags/List/"},{"name":"hihocoder","slug":"hihocoder","permalink":"https://www.oyohyee.com/tags/hihocoder/"}]},{"title":"POJ 1273.Drainage Ditches","date":"2016-09-18T16:25:53.000Z","path":"/post/POJ/1273.html","text":"题目 Description Every time it rains on Farmer John’s fields, a pond forms over Bessie’s favorite clover patch. This means that the clover is covered by water for awhile and takes quite a long time to regrow. Thus, Farmer John has built a set of drainage ditches so that Bessie’s clover patch is never covered in water. Instead, the water is drained to a nearby stream. Being an ace engineer, Farmer John has also installed regulators at the beginning of each ditch, so he can control at what rate water flows into that ditch.Farmer John knows not only how many gallons of water each ditch can transport per minute but also the exact layout of the ditches, which feed out of the pond and into each other and stream in a potentially complex network.Given all this information, determine the maximum rate at which water can be transported out of the pond and into the stream. For any given ditch, water flows in only one direction, but there might be a way that water can flow in a circle. Input The input includes several cases. For each case, the first line contains two space-separated integers, N (0 &lt;= N &lt;= 200) and M (2 &lt;= M &lt;= 200). N is the number of ditches that Farmer John has dug. M is the number of intersections points for those ditches. Intersection 1 is the pond. Intersection point M is the stream. Each of the following N lines contains three integers, Si, Ei, and Ci. Si and Ei (1 &lt;= Si, Ei &lt;= M) designate the intersections between which this ditch flows. Water will flow through this ditch from Si to Ei. Ci (0 &lt;= Ci &lt;= 10,000,000) is the maximum rate at which water will flow through the ditch. Output For each case, output a single integer, the maximum rate at which water may emptied from the pond. Sample Input 5 41 2 401 4 202 4 202 3 303 4 10 Sample Output 50 题解最大流最小割问题,建图后使用最大流算法解决即可采用 Dinic算法 解决 代码Drainage Ditches代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int INF = 0x7FFFFFFF / 2;const double eps = 1e-10;const int maxn = 205;const int maxm = 205*2;struct Edge &#123; int u,v,w; Edge():u(0),v(0),w(0) &#123;&#125; Edge(int a,int b,int c):u(a),v(b),w(c) &#123;&#125;&#125;;int pos;Edge edge[maxm];list&lt;int&gt; L[maxn];queue&lt;int&gt; Q;int dist[maxn];inline void add(int u,int v,int w) &#123; edge[pos] = Edge(u,v,w); L[u].push_back(pos); pos++;&#125;bool bfs(int s,int t) &#123; memset(dist,0,sizeof(dist)); while(!Q.empty()) Q.pop(); Q.push(s); dist[s] = 1; while(!Q.empty()) &#123; int u = Q.front(); Q.pop(); for(list&lt;int&gt;::iterator it = L[u].begin();it != L[u].end();it++) &#123; int v = edge[*it].v; if(!dist[v] &amp;&amp; edge[*it].w) &#123; dist[v] = dist[u] + 1; if(v == t) return true; Q.push(v); &#125; &#125; &#125; return false;&#125;int dfs(int u,int t,int flow) &#123; if(u == t) return flow; int remain = flow; for(list&lt;int&gt;::iterator it = L[u].begin();it != L[u].end() &amp;&amp; remain;it++) &#123; int v = edge[*it].v; if(dist[v] == dist[u] + 1 &amp;&amp; edge[*it].w) &#123; int k = dfs(v,t,min(remain,edge[*it].w)); if(!k) dist[v] = 0; edge[*it].w -= k; edge[(*it) ^ 1].w += k; remain -= k; &#125; &#125; return flow - remain;&#125;int Dinic(int u,int v) &#123; int ans = 0; while(bfs(u,v)) ans += dfs(u,v,INF); return ans;&#125;bool Do() &#123; int n,m; if(!(cin &gt;&gt; n &gt;&gt; m)) return false; for(int i = 1;i &lt;= m;i++) L[i].clear(); pos = 0; for(int i = 0;i &lt; n;i++) &#123; int u,v,w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u,v,w); add(v,u,0); &#125; cout &lt;&lt; Dinic(1,m) &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"网络流","slug":"Network-Flow","permalink":"https://www.oyohyee.com/tags/Network-Flow/"},{"name":"最大流最小割","slug":"Maxflow-Minimalcut","permalink":"https://www.oyohyee.com/tags/Maxflow-Minimalcut/"},{"name":"Dinic","slug":"Dinic","permalink":"https://www.oyohyee.com/tags/Dinic/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"HDU 1532.Drainage Ditches","date":"2016-09-18T16:25:53.000Z","path":"/post/HDU/1273.html","text":"原题,详细看 POJ 1273.Drainage Ditches","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"网络流","slug":"Network-Flow","permalink":"https://www.oyohyee.com/tags/Network-Flow/"},{"name":"最大流最小割","slug":"Maxflow-Minimalcut","permalink":"https://www.oyohyee.com/tags/Maxflow-Minimalcut/"},{"name":"Dinic","slug":"Dinic","permalink":"https://www.oyohyee.com/tags/Dinic/"}]},{"title":"HDU 5889.Barricade(2016 ACM/ICPC Asia Regional Qingdao Online)","date":"2016-09-17T13:37:02.000Z","path":"/post/HDU/5889.html","text":"题目 Description The empire is under attack again. The general of empire is planning to defend his castle. The land can be seen as N towns and M roads, and each road has the same length and connects two towns. The town numbered 1 is where general’s castle is located, and the town numbered N is where the enemies are staying. The general supposes that the enemies would choose a shortest path. He knows his army is not ready to fight and he needs more time. Consequently he decides to put some barricades on some roads to slow down his enemies. Now, he asks you to find a way to set these barricades to make sure the enemies would meet at least one of them. Moreover, the barricade on the i-th road requires wi units of wood. Because of lacking resources, you need to use as less wood as possible. Input The first line of input contains an integer t, then t test cases follow.For each test case, in the first line there are two integers N(N≤1000) and M(M≤10000).The i-the line of the next M lines describes the i-th edge with three integers u,v and w where 0≤w≤1000 denoting an edge between u and v of barricade cost w. Output For each test cases, output the minimum wood cost. Sample Input 14 41 2 12 4 23 1 34 3 4 Sample Output 4 题解在 1~n 的最短路上,删除权值和最少的边,使 1 和 n 在两个连通分量中 分开来看,删除尽可能少的边将两个点分到两个连通分量中,是 最小割问题而又要是最短路的边,因此应该先求一次最短路,保证处理 网络流 时,只有最短路中的边 因此该问题为 找出一个无向图中最短路中的边,建立网络流,求取最小割 由于 最小割等于最大流 因此可以转化为求 最大流问题 第一步,由于每条路的长度都是确定的(看作 1 )因此只需要使用普通的 BFS 即可求出每个点到起点的最短距离如果一个边的两个端点距离起点(源)的距离差不是 1 ,那么说明这条边不是最短路中的边将剩下的边建立网络流即可(有最短路的边,也有死路对连同无影响的边) 在网络流中,根据每个边的权值求取 1~n 的最小割(根据每个边的流量求取 1~n 的最大流) 求取最大流有 Ford-Fulkerson 、 Edmonds-Karp 和 Dicin使用 基于分层思想的网络流算法的 Dinic 算法 来解决最大流问题 直接套用模板即可 代码Barricade代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF/2;const double eps = 1e-10;const int maxn = 1005;const int maxm = 10005 * 2;struct Edge &#123; int u,v,w; Edge():u(0),v(0),w(0) &#123;&#125; Edge(int a,int b,int c):u(a),v(b),w(c) &#123;&#125;&#125;;int pos;Edge edge[maxm],road[maxm];list&lt;int&gt; L[maxn];int n,m;queue&lt;int&gt; Q;int dist[maxn];bool vis[maxn];void init() &#123; pos = 0; for(int i = 1;i &lt;= n;i++) L[i].clear();&#125;//图中增加 u→v 权重为 w 的边inline void add(int u,int v,int w) &#123; edge[pos] = Edge(u,v,w); L[u].push_back(pos); pos++;&#125;//Dinicbool bfs(int s,int t) &#123; memset(dist,0,sizeof(dist)); while(!Q.empty()) Q.pop(); Q.push(s); dist[s] = 1; while(!Q.empty()) &#123; int u = Q.front(); Q.pop(); for(list&lt;int&gt;::iterator it = L[u].begin();it != L[u].end();it++) &#123; int v = edge[*it].v; if(!dist[v] &amp;&amp; edge[*it].w) &#123; dist[v] = dist[u] + 1; if(v == t) return true; Q.push(v); &#125; &#125; &#125; return false;&#125;int dfs(int u,int t,int flow) &#123; if(u == t) return flow; int remain = flow; for(list&lt;int&gt;::iterator it = L[u].begin();it != L[u].end() &amp;&amp; remain;it++) &#123; int v = edge[*it].v; if(dist[v] == dist[u] + 1 &amp;&amp; edge[*it].w) &#123; int k = dfs(v,t,min(remain,edge[*it].w)); if(!k) dist[v] = 0; edge[*it].w -= k; edge[(*it) ^ 1].w += k; remain -= k; &#125; &#125; return flow - remain;&#125;int Dinic(int u,int v) &#123; int ans = 0; while(bfs(u,v)) ans += dfs(u,v,INF); return ans;&#125;void Do() &#123; //读入并建图 init(); cin &gt;&gt; n &gt;&gt; m; for(int i = 0;i &lt; m;i++) &#123; cin &gt;&gt; road[i].u &gt;&gt; road[i].v &gt;&gt; road[i].w; add(road[i].u,road[i].v,1); add(road[i].v,road[i].u,1); &#125; //BFS计算所有点到源点的距离 while(!Q.empty()) Q.pop(); for(int i = 1;i &lt;= n;i++) dist[i] = INF; memset(vis,false,sizeof(vis)); Q.push(1); dist[1] = 0; vis[1] = true; while(!Q.empty()) &#123; int u = Q.front(); Q.pop(); for(list&lt;int&gt;::iterator it = L[u].begin();it != L[u].end();it++) &#123; int v = edge[*it].v; if(!vis[v]) &#123; vis[v] = true; dist[v] = dist[u] + 1; Q.push(v); &#125; &#125; &#125; //重新建图,新图中只有最短路和死路 init(); for(int i = 0;i &lt; m;i++) &#123; int mx,mi; if(dist[road[i].u] &gt; dist[road[i].v]) &#123; mx = road[i].u; mi = road[i].v; &#125; else &#123; mi = road[i].u; mx = road[i].v; &#125; //较远点比较近点恰好远1个单位 if(dist[mx] - dist[mi] == 1) &#123; add(mi,mx,road[i].w); add(mx,mi,0); &#125; &#125; //Dinic模板求最大流(最小割) cout &lt;&lt; Dinic(1,n) &lt;&lt; endl;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--) Do(); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"网络流","slug":"Network-Flow","permalink":"https://www.oyohyee.com/tags/Network-Flow/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"DFS","slug":"DFS","permalink":"https://www.oyohyee.com/tags/DFS/"},{"name":"最大流最小割","slug":"Maxflow-Minimalcut","permalink":"https://www.oyohyee.com/tags/Maxflow-Minimalcut/"},{"name":"Dinic","slug":"Dinic","permalink":"https://www.oyohyee.com/tags/Dinic/"}]},{"title":"HDU 5882.Balanced Game(2016 ACM/ICPC Asia Regional Qingdao Online)","date":"2016-09-17T13:25:03.000Z","path":"/post/HDU/5882.html","text":"题目 DescriptionRock-paper-scissors is a zero-sum hand game usually played between two people, in which each player simultaneously forms one of three shapes with an outstretched hand. These shapes are “rock”, “paper”, and “scissors”. The game has only three possible outcomes other than a tie: a player who decides to play rock will beat another player who has chosen scissors (“rock crushes scissors”) but will lose to one who has played paper (“paper covers rock”); a play of paper will lose to a play of scissors (“scissors cut paper”). If both players choose the same shape, the game is tied and is usually immediately replayed to break the tie. Recently, there is a upgraded edition of this game: rock-paper-scissors-Spock-lizard, in which there are totally five shapes. The rule is simple: scissors cuts paper; paper covers rock; rock crushes lizard; lizard poisons Spock; Spock smashes scissors; scissors decapitates lizard; lizard eats paper; paper disproves Spock; Spock vaporizes rock; and as it always has, rock crushes scissors. Both rock-paper-scissors and rock-paper-scissors-Spock-lizard are balanced games. Because there does not exist a strategy which is better than another. In other words, if one chooses shapes randomly, the possibility he or she wins is exactly 50% no matter how the other one plays (if there is a tie, repeat this game until someone wins). Given an integer N, representing the count of shapes in a game. You need to find out if there exist a rule to make this game balanced. Input The first line of input contains an integer t, the number of test cases. t test cases follow.For each test case, there is only one line with an integer N (2≤N≤1000), as described above. Here is the sample explanation. In the first case, donate two shapes as A and B. There are only two kind of rules: A defeats B, or B defeats A. Obviously, in both situation, one shapes is better than another. Consequently, this game is not balanced. In the second case, donate two shapes as A, B and C. If A defeats B, B defeats C, and C defeats A, this game is balanced. This is also the same as rock-paper-scissors. In the third case, it is easy to set a rule according to that of rock-paper-scissors-Spock-lizard. Output For each test cases, output “Balanced” if there exist a rule to make the game balanced, otherwise output “Bad”. Sample Input 3235 Sample Output BadBalancedBalanced 题解判断出任意一个手势,赢的概率和输的概率是否一样 如果只有两个手势,有关系 A→B ,则出 A 必赢(不输) 如果有三个手势或五个手势,出任意一个手势赢的概率都是 50% 画成图像,可以看作对于每个结点,入度等于出度 如果总结点数为偶数,则对于任意一个结点,除它之外只能有奇数个结点,也即不可能入度等于出度而如果结点数为奇数,根据贪心可以确保每一个的入度都为出度 也即这道题的任务是判断 n 是奇数还是偶数 代码Balanced Game代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリ0隶�要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const double eps = 1e-10;void Do() &#123; int n; cin &gt;&gt; n; if(n &amp; 1) cout &lt;&lt; \"Balanced\" &lt;&lt; endl; else cout &lt;&lt; \"Bad\" &lt;&lt; endl;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--) Do(); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"}]},{"title":"HDU 5879.Cure(2016 ACM/ICPC Asia Regional Qingdao Online)","date":"2016-09-17T13:05:09.000Z","path":"/post/HDU/5879.html","text":"题目 DescriptionGiven an integer n, we only want to know the sum of 1/k2 where k from 1 to n. Input There are multiple cases.For each test case, there is a single line, containing a single positive integer n.The input file is at most 1M. Output The required sum, rounded to the fifth digits after the decimal point. Sample Input 124815 Sample Output 1.000001.250001.423611.527421.58044 题解求 Σ1/n2由于该式在 n→∞ 时,结果为 π&lt;sup&gt;2&lt;/sup&gt;/6 ( ≈1.64493 )由于只需要输出 5 位小数,因此当 n 足够大时,只需要输出一个确定值( 1.64493 )即可 本地调试测试可知,当数据大于 200000 时,就可以放心输出 1.64493 了因此可以先打表计算 200005 内的值,当读入的数大于 200005 时,直接输出即可 由于 n 的大小不确定,因此应该高精度读入(注意前导 0 )然后类似高精度的比较大小即可 代码Cure代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリ0隶�要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxn = 200005;LL n;double ans[maxn];char s[1000000];char cmp[] = \"200000\";int read_string(char s[]) &#123; char c; int i = 0; while(!((c = getchar()) &gt;= '1' &amp;&amp; c &lt;= '9')) if(c == EOF) return -1; while(c &gt;= '0'&amp;&amp;c &lt;= '9') &#123; s[i++] = c; c = getchar(); &#125; s[i] = '\\0'; return i;&#125;bool cmp_biger(char *a,char *b) &#123; int len1 = strlen(a); int len2 = strlen(b); if(len1 &gt; len2) return true; else if(len1 == len2) &#123; len1 = 0; while(a[len1] == b[len1] &amp;&amp; len1 &lt;= len2) len1++; if(len1 &lt;= len2 &amp;&amp; a[len1] &gt; b[len1]) return true; else return false; &#125; else return false;&#125;bool Do() &#123; if(read_string(s) == -1) return false; //cout &lt;&lt; cmp &lt;&lt; \" \" &lt;&lt; s &lt;&lt; endl &lt;&lt; \" \"; if(cmp_biger(cmp,s)) &#123; int len = strlen(s); n = 0; for(int i = 0;i &lt; len;i++) n = n * 10 + s[i] - '0'; cout &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; ans[n] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"1.64493\" &lt;&lt; endl; &#125; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); ans[1] = 1.0; for(int i = 2;i &lt; maxn;i++) ans[i] = ans[i - 1] + 1 / (double)i / (double)i; while(Do()); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"高精度算法","slug":"High-precision","permalink":"https://www.oyohyee.com/tags/High-precision/"}]},{"title":"HDU 1754.I Hate It","date":"2016-09-14T12:42:58.000Z","path":"/post/HDU/1754.html","text":"题目 Description 很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input 本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output 对于每一次询问操作，在一行里面输出最高成绩。 Sample Input 5 61 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5 Sample Output 5659 题解线段树单点更新问题 模板题,注意数组开的大小 代码I Hate It代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const double eps = 1e-10;int kase = 1;int ST[(2 &lt;&lt; 18) + 1];int Size;int Query(int a,int b) &#123; int l = Size + a - 1; int r = Size + b - 1; int Max = 0; while(r - l &gt; 1) &#123; if(l &amp; 1) &#123; Max = max(Max,ST[l]); l = (l &gt;&gt; 1) + 1; &#125; else &#123; l &gt;&gt;= 1; &#125; if(r &amp; 1) &#123; r &gt;&gt;= 1; &#125; else &#123; Max = max(Max,ST[r]); r = (r &gt;&gt; 1) - 1; &#125; &#125; if(l == r) Max = max(Max,ST[l]); else Max = max(Max,max(ST[l],ST[r])); return Max;&#125;void Update(int a,int b) &#123; int pos = Size + a - 1; ST[pos] = b; pos &gt;&gt;= 1; while(pos != 0) &#123; ST[pos] = max(ST[pos &lt;&lt; 1],ST[(pos &lt;&lt; 1) | 1]); pos &gt;&gt;= 1; &#125;&#125;void Build() &#123; for(int i = 1;i &lt; Size;i++) ST[i] = 0; for(int i = Size - 1;i &gt;= 1;i--) ST[i] = max(ST[i &lt;&lt; 1],ST[(i &lt;&lt; 1) | 1]);&#125;bool Do() &#123; int n,m; if(!(cin &gt;&gt; n &gt;&gt; m)) return false; Size = 1; while(Size &lt; n) Size &lt;&lt;= 1; for(int i = 1;i &lt; Size;i++) &#123; if(i &lt;= n) cin &gt;&gt; ST[Size + i - 1]; else ST[Size + i - 1] = 0; &#125; Build(); while(m--) &#123; char c; int a,b; cin &gt;&gt; c &gt;&gt; a &gt;&gt; b; if(c == 'U') Update(a,b); else cout &lt;&lt; Query(a,b) &lt;&lt;endl; &#125; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"线段树","slug":"Segment-tree","permalink":"https://www.oyohyee.com/tags/Segment-tree/"}]},{"title":"HDU 1166.敌兵布阵","date":"2016-09-13T13:03:30.000Z","path":"/post/HDU/1166.html","text":"题目 Description C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input 第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令 Output 对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input 1101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10End Sample Output Case 1:63359 题解线段树 - 基础单点更新 使用了 ZKW线段树 线段树的模板题,只需要更新单点(直接更新即可,不必先标记) 因为自己输入格式问题, TLE 了好久( End 后也读入了两个数字) 比较简单的模板题,如果不是手残应该能一遍过的 代码敌兵布阵代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const double eps = 1e-10;int kase = 1;int ST[(2 &lt;&lt; 16) + 1];int Size;int n;int Query(int a,int b) &#123; int l = Size + a - 1; int r = Size + b - 1; int sum = 0; while(r - l &gt; 1) &#123; if(l &amp; 1) &#123; sum += ST[l]; l = (l &gt;&gt; 1) + 1; &#125; else &#123; l &gt;&gt;= 1; &#125; if(r &amp; 1) &#123; r &gt;&gt;= 1; &#125; else &#123; sum += ST[r]; r = (r &gt;&gt; 1) - 1; &#125; &#125; if(l == r) sum += ST[l]; else sum += ST[l] + ST[r]; return sum;&#125;void Add(int a,int b) &#123; int pos = Size + a - 1; while(pos != 0) &#123; ST[pos] += b; pos &gt;&gt;= 1; &#125;&#125;inline void Sub(int a,int b) &#123; Add(a,-b);&#125;void Build() &#123; for(int i = 1;i &lt; Size;i++) ST[i] = 0; for(int i = Size - 1;i &gt;= 1;i--) ST[i] = ST[i &lt;&lt; 1] + ST[(i &lt;&lt; 1) + 1];&#125;void Do() &#123; cin &gt;&gt; n; Size = 1; while(Size &lt; n) Size &lt;&lt;= 1; for(int i = 1;i &lt; Size;i++) &#123; if(i &lt;= n) cin &gt;&gt; ST[Size + i - 1]; else ST[Size + i - 1] = 0; &#125; Build(); cout &lt;&lt; \"Case \" &lt;&lt; kase++ &lt;&lt; \":\" &lt;&lt; endl; string s; while(cin &gt;&gt; s,s != \"End\") &#123; int a,b; cin &gt;&gt; a &gt;&gt; b; if(s == \"Query\") cout &lt;&lt; Query(a,b) &lt;&lt; endl; else if(s == \"Sub\") Sub(a,b); else Add(a,b); &#125;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--) Do(); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"线段树","slug":"Segment-tree","permalink":"https://www.oyohyee.com/tags/Segment-tree/"}]},{"title":"Uva 11624.Fire!","date":"2016-09-09T14:09:14.000Z","path":"/post/Uva/11624.html","text":"题目 Joe works in a maze.Unfortunately, portions of the maze have caught on fire, and the owner of the maze neglected to create a fire escape plan.Help Joe escape the maze.Given Joe’s location in the maze and which squares of the maze are on fire, you must determine whether Joe can exit the maze before the fire reaches him, and how fast he can do it.Joe and the fire each move one square per minute, vertically or horizontally (not diagonally).The fire spreads all four directions from each square that is on fire.Joe may exit the maze from any square that borders the edge of the maze.Neither Joe nor the fire may enter a square that is occupied by a wall. Input The first line of input contains a single integer, the number of test cases to follow.The first line of each test case contains the two integers R and C, separated by spaces, with 1 ≤ R, C ≤ 1000.The following R lines of the test case each contain one row of the maze.Each of these lines contains exactly C characters, and each of these characters is one of: #, a wall ., a passable square J, Joe’s initial position in the maze, which is a passable square F, a square that is on fireThere will be exactly one J in each test case. Output For each test case, output a single line containing ‘IMPOSSIBLE’ if Joe cannot exit the maze before thefire reaches him, or an integer giving the earliest time Joe can safely exit the maze, in minutes. Sample Input 24 4 #JF# #..# #..#3 3 #J. #.F Sample Output 3IMPOSSIBLE 题解BFS问题只是迷宫的地图是动态的,可以在拓展结点的同时,判断是否需要更新迷宫地形,然后采用另一个 BFS 来更新火焰的位置需要注意的是 火焰起点不止一个 其他就是标准的模板 代码Fire!代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxn = 1005;const int delta[4] = &#123;1,-1,0,0&#125;;char Map[maxn][maxn];bool vis[maxn][maxn];bool fvis[maxn][maxn];int n,m;struct Node &#123; int x,y,dis; Node(int x,int y,int dis) &#123; this-&gt;x = x; this-&gt;y = y; this-&gt;dis = dis; &#125;&#125;;queue&lt;Node&gt; Q;queue&lt;Node&gt; Qf;void fire(int d) &#123; while(!Qf.empty()) &#123; int x = Qf.front().x; int y = Qf.front().y; int dis = Qf.front().dis; if(dis &gt; d) &#123; break; &#125; else &#123; Qf.pop(); &#125; for(int i = 0;i &lt;= 3;i++) &#123; int xx = x + delta[i]; int yy = y + delta[3 - i]; if(xx&lt;1 || xx&gt;n || yy&lt;1 || yy&gt;m) continue; if(Map[xx][yy] == '#') continue; if(fvis[xx][yy]) continue; fvis[xx][yy] = true; Map[xx][yy] = 'F'; Qf.push(Node(xx,yy,dis + 1)); &#125; &#125;&#125;void Do() &#123; int jx,jy; cin &gt;&gt; n &gt;&gt; m; memset(vis,false,sizeof(vis)); memset(fvis,false,sizeof(fvis)); while(!Q.empty()) Q.pop(); while(!Qf.empty()) Qf.pop(); for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= m;j++) &#123; cin &gt;&gt; Map[i][j]; if(Map[i][j] == 'J') jx = i,jy = j; if(Map[i][j] == 'F') &#123; Qf.push(Node(i,j,0)); fvis[i][j] = true; &#125; &#125; &#125; Map[jx][jy] = '.'; int ans = -1; Q.push(Node(jx,jy,0)); vis[jx][jy] = true; int lastdis = -1; while(!Q.empty()) &#123; int x = Q.front().x; int y = Q.front().y; int dis = Q.front().dis; Q.pop(); if(dis != lastdis) &#123; fire(dis); lastdis = dis; &#125; for(int i = 0;i &lt;= 3;i++) &#123; int xx = x + delta[i]; int yy = y + delta[3 - i]; int dist = dis + 1; if(xx&lt;1 || xx&gt;n || yy&lt;1 || yy&gt;m) &#123; ans = dist; break; &#125; if(Map[xx][yy] == '.' &amp;&amp; vis[xx][yy] == false) &#123; vis[xx][yy] = true; Q.push(Node(xx,yy,dist)); &#125; &#125; if(ans != -1) break; &#125; if(ans == -1) cout &lt;&lt; \"IMPOSSIBLE\" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--) Do(); return 0;&#125;","tags":[{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"}]},{"title":"POJ 1995.Raising Modulo Numbers","date":"2016-09-09T14:03:54.000Z","path":"/post/POJ/1995.html","text":"题目 Description People are different. Some secretly read magazines full of interesting girls’ pictures, others create an A-bomb in their cellar, others like using Windows, and some like difficult mathematical games. Latest marketing research shows, that this market segment was so far underestimated and that there is lack of such games. This kind of game was thus included into the KOKODáKH. The rules follow: Each player chooses two numbers Ai and Bi and writes them on a slip of paper. Others cannot see the numbers. In a given moment all players show their numbers to the others. The goal is to determine the sum of all expressions Ai Bi from all players including oneself and determine the remainder after division by a given number M. The winner is the one who first determines the correct result. According to the players’ experience it is possible to increase the difficulty by choosing higher numbers. You should write a program that calculates the result and is able to find out who won the game. Input The input consists of Z assignments. The number of them is given by the single positive integer Z appearing on the first line of input. Then the assignements follow. Each assignement begins with line containing an integer M (1 &lt;= M &lt;= 45000). The sum will be divided by this number. Next line contains number of players H (1 &lt;= H &lt;= 45000). Next exactly H lines follow. On each line, there are exactly two numbers Ai and Bi separated by space. Both numbers cannot be equal zero at the same time. Output For each assingnement there is the only one line of output. On this line, there is a number, the result of expression(A1B1+A2B2+ … +AHBH)mod M. Sample Input 31642 33 44 55 63612312374859 30293821713 18132 Sample Output 21319513 题解&gt;快速幂取模&lt; 代码Raising Modulo Numbers代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const double eps = 1e-10;LL exp_mod(LL a,LL n,LL b) &#123; LL t; if(n == 0) return 1 % b; if(n == 1) return a % b; t = exp_mod(a,n / 2,b); t = t * t % b; if((n &amp; 1) == 1) t = t * a % b; return t;&#125;void Do() &#123; int M; cin &gt;&gt; M; int n; cin &gt;&gt; n; LL ans = 0; for(int i = 0;i &lt; n;i++) &#123; int a,b; cin &gt;&gt; a &gt;&gt; b; ans = (ans + exp_mod(a,b,M)) % M; &#125; cout &lt;&lt; ans&lt;&lt;endl;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int Z; cin &gt;&gt; Z; while(Z--) Do(); return 0;&#125;","tags":[{"name":"快速幂取模","slug":"Raising-Modulo-Numbers","permalink":"https://www.oyohyee.com/tags/Raising-Modulo-Numbers/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"POJ 2184.Cow Exhibition","date":"2016-09-09T13:33:53.000Z","path":"/post/POJ/2184.html","text":"题目 Description “Fat and docile, big and dumb, they look so stupid, they aren’t muchfun…” Cows with Guns by Dana Lyons The cows want to prove to the public that they are both smart and fun. In order to do this, Bessie has organized an exhibition that will be put on by the cows. She has given each of the N (1 &lt;= N &lt;= 100) cows a thorough interview and determined two values for each cow: the smartness Si (-1000 &lt;= Si &lt;= 1000) of the cow and the funness Fi (-1000 &lt;= Fi &lt;= 1000) of the cow. Bessie must choose which cows she wants to bring to her exhibition. She believes that the total smartness TS of the group is the sum of the Si’s and, likewise, the total funness TF of the group is the sum of the Fi’s. Bessie wants to maximize the sum of TS and TF, but she also wants both of these values to be non-negative (since she must also show that the cows are well-rounded; a negative TS or TF would ruin this). Help Bessie maximize the sum of TS and TF without letting either of these values become negative. Input Line 1: A single integer N, the number of cows Lines 2..N+1: Two space-separated integers Si and Fi, respectively the smartness and funness for each cow. Output Line 1: One integer: the optimal sum of TS and TF such that both TS and TF are non-negative. If no subset of the cows has non-negative TS and non- negative TF, print 0. Sample Input 5-5 78 -66 -32 1-8 -5 Sample Output 8 Hint OUTPUT DETAILS: Bessie chooses cows 1, 3, and 4, giving values of TS = -5+6+2 = 3 and TF= 7-3+1 = 5, so 3+5 = 8. Note that adding cow 2 would improve the valueof TS+TF to 10, but the new value of TF would be negative, so it is notallowed. 题解每个牛有两个数值,这两个值有正有负,选取一部分牛,使得两个数值的总和最大,并且两个数值分别的和都是非负数 根据 选取一部分 ,可以转化成 对于一头牛,可以选择,也可以不选择 可以想到 背包问题 将其中一个数值看成体积,另一个看成价值,求取最大价值,然后将价值和对应的体积相加最大的就是结果 难点在于数值存在负数,有两种思路 使用 map 来模拟数组 使用指针偏移来使负数下标合理 使用指针偏移解决 然后就是直接的 01背包问题需要注意的是,根据背包问题的证明,正数部分需要逆序,正数部分需要正序 代码Cow Exhibition代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF / 2;const double eps = 1e-10;const int maxn = 105;const int Zero = 100 * 1000 + 5;const int maxV = 2 * Zero;int F[maxn],S[maxn];int dp[maxV];int *dp_zero = &amp;dp[Zero];int upv,lowv;void ZeroOnePack(int cost,int weight) &#123; if(cost &gt; 0) for(int i = upv; i &gt;= lowv; i--) dp_zero[i] = max(dp_zero[i],dp_zero[i - cost] + weight); else for(int i = lowv; i &lt;= upv; i++) dp_zero[i] = max(dp_zero[i],dp_zero[i - cost] + weight);&#125;bool Do() &#123; int n; if(!(cin &gt;&gt; n)) return false; for(int i = 1;i &lt;= n;i++) &#123; cin &gt;&gt; S[i] &gt;&gt; F[i]; if(S[i] &gt;= 0) upv += S[i]; else lowv += S[i]; &#125; for(int i = 0;i &lt; maxV;i++) dp[i] = -INF; dp_zero[0] = 0; for(int i = 1;i &lt;= n;i++) ZeroOnePack(S[i],F[i]); int Max = 0; for(int i = 0;i &lt; upv;i++) &#123; if(dp_zero[i] &gt;= 0) Max = max(dp_zero[i] + i,Max); &#125; cout &lt;&lt; Max &lt;&lt; endl; return true;&#125;int main()&#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"POJ 2739.Sum of Consecutive Prime Numbers","date":"2016-09-09T13:29:50.000Z","path":"/post/POJ/2739.html","text":"题目 Description Some positive integers can be represented by a sum of one or more consecutive prime numbers. How many such representations does a given positive integer have For example, the integer 53 has two representations 5 + 7 + 11 + 13 + 17 and 53. The integer 41 has three representations 2+3+5+7+11+13, 11+13+17, and 41. The integer 3 has only one representation, which is 3. The integer 20 has no such representations. Note that summands must be consecutive primenumbers, so neither 7 + 13 nor 3 + 5 + 5 + 7 is a valid representation for the integer 20.Your mission is to write a program that reports the number of representations for the given positive integer. Input The input is a sequence of positive integers each in a separate line. The integers are between 2 and 10 000, inclusive. The end of the input is indicated by a zero. Output The output should be composed of lines each corresponding to an input line except the last zero. An output line includes the number of representations for the input integer as the sum of one or more consecutive prime numbers. No other characters should be inserted in the output. Sample Input 2317412066612530 Sample Output 11230012 题解计算使用 10000 内的素数相加可以组成的数,求指定数相加的方案数 筛法求素数 然后打表计算即可 代码Sum of Consecutive Prime Numbers代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxn = 100005;int prime[maxn] = &#123;0&#125;,num_prime = 0;bool isNotPrime[maxn] = &#123;1,1&#125;;LL cnt[maxn];LL sum[maxn];bool Do() &#123; int n; cin &gt;&gt; n; if(n==0) return false; cout &lt;&lt; cnt[n] &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); for(long i = 2;i&lt;maxn;i++) &#123; if(!isNotPrime[i])prime[num_prime++] = i; for(int j = 0;j&lt;num_prime&amp;&amp;i*prime[j]&lt;maxn;j++) &#123; isNotPrime[i*prime[j]] = true; if(!(i%prime[j]))break; &#125; &#125; memset(cnt,0,sizeof(cnt)); sum[0] = prime[0]; for(int i = 1;i &lt; num_prime;i++) sum[i] = sum[i - 1] + prime[i]; for(int i = 0;i &lt; num_prime;i++) &#123; if(sum[i] &lt; maxn) cnt[sum[i]]++; for(int j = i + 1;j &lt; num_prime;j++) &#123; LL s = sum[j] - sum[i]; if(s &lt; maxn) cnt[s]++; &#125; &#125; while(Do()); return 0;&#125;","tags":[{"name":"质数","slug":"Prime","permalink":"https://www.oyohyee.com/tags/Prime/"},{"name":"打表","slug":"List","permalink":"https://www.oyohyee.com/tags/List/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"HYSBZ 1303.中位数图","date":"2016-09-09T13:12:54.000Z","path":"/post/HYSBZ/1303.html","text":"题目 Description 给出1~n的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是b。中位数是指把所有元素从小到大排列后，位于中间的数。 Input 第一行为两个正整数n和b ，第二行为1~n 的排列。 Output 输出一个整数，即中位数为b的连续子序列个数。 Sample Input 7 45 7 2 4 3 1 6 Sample Output 4Hint第三个样例解释：{4}, {7,2,4}, {5,7,2,4,3}和{5,7,2,4,3,1,6}N&lt;=100000 题解从一串数字中(无规律)寻找一个子串,使得该子串的中位数为要求的数,求子串的组数 由于数字本身没有规律,而寻找中位数需要规律,因此如果暴力解决需要 O(n3logn)显然这种时间复杂度很不靠谱 由于数字不存在重复( 1 ~ n ),并且选取的子串的数字个数必然是奇数,因此可以采用一些性质来计算 首先,中位数是一串数中,比它大的数和比它小的数个数相同的数因此可以先将数据处理成是否比要求的数大的形式(大于记为 1 ,小于记为 2 ,等于记为 0 )然后再使用 O(n) 的时间处理信息,分别计算从目标的数向左、向右抵消后仍然比该数大的个数用 map 记录一侧的的数达到某个数的组数,然后在另一侧将能与其抵消的相加起来,最后的数就是答案( 0 要特殊考虑) 样例解释如下: 数字 1 2 3 4 5 6 7 数据 5 7 2 4 3 1 6 第一次处理 +1 +1 -1 0 -1 -1 +1 第二次处理 1 0 -1 0 -1 -2 -1 将左侧(包括目标数)的数映射成 map 有 n -1 0 1 map 1 2 1 则针对右侧的数据,结果为 ans = 2 + map[1] + map[2] + map[1]其中 2 是 map 里 0 的个数 代码中位数图代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxn = 100005;int n,k;int a[maxn];int dp[maxn];map&lt;int,int&gt; m;bool Do() &#123; if(!(cin &gt;&gt; n &gt;&gt; k)) return false; int pos; for(int i = 0;i &lt; n;i++) &#123; cin &gt;&gt; a[i]; if(a[i] == k) pos = i; &#125; m.clear(); dp[pos] = 0; int ans = 1; m.insert(pair&lt;int,int&gt;(0,1)); for(int i = pos - 1;i &gt;= 0;i--) &#123; dp[i] = dp[i + 1] + ((a[i] &gt; k) ? 1 : -1); if(dp[i] == 0) ans++; if(m.count(dp[i])==0) m.insert(pair&lt;int,int&gt;(dp[i],0)); m[dp[i]]++; &#125; for(int i = pos + 1;i &lt; n;i++) &#123; dp[i] = dp[i - 1] + ((a[i] &gt; k) ? 1 : -1); if(m.count(-dp[i]) == 1) ans += m[-dp[i]]; &#125; cout &lt;&lt; ans &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"映射(map)","slug":"Map","permalink":"https://www.oyohyee.com/tags/Map/"},{"name":"HYSBZ","slug":"HYSBZ","permalink":"https://www.oyohyee.com/tags/HYSBZ/"}]},{"title":"HYSBZ 1002.轮状病毒","date":"2016-09-09T13:02:57.000Z","path":"/post/HYSBZ/1002.html","text":"题目 Description 轮状病毒有很多变种，所有轮状病毒的变种都是从一个轮状基产生的。一个N轮状基由圆环上N个不同的基原子和圆心处一个核原子构成的，2个原子之间的边表示这2个原子之间的信息通道。如下图所示 N轮状病毒的产生规律是在一个N轮状基中删去若干条边，使得各原子之间有唯一的信息通道，例如共有16个不同的3轮状病毒，如下图所示 现给定n(N&lt;=100)，编程计算有多少个不同的n轮状病毒 Input 第一行有1个正整数n Output 计算出的不同的n轮状病毒数输出 Sample Input 3 Sample Output 16 题解可以画出 4 时为 45也即 n 结果 1 1 2 5 3 16 4 45 可以找到 dp[i] = dp[i-1] * 3 - dp[i-2] + 2 的规律 虽然很难找,但是通过分类画图,应该能得出一部分,再加上猜测或许能找到规律 由于最后结果很大,因此需要 高精度计算 模板的减法有问题,耽误了好久 代码轮状病毒代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const double eps = 1e-10;string ans[] = &#123;\"0\",\"1\",\"5\",\"16\",\"45\",\"121\",\"320\",\"841\",\"2205\",\"5776\",\"15125\",\"39601\",\"103680\",\"271441\",\"710645\",\"1860496\",\"4870845\",\"12752041\",\"33385280\",\"87403801\",\"228826125\",\"599074576\",\"1568397605\",\"4106118241\",\"10749957120\",\"28143753121\",\"73681302245\",\"192900153616\",\"505019158605\",\"1322157322201\",\"3461452808000\",\"9062201101801\",\"23725150497405\",\"62113250390416\",\"162614600673845\",\"425730551631121\",\"1114577054219520\",\"2918000611027441\",\"7639424778862805\",\"20000273725560976\",\"52361396397820125\",\"137083915467899401\",\"358890350005878080\",\"939587134549734841\",\"2459871053643326445\",\"6440026026380244496\",\"16860207025497407045\",\"44140595050111976641\",\"115561578124838522880\",\"302544139324403592001\",\"792070839848372253125\",\"2073668380220713167376\",\"5428934300813767249005\",\"14213134522220588579641\",\"37210469265847998489920\",\"97418273275323406890121\",\"255044350560122222180445\",\"667714778405043259651216\",\"1748099984655007556773205\",\"4576585175559979410668401\",\"11981655542024930675232000\",\"31368381450514812615027601\",\"82123488809519507169850805\",\"215002084978043708894524816\",\"562882766124611619513723645\",\"1473646213395791149646646121\",\"3858055874062761829426214720\",\"10100521408792494338631998041\",\"26443508352314721186469779405\",\"69230003648151669220777340176\",\"181246502592140286475862241125\",\"474509504128269190206809383201\",\"1242282009792667284144565908480\",\"3252336525249732662226888342241\",\"8514727565956530702536099118245\",\"22291846172619859445381409012496\",\"58360810951903047633608127919245\",\"152790586683089283455442974745241\",\"400010949097364802732720796316480\",\"1047242260609005124742719414204201\",\"2741715832729650571495437446296125\",\"7177905237579946589743592924684176\",\"18791999880010189197735341327756405\",\"49198094402450621003462431058585041\",\"128802283327341673812651951847998720\",\"337208755579574400434493424485411121\",\"882823983411381527490828321608234645\",\"2311263194654570182037991540339292816\",\"6050965600552329018623146299409643805\",\"15841633607002416873831447357889638601\",\"41473935220454921602871195774259272000\",\"108580172054362347934782139964888177401\",\"284266580942632122201475224120405260205\",\"744219570773534018669643532396327603216\",\"1948392131377969933807455373068577549445\",\"5100956823360375782752722586809405045121\",\"13354478338703157414450712387359637585920\",\"34962478192749096460599414575269507712641\",\"91532956239544131967347531338448885552005\",\"239636390525883299441443179440077148943376\",\"627376215338105766356982006981782561278125\",\"1642492255488433999629502841505270534891001\"&#125;;bool Do() &#123; int n; if(!(cin &gt;&gt; n)) return false; cout &lt;&lt; ans[n] &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"高精度算法","slug":"High-precision","permalink":"https://www.oyohyee.com/tags/High-precision/"},{"name":"HYSBZ","slug":"HYSBZ","permalink":"https://www.oyohyee.com/tags/HYSBZ/"}]},{"title":"2016-08-28 ~ 2016-08-30 学习报告","date":"2016-08-31T04:59:10.000Z","path":"/post/Study/2016_08_28-2016_08_30.html","text":"题目： Uva 11210.Chinese Mahjong Uva 11384.Help is needed for Dexter Codeforces 711A.Bus to Udayland Codeforces 711B.Chris and Magic Square Codeforces 711C.Coloring Trees","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"ACM 2016级新生赛题解","date":"2016-08-30T11:23:35.000Z","path":"/post/Project/ACM2016_08_31.html","text":"本次比赛共 9 题主要目的是为了明确大家的实力,可以找到大家的短板,同时熟悉各种题型主要对象是自学过C\\C++的同学,开学后会有正式的比赛选拔 题解比较详细,前几题应该零基础的同学也能看懂 序号 题目名称 OJ编号 考察点 A A+B Problem POJ 1000 基本的输入输出 B 素数判定 HDU 2012 素数判定、循环、函数 C As Easy As A+B HDU 1040 给定组数的输入、排序算法 D Launch of Collider Codeforces 699A 思维 E King Moves Codeforces 710A 判断、循环 F 最小公倍数 HDU 1108 EOF结束的输入、欧几里得算法 G Catch That Cow HDU 2717 BFS H 命运 HDU 2571 动态规划 I 狼抓兔子 BZOJ 1001 网络流 如何读题 Description Calculate a+b Input Two integer a,b (0&lt;=a,b&lt;=10) Output Output a+b Sample Input 1 2 Sample Output 3 这是一个标准的 ACM题目,题目首先有一些信息: Time Limit: 1000MSMemory Limit: 10000KB64bit IO Format: %lld &amp; %llu 这些信息告诉了,运算这道题我们所拥有的运算资源: 共有 1s 的时间,并且内存被限制在 10M 以内 时间限制,要求我们不要进行无用的运算,并且尽可能选取时间复杂度较低的算法 内存限制,要求我们不要随便大范围申请内存,尽可能重复使用变量,并且舍弃不需要保存的信息 接下来是题面(容易出现问题的地方使用 粗体 显示) 题目背景(Description)这里会有题目的一些介绍,可能有废话,也有可能有运算方法 输入说明(Input)这里会讲解输入的格式 是否是多组数据 数据的类型是整数还是浮点数(小数) 整数可能达到的最值 如果最大是100000,一些时间复杂度比较高的算法可能就不能用了 如果最大值超过 231, int 就不能正常存储数据了 输出说明(Output)这里会说明输出的格式 如果有多组数据,两组数据间是不是输出空行 输出前是否要加类似 &quot;#Case 1:&quot; 的前缀 输出字符串是 yes 还是 Yes 还是 YES 样例输入(Sample Input)这里会给出几组符合题意的输入样例 输入重定向到文件输入,也即最后会有一个隐藏的 EOF (文件尾),在多组数据输入时,可以用来判断是否读入结束 样例输出(Sample Output)这里给出上面样例输入对应的结果,你的程序运算的结果必须与此处完全相同 输出不能有任何多余字符、空行、空格 即使输出与样例一样,也不证明你的程序能够 Accepted !!! 提示(Hint)如果题目比较难以理解,这里可能会有一些提示与样例数据的解释 如何理解OJ的返回信息对于所有OJ可能返回的信息有以下几种(经常出现的已 加粗) Accepted 含义: 通过 解释: 这个代表你的程序通过了所有测试数据 这是苦逼一天、一周甚至更久后,最让人激动的字符 (即使通过了所有数据,仍然有可能不是最完美) Pretest Passed 含义: 暂时通过 解释: 这个只出现在 Codeforces 上,证明你的程序通过了当前所有的数据,但是可能会死在终测时的极端数据上 Wrong Answer 含义: 答案错误 解释: 你的程序输出和测试数据的输出不同 解决办法: 重新读题,重新考虑输出的格式、算法、是否有没有考虑到的情况 Presentation Error 含义: 输出格式错误 解释: 你的程序输出格式与测试数据不一样 解决办法: 仔细检查空格、换行,重新读题,离成功只差一步 Compilation Error 含义: 编译错误 解释: 语法问题,自己反思吧 解决办法: 对照返回的信息改下 Runtime Error 含义: 程序运行时出错 解释: 可能是由于数组溢出,栈溢出,除以0等情况造成 解决办法: 检查数组是否开的过小 检查是否有意料外的数组访问 检查在最坏情况下的递归层次 检查除法的除数有没有可能是0 Time Limit Exceeded 含义: 超过时间限制 解释: 程序没有在规定的时间内运行完毕(不代表输出结果是对的) 解决办法: 查找是否存在死循环 换用更好的算法 删去一些不必要的操作 检查数组是否开的太小(个别OJ不报 RE 报 TLE ) Memory Limit Exceeded 含义: 超过内存限制 解释: 程序申请的内存过多 解决办法: 压缩使用的数组,尽量重复数组 不要保存没必要存下来的数据 A+B Problem Description 计算 a+b 的值 Input 两个整数 a 和 b a,b∈[1,10] Output 输出 a+b 的值 Sample Input 1 2 Sample Output 3 这是ACM的经典入门题目,计算两个数的和这道题一般学过编程的都能过 直接读入两个数字,然后输出和即可不牵扯大数,多组数据等任何问题 A+B Problem C语言版本#include &lt;stdio.h&gt;int main()&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\\n\",a+b); return 0;&#125; A+B Problem C++版本#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int a,b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a + b; return 0;&#125; 素数判定题目中文,略 首先先看输入输出,样例中有两行 0 10 0 这两行代表的意思分别是 数据输入 0 1,计算 n ∈ [0,1] 是否表达式的所有值都为素数 数据输入 0 0,表示输入结束,不处理该组数据,结束程序 输入有一行 OK 输出说明中有每组输出占一行,这句的意思是,每组数据都要占据单独的一行,也即每次输出完,要换行对于样例的输出,应该是 printf(&quot;OK\\n&quot;); 而不是 printf(&quot;OK&quot;); 虽然看上去,两组结果一样,但是对于电脑来说,文件的行数是不一样的 其他需要注意的就是 OK 和 Sorry 的拼法,注意大小写,注意没有 . 明白输入输出后,就可以开始做题了 题目要求的是 n^2+n+41 在 [-39,50] 的某个子集中是否结果全部是素数画图像可以得知,在这个区域里,表达式的值域为 [41,2591]也即我们需要判断 [41,2591] 里的一些数是否为整数 首先写一个函数 int isPrime(int n) 判断一个数是否位素数,如果是返回 1 ,如果不是返回 0(如果是 C++ ,可以使用 bool ) 然后我们来看程序主体,由于题目是多组输入,因此我们需要不断读入数据,可以使用 while每次我们读入 x 和 y , 然后判断他们是否 都为0,如果是,跳出则可以使用逗号表达式,从左向右运算,返回最后一个表达式的结果while(scanf(&quot;%d%d&quot;,&amp;x,&amp;y),!(x==0&amp;&amp;y==0)) 这样只要输入的是需要运算的数据,程序就会进行 while 的操作 对于这道题,需要的操作就是一个一个算 n^2+n+41 的值是不是素数如果发现有一个不是素数,就已经确定答案了,因此可以直接跳出循环(节省时间) 运算部分int AllPrime = 1;for(int i=x;i&lt;=y;i++) if(isPrime(i*i+i+41)==0)&#123; AllPrime = 0; break; &#125; 函数主体部分已经完成,然后是 isPrime() 函数的写法在这里有两种方法 暴力模拟法,一个数一个数除,看是否存在除了 1 和 本身之外的因子 筛法求素数,打表,这是一个基础算法,具体看筛法求素数 http://www.oyohyee.com/post/Algorithm/Prime.html#Eratosthenes筛法 以下是能够AC的代码素数判定#include &lt;stdio.h&gt;#include &lt;math.h&gt;int isPrime(int n)&#123; int Prime = 1; for(int i=2;i&lt;=sqrt(n);i++)&#123; if(n%i==0)&#123;//能整除,存在因子 Prime = 0; break; &#125; &#125; return Prime;&#125;int main()&#123; int x,y; while(scanf(\"%d%d\",&amp;x,&amp;y),!(x==0&amp;&amp;y==0))&#123; int AllPrime = 1; for(int i=x;i&lt;=y;i++) if(isPrime(i*i+i+41)==0)&#123; AllPrime = 0; break; &#125; if(AllPrime==1) printf(\"OK\\n\"); else printf(\"Sorry\\n\"); &#125; return 0;&#125; As Easy As A+B给出题目翻译 Description 这几天,我一直在想一个问题,如何出一道像 A+B 一样简单的题目 很显然,这是非常难的,不过熬了几夜后,我最终解决了 给你一些整数,你的任务是对这些数按照升序排序 很简单吧,加油！ Input 输入包括多组数据 第一行有一个整数 T 代表数据组数 接下来有 T 组数据 每组数据开始是一个整数 N (1","tags":[]},{"title":"Codeforces 711C.Coloring Trees","date":"2016-08-29T14:56:59.000Z","path":"/post/Codeforces/711C.html","text":"题目 ZS the Coder and Chris the Baboon has arrived at Udayland! They walked in the park where n trees grow. They decided to be naughty and color the trees in the park. The trees are numbered with integers from 1 to n from left to right. Initially, tree i has color ci. ZS the Coder and Chris the Baboon recognizes only m different colors, so 0 ≤ ci ≤ m, where ci = 0 means that tree i is uncolored. ZS the Coder and Chris the Baboon decides to color only the uncolored trees, i.e. the trees with ci = 0. They can color each of them them in any of the m colors from 1 to m. Coloring the i-th tree with color j requires exactly pi, j litres of paint. The two friends define the beauty of a coloring of the trees as the minimum number of contiguous groups (each group contains some subsegment of trees) you can split all the n trees into so that each group contains trees of the same color. For example, if the colors of the trees from left to right are 2, 1, 1, 1, 3, 2, 2, 3, 1, 3, the beauty of the coloring is 7, since we can partition the trees into 7 contiguous groups of the same color : {2}, {1, 1, 1}, {3}, {2, 2}, {3}, {1}, {3}. ZS the Coder and Chris the Baboon wants to color all uncolored trees so that the beauty of the coloring is exactly k. They need your help to determine the minimum amount of paint (in litres) needed to finish the job. Please note that the friends can’t color the trees that are already colored. Input The first line contains three integers, n, m and k (1 ≤ k ≤ n ≤ 100, 1 ≤ m ≤ 100) — the number of trees, number of colors and beauty of the resulting coloring respectively. The second line contains n integers c1, c2, …, cn (0 ≤ ci ≤ m), the initial colors of the trees. ci equals to 0 if the tree number i is uncolored, otherwise the i-th tree has color ci. Then n lines follow. Each of them contains m integers. The j-th number on the i-th of them line denotes pi, j (1 ≤ pi, j ≤ 109) — the amount of litres the friends need to color i-th tree with color j. pi, j’s are specified even for the initially colored trees, but such trees still can’t be colored. Output Print a single integer, the minimum amount of paint needed to color the trees. If there are no valid tree colorings of beauty k, print - 1. Examplesinput 3 2 20 0 01 23 45 6 output 10 input 3 2 22 1 21 32 43 5 output -1 input 3 2 22 0 01 32 43 5 output 5 input 3 2 32 1 21 32 43 5 output 0 Note In the first sample case, coloring the trees with colors 2, 1, 1 minimizes the amount of paint used, which equals to 2 + 3 + 5 = 10. Note that 1, 1, 1 would not be valid because the beauty of such coloring equals to 1 ({1, 1, 1} is a way to group the trees into a single group of the same color). In the second sample case, all the trees are colored, but the beauty of the coloring is 3, so there is no valid coloring, and the answer is - 1. In the last sample case, all the trees are colored and the beauty of the coloring matches k, so no paint is used and the answer is 0. 题解有一些树,每种树上涂有一些颜色, 0 代表可以涂任意一种颜色颜色编号 1~m ,第 i 个树涂上颜色 j 需要 pij 升颜料相邻的相同颜色的树可以看成一组 题目要求使用最少的颜料将树分成 k 组 不看分组部分,题目和 &gt;HDU 5074.Hatsune Miku(2014 鞍山赛区现场赛 E)&lt; 很像 稍微修改下选取颜色的部分 用 dp[i][j][k] 表示将前 j 棵树分成 i 组并且第 j 棵树颜色为 k 需要的最少的颜料用 ln 表示上棵树的颜色, tn 表示当前树的颜色则 dp[j][i][tn] = min(dp[j][i][tn],dp[j][i - 1][ln] + p[i][tn]) ln == tn dp[j][i][tn] = min(dp[j][i][tn],dp[j - 1][i - 1][ln] + p[i][tn]) ln != tn 数比较大,要用 long long 存,不过 Codeforces 要用 __int64 把所有值置为 INFdp[0][0][0] = 0 思路就这么个思路,乱搞莫名其妙就搞出来了╮(╯▽╰)╭ 代码Coloring Trees代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef __int64 LL;const LL INF = 0x7FFFFFFFFFFFFFFF/2;const int maxn = 105;int tree[maxn];int p[maxn][maxn];LL dp[maxn][maxn][maxn];int n,m,k;void DP(int i,int ln,int tn) &#123; for(int j = k;j &gt;= 1;j--) if(ln == tn) dp[j][i][tn] = min(dp[j][i][tn],dp[j][i - 1][ln] + p[i][tn]); else dp[j][i][tn] = min(dp[j][i][tn],dp[j - 1][i - 1][ln] + p[i][tn]);&#125;void TN(int i,int ln) &#123; if(tree[i] == 0) &#123; for(int j = 1;j &lt;= m;j++) DP(i,ln,j); &#125; else &#123; DP(i,ln,tree[i]); &#125;&#125;void LN(int i) &#123; if(tree[i - 1] == 0 &amp;&amp; i != 1) &#123; for(int j = 1;j &lt;= m;j++) TN(i,j); &#125; else &#123; TN(i,tree[i - 1]); &#125;&#125;bool Do() &#123; if(!(cin &gt;&gt; n &gt;&gt; m &gt;&gt; k)) return false; for(int i = 1;i &lt;= n;i++) cin &gt;&gt; tree[i]; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; cin &gt;&gt; p[i][j]; if(j == tree[i]) p[i][j] = 0; &#125; for(int i = 0;i &lt;= k;i++) for(int j = 0;j &lt;= n;j++) for(int o = 0;o &lt;= m;o++) dp[i][j][o] = INF; dp[0][0][0] = 0; for(int i = 1;i &lt;= n;i++) &#123; LN(i); &#125; LL Min = INF; for(int i = 1;i &lt;= m;i++) Min = min(Min,dp[k][n][i]); if(Min == INF) Min = -1; cout &lt;&lt; Min &lt;&lt; endl; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"Codeforces 711B.Chris and Magic Square","date":"2016-08-29T14:42:01.000Z","path":"/post/Codeforces/711B.html","text":"题目 ZS the Coder and Chris the Baboon arrived at the entrance of Udayland. There is a n × n magic grid on the entrance which is filled with integers. Chris noticed that exactly one of the cells in the grid is empty, and to enter Udayland, they need to fill a positive integer into the empty cell. Chris tried filling in random numbers but it didn’t work. ZS the Coder realizes that they need to fill in a positive integer such that the numbers in the grid form a magic square. This means that he has to fill in a positive integer so that the sum of the numbers in each row of the grid (), each column of the grid (), and the two long diagonals of the grid (the main diagonal — and the secondary diagonal — ) are equal. Chris doesn’t know what number to fill in. Can you help Chris find the correct positive integer to fill in or determine that it is impossible Input The first line of the input contains a single integer n (1 ≤ n ≤ 500) — the number of rows and columns of the magic grid. n lines follow, each of them contains n integers. The j-th number in the i-th of them denotes ai, j (1 ≤ ai, j ≤ 109 or ai, j = 0), the number in the i-th row and j-th column of the magic grid. If the corresponding cell is empty, ai, j will be equal to 0. Otherwise, ai, j is positive. It is guaranteed that there is exactly one pair of integers i, j (1 ≤ i, j ≤ n) such that ai, j = 0. Output Output a single integer, the positive integer x (1 ≤ x ≤ 1018) that should be filled in the empty cell so that the whole grid becomes a magic square. If such positive integer x does not exist, output - 1 instead. If there are multiple solutions, you may print any of them. Examplesinput 34 0 23 5 78 1 6 output 9 input 41 1 1 11 1 0 11 1 1 11 1 1 1 output 1 input 41 1 1 11 1 0 11 1 2 11 1 1 1 output -1 Note In the first sample case, we can fill in 9 into the empty cell to make the resulting grid a magic square. Indeed, The sum of numbers in each row is: 4 + 9 + 2 = 3 + 5 + 7 = 8 + 1 + 6 = 15. The sum of numbers in each column is: 4 + 3 + 8 = 9 + 5 + 1 = 2 + 7 + 6 = 15. The sum of numbers in the two diagonals is: 4 + 5 + 6 = 2 + 5 + 8 = 15. In the third sample case, it is impossible to fill a number in the empty square such that the resulting grid is a magic square. 题解在 0 的位置填入一个数,使每一行每一列以及两条最长的对角线的和相同在输入的同时记录 0 的位置找到任意一个没有 0 的行(列),计算总和,然后反推出 0 应该的取值给每个 0 影响到的行加上这个值,判断一遍有没有不合法的即可 要注意 10 这组数据应该输出任意一个整数 计算时,由于 ‘0’ 对总和没影响,可以在读入的同时直接记录下每行每列的和 判断总和只需要看第 0 行和第 1 行即可选择 0 不在的那行就行具体看代码 代码Chris and Magic Square代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 505;const int INF = 0x7FFFFFFF;typedef __int64 LL;LL Map[maxn][maxn];LL sum1[maxn];LL sum2[maxn];LL sum3,sum4;bool Do() &#123; int n; if(!(cin &gt;&gt; n)) return false; int tx,ty; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= n;j++) &#123; cin &gt;&gt; Map[i][j]; if(Map[i][j] == 0) &#123; tx = i; ty = j; &#125; &#125; LL ans = -1; bool can = true; if(n == 1) &#123; ans = 1; can = true; &#125; else &#123; memset(sum1,0,sizeof(sum1)); memset(sum2,0,sizeof(sum2)); sum3 = sum4 = 0; for(int i = 1;i &lt;= n;i++) &#123; sum3 += Map[i][i]; sum4 += Map[i][n - i + 1]; for(int j = 1;j &lt;= n;j++) &#123; sum1[i] += Map[i][j]; sum2[j] += Map[i][j]; &#125; &#125; LL sum = 0; if(tx == 1) sum = sum1[2]; else sum = sum1[1]; ans = sum - sum1[tx]; sum1[tx] += ans; sum2[ty] += ans; if(tx == ty) sum3 += ans; if(tx == n - ty + 1) sum4 += ans; for(int i = 1;i &lt;= n;i++) &#123; if(sum1[i] != sum || sum2[i] != sum) &#123; can = false; break; &#125; &#125; if(sum3 != sum || sum4 != sum) can = false; &#125; if(can &amp;&amp; ans &gt; 0) cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; \"-1\" &lt;&lt; endl; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"Codeforces 711A.Bus to Udayland","date":"2016-08-29T14:17:39.000Z","path":"/post/Codeforces/711A.html","text":"题目 ZS the Coder and Chris the Baboon are travelling to Udayland! To get there, they have to get on the special IOI bus. The IOI bus has n rows of seats. There are 4 seats in each row, and the seats are separated into pairs by a walkway. When ZS and Chris came, some places in the bus was already occupied. ZS and Chris are good friends. They insist to get a pair of neighbouring empty seats. Two seats are considered neighbouring if they are in the same row and in the same pair. Given the configuration of the bus, can you help ZS and Chris determine where they should sit Input The first line of the input contains a single integer n (1 ≤ n ≤ 1000) — the number of rows of seats in the bus. Then, n lines follow. Each line contains exactly 5 characters, the first two of them denote the first pair of seats in the row, the third character denotes the walkway (it always equals ‘|’) and the last two of them denote the second pair of seats in the row. Each character, except the walkway, equals to ‘O’ or to ‘X’. ‘O’ denotes an empty seat, ‘X’ denotes an occupied seat. See the sample cases for more details. Output If it is possible for Chris and ZS to sit at neighbouring empty seats, print “YES” (without quotes) in the first line. In the next n lines print the bus configuration, where the characters in the pair of seats for Chris and ZS is changed with characters ‘+’. Thus the configuration should differ from the input one by exactly two charaters (they should be equal to ‘O’ in the input and to ‘+’ in the output). If there is no pair of seats for Chris and ZS, print “NO” (without quotes) in a single line. If there are multiple solutions, you may print any of them. Examplesinput 6OO|OXXO|XXOX|OOXX|OXOO|OOOO|XX output YES++|OXXO|XXOX|OOXX|OXOO|OOOO|XX input 4XO|OXXO|XXOX|OXXX|OX output NO input 5XX|XXXX|XXXO|OXXO|OOOX|XO output YESXX|XXXX|XXXO|OXXO|++OX|XO Note Note that the following is an incorrect configuration for the first sample case because the seats must be in the same pair. O+|+X XO|XX OX|OO XX|OX OO|OO OO|XX 题解水题,给出公交车的座位情况 “O” 表示空位 “|” 表示过道 “X” 表示已经有人坐了找出两个相邻的空位标记上 “+” 输入的时候判断下即可 直接模拟正常思路就行 代码Bus to Udayland代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 1005;const int INF = 0x7FFFFFFF;char seat[maxn][8];bool Do() &#123; int n; if(!(cin &gt;&gt; n)) return false; bool yes = false; for(int i = 0;i &lt; n;i++) &#123; cin &gt;&gt; seat[i]; if(!yes&amp;&amp;seat[i][0] == 'O'&amp;&amp;seat[i][1] == 'O') &#123; seat[i][0] = seat[i][1] = '+'; yes = true; &#125; if(!yes&amp;&amp;seat[i][3] == 'O'&amp;&amp;seat[i][4] == 'O') &#123; seat[i][3] = seat[i][4] = '+'; yes = true; &#125; &#125; if(yes) &#123; cout &lt;&lt; \"YES\" &lt;&lt; endl; for(int i = 0;i &lt; n;i++) &#123; cout &lt;&lt; seat[i]&lt;&lt;endl; &#125; &#125; else &#123; cout &lt;&lt; \"NO\" &lt;&lt; endl; &#125; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"麦克风清灰","date":"2016-08-29T10:50:43.000Z","path":"/post/Writing/Microphone_cleaning.html","text":"第一次见手机话筒堵了没声的………… 打电话没声……急忙换耳机打,打完拿录音机测试发现有问题 敲击手机有震动声音记录 说话没声 看下面录音口和除噪口,堵死了!!!尴尬清了半天灰好了…… 设计问题！！！绝对是设计问题！！！ 看了下别的手机,口比这大得多。这么小铁定要堵啊………… 【图 按顺序是 耳机口 除噪口 充电口 话筒】","tags":[{"name":"Android","slug":"Android","permalink":"https://www.oyohyee.com/tags/Android/"},{"name":"三星(SAMSUNG)","slug":"SAMSUNG","permalink":"https://www.oyohyee.com/tags/SAMSUNG/"},{"name":"C5","slug":"C5","permalink":"https://www.oyohyee.com/tags/C5/"}]},{"title":"Uva 11384.Help is needed for Dexter","date":"2016-08-28T07:36:16.000Z","path":"/post/Uva/11384.html","text":"题目 Dexter is tired of Dee Dee. So he decided to keep Dee Dee busy in a game.The game he planned for her is quite easy to play but not easy to win at least not for Dee Dee.But Dexter does not have time to spend on this silly task, so he wants your help. There will be a button, when it will be pushed a random number N will be chosen by computer. Then on screen there will be numbers from 1 to N.Dee Dee can choose any number of numbers from the numbers on the screen, and then she will command computer to subtract a positive number chosen by her (not necessarily on screen) from the selected numbers.Her objective will be to make all the numbers 0. For example if N = 3, then on screen there will be 3 numbers on screen: 1, 2, 3.Say she now selects 1 and 2.Commands to subtract 1, then the numbers on the screen will be: 0, 1, 3.Then she selects 1 and 3 and commands to subtract 1.Now the numbers are 0, 0, 2.Now she subtracts 2 from 2 and all the numbers become 0. Dexter is not so dumb to understand that this can be done very easily, so to make a twist he will give a limit L for each N and surely L will be as minimum as possible so that it is still possible to win within L moves.But Dexter does not have time to think how to determine L for each N, so he asks you to write a code which will take N as Input and give L as Output. Input Input consists of several lines each with N such that 1 ≤ N ≤ 1, 000, 000, 000.Input will be terminated by end of file. Output For each N output L in separate lines. Sample Input 123 Sample Output 122 题解对 1~n 的数,可以任意选一些数,使这些数同时减去一个整数,最后使所有数都为 0求最少的步骤数 采用二分的思路解题,每次将最大的一部分折半减小,这样两部分就相等了,可以看作一部分每次都可以减少一半的工作量 二分法的思路,类似二分法的时间复杂度最后的结果就是 log2n 答案向上取整注意浮点数到整数的浮点误差 代码Help is needed for Dexter代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxn = 32;bool Do() &#123; int n; if(!(cin &gt;&gt; n)) return false; cout &lt;&lt; (int)(log(n)/log(2) + eps) + 1 &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"二分","slug":"Division","permalink":"https://www.oyohyee.com/tags/Division/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"},{"name":"算法竞赛入门经典","slug":"White-book","permalink":"https://www.oyohyee.com/tags/White-book/"}]},{"title":"Uva 11210.Chinese Mahjong","date":"2016-08-28T07:02:25.000Z","path":"/post/Uva/11210.html","text":"题目 Mahjong ( ) is a game of Chinese origin usually played by four persons with tiles resembling dominoesand bearing various designs, which are drawn and discarded until one player wins with a hand of fourcombinations of three tiles each and a pair of matching tiles.A set of Mahjong tiles will usually differ from place to place. It usually has at least 136 tiles, mostcommonly 144, although sets originating from America or Japan will have more. The 136-tile Mahjongincludes:Dots: named as each tile consists of a number of circles. Each circle is said to represent copper(tong) coins with a square hole in the middle. In this problem, they’re represented by 1T, 2T, 3T, 4T,5T, 6T, 7T, 8T and 9T.Bams: named as each tile (except the 1 Bamboo) consists of a number of bamboo sticks. Eachstick is said to represent a string (suo) that holds a hundred coins. In this problem, they’re representedby 1S, 2S, 3S, 4S, 5S, 6S, 7S, 8S and 9S.Craks: named as each tile represents ten thousand (wan) coins, or one hundred strings of onehundred coins. In this problem, they’re represented by 1W, 2W, 3W, 4W, 5W, 6W, 7W, 8W and 9W.Wind tiles: East, South, West, and North. In this problem, they’re represented by DONG, NAN,XI, BEI.Dragon tiles: red, green, and white. The term dragon tile is a western convention introduced byJoseph Park Babcock in his 1920 book introducing Mahjong to America. Originally, these tiles aresaid to have something to do with the Chinese Imperial Examination. The red tile means you pass theexamination and thus will be appointed a government official. The green tile means, consequently youwill become financially well off. The white tile (a clean board) means since you are now doing well youshould act like a good, incorrupt official. In this problem, they’re represented by ZHONG, FA, BAI.There are 9 3 + 4 + 3 = 34 kinds, with exactly 4 tiles of each kind, so there are 136 tiles in total.To who may be interested, the 144-tile Mahjong also includes:Flower tiles: typically optional components to a set of mahjong tiles, often contain artwork ontheir tiles. There are exactly one tile of each kind, so 136+8=144 tiles in total. In this problem, wedon t consider these tiles.Chinese Mahjong is very complicated. However, we only need to know very few of the rules in orderto solve this problem. A meld is a certain set of tiles in one’s hand. There are three kinds of meldsyou need to know (to who knows Mahjong already, kong is not considered):Pong: A set of three identical titles. Example: , .Chow: A set of three suited tiles in sequence. All three tiles must be of the same suites. Sequencesof higher length are not permissible (unless it forms more than one meld). Obviously, wind tiles anddragon tiles can never be involved in chows. Example: , .Eye: The pair, while not a meld, is the final component to the standard hand. It consists of anytwo identical tiles.A player wins the round by creating a standard mahjong hand. That means, the hand consists ofan eye and several (possible zero) pongs and chows. Note that each title can be involved in exactly oneeye/pong/chow.When a hand is one tile short of wining, the hand is said to be a ready hand, or more figuratively,’on the pot’. The player holding a ready hand is said to be waiting for certain tiles. For exampleis waiting for , and .To who knows more about Mahjong: don’t consider special winning hands such as ‘ ’. Input The input consists of at most 50 test cases. Each case consists of 13 tiles in a single line. The hand islegal (e.g. no invalid tiles, exactly 13 tiles). The last case is followed by a single zero, which should notbe processed. Output For each test case, print the case number and a list of waiting tiles sorted in the order appeared inthe problem ## Description (1T 9T, 1S 9S, 1W 9W, DONG, NAN, XI, BEI, ZHONG, FA, BAI). Each waiting tileshould be appeared exactly once. If the hand is not ready, print a message ‘Not ready’ without quotes. Sample Input 1S 1S 2S 2S 2S 3S 3S 3S 7S 8S 9S FA FA1S 2S 3S 4S 5S 6S 7S 8S 9S 1T 3T 5T 7T0 Sample Output Case 1: 1S 4S FACase 2: Not ready 题解给出手中已有的牌,求再加哪些牌能 “和” 总共只有 23 张排,枚举即可先枚举所有的可能再枚举所有的 “将”(两张一样的)再对剩下的牌分别用不同的方式凑成 “顺” 和 “刻” 纯 暴力模拟时刻明确自己在干什么,函数分清楚就行 代码Chinese Mahjong代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxn = 32;const string mj[34] = &#123; \"1T\",\"2T\",\"3T\",\"4T\",\"5T\",\"6T\",\"7T\",\"8T\",\"9T\", \"1S\",\"2S\",\"3S\",\"4S\",\"5S\",\"6S\",\"7S\",\"8S\",\"9S\", \"1W\",\"2W\",\"3W\",\"4W\",\"5W\",\"6W\",\"7W\",\"8W\",\"9W\", \"DONG\",\"NAN\",\"XI\",\"BEI\",\"ZHONG\",\"FA\",\"BAI\"&#125;;map&lt;string,int&gt; mjmap;int mjlist[34];int ans[34];int kase = 1;void init() &#123; mjmap.clear(); for(int i = 0;i &lt; 34;i++) mjmap.insert(pair&lt;string,int&gt;(mj[i],i));&#125;bool xp(int a = -1,int b = -1,int c = -1) &#123; //删除3张可以顺或者刻牌 if(a != -1) &#123; mjlist[a]--; mjlist[b]--; mjlist[c]--; &#125; bool empty = true; bool win = false; for(int i = 0;i &lt; 34;i++) &#123; if(mjlist[i] != 0) &#123; empty = false; bool can = false; if(mjlist[i] &gt;= 3) &#123; can = true; if(xp(i,i,i)) &#123; win = true; break; &#125; &#125; if(mjlist[i] &gt;= 1 &amp;&amp; ( (i &gt;= 0 &amp;&amp; i &lt;= 6) || (i &gt;= 9 &amp;&amp; i &lt;= 15) || (i &gt;= 18 &amp;&amp; i &lt;= 24)) &amp;&amp; mjlist[i + 1] &gt;= 1 &amp;&amp; mjlist[i + 2] &gt;= 1) &#123; can = true; if(xp(i,i + 1,i + 2)) &#123; win = true; break; &#125; &#125; if(!can) break; &#125; &#125; if(a != -1) &#123; mjlist[a]++; mjlist[b]++; mjlist[c]++; &#125; return empty || win;&#125;bool shun(int j) &#123; //用 j 做将时,是否能赢 mjlist[j] -= 2; bool win = false; for(int i = 0;i &lt; 34;i++) if(xp()) &#123; win = true; break; &#125; mjlist[j] += 2; return win;&#125;bool ting(int p) &#123; //判断加上编号为 p 的牌是否能赢 if(mjlist[p] == 4) return false; bool win = false; mjlist[p]++; for(int i = 0;i &lt; 34;i++) if(mjlist[i] &gt;= 2) if(shun(i)) &#123; win = true; break; &#125; mjlist[p]--; return win;&#125;bool Do() &#123; memset(mjlist,0,sizeof(mjlist)); int pos = 0; for(int i = 0;i &lt; 13;i++) &#123; string t; cin &gt;&gt; t; if(t == \"0\") return false; mjlist[mjmap[t]]++; &#125; for(int i = 0;i &lt; 34;i++) &#123; if(ting(i)) ans[pos++] = i; &#125; cout &lt;&lt; \"Case \" &lt;&lt; kase++ &lt;&lt; \":\"; if(pos) &#123; for(int i = 0;i &lt; pos;i++) cout &lt;&lt; \" \" &lt;&lt; mj[ans[i]]; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \" Not ready\" &lt;&lt; endl; &#125; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); init(); while(Do()); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"暴力","slug":"Violence","permalink":"https://www.oyohyee.com/tags/Violence/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"},{"name":"算法竞赛入门经典","slug":"White-book","permalink":"https://www.oyohyee.com/tags/White-book/"}]},{"title":"2016-08-25 ~ 2016-08-27 学习报告","date":"2016-08-28T04:59:10.000Z","path":"/post/Study/2016_08_25-2016_08_27.html","text":"题目： Uva 1030.Image Is Everything Uva 11464.Even Parity Uva 1352.Colored Cubes HDU 5078.Osu(2014 鞍山赛区现场赛 I) HDU 5074.Hatsune Miku(2014 鞍山赛区现场赛 E) HDU 5073.Galaxy(2014 鞍山赛区现场赛 D)","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"HDU 5073.Galaxy(2014 鞍山赛区现场赛 D)","date":"2016-08-27T11:52:56.000Z","path":"/post/HDU/5073.html","text":"题目 Description Good news for us: to release the financial pressure, the government started selling galaxies and we can buy them from now on! The first one who bought a galaxy was Tianming Yun and he gave it to Xin Cheng as a present. To be fashionable, DRD also bought himself a galaxy. He named it Rho Galaxy. There are n stars in Rho Galaxy, and they have the same weight, namely one unit weight, and a negligible volume. They initially lie in a line rotating around their center of mass. Everything runs well except one thing. DRD thinks that the galaxy rotates too slow. As we know, to increase the angular speed with the same angular momentum, we have to decrease the moment of inertia. The moment of inertia I of a set of n stars can be calculated with the formula where w i is the weight of star i, d i is the distance form star i to the mass of center. As DRD’s friend, ATM, who bought M78 Galaxy, wants to help him. ATM creates some black holes and white holes so that he can transport stars in a negligible time. After transportation, the n stars will also rotate around their new center of mass. Due to financial pressure, ATM can only transport at most k stars. Since volumes of the stars are negligible, two or more stars can be transported to the same position. Now, you are supposed to calculate the minimum moment of inertia after transportation. Input The first line contains an integer T (T ≤ 10), denoting the number of the test cases. For each test case, the first line contains two integers, n(1 ≤ n ≤ 50000) and k(0 ≤ k ≤ n), as mentioned above. The next line contains n integers representing the positions of the stars. The absolute values of positions will be no more than 50000. Output For each test case, output one real number in one line representing the minimum moment of inertia. Your answer will be considered correct if and only if its absolute or relative error is less than 1e-9. Sample Input 23 2-1 0 14 2-2 -1 1 2 Sample Output 00.5 题解给一些数,删去一些数,使剩下的数的方差最小 方差的意义是一串数的离散程度因此应该尽可能选取 “近” 的数 那么首先要做的第一件事就是排序这样只需要找到连续的串中最大的就行 所以可以再 O(n) 的时间里扫描所有的串 由于串的长度是确定的,因此每次都是减去一个数再加上一个数因此可以在 O(1) 的时间里算出所有数的和 sum 和平方的和 sums 我们要算的是方差,方差是 所有数与平均数的平方的和除以数目 也即 average = sum/(n-k) ans = {(a[i] - average)*(a[i] - average)}/(n-k) 展开化简可得 ans = (n - k)*average*average + sums - 2 * average*sum 这样可以再 O(1) 的时间算出来当前串的方差 能优化到这一步一般题应该没问题了,但是这个题还存在 溢出 的情况, sums 最大是非常大的,如果用 double 存,最高位和最低位错的会比较多只能继续转换公式,尽可能用 long long 存 再把上面的式子展开化简可得 ans = sums - sum*sum/(n-k)有一点技巧就是 在这里可以用 long long 保存ans = (n - k)*sums - sum*sum比较和保存这个值,由于 n-k 是常数,并不会对结果造成影响,最后输出的时候再除以 n-k 即可 注意各种细节的处理,因为 for 的循环条件坑了好久…… 代码Galaxy代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxn = 50005;int n,k;long long a[maxn];void Do() &#123; cin &gt;&gt; n &gt;&gt; k; for(int i = 0;i &lt; n;i++) cin &gt;&gt; a[i]; if(n - k &gt; 1) &#123; sort(a,a + n); long long Min = -1; long long sum = 0; long long sums = 0; for(int i = 0;i &lt; n - k;i++) &#123; sum += a[i]; sums += a[i] * a[i]; &#125; for(int i = 0;i &lt;= k;i++) &#123; if(i) &#123; sum -= a[i - 1]; sum += a[n - k + i - 1]; sums -= a[i - 1] * a[i - 1]; sums += a[n - k + i - 1] * a[n - k + i - 1]; &#125; //double average = sum / (double)(n - k); //double ans = (double)(n - k)*average*average + sums - 2 * average*sum; long long ans = (n - k)*sums - sum*sum; if(Min == -1) Min = ans; else Min = min(Min,ans); &#125; if(Min == -1) Min = 0; cout &lt;&lt; fixed &lt;&lt; setprecision(11) &lt;&lt; (double)Min / (double)(n - k) &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; 0 &lt;&lt; endl; &#125;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--) Do(); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"}]},{"title":"HDU 5074.Hatsune Miku(2014 鞍山赛区现场赛 E)","date":"2016-08-27T09:35:56.000Z","path":"/post/HDU/5074.html","text":"题目 Description Hatsune Miku is a popular virtual singer. It is very popular in both Japan and China. Basically it is a computer software that allows you to compose a song on your own using the vocal package. Today you want to compose a song, which is just a sequence of notes. There are only m different notes provided in the package. And you want to make a song with n notes. Also, you know that there is a system to evaluate the beautifulness of a song. For each two consecutive notes a and b, if b comes after a, then the beautifulness for these two notes is evaluated as score(a, b). So the total beautifulness for a song consisting of notes a 1, a 2, . . . , a n, is simply the sum of score(a i, a i+1) for 1 ≤ i ≤ n - 1. Now, you find that at some positions, the notes have to be some specific ones, but at other positions you can decide what notes to use. You want to maximize your song’s beautifulness. What is the maximum beautifulness you can achieve Input The first line contains an integer T (T ≤ 10), denoting the number of the test cases. For each test case, the first line contains two integers n(1 ≤ n ≤ 100) and m(1 ≤ m ≤ 50) as mentioned above. Then m lines follow, each of them consisting of m space-separated integers, the j-th integer in the i-th line for score(i, j)( 0 ≤ score(i, j) ≤ 100). The next line contains n integers, a 1, a 2, . . . , a n (-1 ≤ a i ≤ m, a i ≠ 0), where positive integers stand for the notes you cannot change, while negative integers are what you can replace with arbitrary notes. The notes are named from 1 to m. Output For each test case, output the answer in one line. Sample Input 25 383 86 7715 93 3586 92 493 3 3 1 210 536 11 68 67 2982 30 62 23 6735 29 2 22 5869 67 93 56 1142 29 73 21 19-1 -1 5 -1 4 -1 -1 -1 4 -1 Sample Output 270625 题解有不同的节奏,给出每两个节奏的分值,计算一首歌的最高得分正数代表节奏序号,负数代表可以填入任意一个节奏 由于歌曲长达 100 节奏种类多达 50如果所有情况都列举出来,可能数太多采用动态规划来处理 使用 dp[i][j] 来记录前 i 个节奏且第 i 个节奏为 j 的最高分数 循环到 i 时,如果 i-1 是不确定的,循环所有可能计算如果是确定的只需要计算这一种情况再同理判断 i ,两个数都得到后调用公式即可 由于此处嵌套比较乱,可以写成函数来使思路更加清晰(本来有 bug 改成函数瞬间就没 bug 了) 代码Hatsune Miku代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxm = 55;const int maxn = 105;int n,m;int score[maxm][maxm];int note[maxn];int dp[maxn][maxm];void DP(int i,int ln,int tn) &#123; dp[i][tn] = max(dp[i][tn],dp[i - 1][ln] + score[ln][tn]);&#125;void TN(int i,int ln) &#123; if(note[i] &lt; 0) &#123; for(int j = 1;j &lt;= m;j++) DP(i,ln,j); &#125; else &#123; DP(i,ln,note[i]); &#125;&#125;void LN(int i) &#123; if(note[i - 1] &lt; 0) &#123; for(int j = 1;j &lt;= m;j++) TN(i,j); &#125; else &#123; TN(i,note[i - 1]); &#125;&#125;void Do() &#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1;i &lt;= m;i++) for(int j = 1;j &lt;= m;j++) cin &gt;&gt; score[i][j]; for(int i = 0;i &lt; n;i++) cin &gt;&gt; note[i]; memset(dp,0,sizeof(dp)); for(int i = 1;i &lt; n;i++) &#123; LN(i); &#125; int Max = 0; for(int i = 1;i &lt;= m;i++) Max = max(Max,dp[n - 1][i]); cout &lt;&lt; Max &lt;&lt; endl;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--) Do(); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"HDU 5078.Osu(2014 鞍山赛区现场赛 I)","date":"2016-08-27T06:03:33.000Z","path":"/post/HDU/5078.html","text":"题目 Description Osu! is a very popular music game. Basically, it is a game about clicking. Some points will appear on the screen at some time, and you have to click them at a correct time. Now, you want to write an algorithm to estimate how diffecult a game is. To simplify the things, in a game consisting of N points, point i will occur at time t i at place (x i, y i), and you should click it exactly at t i at (x i, y i). That means you should move your cursor from point i to point i+1. This movement is called a jump, and the difficulty of a jump is just the distance between point i and point i+1 divided by the time between t i and t i+1. And the difficulty of a game is simply the difficulty of the most difficult jump in the game. Now, given a description of a game, please calculate its difficulty. Input The first line contains an integer T (T ≤ 10), denoting the number of the test cases. For each test case, the first line contains an integer N (2 ≤ N ≤ 1000) denoting the number of the points in the game. Then N lines follow, the i-th line consisting of 3 space-separated integers, t i(0 ≤ t i &lt; t i+1 ≤ 10 6), x i, and y i (0 ≤ x i, y i ≤ 10 6) as mentioned above. Output For each test case, output the answer in one line. Your answer will be considered correct if and only if its absolute or relative error is less than 1e-9. Sample Input 252 1 93 7 25 9 06 6 37 6 01011 35 6723 2 2929 58 2230 67 6936 56 9362 42 1167 73 2968 19 2172 37 8482 24 98 Sample Output 9.219544457354.5893762558 题解两个 note 之间的距离与时间差的比值叫做难度求整首歌的最大难度 直接按时间排序算一遍,求最大值即可尽量多输出小数保证精度 代码Osu代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxn = 1005;struct Node &#123; double t,x,y; bool operator &lt; (const Node &amp;rhs)const &#123; return t &lt; rhs.t; &#125; double operator - (const Node &amp;rhs)const &#123; return sqrt((x - rhs.x)*(x - rhs.x) + (y - rhs.y)*(y-rhs.y)); &#125;&#125;;Node note[maxn];void Do() &#123; int n; cin &gt;&gt; n; for(int i = 0;i &lt; n;i++) cin &gt;&gt; note[i].t &gt;&gt; note[i].x &gt;&gt; note[i].y; sort(note,note + n); double Max = 0; for(int i = 1;i &lt; n;i++) Max = max(Max,(note[i] - note[i - 1]) / (note[i].t - note[i - 1].t)); cout &lt;&lt; fixed &lt;&lt; setprecision(20) &lt;&lt; Max &lt;&lt; endl;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--) Do(); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"Uva 1352.Colored Cubes","date":"2016-08-26T13:30:36.000Z","path":"/post/Uva/1352.html","text":"题目图比较多,看原题吧 There are several colored cubes.All of them are of the same size but they may be colored differently. Each face of these cubes has a single color.Colors of distinct faces of a cube may or may not be the same. Two cubes are said to be identically colored if some suitable rotations of one of the cubes give identical looks to both of the cubes.For example, two cubes shown in Figure 2 are identically colored. A set of cubes is said to be identically colored if every pair of them are identically colored. A cube and its mirror image are not necessarily identically colored.For example, two cubes shown in Figure 3 are not identically colored. You can make a given set of cubes identically colored by repainting some of the faces, whatever colors the faces may have.In Figure 4, repainting four faces makes the three cubes identically colored and repainting fewer faces will never do. Your task is to write a program to calculate the minimum number of faces that needs to be repainted for a given set of cubes to become identically colored. Input The input is a sequence of datasets.A dataset consists of a header and a body appearing in this order. A header is a line containing one positive integer n and the body following it consists of n lines.You can assume that 1 ≤ n ≤ 4.Each line in a body contains six color names separated by a space.A color name consists of a word or words connected with a hyphen (-).A word consists of one or more lowercase letters.You can assume that a color name is at most 24-characters long including hyphens. A dataset corresponds to a set of colored cubes.The integer n corresponds to the number of cubes. Each line of the body corresponds to a cube and describes the colors of its faces.Color names in a lineis ordered in accordance with the numbering of faces shown in Figure 5.A line color1 color2 color3 color4 color5 color 6 corresponds to a cube colored as shown in Figure 6. The end of the input is indicated by a line containing a single zero.It is not a dataset nor a part of a dataset. Figure 2: Identically colored cubesFigure 3: cubes that are not identically coloredFigure 4: An example of recoloringFigure 5: Numbering of faces Figure 6: Coloring Output For each dataset, output a line containing the minimum number of faces that need to be repainted tomake the set of cub es identically colored. Sample Input 3scarlet green blue yellow magenta cyanblue pink green magenta cyan lemonpurple red blue yellow cyan green2red green blue yellow magenta cyancyan green blue yellow magenta red2red green gray gray magenta cyancyan green gray gray magenta red2red green blue yellow magenta cyanmagenta red blue yellow cyan green3red green blue yellow magenta cyancyan green blue yellow magenta redmagenta red blue yellow cyan green3blue green green green green bluegreen blue blue green green greengreen green green green green sea-green3red yellow red yellow red yellowred red yellow yellow red yellowred red red red red red4violet violet salmon salmon salmon salmonviolet salmon salmon salmon salmon violetviolet violet salmon salmon violet violetviolet violet violet violet salmon salmon1red green blue yellow magenta cyan4magenta pink red scarlet vermilion wine-redaquamarine blue cyan indigo sky-blue turquoise-blueblond cream chrome-yellow lemon olive yellowchrome-green emerald-green green olive vilidian sky-blue0 Sample Output 42002344016 题解第一个难点在于同一个立方体有不同的表示方式可以从任一个面开始,向它相邻的 4 个面进行描述这个立方体,因此每个立方体有 24 种描述方式 最初的想法是,计算每两个立方体的每种形态之间的 “距离”计算出最少的组合 最后发现有小问题: 最后的形态可能和之前每一种都不一样 因此需要 将每个面涂成当前面颜色最多的面 因此需要枚举所有情况,在每种描述方式下,计算每个面的最少的涂色方法 循环的层数不定,采用递归的方式最后用一个函数判断对应每个方块的描述方式的情况下最少的涂色方案 时间复杂度比较高,本地机子跑了 15s本来觉得肯定 TLE 结果竟然过了…… 不过该优化的地方还是要优化的,如果结果出现 0 证明已经找到结果了应该及时跳出循环 代码Colored Cubes代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxn = 5;const int order[24][6] = &#123; &#123;1,2,3,4,5,6&#125;, &#123;1,3,5,2,4,6&#125;, &#123;1,4,2,5,3,6&#125;, &#123;1,5,4,3,2,6&#125;, &#123;2,1,4,3,6,5&#125;, &#123;2,3,1,6,4,5&#125;, &#123;2,4,6,1,3,5&#125;, &#123;2,6,3,4,1,5&#125;, &#123;3,1,2,5,6,4&#125;, &#123;3,2,6,1,5,4&#125;, &#123;3,5,1,6,2,4&#125;, &#123;3,6,5,2,1,4&#125;, &#123;4,1,5,2,6,3&#125;, &#123;4,2,1,6,5,3&#125;, &#123;4,5,6,1,2,3&#125;, &#123;4,6,2,5,1,3&#125;, &#123;5,1,3,4,6,2&#125;, &#123;5,3,6,1,4,2&#125;, &#123;5,4,1,6,3,2&#125;, &#123;5,6,4,3,1,2&#125;, &#123;6,2,4,3,5,1&#125;, &#123;6,3,2,5,4,1&#125;, &#123;6,4,5,2,3,1&#125;, &#123;6,5,3,4,2,1&#125;&#125;;struct Cube &#123; string v[6];&#125;;Cube cube[maxn];int dis[maxn][maxn];//计算n个正方体,分别取a b c d视图的最优解int calc(int n,int a = -1,int b = -1,int c = -1,int d = -1) &#123; int num[] = &#123;a,b,c,d&#125;; map&lt;string,int&gt; m; int cnt[maxn]; int sum = 0; for(int k = 0;k &lt; 6;k++) &#123; //循环计算6个面 memset(cnt,0,sizeof(cnt)); m.clear(); int pos = 0; for(int i = 0;i &lt; n;i++) &#123; //第i个方块 int str = order[num[i]][k] - 1;//第i个方块第k个面在制定次序下的编号 if(m.count(cube[i].v[str]) == 0) m.insert(pair&lt;string,int&gt;(cube[i].v[str],pos++)); cnt[m[cube[i].v[str]]]++; &#125; sort(cnt,cnt + pos); sum += n - cnt[pos - 1]; &#125; return sum;&#125;int dfs(int n,int it,int a = -1,int b = -1,int c = -1,int d = -1) &#123; if(it == 0) &#123; return calc(n,a,b,c,d); &#125; else &#123; int num[] = &#123;a,b,c,d&#125;; int Min = INF; for(int i = 0;i &lt; 24;i++) &#123; num[n - it] = i; Min = min(Min,dfs(n,it - 1,num[0],num[1],num[2],num[3])); if(Min == 0) return 0; &#125; return Min; &#125;&#125;bool Do() &#123; int n; cin &gt;&gt; n; if(n == 0) return false; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; 6;j++) cin &gt;&gt; cube[i].v[j]; cout &lt;&lt; dfs(n,n - 1,0) &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"映射(map)","slug":"Map","permalink":"https://www.oyohyee.com/tags/Map/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"},{"name":"算法竞赛入门经典","slug":"White-book","permalink":"https://www.oyohyee.com/tags/White-book/"}]},{"title":"Uva 11464.Even Parity","date":"2016-08-26T07:16:29.000Z","path":"/post/Uva/11464.html","text":"题目 We have a grid of size N × N.Each cell of the grid initially contains a zero(0) or a one(1).The parity of a cell is the number of 1s surrounding that cell.A cell is surrounded by at most 4 cells (top, bottom, left, right). Suppose we have a grid of size 4 × 4: For this problem, you have to change some of the 0s to 1s so that the parity of every cell becomes even.We are interested in the minimum number of transformations of 0 to 1 that is needed to achieve the desired requirement. Input The first line of input is an integer T (T &lt; 30) that indicates the number of test cases.Each case starts with a positive integer N (1 ≤ N ≤ 15).Each of the next N lines contain N integers (0/1) each.The integers are separated by a single space character. Output For each case, output the case number followed by the minimum number of transformations required. If it’s impossible to achieve the desired result, then output ‘-1’ instead. Sample Input 330 0 00 0 00 0 030 0 01 0 00 0 031 1 11 1 10 0 0 Sample Output Case 1: 0Case 2: 3Case 3: -1 题解本来想使用动态规划,仔细一想压根没法计算 枚举 第一行的所有可能模拟 生成剩下的每一行,计算与原图最 相近 的 输出结果即可,没什么明显的大坑,就是交题的时候服务器抽了2个多小时 代码Even Parity代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxn = 16;const int delta[3][2] = &#123;&#123;-1,-1&#125;,&#123;-1,1&#125;,&#123;-2,0&#125;&#125;;int state[maxn];int Map[maxn];int n;int kase = 1;//比较两种状态,返回需要变成1的0的数量,不能完成返回-1int Get(int res,int e) &#123; int ans = 0; for(int i = 0;i &lt; n;i++) &#123; int a = res &amp; 1; int b = e &amp; 1; res &gt;&gt;= 1; e &gt;&gt;= 1; if(a != b) if(a == 0) ans++; else return -1; &#125; return ans;&#125;inline int SetI(int num,int i,bool flag) &#123; if(flag) return num | (1 &lt;&lt; i); else return num &amp; (~(1 &lt;&lt; i));&#125;inline bool GetI(int num,int i) &#123; return num &gt;&gt; i &amp; 1;&#125;void Do() &#123; cin &gt;&gt; n; int Min = INF; for(int i = 0;i &lt; n;i++) &#123; int m = 0; for(int j = 0;j &lt; n;j++) &#123; int t; cin &gt;&gt; t; m &lt;&lt;= 1; m = SetI(m,0,t); &#125; Map[i] = m; &#125; for(int k = 0;k &lt; (1 &lt;&lt; n);k++) &#123; //枚举初始态 int ans = 0; state[0] = k; int temp = Get(Map[0],state[0]); if(temp == -1) continue; else ans += temp; for(int i = 1;i &lt; n;i++) &#123; //处理第i行 for(int j = 0;j &lt; n;j++) &#123; //处理第j个位置 int sum = 0; for(int t = 0;t &lt; 3;t++) &#123; int xx = i + delta[t][0]; int yy = j + delta[t][1]; if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; n) &#123; sum += GetI(state[xx],yy); &#125; &#125; if(sum &amp; 1) state[i] = SetI(state[i],j,1); else state[i] = SetI(state[i],j,0); &#125; temp = Get(Map[i],state[i]); if(temp == -1) break; else ans += temp; &#125; if(temp == -1) continue; else Min = min(Min,ans); &#125; cout &lt;&lt; \"Case \" &lt;&lt; kase++ &lt;&lt; \": \"; if(Min == INF) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; Min &lt;&lt; endl;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--) Do(); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"位运算","slug":"Bit","permalink":"https://www.oyohyee.com/tags/Bit/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"},{"name":"算法竞赛入门经典","slug":"White-book","permalink":"https://www.oyohyee.com/tags/White-book/"}]},{"title":"2016-08-22 ~ 2016-08-24 学习报告","date":"2016-08-25T04:59:10.000Z","path":"/post/Study/2016_08_22-2016_08_24.html","text":"题目： Uva 1388.Graveyard Uva 10881.Piotr’s Ants","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"Uva 1030.Image Is Everything","date":"2016-08-25T04:26:48.000Z","path":"/post/Uva/1030.html","text":"题目 Your new company is building a robot that can hold small lightweight objects.The robot will have the intelligence to determine if an object is light enough to hold.It does this by taking pictures of the object from the 6 cardinal directions, and then inferring an upper limit on the object’s weight based on those images.You must write a program to do that for the robot.You can assume that each object is formed from an N × N × N lattice of cubes, some of which may be missing.Each 1 × 1 × 1 cube weighs 1 gram, and each cube is painted a single solid color.The object is not necessarily connected. Input The input for this problem consists of several test cases representing different objects.Every case begins with a line containing N, which is the size of the object (1 ≤ N ≤ 10).The next N lines are the different N × N views of the object, in the order front, left, back, right, top, bottom.Each view will be separated by a single space from the view that follows it.The bottom edge of the top view corresponds to the top edge of the front view.Similarly, the top edge of the bottom view corresponds to the bottom edge of the front view.In each view, colors are represented by single, unique capital letters, while a period (.) indicates that the object can be seen through at that location. Input for the last test case is followed by a line consisting of the number ‘0’. Output For each test case, print a line containing the maximum possible weight of the object, using the formatshown below. Sample Input 3.R. YYR .Y. RYY .Y. .R.GRB YGR BYG RBY GYB GRB.R. YRR .Y. RRY .R. .Y.2ZZ ZZ ZZ ZZ ZZ ZZZZ ZZ ZZ ZZ ZZ ZZ0 Sample Output Maximum weight: 11 gram(s)Maximum weight: 8 gram(s) 题解一道非常不水的水题没有用到任何算法,但是实现起来又到处都考验细节 首先是理解输入每 n 列划分在一起,每部分的矩形分别是前视图,左视图,后视图,右视图,顶视图,底视图 要求出最多的方块数,因此任务就是找到一定不合理的方块删掉,然后计算出剩下的方块还有多少 不合理的方块有以下可能 能够看透的方块本身不存在,必然不合理 不同视图有矛盾的方块一个方块的颜色是确定的,不管从哪个方向看一定是一样的 因此工作就是不同的从各个方向看这个立方体,判断每个方块是不是合理 使用 get() 函数获得从某个视图看 (a,b) 格第一个可能合法的方块(前面的方块已确定不存在) 使用 lp() 函数分担循环的工作根据参数的不同进行顺序和逆序循环及需要循环的维度 如图是各个视图与方块的对应关系根据对应关系确定某个视图应该是顺序查找还是逆序查找, (a,b) 对应的分别是哪个维度 一直找到所有方块全部都合法为止,统计还存在的方块 代码Image Is Everything代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxn = 16;//前 左 后 右 顶 底char view[6][maxn][maxn];char cube[maxn][maxn][maxn];int n;bool lp(bool sx,int &amp;x,int &amp;y,int &amp;z,int a = -1,int b = -1,int c = -1) &#123; int *i = &amp;a; if(a == -1) i = &amp;a; if(b == -1) i = &amp;b; if(c == -1) i = &amp;c; if(sx) &#123; for((*i) = 0;(*i) &lt; n;(*i)++) &#123; if(cube[a][b][c] != -1) &#123; x = a; y = b; z = c; return true; &#125; &#125; &#125; else &#123; for((*i) = n - 1;(*i) &gt;= 0;(*i)--) &#123; if(cube[a][b][c] != -1) &#123; x = a; y = b; z = c; return true; &#125; &#125; &#125; return false;&#125;bool Get(int v,int a,int b,int &amp;x,int &amp;y,int &amp;z) &#123; if(v == 0)//从前往后 return lp(true,x,y,z,-1,a,b); else if(v == 1)//从左往右 return lp(true,x,y,z,n - 1 - b,a,-1); else if(v == 2)//从后往前 return lp(false,x,y,z,-1,a,n - 1 - b); else if(v == 3)//从右往左 return lp(false,x,y,z,b,a,-1); else if(v == 4)//从上到下 return lp(true,x,y,z,n - 1 - a,-1,b); else//从下到上 return lp(false,x,y,z,a,-1,b);&#125;int Do() &#123; cin &gt;&gt; n; if(n == 0) return false; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; 6;j++) for(int k = 0;k &lt; n;k++) cin &gt;&gt; view[j][i][k]; memset(cube,0,sizeof(cube)); bool flag = true; while(flag) &#123; flag = false; for(int i = 0;i &lt; 6;i++) for(int j = 0;j &lt; n;j++) for(int k = 0;k &lt; n;k++) &#123; int x,y,z; if(Get(i,j,k,x,y,z)) &#123; if(view[i][j][k] == '.') &#123; //可以看透 cube[x][y][z] = -1; flag = true; &#125; else &#123; if(cube[x][y][z] == 0) &#123; //未涂色的方块 cube[x][y][z] = view[i][j][k]; flag = true; &#125; else if(cube[x][y][z] != view[i][j][k]) &#123; //涂色产生矛盾 cube[x][y][z] = -1; flag = true; &#125; &#125; &#125; &#125; &#125; int ans = 0; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) for(int k = 0;k &lt; n;k++) if(cube[i][j][k] != -1) ans++; cout &lt;&lt; \"Maximum weight: \" &lt;&lt; ans &lt;&lt; \" gram(s)\" &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"},{"name":"算法竞赛入门经典","slug":"White-book","permalink":"https://www.oyohyee.com/tags/White-book/"}]},{"title":"Uva 10881.Piotr's Ants","date":"2016-08-23T08:05:00.000Z","path":"/post/Uva/10881.html","text":"题目 Piotr likes playing with ants.He has n of them on a horizontal pole L cm long. Each ant is facing either left or right and walks at a constant speed of 1 cm/s.When two ants bump into each other, they both turn around (instantaneously) and start walking in opposite directions.Piotr knows where each of the ants starts and which direction it is facing and wants to calculate where the ants will end up T seconds from now. Input The first line of input gives the number of cases, N. N test cases follow. Each one starts with a linecontaining 3 integers: L , T and n (0 ≤ n ≤ 10000). The next n lines give the locations of the n ants(measured in cm from the left end of the pole) and the direction they are facing (L or R). Output For each test case, output one line containing ‘Case #x:’ followed by n lines describing the locationsand directions of the n ants in the same format and order as in the input. If two or more ants are atthe same location, print ‘Turning’ instead of ‘L’ or ‘R’ for their direction. If an ant falls off the polebefore T seconds, print ‘Fell off’ for that ant. Print an empty line after each test case. Sample Input 210 1 41 R5 R3 L10 R10 2 34 R5 L8 R Sample Output Case #1:2 Turning6 R2 TurningFell off Case #2:3 L6 R10 R 题解画图模拟下,很容易可以发现在忽略次序的情况下,完全可以无视碰撞,直接穿过单独记录次序输出即可 按照样例画下图应该不难想 给几组测试数据 12 10 1 2 3 R 4 L 10 1 2 1 R 2 L 10 1 2 1 R 3 L 3 2 2 1 R 3 L 3 1 2 1 R 3 L 10 2 3 1 R 2 R 3 R 10 1 4 1 R 5 R 3 L 10 R 10 2 3 4 R 5 L 8 R 1 1 1 1 L 5 3 5 4 L 2 R 5 L 1 R 3 L 10000 500 1 5 R 20 5 10 8 L 9 L 5 R 1 R 19 L 13 R 7 R 16 R 11 L 14 R Case #1: 3 L 4 R Case #2: 1 L 2 R Case #3: 2 Turning 2 Turning Case #4: 1 L 3 R Case #5: 2 Turning 2 Turning Case #6: 3 R 4 R 5 R Case #7: 2 Turning 6 R 2 Turning Fell off Case #8: 3 L 6 R 10 R Case #9: 0 L Case #10: 4 R 1 L 5 R 0 L 2 L Case #11: 505 R Case #12: 6 Turning 10 R 4 L 3 L Fell off 14 L 6 Turning 19 R 12 R 18 R 代码Piotr's Ants代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int INF = 0x7FFFFFFF;const double eps = 1e-10;const int maxn = 10005;struct Node &#123; int n; int pos; char d; bool operator &lt; (const Node &amp; rhs)const &#123; return pos &lt; rhs.pos; &#125; static bool compare(Node &amp;a,Node &amp;b) &#123; return a.n &lt; b.n; &#125;&#125;;Node ants[maxn];int kase = 1;int num[maxn];void Do() &#123; int L,T,n; cin &gt;&gt; L &gt;&gt; T &gt;&gt; n; for(int i = 0;i &lt; n;i++) &#123; cin &gt;&gt; ants[i].pos &gt;&gt; ants[i].d; ants[i].n = i; &#125; sort(ants,ants + n); for(int i = 0;i &lt; n;i++) &#123; num[ants[i].n] = i; if(ants[i].d == 'L') ants[i].pos -= T; else ants[i].pos += T; &#125; sort(ants,ants + n); for(int i = 1;i &lt; n;i++) if(ants[i].pos == ants[i - 1].pos) ants[i].d = ants[i - 1].d = 'T'; cout &lt;&lt; \"Case #\" &lt;&lt; kase++ &lt;&lt; \":\" &lt;&lt; endl; for(int i = 0;i &lt; n;i++) &#123; int t = num[i]; if(ants[t].pos &gt; L || ants[t].pos &lt; 0) cout &lt;&lt; \"Fell off\" &lt;&lt; endl; else if(ants[t].d == 'T') cout &lt;&lt; ants[t].pos &lt;&lt; \" Turning\" &lt;&lt; endl; else cout &lt;&lt; ants[t].pos &lt;&lt; \" \" &lt;&lt; ants[t].d &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--) Do(); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"},{"name":"算法竞赛入门经典","slug":"White-book","permalink":"https://www.oyohyee.com/tags/White-book/"}]},{"title":"Uva 1388.Graveyard","date":"2016-08-22T11:21:00.000Z","path":"/post/Uva/1388.html","text":"题目 Programming contests became so popular in the year 2397 that the governor of New Earck — the largest human-inhabited planet of the galaxy — opened a special Alley of Contestant Memories (ACM) at the local graveyard.The ACM encircles a green park, and holds the holographic statues of famous contestants placed equidistantly along the park perimeter.The alley has to be renewed from time to time when a new group of memorials arrives.When new memorials are added, the exact place for each can be selected arbitrarily along the ACM, but the equidistant disposition must be maintained by moving some of the old statues along the alley.Surprisingly, humans are still quite superstitious in 24th century:the graveyard keepers believe the holograms are holding dead people souls, and thus always try to renew the ACM with minimal possible movements of existing statues (besides, the holographic equipment is very heavy). Statues aremoved along the park perimeter. Your work is to find a renewal plan which minimizes the sum of travel distances of all statues. Installation of a new hologram adds no distance penalty, so choose the places for newcomers wisely! Input The input file contains several test cases, each of them consists of a a line that contains two integernumbers: n — the number of holographic statues initially located at the ACM, and m — the numberof statues to be added (2 ≤ n ≤ 1000, 1 ≤ m ≤ 1000). The length of the alley along the park perimeteris exactly 10 000 feet. Output For each test case, write to the output a line with a single real number — the minimal sum of traveldistances of all statues (in feet). The answer must be precise to at least 4 digits after decimal point.Note:Pictures show the first three examples. Marked circles denote original statues, empty circles denotenew equidistant places, arrows denote movement plans for existing statues. Sample Input 2 12 33 110 10 Sample Output 1666.66671000.01666.66670.0 题解原本有 n 个东西在圆周上平均分配,再多 m 个, 求最少需要移动的距离 画下图很容易找到关系将最上面当作原点,所有点从原点开始按间距摆放 每个点应该移动到与其最接近的点上,由于平均分配,并且是增加数量,因此新的图里,点会更加密集,这就保证了不会有有一个新位置同时是两个老位置的最近位置 只需要找到每个位置最近的新位置即可 最需要注意的是 double 造成的各种 浮点误差 结果最少输出 4 位精度,输出 6 位小数妥妥的 代码Graveyard代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const double eps = 1e-6;const double l = 10000;bool equal(double a,double b) &#123; return fabs(a - b) &lt; eps;&#125;int toInt(double a) &#123; return (int)(a + 0.001);&#125;bool Do() &#123; double n,m; if(!(cin &gt;&gt; n &gt;&gt; m)) return false; m += n; double per = l / n; double newper = l / m; double ans = 0; for(int i = 0;i &lt; n;i++) &#123; double pos = i * per; double newpos = pos / newper; if(!equal(newpos,(double)(toInt(newpos)))) &#123; int a = toInt(newpos); ans += min(fabs(pos - a*newper),fabs(pos - (a + 1)*newper)); &#125; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; ans &lt;&lt; endl; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"},{"name":"算法竞赛入门经典","slug":"White-book","permalink":"https://www.oyohyee.com/tags/White-book/"}]},{"title":"2016-08-19 ~ 2016-08-21 学习报告","date":"2016-08-22T04:59:10.000Z","path":"/post/Study/2016_08_19-2016_08_21.html","text":"题目： Uva 10125.SumsetsPOJ 2549.Sumsets Uva 11584.Partitioning by Palindromes POJ 2342.Anniversary party Uva 11292.Dragon of Loowater Codeforces 707A.Brain’s Photos Codeforces 707B.Bakery Codeforces 707C.Pythagorean Triples Uva 11729.Commando War Uva 11300.Spreading the Wealth","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"Uva 11300.Spreading the Wealth","date":"2016-08-21T09:18:16.000Z","path":"/post/Uva/11300.html","text":"题目 Description A Communist regime is trying to redistribute wealth in a village.They have have decided to sit everyone around a circular table.First, everyone has converted all of their properties to coins of equal value, such that the total number of coins is divisible by the number of people in the village.Finally, each person gives a number of coins to the person on his right and a number coins to the person on his left, such that in the end, everyone has the same number of coins.Given the number of coins of each person, compute the minimum number of coins that must be transferred using this method so that everyone has the same number of coins. Input There is a number of inputs. Each input begins with n (n &lt; 1000001), the number of people in thevillage. n lines follow, giving the number of coins of each person in the village, in counterclockwiseorder around the table. The total number of coins will fit inside an unsigned 64 bit integer. Output For each input, output the minimum number of coins that must be transferred on a single line. Sample Input 310010010041254 Sample Output 04 题解n 个人循环给金币,使大家最后的金币数一样 直接模拟非常麻烦根据数学推导假设第 i 个人原有 Ai 个金币,他会给第 i+1 个人(最后一个人给第 1 个) xi 个金币金币平均数为 M 对于第 1 个: M = A1 - x1 + xn 对于第 2 个: M = A2 - x2 + x1可化为: x2 = A2 - M + x1 对于第 3 个: M = A3 - x3 + x2可化为: x3 = A3 - M + x2 = A2 + A3 - 2M + x1 …… 对于第 n 个: xn = A2 + …… + An - (n-1)M + x1 要求的就是 |x1| + |x2| + |x3| + …… + |xn| 的最小值也即 |x1| + |A2 - M + x1| + |A2 + A3 - 2M + x1| + …… + |A2 + …… + An - (n-1)M + x1其中每部分非 x1 的部分全部都是常数,可化成 |x1 - c1| + |x1 - c2| + …… + |x1 - cn|只需求出距离坐标轴上 c1 c2 c3 …… cn 距离和最短的点显然最中间的点就是答案,可以取中间点(或中间两个点中间任意一个点),分别求出其到各点的和就是答案 需要使用 long long 状态不佳,简直药丸 代码Spreading the Wealth代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int maxn = 1000005;long long a[maxn];bool Do() &#123; int n; if(!(cin &gt;&gt; n)) return false; long long sum = 0; for(int i = 0;i &lt; n;i++) &#123; long long t; cin &gt;&gt; t; sum += t; if(i == 0) a[0] = t; else a[i] = sum - a[0]; &#125; sum /= n; for(int i = 0;i &lt; n;i++) &#123; if(i == 0) a[0] = 0; else a[i] -= i*sum; &#125; sort(a,a + n); sum = 0; for(int i = 0;i &lt; n;i++) sum += abs(a[i] - a[n / 2 - 1]); cout &lt;&lt; sum &lt;&lt; endl; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"},{"name":"算法竞赛入门经典","slug":"White-book","permalink":"https://www.oyohyee.com/tags/White-book/"}]},{"title":"Uva 11729.Commando War","date":"2016-08-21T03:56:24.000Z","path":"/post/Uva/11729.html","text":"题目 Description There is a war and it doesn’t look very promising for your country. Now it’s time to act.You have a commando squad at your disposal and planning an ambush on an important enemy camp located nearby.You have N soldiers in your squad.In your master-plan, every single soldier has a unique responsibility and you don’t want any of your soldier to know the plan for other soldiers so that everyone can focus on his task only.In order to enforce this, you brief every individual soldier about his tasks separately and just before sending him to the battlefield.You know that every single soldier needs a certain amount of time to execute his job.You also know very clearly how much time you need to brief every single soldier.Being anxious to finish the total operation as soon as possible, you need to find an order of briefing your soldiers that will minimize the time necessary for all the soldiers to complete their tasks.You may assume that, no soldier has a plan that depends on the tasks of his fellows.In other words, once a soldier begins a task, he can finish it without the necessity of pausing in between. Input There will be multiple test cases in the input file. Every test case starts with an integer N (1 ≤N ≤ 1000), denoting the number of soldiers. Each of the following N lines describe a soldier with twointegers B (1 ≤ B ≤ 10000) &amp; J (1 ≤ J ≤ 10000). B seconds are needed to brief the soldier whilecompleting his job needs J seconds. The end of input will be denoted by a case with N = 0. This caseshould not be processed. Output For each test case, print a line in the format, ‘Case X: Y ’, where X is the case number &amp; Y is thetotal number of seconds counted from the start of your first briefing till the completion of all jobs. Sample Input 32 53 22 133 34 45 50 Sample Output Case 1: 8Case 2: 15 题解有 安排工作时间 和 工作时间求最短的工作时间 要想时间最短就要尽可能让大家的工作时间重合显然应该先让工作时间最长的尽早投入到工作中 代码Commando War代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int maxn = 1005;struct Node &#123; int a,b; bool operator &lt; (const Node &amp;rhs)const &#123; if(b == rhs.b) return a &lt; rhs.a; return b &gt; rhs.b; &#125;&#125;;int kase = 1;Node s[maxn];bool Do() &#123; int n; cin &gt;&gt; n; if(n == 0) return false; for(int i = 0;i &lt; n;i++) cin &gt;&gt; s[i].a &gt;&gt; s[i].b; sort(s,s + n); int end = 0; int time = 0; for(int i = 0;i &lt; n;i++) &#123; time += s[i].a; end = max(end,time + s[i].b); &#125; cout &lt;&lt;\"Case \"&lt;&lt;kase++&lt;&lt;\": \"&lt;&lt; end &lt;&lt; endl; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"},{"name":"算法竞赛入门经典","slug":"White-book","permalink":"https://www.oyohyee.com/tags/White-book/"}]},{"title":"Codeforces 707C.Pythagorean Triples","date":"2016-08-20T14:47:48.000Z","path":"/post/Codeforces/707C.html","text":"题目 Description Katya studies in a fifth grade. Recently her class studied right triangles and the Pythagorean theorem. It appeared, that there are triples of positive integers such that you can construct a right triangle with segments of lengths corresponding to triple. Such triples are called Pythagorean triples. For example, triples (3, 4, 5), (5, 12, 13) and (6, 8, 10) are Pythagorean triples. Here Katya wondered if she can specify the length of some side of right triangle and find any Pythagorean triple corresponding to such length Note that the side which length is specified can be a cathetus as well as hypotenuse. Katya had no problems with completing this task. Will you do the same Input The only line of the input contains single integer n (1 ≤ n ≤ 109) — the length of some side of a right triangle. Output Print two integers m and k (1 ≤ m, k ≤ 1018), such that n, m and k form a Pythagorean triple, in the only line. In case if there is no any Pythagorean triple containing integer n, print - 1 in the only line. If there are many answers, print any of them. Examples input 3 output 4 5 input 6 output 8 10 input 1 output -1 input 17 output 144 145 input 67 output 2244 2245 题解对于完全平方数,有2n n2-1 n2+12n+1 2n2+2n 2n2+2n+1两种形式分别计算即可 当然,奇数直接 3 4 5 等比例扩大也行 代码Pythagorean Triples代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 100005;const int INF = 0x7FFFFFFF;bool Do() &#123; __int64 n; if(scanf(\"%I64d\",&amp;n) == EOF) return false; if(n == 1 || n == 2) printf(\"-1\\n\"); else if(n % 2) &#123; n = (n - 1) / 2; printf(\"%I64d %I64d\\n\",2 * n*n + 2 * n,2 * n*n + 2 * n + 1); &#125; else &#123; n /= 2; printf(\"%I64d %I64d\\n\",n*n - 1,n*n + 1); &#125; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"Codeforces 707B.Bakery","date":"2016-08-20T14:43:24.000Z","path":"/post/Codeforces/707B.html","text":"题目 Description Masha wants to open her own bakery and bake muffins in one of the n cities numbered from 1 to n. There are m bidirectional roads, each of whose connects some pair of cities. To bake muffins in her bakery, Masha needs to establish flour supply from some storage. There are only k storages, located in different cities numbered a1, a2, …, ak. Unforunately the law of the country Masha lives in prohibits opening bakery in any of the cities which has storage located in it. She can open it only in one of another n - k cities, and, of course, flour delivery should be paid — for every kilometer of path between storage and bakery Masha should pay 1 ruble. Formally, Masha will pay x roubles, if she will open the bakery in some city b (ai ≠ b for every 1 ≤ i ≤ k) and choose a storage in some city s (s = aj for some 1 ≤ j ≤ k) and b and s are connected by some path of roads of summary length x (if there are more than one path, Masha is able to choose which of them should be used). Masha is very thrifty and rational. She is interested in a city, where she can open her bakery (and choose one of k storages and one of the paths between city with bakery and city with storage) and pay minimum possible amount of rubles for flour delivery. Please help Masha find this amount. Input The first line of the input contains three integers n, m and k (1 ≤ n, m ≤ 105, 0 ≤ k ≤ n) — the number of cities in country Masha lives in, the number of roads between them and the number of flour storages respectively. Then m lines follow. Each of them contains three integers u, v and l (1 ≤ u, v ≤ n, 1 ≤ l ≤ 109, u ≠ v) meaning that there is a road between cities u and v of length of l kilometers . If k &gt; 0, then the last line of the input contains k distinct integers a1, a2, …, ak (1 ≤ ai ≤ n) — the number of cities having flour storage located in. If k = 0 then this line is not presented in the input. Output Print the minimum possible amount of rubles Masha should pay for flour delivery in the only line. If the bakery can not be opened (while satisfying conditions) in any of the n cities, print - 1 in the only line. Examplesinput 5 4 21 2 51 2 32 3 41 4 101 5 output 3 input 3 1 11 2 33 output -1 题解输出距离最后 k 个点最近的点(不在 k 个点中)的距离 直接模拟即可使用二分查找的时间可以忽略 代码Bakery代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 100005;const int INF = 0x7FFFFFFF;struct Node &#123; int u,v,w; Node(int a = -1,int b = -1,int c = -1) &#123; u = a; v = b; w = c; &#125; bool operator &lt;(const Node &amp;rhs)const &#123; if(u == rhs.u) if(v == rhs.v) return w &lt; rhs.w; else return v &lt; rhs.v; else return u &lt; rhs.u; &#125; bool operator &lt;(const int &amp;rhs)const &#123; return u &lt; rhs; &#125;&#125;;Node edge[2 * maxn];bool storage[maxn];bool Do() &#123; int n,m,k; if(scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k) == EOF) return false; int pos = 0; for(int i = 0;i &lt; m;i++) &#123; int u,v,w; scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); edge[pos++] = Node(u,v,w); edge[pos++] = Node(v,u,w); &#125; int ans = INF; memset(storage,false,sizeof(storage)); for(int i = 0;i &lt; k;i++) &#123; int p; scanf(\"%d\",&amp;p); storage[p] = true; &#125; sort(edge,edge + pos); for(int i = 1;i &lt;= n;i++) if(storage[i]) &#123; int it = lower_bound(edge,edge + pos,i) - edge; for(it;it &lt; pos &amp;&amp; edge[it].u == i;it++) if(!storage[edge[it].v]) ans = min(ans,edge[it].w); &#125; if(ans == INF) printf(\"-1\\n\"); else printf(\"%d\\n\",ans); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"Codeforces 707A.Brain's Photos","date":"2016-08-20T14:40:04.000Z","path":"/post/Codeforces/707A.html","text":"题目 Description Small, but very brave, mouse Brain was not accepted to summer school of young villains. He was upset and decided to postpone his plans of taking over the world, but to become a photographer instead. As you may know, the coolest photos are on the film (because you can specify the hashtag #film for such). Brain took a lot of colourful pictures on colored and black-and-white film. Then he developed and translated it into a digital form. But now, color and black-and-white photos are in one folder, and to sort them, one needs to spend more than one hour! As soon as Brain is a photographer not programmer now, he asks you to help him determine for a single photo whether it is colored or black-and-white. Photo can be represented as a matrix sized n × m, and each element of the matrix stores a symbol indicating corresponding pixel color. There are only 6 colors: ‘C’ (cyan)‘M’ (magenta)‘Y’ (yellow)‘W’ (white)‘G’ (grey)‘B’ (black)The photo is considered black-and-white if it has only white, black and grey pixels in it. If there are any of cyan, magenta or yellow pixels in the photo then it is considered colored. Input The first line of the input contains two integers n and m (1 ≤ n, m ≤ 100) — the number of photo pixel matrix rows and columns respectively. Then n lines describing matrix rows follow. Each of them contains m space-separated characters describing colors of pixels in a row. Each character in the line is one of the ‘C’, ‘M’, ‘Y’, ‘W’, ‘G’ or ‘B’. Output Print the “#Black&amp;White” (without quotes), if the photo is black-and-white and “#Color” (without quotes), if it is colored, in the only line. Examplesinput 2 2C MY Y output #Color input 3 2W WW WB B output #Black&amp;White input 1 1W output #Black&amp;White 题解只有黑( B ) 白( W ) 灰( G ) 输出 #Black&amp;White 否则输出 #Color 代码Brain's Photos代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 1030;const int INF = 0x7FFFFFFF;char a[maxn],b[maxn];int dp[maxn][maxn];bool Do() &#123; int n,m; if(scanf(\"%d%d\",&amp;n,&amp;m) == EOF) return false; bool color = false; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) &#123; char c; scanf(\"\\n%c\",&amp;c); if(!(c == 'W' || c == 'B' || c=='G')) color = true; &#125; if(color) printf(\"#Color\\n\"); else printf(\"#Black&amp;White\\n\"); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"Uva 11292.Dragon of Loowater","date":"2016-08-20T10:04:48.000Z","path":"/post/Uva/11292.html","text":"题目 Description Once upon a time, in the Kingdom of Loowater, a minor nuisance turned into a major problem.The shores of Rellau Creek in central Loowater had always been a prime breeding ground for geese.Due to the lack of predators, the geese population was out of control.The people of Loowater mostly kept clear of the geese.Occasionally, a goose would attack one of the people, and perhaps bite off a finger or two, but in general, the people tolerated the geese as a minor nuisance.One day, a freak mutation occurred, and one of the geese spawned a multi-headed fire-breathing dragon. When the dragon grew up, he threatened to burn the Kingdom of Loowater to a crisp.Loowater had a major problem. The king was alarmed, and called on his knights to slay the dragon and save the kingdom.The knights explained: “To slay the dragon, we must chop off all its heads.Each knight can chop off one of the dragon’s heads. The heads of the dragon are of different sizes. In order to chop off a head, a knight must be at least as tall as the diameter of the head.The knights’ union demands that for chopping off a head, a knight must be paid a wage equal to one gold coin for each centimetre of the knight’s height.”Would there be enough knights to defeat the dragon The king called on his advisors to help him decide how many and which knights to hire. After having lost a lot of money building Mir Park, theking wanted to minimize the expense of slaying the dragon. As one of the advisors, your job was to help the king. You took it very seriously: if you failed, you and the whole kingdom would be burnt to a crisp! Input The input contains several test cases. The first line of each test case contains two integers between 1 and20000 inclusive, indicating the number n of heads that the dragon has, and the number m of knights inthe kingdom. The next n lines each contain an integer, and give the diameters of the dragon’s heads,in centimetres. The following m lines each contain an integer, and specify the heights of the knights ofLoowater, also in centimetres.The last test case is followed by a line containing ‘0 0’. Output For each test case, output a line containing the minimum number of gold coins that the king needs topay to slay the dragon. If it is not possible for the knights of Loowater to slay the dragon, output theline ‘Loowater is doomed!’. Sample Input 2 3547842 155100 0 Sample Output 11Loowater is doomed! 题解贪心问题要想尽可能的少花金币,就要在屠龙的时候选最不浪费的骑士二分搜索 lower_bound() 往后找即可 代码Dragon of Loowater代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int maxn = 20005;int dragon[maxn];int knight[maxn];bool vis[maxn];bool Do() &#123; int n,m; cin &gt;&gt; n &gt;&gt; m; if(n == 0 &amp;&amp; m == 0) return false; for(int i = 0;i &lt; n;i++) cin &gt;&gt; dragon[i]; for(int i = 0;i &lt; m;i++) cin &gt;&gt; knight[i]; int ans = 0; sort(dragon,dragon + n); sort(knight,knight + m); memset(vis,false,sizeof(vis)); for(int i = 0;i &lt; n;i++) &#123; int it = lower_bound(knight,knight + m,dragon[i]) - knight; for(it;it&lt;m;it++) if(!vis[it]) &#123; ans += knight[it]; vis[it] = true; break; &#125; if(it == m) &#123; ans = -1; break; &#125; &#125; if(ans == -1) &#123; cout &lt;&lt; \"Loowater is doomed!\" &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; ans &lt;&lt; endl; &#125; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"二分","slug":"Division","permalink":"https://www.oyohyee.com/tags/Division/"},{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"},{"name":"算法竞赛入门经典","slug":"White-book","permalink":"https://www.oyohyee.com/tags/White-book/"}]},{"title":"POJ 2342.Anniversary party","date":"2016-08-20T07:41:22.000Z","path":"/post/POJ/2342.html","text":"题目 Description There is going to be a party to celebrate the 80-th Anniversary of the Ural State University. The University has a hierarchical structure of employees. It means that the supervisor relation forms a tree rooted at the rector V. E. Tretyakov. In order to make the party funny for every one, the rector does not want both an employee and his or her immediate supervisor to be present. The personnel office has evaluated conviviality of each employee, so everyone has some number (rating) attached to him or her. Your task is to make a list of guests with the maximal possible sum of guests’ conviviality ratings. Input Employees are numbered from 1 to N. A first line of input contains a number N. 1 &lt;= N &lt;= 6 000. Each of the subsequent N lines contains the conviviality rating of the corresponding employee. Conviviality rating is an integer number in a range from -128 to 127. After that go N – 1 lines that describe a supervisor relation tree. Each line of the tree specification has the form:L KIt means that the K-th employee is an immediate supervisor of the L-th employee. Input is ended with the line0 0 Output Output should contain the maximal sum of guests’ ratings. Sample Input 711111111 32 36 47 44 53 50 0 Sample Output 5 题解树形dp 的样例题 树形dp根据名字可以看出是 树 和 动态规划 的结合树有递归性,有向性这些特点动态规划有递推性的特点树形dp就是他们的结合 如图是样例构成的树 根据题意,求取最大结点和,保证每个结点和他的父节点不同时存在 用 dp[i][1] 表示选取第 i 个结点所能达到的以其为根的树的最大值用 dp[i][0] 表示不选取第 i 个结点所能达到的以其为根的树的最大值 则,有递推方程dp[i][0] += dp[j][1]dp[i][1] += max(dp[j][1],dp[j][0])其中 j 是 i 的子结点 递归计算即可 代码Anniversary party代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int maxn = 6005;int happy[maxn];int father[maxn];vector&lt;int&gt; children[maxn];int dp[maxn][2];void tree(int t) &#123; for(size_t i = 0;i &lt; children[t].size();i++) &#123; int &amp;child = children[t][i]; tree(child); dp[t][1] += dp[child][0]; dp[t][0] += max(dp[child][1],dp[child][0]); &#125;&#125;bool Do() &#123; int n; if(!(cin &gt;&gt; n)) return false; memset(dp,0,sizeof(dp)); for(int i = 1;i &lt;= n;i++) &#123; cin &gt;&gt; dp[i][1]; children[i].clear(); &#125; while(1) &#123; int a,b; cin &gt;&gt; a &gt;&gt; b; if(a == 0 &amp;&amp; b == 0) break; father[a] = b; children[b].push_back(a); &#125; int root = 1; while(father[root]) root = father[root]; tree(root); cout &lt;&lt; max(dp[root][0],dp[root][1]) &lt;&lt; endl; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"DFS","slug":"DFS","permalink":"https://www.oyohyee.com/tags/DFS/"},{"name":"树形dp","slug":"Tree-dp","permalink":"https://www.oyohyee.com/tags/Tree-dp/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"Uva 11584.Partitioning by Palindromes","date":"2016-08-20T04:22:26.000Z","path":"/post/Uva/11584.html","text":"题目 Description We say a sequence of characters is a palindrome if it is the same written forwards and backwards.For example, ‘racecar’ is a palindrome, but ‘fastcar’ is not.A partition of a sequence of characters is a list of one or more disjoint non-empty groups of consecutive characters whose concatenation yields the initial sequence.For example, (‘race’, ‘car’) is a partition of ‘racecar’ into two groups.Given a sequence of characters,we can always create a partition of these characters such that each group in the partition is a palindrome! Given this observation it is natural to ask:what is the minimum number of groups needed for a given string such that every group is a palindromeFor example: ‘racecar’ is already a palindrome, therefore it can be partitioned into one group. ‘fastcar’ does not contain any non-trivial palindromes, so it must be partitioned as (‘f’, ‘a’, ‘s’, ‘t’, ‘c’, ‘a’, ‘r’). ‘aaadbccb’ can be partitioned as (‘aaa’, ‘d’, ‘bccb’). Input Input begins with the number n of test cases. Each test case consists of a single line of between 1 and1000 lowercase letters, with no whitespace within. Output For each test case, output a line containing the minimum number of groups required to partition theinput into groups of palindromes. Sample Input 3racecarfastcaraaadbccb Sample Output 173 题解求最少的划分,使所有部分都是回文串 最初的想法是:尽可能长的划分每一部分,最后输出答案这样有一个问题就是 bcbaabc 答案应该是 2 但是输出会是 4局部不取最优反而能使结果最优 类似于 贪心 与 背包 的关系因此换用 动态规划还是仿照上面的思路有 dp[i] = min{dp[j-1] + 1} ( j~i 是回文串) 写到这很容易,但是最后 WA 了好几发问题在于 边界值由于字符串从 0 开始因此循环的时候 j-1 有可能为 -1这是一个随机的值,本地测试的时候可能会是 0 输出正确答案,但是交上去后就只能看脸了 要解决也很简单从 1~len 循环判断回文串的时候将位置坐标减去 1 即可 时间复杂度是 O(n3)不过大多数情况最后一个循环(判断回文串)是立即结束的 代码Partitioning by Palindromes代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int maxn = 1005;int dp[maxn];string s;bool isPalindrome(int a,int b) &#123; for(int it1 = a,it2 = b;it1 &lt; it2;it1++,it2--) if(s[it1] != s[it2]) return false; return true;&#125;void Do() &#123; cin &gt;&gt; s; int len = s.size(); int ans = 0; dp[0] = 0; for(int i = 1;i &lt;= len;i++) &#123; dp[i] = dp[i - 1] + 1; for(int j = 1;j &lt; i;j++) if(isPalindrome(j - 1,i - 1)) dp[i] = min(dp[i],dp[j - 1] + 1); &#125; cout &lt;&lt; dp[len] &lt;&lt; endl;&#125;int main() &#123; int T; cin &gt;&gt; T; for(int i = 1;i &lt;= T;i++) Do(); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"字符串(string)","slug":"String","permalink":"https://www.oyohyee.com/tags/String/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"}]},{"title":"POJ 2549.Sumsets","date":"2016-08-19T10:00:02.000Z","path":"/post/POJ/2549.html","text":"原题,详细看 &gt;Uva 10125.Sumsets&lt;","tags":[{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"Uva 10125.Sumsets","date":"2016-08-19T10:00:02.000Z","path":"/post/Uva/10125.html","text":"题目 Describe Given S, a set of integers, find the largest d such that a + b + c = dwhere a, b, c, and d are distinct elements of S. Input Several S, each consisting of a line containing an integer 1 ≤ n ≤1000 indicating the number of elements in S, followed by the elementsof S, one per line. Each element of S is a distinct integer between -536870912 and +536870911 inclusive. The last line of input contains‘0’. Output For each S, a single line containing d, or a single line containing ‘no solution’. Sample Input 523571252166425610240 Sample Output 12no solution 题解枚举 a b c d显然 O(n4) 肯定超时 保证等号两侧的时间复杂度相同将 c 移位得到 a + b = d - c 1000 的数据量 O(n2) 的复杂度可以接受先算出来所有的 a + b然后枚举所有的 d - c二分查找找到满足题意的 细节需要注意存在负数,需要考虑到这一点 代码Sumsets代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;functional&gt;using namespace std;const int maxn = 1005;struct Node &#123; int a,b; int sum; bool operator &lt; (const int &amp;rhs)const &#123; return sum &lt; rhs; &#125; bool operator &lt; (const Node &amp;rhs)const &#123; return sum &lt; rhs.sum; &#125;&#125;;int n;int a[maxn];Node sum[maxn*maxn];bool Do() &#123; cin &gt;&gt; n; if(n == 0) return false; int pos = 0; for(int i = 0;i &lt; n;i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a,a + n); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; i;j++) &#123; sum[pos].a = j; sum[pos].b = i; sum[pos++].sum = a[i] + a[j]; &#125; sort(sum,sum + pos); bool flag = true; int ans; for(int i = n - 1;i &gt;= 0 &amp;&amp; flag;i--) for(int j = n - 1;j &gt;= 0 &amp;&amp; flag;j--) &#123; int minute = a[i] - a[j]; int it = lower_bound(sum,sum + pos,minute) - sum; for(it;it &lt; pos;it++) &#123; if(sum[it].sum != minute) break; if(sum[it].b &lt; j &amp;&amp; i != j) &#123; ans = a[i]; flag = false; break; &#125; &#125; &#125; if(flag) cout &lt;&lt; \"no solution\" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"}]},{"title":"2016-08-16 ~ 2016-08-18 学习报告","date":"2016-08-18T14:59:10.000Z","path":"/post/Study/2016_08_16-2016_08_18.html","text":"题目： POJ 1258.Agri-Net POJ 1659.Frogs’ Neighborhood HDU 1165.Eddy’s research II HDU 5366.The mook jong POJ 3273.Monthly Expense Uva 11137.Ingenuous Cubrency POJ 3061.Subsequence POJ 3517.And Then There Was One","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"POJ 3517.And Then There Was One","date":"2016-08-17T14:54:48.000Z","path":"/post/POJ/3517.html","text":"题目 Description Let’s play a stone removing game. Initially, n stones are arranged on a circle and numbered 1, …, n clockwise (Figure 1). You are also given two numbers k and m. From this state, remove stones one by one following the rules explained below, until only one remains. In step 1, remove stone m. In step 2, locate the k-th next stone clockwise from m and remove it. In subsequent steps, start from the slot of the stone removed in the last step, make k hops clockwise on the remaining stones and remove the one you reach. In other words, skip (k 1) remaining stones clockwise and remove the next one. Repeat this until only one stone is left and answer its number. For example, the answer for the case n = 8, k = 5, m = 3 is 1, as shown in Figure 1. Initial stateStep 1Step 2Step 3Step 4 Step 5Step 6Step 7Final stateFigure 1: An example gameInitial state: Eight stones are arranged on a circle. Step 1: Stone 3 is removed since m = 3. Step 2: You start from the slot that was occupied by stone 3. You skip four stones 4, 5, 6 and 7 (since k = 5), and remove the next one, which is 8. Step 3: You skip stones 1, 2, 4 and 5, and thus remove 6. Note that you only count stones that are still on the circle and ignore those already removed. Stone 3 is ignored in this case. Steps 4–7: You continue until only one stone is left. Notice that in later steps when only a few stones remain, the same stone may be skipped multiple times. For example, stones 1 and 4 are skipped twice in step 7. Final State: Finally, only one stone, 1, is on the circle. This is the final state, so the answer is 1. Input The input consists of multiple datasets each of which is formatted as follows. n k m The last dataset is followed by a line containing three zeros. Numbers in a line are separated by a single space. A dataset satisfies the following conditions. 2 ≤ n ≤ 10000, 1 ≤ k ≤ 10000, 1 ≤ m ≤ n The number of datasets is less than 100. Output For each dataset, output a line containing the stone number left in the final state. No extra characters such as spaces should appear in the output. Sample Input 8 5 3100 9999 9810000 10000 100000 0 0 Sample Output 1932019 题解约瑟夫环问题该问题有 O(n) 的数学化简对于 1~n 的约瑟夫环从 m 开始,每次走 k 步最后的答案的计算方法为 约瑟夫环问题 if(n == 0 &amp;&amp; m == 0 &amp;&amp; k == 0) return false;int ans = 0;for(int i = 2; i &lt;= n; i++) ans = (ans + k) % i;ans = (m - k + 1 + ans) % n;if(ans &lt;= 0) ans += n; 代码And Then There Was One代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;bool Do() &#123; int n,k,m; cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; if(n == 0 &amp;&amp; m == 0 &amp;&amp; k == 0) return false; int ans = 0; for(int i = 2; i &lt;= n; i++) ans = (ans + k) % i; ans = (m - k + 1 + ans) % n; if(ans &lt;= 0) ans += n; cout &lt;&lt; ans &lt;&lt; endl; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"},{"name":"约瑟夫环问题","slug":"Joseph-problem","permalink":"https://www.oyohyee.com/tags/Joseph-problem/"}]},{"title":"POJ 3061.Subsequence","date":"2016-08-17T14:42:32.000Z","path":"/post/POJ/3061.html","text":"题目 A sequence of N positive integers (10 &lt; N &lt; 100 000), each of them less than or equal 10000, anda positive integer S (S &lt; 100 000 000) are given. Write a program to find the minimal length of thesubsequence of consecutive elements of the sequence, the sum of which is greater than or equal to S. Input Many test cases will be given. For each test case the program has to read the numbers N and S,separated by an interval, from the first line. The numbers of the sequence are given in the second lineof the test case, separated by intervals. The input will finish with the end of file. Output For each the case the program has to print the result on separate line of the output file. Sample Input 10 155 1 3 5 10 7 4 9 2 85 111 2 3 4 5 Sample Output 23 题解判断最少需要多少个连续的数能使和大于 s 可以采用二分找到到当前数最近的一个能够使和小于 s 的数的位置(最近的不满足的位置)则 i-begin+2 就是前 i 个数在以第 i 个数结束的最短位置 最后返回最小的值即可如果当前的数本身就已经符合要求,可以直接返回 1 如果最后没有答案应该输出 0虽然答案没说…… 代码Subsequence代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;const int INF = 0x7FFFFFFF;const int maxn = 100005;int n,s;int a[maxn];long long sum[maxn];bool Could(int n,int i) &#123; return sum[i] - sum[n - 1] &lt; s;&#125;int Division(int l,int r,int i) &#123; if(l == r) &#123; return l; &#125; int mid = (l + r) / 2; if(Could(mid,i)) return Division(l,mid,i); else return Division(mid + 1,r,i);&#125;bool Do() &#123; if(!(cin &gt;&gt; n &gt;&gt; s)) return false; int Min = INF; sum[0] = 0; for(int i = 1;i &lt;= n;i++) &#123; cin &gt;&gt; a[i]; sum[i] = sum[i - 1] + a[i]; int begin = Division(1,i,i); if(a[i] &gt;= s) Min = min(Min,1); else if(begin != 1) Min = min(Min,i - begin + 2); &#125; if(Min == INF) Min = 0; cout &lt;&lt; Min &lt;&lt; endl; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"二分","slug":"Division","permalink":"https://www.oyohyee.com/tags/Division/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"Uva 11137.Ingenuous Cubrency","date":"2016-08-17T14:35:18.000Z","path":"/post/Uva/11137.html","text":"题目 Description People in Cubeland use cubic coins. Not only the unit of currency iscalled a cube but also the coins are shaped like cubes and their valuesare cubes. Coins with values of all cubic numbers up to 9261(= 213),i.e., coins with the denominations of 1, 8, 27, . . ., up to 9261 cubes,are available in Cubeland.Your task is to count the number of ways to pay a given amountusing cubic coins of Cubeland. For example, there are 3 ways to pay21 cubes: twenty one 1 cube coins, or one 8 cube coin and thirteen 1cube coins, or two 8 cube coin and five 1 cube coins. Input Input consists of lines each containing an integer amount to be paid. You may assume that all theamounts are positive and less than 10000. Output For each of the given amounts to be paid output one line containing a single integer representing thenumber of ways to pay the given amount using the coins available in Cubeland. Sample Input 1021779999 Sample Output 2322440022018293 题解判断立方数组成 n 的方案数&gt;背包问题 完全背包问题&lt; 输出需要使用 long long 代码Ingenuous Cubrency代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;const int INF = 0x7FFFFFFF;const int maxn = 10005;int v;long long dp[maxn];void CompletePack(int cost) &#123; for(int i = cost; i &lt;= v; i++) dp[i] += dp[i - cost];&#125;bool Do() &#123; if(!(cin &gt;&gt; v)) return false; memset(dp,0,sizeof(dp)); dp[0] = 1; for(int i = 1;i &lt;= 21;i++) CompletePack(i*i*i); cout &lt;&lt; dp[v]&lt;&lt;endl; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"}]},{"title":"POJ 3273.Monthly Expense","date":"2016-08-17T04:28:31.000Z","path":"/post/POJ/3273.html","text":"题目 Description Farmer John is an astounding accounting wizard and has realized he might run out of money to run the farm. He has already calculated and recorded the exact amount of money (1 ≤ moneyi ≤ 10,000) that he will need to spend each day over the next N (1 ≤ N ≤ 100,000) days. FJ wants to create a budget for a sequential set of exactly M (1 ≤ M ≤ N) fiscal periods called “fajomonths”. Each of these fajomonths contains a set of 1 or more consecutive days. Every day is contained in exactly one fajomonth. FJ’s goal is to arrange the fajomonths so as to minimize the expenses of the fajomonth with the highest spending and thus determine his monthly spending limit. Input Line 1: Two space-separated integers: N and MLines 2.. N+1: Line i+1 contains the number of dollars Farmer John spends on the ith day Output Line 1: The smallest possible monthly limit Farmer John can afford to live with. Sample Input 7 5100400300100500101400 Sample Output 500 Hint If Farmer John schedules the months so that the first two days are a month, the third and fourth are a month, and the last three are their own months, he spends at most $500 in any month. Any other method of scheduling gives a larger minimum monthly limit. 题解神奇的二分法,最后答案必然在最大值和总和之间因此下界为最大值,上界为总和 判断函数判断连续多个(或一个)数是否大于要判断的数如果大于就将最新的数分到新的一组根据是否能分成 m 组来判断应该查找左侧还是右侧 二分的时间复杂度是 O(logn)判断的时间复杂度是 O(n)总的时间复杂度是 O(nlogn) 代码Monthly Expense代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;const int INF = 0x7FFFFFFF;const int maxn = 100005;int a[maxn];long long sum;int n,m;bool Could(long long num) &#123; int per = 0,g = 1; for(int i = 1;i &lt;= n;i++) &#123; if(per + a[i] &gt; num) &#123; g++; per = a[i]; if(g &gt; m) return false; &#125; else &#123; per += a[i]; &#125; &#125; return true;&#125;long long Division(long long l,long long r) &#123; if(l == r) &#123; return l; &#125; long long mid = (l + r) / 2; if(Could(mid)) return Division(l,mid); else return Division(mid + 1,r);&#125;bool Do() &#123; if(!(cin &gt;&gt; n &gt;&gt; m)) return false; sum = 0; int Max = 0; for(int i = 1;i &lt;= n;i++) &#123; cin &gt;&gt; a[i]; sum += a[i]; Max = max(Max,a[i]); &#125; cout &lt;&lt; Division(Max,sum) &lt;&lt; endl; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"二分","slug":"Division","permalink":"https://www.oyohyee.com/tags/Division/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"HDU 5366.The mook jong","date":"2016-08-16T14:40:57.000Z","path":"/post/HDU/5366.html","text":"题目 Description ZJiaQ want to become a strong man, so he decided to play the mook jong。ZJiaQ want to put some mook jongs in his backyard. His backyard consist of n bricks that is 11,so it is 1n。ZJiaQ want to put a mook jong in a brick. because of the hands of the mook jong， the distance of two mook jongs should be equal or more than 2 bricks. Now ZJiaQ want to know how many ways can ZJiaQ put mook jongs legally(at least one mook jong). Input There ar multiply cases. For each case, there is a single integer n( 1 &lt; = n &lt; = 60) Output Print the ways in a single line for each case. Sample Input 123456 Sample Output 1235812 题解显然存在规律由于相邻的两个需要相邻两格因此 dp[i] 和 dp[i-3] 存在关系找规律有 dp[i] = dp[i-1] + dp[i-3] + 1 具体证明画图很容易理解 数据有限,打表 代码The mook jong代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;const int maxn = 65;long long dp[] = &#123;0,1,2,3,5,8,12,18,27,40,59,87,128,188,276,405,594,871,1277,1872,2744,4022,5895,8640,12663,18559,27200,39864,58424,85625,125490,183915,269541,395032,578948,848490,1243523,1822472,2670963,3914487,5736960,8407924,12322412,18059373,26467298,38789711,56849085,83316384,122106096,178955182,262271567,384377664,563332847,825604415,1209982080,1773314928,2598919344,3808901425,5582216354,8181135699,11990037125,17572253480,25753389180,37743426306,55315679787&#125;;bool Do() &#123; int n; if(!(cin &gt;&gt; n)) return false; cout &lt;&lt; dp[n]&lt;&lt;endl; return true;&#125;int main() &#123; /* for(int i = 4;i &lt; 65;i++) &#123; dp[i] = dp[i - 1] + dp[i - 3] + 1; cout&lt;&lt;dp[i]&lt;&lt;\",\"; &#125; */ while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"打表","slug":"List","permalink":"https://www.oyohyee.com/tags/List/"}]},{"title":"HDU 1165.Eddy's research II","date":"2016-08-16T14:32:28.000Z","path":"/post/HDU/1165.html","text":"题目 Description As is known, Ackermann function plays an important role in the sphere of theoretical computer science. However, in the other hand, the dramatic fast increasing pace of the function caused the value of Ackermann function hard to calcuate. Ackermann function can be defined recursively as follows: Now Eddy Gives you two numbers: m and n, your task is to compute the value of A(m,n) .This is so easy problem,If you slove this problem,you will receive a prize(Eddy will invite you to hdu restaurant to have supper). Input Each line of the input will have two integers, namely m, n, where 0 &lt; m &lt; =3.Note that when m&lt;3, n can be any integer less than 1000000, while m=3, the value of n is restricted within 24.Input is terminated by end of file. Output For each value of m,n, print out the value of A(m,n). Sample Input 1 32 4 Sample Output 511 题解看题目应该是 记忆化搜索但是直接搜会导致栈溢出找下规律可以发现 m 为 0 、 1 、 2 时是 等差数列因此可以在 O(1) 的时间内得到答案 而对于 m==3 如果直接递归展开仍然会栈溢出但是可以手动将它展开一步,这样最多也只会递归 24 层 代码Eddy's research II代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 5000001;const int maxm = 4;int dp(int m,int n) &#123; if(m == 0) return n + 1; if(m == 1) return n + 2; if(m == 2) return 3 + 2 * n; if(n == 0) return dp(m - 1,1); return 2 * dp(3,n - 1) + 3;&#125;int main() &#123; int m,n; while(cin &gt;&gt; m &gt;&gt; n) &#123; cout &lt;&lt; dp(m,n) &lt;&lt; endl; &#125; return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"DFS","slug":"DFS","permalink":"https://www.oyohyee.com/tags/DFS/"},{"name":"记忆化搜索","slug":"Memory-Search","permalink":"https://www.oyohyee.com/tags/Memory-Search/"}]},{"title":"POJ 1659.Frogs' Neighborhood","date":"2016-08-16T14:30:11.000Z","path":"/post/POJ/1659.html","text":"题目 Description 未名湖附近共有N个大小湖泊L1, L2, …, Ln(其中包括未名湖),每个湖泊Li里住着一只青蛙Fi(1 ≤ i ≤ N)如果湖泊Li和Lj之间有水路相连,则青蛙Fi和Fj互称为邻居现在已知每只青蛙的邻居数目x1, x2, …, xn,请你给出每两个湖泊之间的相连关系 Input 第一行是测试数据的组数T(0 ≤ T ≤ 20)每组数据包括两行,第一行是整数N(2 &lt; N &lt; 10),第二行是N个整数,x1, x2,…, xn(0 ≤ xi ≤ N) Output 对输入的每组测试数据,如果不存在可能的相连关系,输出”NO”否则输出”YES”,并用N×N的矩阵表示湖泊间的相邻关系,即如果湖泊i与湖泊j之间有水路相连,则第i行的第j个数字为1,否则为0每两个数字之间输出一个空格如果存在多种可能,只需给出一种符合条件的情形相邻两组测试数据之间输出一个空行 Sample Input 374 3 1 5 4 2 164 3 1 4 2 062 3 1 1 2 1 Sample Output YES0 1 0 1 1 0 11 0 0 1 1 0 00 0 0 1 0 0 01 1 1 0 1 1 01 1 0 1 0 1 00 0 0 1 1 0 01 0 0 0 0 0 0 NO YES0 1 0 0 1 01 0 0 1 1 00 0 0 0 0 10 1 0 0 0 01 1 0 0 0 00 0 1 0 0 0 题解有 Havel-Hakimi定理 给定一个非负整数序列{dn},若存在一个无向图使得图中各点的度与此序列一一对应,则称此序列可图化进一步,若图为简单图,则称此序列可简单图化可图化的判定：d1+d2+……dn=0(mod 2)关于具体图的构造,我们可以简单地把奇数度的点配对,剩下的全部搞成自环 可简单图化的判定(Havel定理)：把序列排成不增序,即d1&gt;=d2&gt;=……&gt;=dn,则d可简单图化当且仅当d’={d2-1,d3-1,……d(d1+1)-1, d(d1+2),d(d1+3),……dn}可简单图化简单的说,把d排序后,找出度最大的点(设度为d1),把它与度次大的d1个点之间连边,然后这个点就可以不管了,一直继续这个过程,直到建出完整的图,或出现负度等明显不合理的情况 简单来说就是从多到少开始尽可能多的连接用一个 优先队列 维护当前状态下还能连接的个数最多的点 虽然当时不知道这个定理,但是感觉这样是对的…… 代码Frogs' Neighborhood代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;const int maxn = 15;struct naive &#123; int n; int f; bool operator &lt; (const naive &amp;rhs)const &#123; return f &lt; rhs.f; &#125;&#125;;bool Map[maxn][maxn];priority_queue &lt;naive&gt; Q1;queue&lt;naive&gt; Q2;void Do() &#123; int n; cin &gt;&gt; n; while(!Q1.empty()) Q1.pop(); while(!Q2.empty()) Q2.pop(); bool flag = false; memset(Map,false,sizeof(Map)); for(int i = 0;i &lt; n;i++) &#123; naive t; cin &gt;&gt; t.f; t.n = i; Q1.push(t); &#125; while(!Q1.empty()) &#123; naive qu = Q1.top(); Q1.pop(); while(!Q1.empty() &amp;&amp; qu.f &gt; 0) &#123; naive qv = Q1.top(); Q1.pop(); if(qv.f == 0) continue; int u = qu.n; int v = qv.n; if(Map[u][v] == false) &#123; Map[u][v] = Map[v][u] = true; qu.f--; qv.f--; &#125; if(qv.f &gt; 0) Q2.push(qv); &#125; if(qu.f &gt; 0) &#123; flag = true; break; &#125; while(!Q2.empty()) &#123; Q1.push(Q2.front()); Q2.pop(); &#125; &#125; if(flag) &#123; cout &lt;&lt; \"NO\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"YES\" &lt;&lt; endl; for(int i = 0;i &lt; n;i++) &#123; for(int j = 0;j &lt; n;j++) &#123; if(j != 0) cout &lt;&lt; \" \"; cout &lt;&lt; Map[i][j] ? 1 : 0; &#125; cout &lt;&lt; endl; &#125; &#125;&#125;int main()&#123; int T; cin &gt;&gt; T; while(T--) &#123; Do(); if(T) cout &lt;&lt; endl; &#125; return 0;&#125;","tags":[{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"},{"name":"Havel-Hakimi定理","slug":"Havel-Hakimi","permalink":"https://www.oyohyee.com/tags/Havel-Hakimi/"}]},{"title":"POJ 1258.Agri-Net","date":"2016-08-16T14:20:31.000Z","path":"/post/POJ/1258.html","text":"题目 Description Farmer John has been elected mayor of his town! One of his campaign promises was to bring internet connectivity to all farms in the area. He needs your help, of course.Farmer John ordered a high speed connection for his farm and is going to share his connectivity with the other farmers. To minimize cost, he wants to lay the minimum amount of optical fiber to connect his farm to all the other farms.Given a list of how much fiber it takes to connect each pair of farms, you must find the minimum amount of fiber needed to connect them all together. Each farm must connect to some other farm such that a packet can flow from any one farm to any other farm.The distance between any two farms will not exceed 100,000. Input The input includes several cases. For each case, the first line contains the number of farms, N (3 &lt;= N &lt;= 100). The following lines contain the N x N conectivity matrix, where each element shows the distance from on farm to another. Logically, they are N lines of N space-separated integers. Physically, they are limited in length to 80 characters, so some lines continue onto others. Of course, the diagonal will be 0, since the distance from farm i to itself is not interesting for this problem. Output For each case, output a single integer length that is the sum of the minimum length of fiber required to connect the entire set of farms. Sample Input 40 4 9 214 0 8 179 8 0 1621 17 16 0 Sample Output 28 题解将所有的点连接起来,使总距离最小 &gt;最小生成树问题&lt;直接套用模板即可 代码Agri-Net代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;const int maxn = 105;struct Edge &#123; int u,v; int w; bool operator &lt; (const Edge &amp;rhs)const &#123; return w &lt; rhs.w; &#125;&#125;;int f[maxn];Edge e[maxn*maxn / 2];int ufs(int x) &#123; return f[x] == x ? x : f[x] = ufs(f[x]);&#125;int Kruskal(int n,int m) &#123; int w = 0; for(int i = 0; i &lt; n; i++) f[i] = i; sort(e,e + m); for(int i = 0; i &lt; m; i++) &#123; int x = ufs(e[i].u),y = ufs(e[i].v); if(x != y) &#123; f[x] = y; w += e[i].w; &#125; &#125; return w;&#125;bool Do() &#123; int n; if(!(cin &gt;&gt; n)) return false; int pos = 0; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) &#123; if(i &lt; j) &#123; e[pos].u = i; e[pos].v = j; cin &gt;&gt; e[pos].w; pos++; &#125; else &#123; int t; cin &gt;&gt; t; &#125; &#125; cout &lt;&lt; Kruskal(n,n*(n-1)/2) &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"最小生成树","slug":"MST","permalink":"https://www.oyohyee.com/tags/MST/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"2016-08-13 ~ 2016-08-15 学习报告","date":"2016-08-16T04:30:10.000Z","path":"/post/Study/2016_08_13-2016_08_15.html","text":"题目： Codeforces 371A.K-Periodic Array Codeforces 371B.Fox Dividing Cheese Codeforces 371C.Hamburgers HDU 5832.A water problem HDU 5835.Danganronpa HDU 5842.Lweb and String Codeforces 705A.Hulk","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"Codeforces 705A.Hulk","date":"2016-08-16T03:17:49.000Z","path":"/post/Codeforces/705A.html","text":"题目 Description Dr. Bruce Banner hates his enemies (like others don’t). As we all know, he can barely talk when he turns into the incredible Hulk. That’s why he asked you to help him to express his feelings. Hulk likes the Inception so much, and like that his feelings are complicated. They have n layers. The first layer is hate, second one is love, third one is hate and so on… For example if n = 1, then his feeling is “I hate it” or if n = 2 it’s “I hate that I love it”, and if n = 3 it’s “I hate that I love that I hate it” and so on. Please help Dr. Banner. Input The only line of the input contains a single integer n (1 ≤ n ≤ 100) — the number of layers of love and hate. Output Print Dr.Banner’s feeling in one line. Sample Input Input 1 Output I hate it Input2 Output I hate that I love it Input3 Output I hate that I love that I hate it 题解直接模拟即可奇数个是 hate偶数个是 love最后一个不是 that 是 it 代码Hulk代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;bool Do() &#123; int n; if(!(cin &gt;&gt; n)) return false; for(int i = 1;i &lt;= n;i++) &#123; if(i != 1) cout &lt;&lt; \" \"; if(i == n) if(i % 2) cout &lt;&lt; \"I hate it\"; else cout &lt;&lt; \"I love it\"; else if(i % 2) cout &lt;&lt; \"I hate that\"; else cout &lt;&lt; \"I love that\"; &#125; cout &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"HDU 5842.Lweb and String","date":"2016-08-14T08:48:50.000Z","path":"/post/HDU/5842.html","text":"题目 Description Lweb has a string S. Oneday, he decided to transform this string to a new sequence. You need help him determine this transformation to get a sequence which has the longest LIS(Strictly Increasing). You need transform every letter in this string to a new number. A is the set of letters of S, B is the set of natural numbers. Every injection f:A→B can be treat as an legal transformation. For example, a String “aabc”, A={a,b,c}, and you can transform it to “1 1 2 3”, and the LIS of the new sequence is 3. Now help Lweb, find the longest LIS which you can obtain from S. LIS: Longest Increasing Subsequence. (https://en.wikipedia.org/wiki/Longest_increasing_subsequence) Input The first line of the input contains the only integer T,(1≤T≤20). Then T lines follow, the i-th line contains a string S only containing the lowercase letters, the length of S will not exceed 105. Output For each test case, output a single line “Case #x: y”, where x is the case number, starting from 1. And y is the answer. Sample Input 2aabccacdeaa Sample Output Case #1: 3Case #2: 4 题解不是最长上升子序列！！！ 不是最长上升子序列！！！ 不是最长上升子序列！！！ 尽管题目一直恶意引导,比赛的时候也有人恶意引导…… 字母和数字的映射是自己随便选的,只要能达到最长就行比如 cba 答案应该是 3 要达到最长,就应该前面的尽可能小,后面的尽可能大或者说,就是 计数总共出现了多少个不同的字符…… 代码Lweb and String代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;#include &lt;iomanip&gt; using namespace std;const int maxn = 27;bool vis[maxn];void Do() &#123; char c = getchar();; memset(vis,false,sizeof(vis)); int ans = 0; while(!(c &gt;= 'a'&amp;&amp;c &lt;= 'z')) c=getchar(); while(c &gt;= 'a'&amp;&amp;c &lt;= 'z') &#123; int t = c - 'a'; if(!vis[t]) &#123; ans++; vis[t] = true; &#125; c = getchar(); &#125; printf(\"%d\\n\",ans);&#125;int main() &#123; //cin.tie(0); //cin.sync_with_stdio(false); int T; scanf(\"%d\",&amp;T); for(int i = 1;i &lt;= T;i++) &#123; printf(\"Case #%d: \",i); Do(); &#125; return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"CCPC","slug":"CCPC","permalink":"https://www.oyohyee.com/tags/CCPC/"}]},{"title":"HDU 5835.Danganronpa","date":"2016-08-14T08:48:47.000Z","path":"/post/HDU/5835.html","text":"题目 Description Chisa Yukizome works as a teacher in the school. She prepares many gifts, which consist of n kinds with a[i] quantities of each kind, for her students and wants to hold a class meeting. Because of the busy work, she gives her gifts to the monitor, Chiaki Nanami. Due to the strange design of the school, the students’ desks are in a row. Chiaki Nanami wants to arrange gifts like this: Each table will be prepared for a mysterious gift and an ordinary gift. In order to reflect the Chisa Yukizome’s generosity, the kinds of the ordinary gift on the adjacent table must be different. There are no limits for the mysterious gift. The gift must be placed continuously. She wants to know how many students can get gifts in accordance with her idea at most (Suppose the number of students are infinite). As the most important people of her, you are easy to solve it, aren’t you Input The first line of input contains an integer T(T≤10) indicating the number of test cases. Each case contains one integer n. The next line contains n (1≤n≤10) numbers: a1,a2,…,an, (1≤ai≤100000). Output For each test case, output one line containing “Case #x: y” (without quotes) , where x is the test case number (starting from 1) and y is the answer of Chiaki Nanami’s question. Sample Input 123 2 Sample Output Case #1: 2 题解给同学发礼物,共有 n 种礼物,其中第 i 种礼物有 a[i] 个礼物分为两种 普通礼物:相邻两个人的普通礼物不能相同 神秘礼物:可以和普通礼物相同,不做任何限制 任何一个礼物都可以做普通礼物或者神秘礼物 根据上面的要求,显然限制只有普通礼物,可以先考虑普通礼物的问题先在只考虑普通礼物的情况下尽可能的多分,计算能分多少组假设结果为 ans ,礼物总数为 sum 如果 ans 比 sum/2 还大,证明普通礼物的限制已经无法阻挡发礼物了~因此结果应该是 sum/2 (每个人至少需要两个礼物) 如果 ans 没有 sum/2 大,那么说明普通礼物的限制导致最多只能发给 ans 个同学剩下的礼物中随便拿 ans 个当作神秘礼物发放即可 根据上面的分析,可以得出: 只需要计算出所有礼物中排列后不连续能达到多长,将答案记为 ans ,则最后答案就是 min(ans,sum/2) 问题转化成:有 n 种礼物,每种有 a[i] 个,相邻不相同,最多能有多少个 排列不相邻 可以很容易想到数学中 排列组合 的 插值法 插值的意思是先将一些相同元素排列好,然后在每两个中间插入另一种元素,这样就能保证所有元素相邻的元素都不相同完成插值第二种元素至少只能比第一种元素少 1 (参考下面的图) 因此,需要先对所有礼物排序,从最多的开始判断有两种情况:(用 青色 表示最多的一种礼物, 绿色 表示其他所有礼物) 最多的元素不到礼物总数的一半由于最多的元素不到礼物总数的一半,因此剩下的元素必然满足 大于等于最多的元素也即,绿色元素必定能够将所有的青色元素分割开 根据 贪心 ,要满足尽可能多插,就要从多往少插按照上面的解释,已经可以保证在将青色元素分隔开后,相邻元素必然是不相同的剩下的礼物不管有多少个,必然会有一个和它不同,并且比它多的另一种礼物只需要将其插到这个比它多的礼物中即可 所有的礼物都可以被按照要求排序这种情况下 ans = sum 最多的元素超过了礼物总数的一半这种情况下,青色的元素都不能被分隔开最多只能有红框内的区域能够分割开 这种情况下 ans = (sum-a[n-1])*2 + 1 得到 ans 后,结果就应该是 min(ans,sum/2) 代码Danganronpa代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリ0隶�要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;#include &lt;iomanip&gt; using namespace std;const int maxn = 15;int a[maxn];void Do() &#123; int n; cin &gt;&gt; n; int sum = 0; for(int i = 0;i &lt; n;i++) &#123; cin &gt;&gt; a[i]; sum += a[i]; &#125; sort(a,a + n); int ans = 0; if(sum / 2 &lt; a[n - 1]) &#123; ans = (sum - a[n - 1]) * 2 + 1; &#125; else &#123; ans = sum; &#125; cout &lt;&lt; min(ans,sum / 2)&lt;&lt;endl;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); int T; cin &gt;&gt; T; for(int i = 1;i &lt;= T;i++) &#123; cout &lt;&lt; \"Case #\" &lt;&lt; i &lt;&lt; \": \"; Do(); &#125; return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"},{"name":"CCPC","slug":"CCPC","permalink":"https://www.oyohyee.com/tags/CCPC/"}]},{"title":"HDU 5832.A water problem","date":"2016-08-14T08:48:43.000Z","path":"/post/HDU/5832.html","text":"题目 Description Two planets named Haha and Xixi in the universe and they were created with the universe beginning. There is 73 days in Xixi a year and 137 days in Haha a year. Now you know the days N after Big Bang, you need to answer whether it is the first day in a year about the two planets. Input There are several test cases(about 5 huge test cases). For each test, we have a line with an only integer N(0≤N), the length of N is up to 10000000. Output For the i-th test case, output Case #i: , then output “YES” or “NO” for the answer. Sample Input 100010333 Sample Output Case #1: YESCase #2: YESCase #3: NO 题解求两个公转周期分别为 73 和 137 的星球在第 i 天是否都是新年第一天也即 i%73 和 i%137 是否都为 0 由于输入数据最大为 10000000 位因此需要 高精度算法 高精度读入后取余即可 由于数组较大,直接套用模板的高精度可能会因为构造函数爆掉因此应该自己写读入部分(数据貌似有前导 0 ) 代码A water problem代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリ0隶�要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;#include &lt;iomanip&gt; using namespace std;const int maxn = 10000005;int kase = 0;/** 完全大数模板* 输出cin&gt;&gt;a* 输出a.print();* 注意这个输入不能自动去掉前导0的，可以先读入到char数组，去掉前导0，再用构造函数。*/#define MAXN 9999#define MAXSIZE 1010#define DLEN 4struct BigInter &#123; int a[maxn]; //可以控制大数的位数 int len; BigInter() &#123; len = 1; memset(a,0,sizeof(a)); &#125; //构造函数 BigInter(const char*); //将一个字符串类型的变量转化为大数 int operator % (const int &amp;)const; //大数对一个int类型的变量进行取模运算 void print(); //输出大数 void read(const char *s);&#125;;BigInter::BigInter(const char *s) //将一个字符串类型的变量转化为大数&#123; int t,k,index,L,i; memset(a,0,sizeof(a)); L = strlen(s); len = L / DLEN; if(L%DLEN)len++; index = 0; for(i = L - 1; i &gt;= 0; i -= DLEN) &#123; t = 0; k = i - DLEN + 1; if(k &lt; 0)k = 0; for(int j = k; j &lt;= i; j++) t = t * 10 + s[j] - '0'; a[index++] = t; &#125;&#125;int BigInter::operator % (const int &amp;b)const //大数对一个 int类型的变量进行取模&#123; int i,d = 0; for(i = len - 1; i &gt;= 0; i--) d = ((d*(MAXN + 1)) % b + a[i]) % b; return d;&#125;void BigInter::print() //输出大数&#123; int i; printf(\"%d\",a[len - 1]); for(i = len - 2; i &gt;= 0; i--) printf(\"%04d\",a[i]); printf(\"\\n\");&#125;void BigInter::read(const char *s) &#123; int t,k,index,L,i; memset(a,0,sizeof(a)); L = strlen(s); len = L / DLEN; if(L%DLEN)len++; index = 0; for(i = L - 1; i &gt;= 0; i -= DLEN) &#123; t = 0; k = i - DLEN + 1; if(k &lt; 0)k = 0; for(int j = k; j &lt;= i; j++) t = t * 10 + s[j] - '0'; a[index++] = t; &#125;&#125;BigInter ans;char s[maxn];bool Do() &#123; if(scanf(\"%s\",s) == EOF) return false; printf(\"Case #%d: \",++kase); int pos = 0; int len = strlen(s); for(int i = 0;i &lt; len;i++) &#123; if(s[i] != '0') &#123; pos = i; break; &#125; &#125; for(int i = pos;i &lt; len;i++) s[i - pos] = s[i]; s[len - pos] = '\\0'; ans.read(s); if(ans % 73 == 0 &amp;&amp; 0 == ans % 137) printf(\"YES\\n\"); else printf(\"NO\\n\"); return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"高精度算法","slug":"High-precision","permalink":"https://www.oyohyee.com/tags/High-precision/"},{"name":"CCPC","slug":"CCPC","permalink":"https://www.oyohyee.com/tags/CCPC/"}]},{"title":"Codeforces 371C.Hamburgers","date":"2016-08-13T13:30:32.000Z","path":"/post/Codeforces/371C.html","text":"题目 Description Polycarpus loves hamburgers very much. He especially adores the hamburgers he makes with his own hands. Polycarpus thinks that there are only three decent ingredients to make hamburgers from: a bread, sausage and cheese. He writes down the recipe of his favorite “Le Hamburger de Polycarpus” as a string of letters ‘B’ (bread), ‘S’ (sausage) и ‘C’ (cheese). The ingredients in the recipe go from bottom to top, for example, recipe “ВSCBS” represents the hamburger where the ingredients go from bottom to top as bread, sausage, cheese, bread and sausage again. Polycarpus has nb pieces of bread, ns pieces of sausage and nc pieces of cheese in the kitchen. Besides, the shop nearby has all three ingredients, the prices are pb rubles for a piece of bread, ps for a piece of sausage and pc for a piece of cheese. Polycarpus has r rubles and he is ready to shop on them. What maximum number of hamburgers can he cook You can assume that Polycarpus cannot break or slice any of the pieces of bread, sausage or cheese. Besides, the shop has an unlimited number of pieces of each ingredient. Input The first line of the input contains a non-empty string that describes the recipe of “Le Hamburger de Polycarpus”. The length of the string doesn’t exceed 100, the string contains only letters ‘B’ (uppercase English B), ‘S’ (uppercase English S) and ‘C’ (uppercase English C). The second line contains three integers nb, ns, nc (1 ≤ nb, ns, nc ≤ 100) — the number of the pieces of bread, sausage and cheese on Polycarpus’ kitchen. The third line contains three integers pb, ps, pc (1 ≤ pb, ps, pc ≤ 100) — the price of one piece of bread, sausage and cheese in the shop. Finally, the fourth line contains integer r (1 ≤ r ≤ 1012) — the number of rubles Polycarpus has. Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier. Output Print the maximum number of hamburgers Polycarpus can make. If he can’t make any hamburger, print 0. Sample Input Input BBBSSC6 4 11 2 34 Output 2 Input BBC1 10 11 10 121 Output 7 Input BSC1 1 11 1 31000000000000 Output 200000000001 题解题意比较容易理解思路也很清晰但是需要考虑的情况太多了很容易因为一个小细节而出现问题 第一次见到用 二分法 来解决这种问题的题 列举所有可能的答案采用二分来找结果由于最多也只是 64 位存储的内容也即采用二分只需要查询64次 查询第一个严格大于的结果再将结果减去 1 就是答案 比较神奇的思路记录下模板 二分模板long long Division(long long l,long long r) &#123; if(l == r) &#123; return l; &#125; long long mid = (l + r) / 2; if(Could(mid)) return Division(l,mid); else return Division(mid + 1,r);&#125; 判断是否大于bool Could(long long n) &#123; long long money = 0; for(int i = 0;i &lt; maxn;i++) if(n*need[i] &gt; num[i]) money += p[i] * (n*need[i]-num[i]); return money &gt; r;&#125; 代码Hamburgers代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;#include &lt;iomanip&gt; using namespace std;const int maxn = 3;long long need[maxn];long long num[maxn];long long p[maxn];long long temp[maxn];long long r;long long per;bool Could(long long n) &#123; long long money = 0; for(int i = 0;i &lt; maxn;i++) if(n*need[i] &gt; num[i]) money += p[i] * (n*need[i]-num[i]); return money &gt; r;&#125;long long Division(long long l,long long r) &#123; if(l == r) &#123; return l; &#125; long long mid = (l + r) / 2; if(Could(mid)) return Division(l,mid); else return Division(mid + 1,r);&#125;bool Do() &#123; string s; if(!(cin &gt;&gt; s)) return false; need[0] = need[1] = need[2] = 0; for(size_t i = 0;i &lt; s.size();i++) &#123; if(s[i] == 'B') need[0]++; if(s[i] == 'S') need[1]++; if(s[i] == 'C') need[2]++; &#125; per = 0; for(int i = 0;i &lt; 3;i++) cin &gt;&gt; num[i]; for(int i = 0;i &lt; 3;i++) &#123; cin &gt;&gt; p[i]; per += need[i] * p[i]; &#125; cin &gt;&gt; r; cout &lt;&lt; Division(0,2000000000000) - 1 &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"二分","slug":"Division","permalink":"https://www.oyohyee.com/tags/Division/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"Codeforces 371B.Fox Dividing Cheese","date":"2016-08-13T13:30:26.000Z","path":"/post/Codeforces/371B.html","text":"题目 Description Two little greedy bears have found two pieces of cheese in the forest of weight a and b grams, correspondingly. The bears are so greedy that they are ready to fight for the larger piece. That’s where the fox comes in and starts the dialog: “Little bears, wait a little, I want to make your pieces equal” “Come off it fox, how are you going to do that “, the curious bears asked. “It’s easy”, said the fox. “If the mass of a certain piece is divisible by two, then I can eat exactly a half of the piece. If the mass of a certain piece is divisible by three, then I can eat exactly two-thirds, and if the mass is divisible by five, then I can eat four-fifths. I’ll eat a little here and there and make the pieces equal”. The little bears realize that the fox’s proposal contains a catch. But at the same time they realize that they can not make the two pieces equal themselves. So they agreed to her proposal, but on one condition: the fox should make the pieces equal as quickly as possible. Find the minimum number of operations the fox needs to make pieces equal. Input The first line contains two space-separated integers a and b (1 ≤ a, b ≤ 109). Output If the fox is lying to the little bears and it is impossible to make the pieces equal, print -1. Otherwise, print the required minimum number of operations. If the pieces of the cheese are initially equal, the required number is 0. Sample Input Input 15 20 Output 3 Input 14 8 Output -1 Input 6 6 Output 0 题解求 a 和 b 的最大公因数输出最少需要除以 2 3 5 多少次,能使 a 和 b 都变成最大公因数如果 a==b 输出 0如果不能得到,输出 -1 读懂题意后直接模拟即可然而题意真难读懂 代码Fox Dividing Cheese代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;#include &lt;iomanip&gt; using namespace std;const int d[] = &#123;2,3,5&#125;;int gcd(int a,int b) &#123; return b == 0 ? a : gcd(b,a%b);&#125;bool Do() &#123; int a,b; if(!(cin &gt;&gt; a &gt;&gt; b)) return false; if(a == b) &#123; cout &lt;&lt; 0 &lt;&lt; endl; return true; &#125; int ans = 0; int g = gcd(a,b); a /= g; b /= g; for(int i = 0;i &lt; 3;i++) &#123; while(a%d[i] == 0) &#123; a /= d[i]; ans++; &#125; while(b%d[i] == 0) &#123; b /= d[i]; ans++; &#125; &#125; if(a == 1 &amp;&amp; b == 1) cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"欧几里得算法","slug":"Euclid","permalink":"https://www.oyohyee.com/tags/Euclid/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"Codeforces 371A.K-Periodic Array","date":"2016-08-13T13:30:07.000Z","path":"/post/Codeforces/371A.html","text":"题目 Description This task will exclusively concentrate only on the arrays where all elements equal 1 and/or 2. Array a is k-period if its length is divisible by k and there is such array b of length k, that a is represented by array b written exactly times consecutively. In other words, array a is k-periodic, if it has period of length k. For example, any array is n-periodic, where n is the array length. Array [2, 1, 2, 1, 2, 1] is at the same time 2-periodic and 6-periodic and array [1, 2, 1, 1, 2, 1, 1, 2, 1] is at the same time 3-periodic and 9-periodic. For the given array a, consisting only of numbers one and two, find the minimum number of elements to change to make the array k-periodic. If the array already is k-periodic, then the required value equals 0. Input The first line of the input contains a pair of integers n, k (1 ≤ k ≤ n ≤ 100), where n is the length of the array and the value n is divisible by k. The second line contains the sequence of elements of the given array a1, a2, …, an (1 ≤ ai ≤ 2), ai is the i-th element of the array. Output Print the minimum number of array elements we need to change to make the array k-periodic. If the array already is k-periodic, then print 0. Sample Input Input 6 22 1 2 2 2 1 Output 1 Input 8 41 1 2 1 1 1 2 1 Output 0 Input 9 32 1 1 1 2 1 1 1 2 Output 3 Hint In the first sample it is enough to change the fourth element from 2 to 1, then the array changes to [2, 1, 2, 1, 2, 1]. In the second sample, the given array already is 4-periodic. In the third sample it is enough to replace each occurrence of number two by number one. In this case the array will look as [1, 1, 1, 1, 1, 1, 1, 1, 1] — this array is simultaneously 1-, 3- and 9-periodic. 题解判断长度为 n 的字符串以 k 为循环长度最少改变( 1 变成 2 或者 2 变成 1 )多少次可以满足循环 对于每一位,最后的效果是每个循环节,这一位的数字相同由于只有可能是 1 和 2可以记录 1 出现的次数 cnt改变的次数就是 min(cnt,k-cnt) 最后将所有的改变次数加起来即可 代码K-Periodic Array代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;#include &lt;iomanip&gt; using namespace std;const int maxn = 105;int num[maxn];bool Do() &#123; int n,k; if(!(cin &gt;&gt; n &gt;&gt; k)) return false; int p = n / k; memset(num,0,sizeof(num)); for(int i = 1;i &lt;= n;i++) &#123; int t; cin &gt;&gt; t; if(t == 1) num[i%k]++; &#125; int ans = 0; for(int i = 0;i &lt; k;i++) &#123; ans += min(p- num[i],num[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"Codeforces 706C.Hard problem","date":"2016-08-13T08:43:59.000Z","path":"/post/Codeforces/706C.html","text":"题目 Description Vasiliy is fond of solving different tasks. Today he found one he wasn’t able to solve himself, so he asks you to help. Vasiliy is given n strings consisting of lowercase English letters. He wants them to be sorted in lexicographical order (as in the dictionary), but he is not allowed to swap any of them. The only operation he is allowed to do is to reverse any of them (first character becomes last, second becomes one before last and so on). To reverse the i-th string Vasiliy has to spent ci units of energy. He is interested in the minimum amount of energy he has to spent in order to have strings sorted in lexicographical order. String A is lexicographically smaller than string B if it is shorter than B (|A| &lt; |B|) and is its prefix, or if none of them is a prefix of the other and at the first position where they differ character in A is smaller than the character in B. For the purpose of this problem, two equal strings nearby do not break the condition of sequence being sorted lexicographically. Input The first line of the input contains a single integer n (2 ≤ n ≤ 100 000) — the number of strings. The second line contains n integers ci (0 ≤ ci ≤ 109), the i-th of them is equal to the amount of energy Vasiliy has to spent in order to reverse the i-th string. Then follow n lines, each containing a string consisting of lowercase English letters. The total length of these strings doesn’t exceed 100 000. Output If it is impossible to reverse some of the strings such that they will be located in lexicographical order, print - 1. Otherwise, print the minimum total amount of energy Vasiliy has to spent. Sample Input Input 21 2baac Output 1 Input 31 3 1aabaac Output 1 Input 25 5bbbaaa Output -1 Input 23 3aaaaa Output-1 Hint In the second sample one has to reverse string 2 or string 3. To amount of energy required to reverse the string 3 is smaller. In the third sample, both strings do not change after reverse and they go in the wrong order, so the answer is - 1. In the fourth sample, both strings consists of characters ‘a’ only, but in the sorted order string “aa” should go before string “aaa”, thus the answer is - 1. 题解反转一次字符串需要一定的能量求使用最少的能量,通过反转字符串使每一个字符串的字典序都比它前面的大 动态规划问题dp[i][j] 表示第 j 个字符串 不反转( i==0 ) 或 反转( i==1 ) 使前 j 个字符串符合要求所需的最少能量 对于字符串 j 只需要判断它反转和不反转与字符串 j-1 反转和不反转总共 4 种情况 注意比较应该是 &gt;= 因为会有相等的情况.是不需要反转的 如果有在某个字符串无论反转还是不反转都不能满足字典序递增,那么显然是无解的,可以直接输出 代码Hard problem代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;#include &lt;iomanip&gt; using namespace std;const long long INF = 0x7FFFFFFFFFFFFFFF / 2;const int maxn = 100005;int e[maxn];string s[maxn];string s2[maxn];long long dp[2][maxn];bool Do() &#123; int n; if(!(cin &gt;&gt; n)) return false; for(int i = 1;i &lt;= n;i++) cin &gt;&gt; e[i]; for(int i = 1;i &lt;= n;i++) &#123; cin &gt;&gt; s[i]; s2[i] = s[i]; reverse(s2[i].begin(),s2[i].end()); &#125; dp[0][1] = 0; dp[1][1] = e[1]; for(int i = 2;i &lt;= n;i++) &#123; dp[0][i] = dp[1][i] = INF; if(dp[0][i - 1] != INF &amp;&amp; s[i] &gt;= s[i - 1]) dp[0][i] = min(dp[0][i],dp[0][i - 1]); if(dp[1][i - 1] != INF &amp;&amp; s[i] &gt;= s2[i - 1]) dp[0][i] = min(dp[0][i],dp[1][i - 1]); if(dp[0][i - 1] != INF &amp;&amp; s2[i] &gt;= s[i - 1]) dp[1][i] = min(dp[1][i],dp[0][i - 1] + e[i]); if(dp[1][i - 1] != INF &amp;&amp; s2[i] &gt;= s2[i - 1]) dp[1][i] = min(dp[1][i],dp[1][i - 1] + e[i]); if(dp[0][i] == INF &amp;&amp; dp[1][i] == INF) &#123; cout &lt;&lt; -1 &lt;&lt; endl; return true; &#125; &#125; cout &lt;&lt; min(dp[0][n],dp[1][n]) &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"},{"name":"字符串(string)","slug":"String","permalink":"https://www.oyohyee.com/tags/String/"}]},{"title":"Codeforces 706B.Interesting drink","date":"2016-08-13T08:43:56.000Z","path":"/post/Codeforces/706B.html","text":"题目 Description Vasiliy likes to rest after a hard work, so you may often meet him in some bar nearby. As all programmers do, he loves the famous drink “Beecola”, which can be bought in n different shops in the city. It’s known that the price of one bottle in the shop i is equal to xi coins. Vasiliy plans to buy his favorite drink for q consecutive days. He knows, that on the i-th day he will be able to spent mi coins. Now, for each of the days he want to know in how many different shops he can buy a bottle of “Beecola”. Input The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of shops in the city that sell Vasiliy’s favourite drink. The second line contains n integers xi (1 ≤ xi ≤ 100 000) — prices of the bottles of the drink in the i-th shop. The third line contains a single integer q (1 ≤ q ≤ 100 000) — the number of days Vasiliy plans to buy the drink. Then follow q lines each containing one integer mi (1 ≤ mi ≤ 109) — the number of coins Vasiliy can spent on the i-th day. Output Print q integers. The i-th of them should be equal to the number of shops where Vasiliy will be able to buy a bottle of the drink on the i-th day. Sample Input Input 53 10 8 6 114110311 Output 0415 Hint On the first day, Vasiliy won’t be able to buy a drink in any of the shops. On the second day, Vasiliy can buy a drink in the shops 1, 2, 3 and 4. On the third day, Vasiliy can buy a drink only in the shop number 1. Finally, on the last day Vasiliy can buy a drink in any shop. 题解多次查询小于等于 m 的数据的个数查询次数较多,直接查找会超时应该使用二分查找使用 upper_bound() 可以直接获得答案 upper_bound 和 lower_boundupper_bound(a,a+n,e)返回 a ~ a+n 区域内大于 e 的第一个内存地址用其减去首地址即可得到下标则可以直接获取大于 e 的第一个数据的下标如果从 0 开始的话,恰好多的一位补到从 0 开始错的一位上 lower_bound(a,a+n,e)返回 a ~ a+n 区域大于等于 e 的第一个内存地址如果 e 不存在,则 lower_bound() 和 upper_bound() 的结果应该是一样的如果有 e 存在,则 lower_bound() 会返回第一个 e 的地址而 upper_bound() 会返回最后一个 e 的下一个地址 代码Interesting drink代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;#include &lt;iomanip&gt; using namespace std;const int maxn = 100005;int a[maxn];bool Do() &#123; int n; if(!(cin &gt;&gt; n)) return false; for(int i = 0;i &lt; n;i++) cin &gt;&gt; a[i]; sort(a,a + n); int q; cin &gt;&gt; q; for(int i = 0;i &lt; q;i++) &#123; int t; cin &gt;&gt; t; cout &lt;&lt; upper_bound(a,a + n,t) - a &lt;&lt; endl; &#125; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"二分","slug":"Division","permalink":"https://www.oyohyee.com/tags/Division/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"Codeforces 706A.Beru-taxi","date":"2016-08-13T08:41:53.000Z","path":"/post/Codeforces/706A.html","text":"题目 Description Vasiliy lives at point (a, b) of the coordinate plane. He is hurrying up to work so he wants to get out of his house as soon as possible. New app suggested n available Beru-taxi nearby. The i-th taxi is located at point (xi, yi) and moves with a speed vi. Consider that each of n drivers will move directly to Vasiliy and with a maximum possible speed. Compute the minimum time when Vasiliy will get in any of Beru-taxi cars. Input The first line of the input contains two integers a and b ( - 100 ≤ a, b ≤ 100) — coordinates of Vasiliy’s home. The second line contains a single integer n (1 ≤ n ≤ 1000) — the number of available Beru-taxi cars nearby. The i-th of the following n lines contains three integers xi, yi and vi ( - 100 ≤ xi, yi ≤ 100, 1 ≤ vi ≤ 100) — the coordinates of the i-th car and its speed. It’s allowed that several cars are located at the same point. Also, cars may be located at exactly the same point where Vasiliy lives. Output Print a single real value — the minimum time Vasiliy needs to get in any of the Beru-taxi cars. You answer will be considered correct if its absolute or relative error does not exceed 10 - 6. Namely: let’s assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if . Sample Input Input 0 022 0 10 2 2 Output 1.00000000000000000000 Input 1 333 3 2-2 3 6-2 7 10 Output 0.50000000000000000000 Hint In the first sample, first taxi will get to Vasiliy in time 2, and second will do this in time 1, therefore 1 is the answer. In the second sample, cars 2 and 3 will arrive simultaneously. 题解使用两点间距离公式计算距离除以速度获得时间输出最小的时间与正确答案误差应该尽可能小,因此应该尽可能多输出小数位数 按照样例输出 20 位小数 代码Beru-taxi代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;#include &lt;iomanip&gt; using namespace std;inline double dis(double x1,double y1,double x2,double y2) &#123; return sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));&#125;bool Do() &#123; double x,y; if(!(cin &gt;&gt; x &gt;&gt; y)) return false; int n; cin &gt;&gt; n; double Min = 9999999999; for(int i = 1;i &lt;= n;i++) &#123; double tx,ty,v; cin &gt;&gt; tx &gt;&gt; ty &gt;&gt; v; double distance = fabs(dis(x,y,tx,ty)); Min = min(Min,distance / v); &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(20) &lt;&lt; Min &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"2016-08-10 ~ 2016-08-12 学习报告","date":"2016-08-13T04:30:10.000Z","path":"/post/Study/2016_08_10-2016_08_12.html","text":"题目： AOJ 400.Subset Sums AOJ 363.取数字问题 Codeforces 706A.Beru-taxi Codeforces 706B.Interesting drink Codeforces 706C.Hard problem 算法 ST算法 线段树 RMQ问题","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"线段树","date":"2016-08-11T13:49:23.000Z","path":"/post/Algorithm/Segment_tree.html","text":"线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。 百度百科线段树 对于一棵线段树，其叶节点是长度为1的线段如图，是一棵(0,10)的线段树 可以看出，叶节点是区间内长度为1的线段的集合 二叉树的优势在于访问的快速，我们可以在O(logN)的时间内找到我们需要的节点因此，借助线段树，我们可以进行高效的线段操作。 最简单的线段树简单的线段树只需要实现快速获取一个区间的最大值或者最小值等数据即可 代码根据 AOJ 351.求最值之差 编写 结构定义首先线段树是一棵二叉树,他应该有二叉树基本的数据struct Tree&#123; int l,r; int n;&#125;; l 和 r 是线段树的两个端点n 是线段树的这个结点存储的数值,可以根据具体需要更改 建树首先需要根据数据建立线段树采用 递归与分治 的思想递归建树compare 是函数指针,可以是 max 或者 min 用于确定是要最大值还是最小值这样就构建好了一棵线段树建树 int BuildTree(int a,int b,int (*compare)(int,int),int* num,Tree *T,int pos = 1) &#123; T[pos].l = a; T[pos].r = b; if(b - a == 1) return T[pos].n = compare(num[a],num[b]); int mid = (a + b) / 2; int leftchild = 2 * pos; int rightchild = 2 * pos + 1; T[pos].n = compare( BuildTree(a,mid,compare,num,T,leftchild), BuildTree(mid,b,compare,num,T,rightchild) );&#125; 查询线段树的查询只需要判断区间关系即可如果正好是当前访问的区间,那么直接返回结果即可如果完全在当前区间的一侧,则递归返回如果跨越区间中点,则分别取两侧的最值然后比较返回即可 查询int GetNum(int a,int b,int(*compare)(int,int),int* num,Tree *T,int pos = 1) &#123; if(a == b) return num[a]; int &amp;l = T[pos].l; int &amp;r = T[pos].r; if(a == l &amp;&amp; b == r) return T[pos].n; int mid = (l + r) / 2; int leftchild = 2 * pos; int rightchild = 2 * pos + 1; if(b &lt;= mid) return GetNum(a,b,compare,num,T,leftchild); if(a &gt;= mid) return GetNum(a,b,compare,num,T,rightchild); return T[pos].n = compare( GetNum(a,mid,compare,num,T,leftchild), GetNum(mid + 1,b,compare,num,T,rightchild) );&#125;","tags":[{"name":"树","slug":"Tree","permalink":"https://www.oyohyee.com/tags/Tree/"},{"name":"线段树","slug":"Segment-tree","permalink":"https://www.oyohyee.com/tags/Segment-tree/"},{"name":"递归与分治","slug":"Recursion","permalink":"https://www.oyohyee.com/tags/Recursion/"}]},{"title":"RMQ问题","date":"2016-08-11T13:37:00.000Z","path":"/post/Algorithm/RMQ.html","text":"RMQ ( Range Minimum / Maximum Query )问题是指： 对于长度为 n 的数列 A ，回答若干询问 RMQ(A,i,j) ( i,j&lt;=n )，返回数列 A 中下标在 i , j 里的最小(大)值也就是说，RMQ 问题是指求区间最值的问题 百度百科RMQ 问题 显然,最直观的算法是用 O(n) 的时间找到查询范围内的最值,然后输出当查询的次数 m 非常大时,时间复杂度是 O(n*m)很可能是一个非常大的数字 于是有了一些其他的查询方法: 预处理区间用 O(n2) 的时间进行预处理分别用 Max[i][j] 、 Min[i][j] 表示 [i,j] 的最值预处理时间 O(n2)单次查询时间 O(1)总时间 O(n2) + m * O(1)显然,当 n 比较大时,这种方法并不好 &gt;线段树&lt;通过二分法,用 O(logn) 的时间建树,再用 O(logn) 的时间查询总时间 O(logn) + m * O(logn)综合来看时间复杂度能够接受,但是由于需要构建二叉树,因此对内存的占用较大 &gt;ST算法&lt;将线段分成一个个 [i,i+2k-1] 的区间采用动态规划的方法在 O(nlogn) 的时间内预处理采用数学方法,在 O(1) 的时间内完成一次查询总时间 O(nlogn) + m * O(1)综合时间复杂度较低,并且对内存占用也比较小是解决RMQ问题的最好方法","tags":[{"name":"二分","slug":"Division","permalink":"https://www.oyohyee.com/tags/Division/"},{"name":"RMQ问题","slug":"RMQ","permalink":"https://www.oyohyee.com/tags/RMQ/"},{"name":"ST算法","slug":"ST","permalink":"https://www.oyohyee.com/tags/ST/"},{"name":"线段树","slug":"Segment-tree","permalink":"https://www.oyohyee.com/tags/Segment-tree/"}]},{"title":"AOJ 351.求最值之差","date":"2016-08-11T05:12:21.000Z","path":"/post/AOJ/351.html","text":"题目 Description 给出N个数，求第a个数到第b个数之间最大的数减去最小的数的结果 Input N（N小于100,000），M（M小于100,000）接下来有N个数接下来M组范围,所有数均在[0,231-1]内每个范围有2个整数a,b(1&lt;=a&lt;=b&lt;=N) Output 每行输出一个结果 Sample Input 5 34 2 5 1 101 52 32 2 Sample Output 930 题解经典的 &gt;RMQ问题&lt;分别采用 &gt;ST算法&lt; 和 &gt;线段树&lt; 求解 代码ST算法ST算法代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.com かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std; const int maxn = 100005;const int maxk = 17; int num[maxn];int Max[maxn][maxk];int Min[maxn][maxk]; int n,m; int pow(int a,int n) &#123; if(a == 2) return 1 &lt;&lt; n; if(n == 1) return a; return pow(a,n / 2) * pow(a,n / 2) * (n &amp; 1 ? a : 1);&#125; bool Do() &#123; if(!(cin &gt;&gt; n &gt;&gt; m)) return false; for(int i = 1;i &lt;= n;i++) cin &gt;&gt; num[i]; /*ST算法*/ for(int k = 0;pow(2,k) &lt;= n;k++) &#123; for(int i = 1;i + pow(2,k) - 1 &lt;= n;i++) &#123; //dp[i][k] 为 (i,j)区间的最值 if(k == 0) &#123; Max[i][k] = Min[i][k] = num[i]; &#125; else &#123; Max[i][k] = max(Max[i][k - 1],Max[i + pow(2,k - 1)][k - 1]); Min[i][k] = min(Min[i][k - 1],Min[i + pow(2,k - 1)][k - 1]); &#125; &#125; &#125; for(int i = 1;i &lt;= m;i++) &#123; int a,b; cin &gt;&gt; a &gt;&gt; b; int k = (int)(log(b - a + 1.0) / log(2.0)); cout &lt;&lt; max(Max[a][k],Max[b - pow(2,k) + 1][k]) - min(Min[a][k],Min[b - pow(2,k) + 1][k]) &lt;&lt; endl; &#125; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125; 线段树线段树代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;const int maxn = 100005;struct Tree &#123; int l,r; int Max,Min;&#125;;int num[maxn];Tree T[maxn * 4];int max(int a,int b) &#123; return a &gt; b ? a : b;&#125;int min(int a,int b) &#123; return a &lt; b ? a : b;&#125;void BuildTree(int a,int b,int* num,Tree *T,int pos = 1) &#123; //根据数组 num[] a ~ b 下标区域 compare() 函数返回 true 建树 T[pos].l = a; T[pos].r = b; if(b - a == 1) &#123; T[pos].Max = max(num[a],num[b]); T[pos].Min = min(num[a],num[b]); return; &#125; int mid = (a + b) / 2; int leftchild = 2 * pos; int rightchild = 2 * pos + 1; BuildTree(a,mid,num,T,leftchild); BuildTree(mid,b,num,T,rightchild); T[pos].Max = max(T[leftchild].Max,T[rightchild].Max); T[pos].Min = min(T[leftchild].Min,T[rightchild].Min); return;&#125;void GetNum(int a,int b,int* num,Tree *T,int &amp;Max,int &amp;Min,int pos = 1) &#123; //根据数组 num[] a ~ b 下标区域 compare() 函数返回 true 建树 if(a == b) &#123; Max = a; Min = a; return; &#125; int &amp;l = T[pos].l; int &amp;r = T[pos].r; if(a == l &amp;&amp; b == r) &#123; Max = T[pos].Max; Min = T[pos].Min; return; &#125; int mid = (l + r) / 2; int leftchild = 2 * pos; int rightchild = 2 * pos + 1; if(b &lt;= mid) &#123; GetNum(a,b,num,T,Max,Min,leftchild); return; &#125; if(a &gt;= mid) &#123; GetNum(a,b,num,T,Max,Min,rightchild); return; &#125; int Max1,Max2,Min1,Min2; GetNum(a,mid,num,T,Max1,Min1,leftchild); GetNum(mid,b,num,T,Max2,Min2,rightchild); Max = max(Max1,Max2); Min = min(Min1,Min2); return;&#125;int n,m;bool Do() &#123; if(!(cin &gt;&gt; n &gt;&gt; m)) return false; for(int i = 1;i &lt;= n;i++) cin &gt;&gt; num[i]; /*线段树*/ BuildTree(1,n,num,T); for(int i = 1;i &lt;= m;i++) &#123; int a,b; cin &gt;&gt; a &gt;&gt; b; int Max,Min; GetNum(a,b,num,T,Max,Min); cout &lt;&lt; Max-Min &lt;&lt; endl; &#125; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"RMQ问题","slug":"RMQ","permalink":"https://www.oyohyee.com/tags/RMQ/"},{"name":"ST算法","slug":"ST","permalink":"https://www.oyohyee.com/tags/ST/"},{"name":"线段树","slug":"Segment-tree","permalink":"https://www.oyohyee.com/tags/Segment-tree/"}]},{"title":"ST算法","date":"2016-08-10T12:43:08.000Z","path":"/post/Algorithm/ST.html","text":"ST 算法是一种高效求解 &gt;RMQ 问题&lt; 的算法 其预处理时间复杂度为 O(nlogn) 查询时间复杂度为 O(1) 在进行大量数据的查询时,是一种非常好的算法 其思路是类似采用 二分 的思路对各个区间进行预处理在查询时(查询 (a,d) )通过查询 [a,c) 和 [b,d) (a&lt;=b&lt;=c&lt;=d) 来获取结果 预处理用 dp[i][k] 表示区间 [i,i+2^k-1] (也即 [i,i+2^k] ) 范围内的最值显然, dp[i][0] = num[i] ( [i,i) 的最值就是第 i 个数)其他情况有 dp[i][k] = compare( dp[i][k-1] , dp[i+2^(k-1)][k-1] )( [i,i+2^k-1) 的最值来自 [i,i+2(k-1)-1) 和 [i+2^(k-1),i+2^k-1) ) 注意,要 先循环 k 再循环 i 预处理部分for(int k = 0;(1 &lt;&lt; k) &lt;= n;k++) &#123; for(int i = 1;i + (1 &lt;&lt; k) - 1 &lt;= n;i++) &#123; //dp[i][k] 为 (i,j)区间的最值 if(k == 0) &#123; Max[i][k] = Min[i][k] = num[i]; &#125; else &#123; Max[i][k] = max(Max[i][k - 1],Max[i + (1 &lt;&lt; (k-1))][k - 1]); Min[i][k] = min(Min[i][k - 1],Min[i + (1 &lt;&lt; (k-1))][k - 1]); &#125; &#125;&#125; 查询查询时,由于不能确保一定能恰好使用 [i,i+2^k-1) 的形式表示因此可以拆开成两个 有交集 的区间,比较求得最值因此要找到数 c 和 d 使得 a&lt;=b&lt;=c&lt;=d 并且可以表示成 i+2^k-1 的形式可以找到数 k 有 [a,2^k-1) 和 [b-2^k+1,b) 可以表示成符合的形式可推出 k=log2(a+b+1)也即int k = (int)(log(b - a + 1.0) / log(2.0)); 查询时只需要比较 dp[a][k] 和 dp[b-2^k+1][k] 即可 预处理部分int k = (int)(log(b - a + 1.0) / log(2.0));cout &lt;&lt; \"Max: \" &lt;&lt; max(Max[a][k],Max[b - (2&lt;&lt;k) + 1][k]) &lt;&lt; endl;cout &lt;&lt; \"Min: \" &lt;&lt; min(Min[a][k],Min[b - (2&lt;&lt;k) + 1][k]) &lt;&lt; endl;","tags":[{"name":"二分","slug":"Division","permalink":"https://www.oyohyee.com/tags/Division/"},{"name":"RMQ问题","slug":"RMQ","permalink":"https://www.oyohyee.com/tags/RMQ/"},{"name":"ST算法","slug":"ST","permalink":"https://www.oyohyee.com/tags/ST/"}]},{"title":"AOJ 363.取数字问题","date":"2016-08-10T07:53:42.000Z","path":"/post/AOJ/363.html","text":"题目 Description 定的M*N的矩阵，其中的每个元素都是-10到10之间的整数，你的任务是从左上角（1，1），走到右下角（M,N），每一步只能向下或者向右，你所经过的方格里面的数字都必须被选取，请找出一条最合适的路，使得在路上被选取的数字之和是尽可能小的正整数。 Input 测试数据包括多组，以文件结尾为结束。第一行：两个正整数M,N(2=&lt;M,N&lt;=10)；接下来的M行：每行包括N个整数，是矩阵中每一行的N个元素。 Output 输出只有一行，就是一个整数，表示所选道路上数字之和所能达到的最小正整数。如果不能达到任何正整数，输出-1。 Sample Input 2 20 21 0 Sample Output 1 题解由于要输出最小的正整数因此单纯找最小是不行的,需要使用 DFS 深搜0 不是正整数 代码取数字问题代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;const int maxn = 15;int ans;int Map[maxn][maxn];int n,m;void dfs(int x,int y,int sum) &#123; if(x &gt; n || y &gt; m) return; int tsum = sum + Map[x][y]; if(x == n &amp;&amp; y == m) if(tsum &gt; 0) ans = ((ans == -1) ? tsum : min(ans,tsum)); dfs(x + 1,y,tsum); dfs(x,y + 1,tsum);&#125;bool Do() &#123; if(!(cin &gt;&gt; n &gt;&gt; m)) return false; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; cin &gt;&gt; Map[i][j]; &#125; ans = -1; dfs(1,1,0); cout &lt;&lt; ans &lt;&lt; endl; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"DFS","slug":"DFS","permalink":"https://www.oyohyee.com/tags/DFS/"}]},{"title":"AOJ 400.Subset Sums","date":"2016-08-10T07:00:52.000Z","path":"/post/AOJ/400.html","text":"题目 Description For many sets of consecutive integers from 1 through N (1 &lt;= N &lt;= 39), one can partition the set into two sets whose sums are identical. For example, if N=3, one can partition the set {1, 2, 3} in one way so that the sums of both subsets are identical: {3} and {1,2}This counts as a single partitioning (i.e., reversing the order counts as the same partitioning and thus does not increase the count of partitions). If N=7, there are four ways to partition the set {1, 2, 3, … 7} so that each partition has the same sum: {1,6,7} and {2,3,4,5}{2,5,7} and {1,3,4,6}{3,4,7} and {1,2,5,6}{1,2,4,7} and {3,5,6}Given N, your program should print the number of ways a set containing the integers from 1 through N can be partitioned into two sets whose sums are identical. Print 0 if there are no such ways. Your program must calculate the answer, not look it up from a table. Input The input file contains a single line with a single integer representing N, as above. Output The output file contains a single line with a single integer that tells how many same-sum partitions can be made from the set {1, 2, …, N}. The output file should contain 0 if there are no ways to make a same-sum partition. Sample Input 7 Sample Output 4 题解&gt;背包问题 01背包问题&lt; 由于所有数都要用上,因此每一部分数的大小应该是总和的一半如果总和是 0 必然无解然后是统计组合个数的背包问题到达和为 i 可以从 i-j 转移过来dp[i] += dp[i-j] n 为 40 的时候结果貌似会溢出 int 以防万一用了 long long 代码Subset Sums代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.com かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std; const int maxn = 1000; int v;long long dp[maxn]; void ZeroOnePack(int cost,int weight) &#123; for(int i = v; i &gt;= cost; i--) dp[i] += dp[i - cost];&#125; bool Do() &#123; int n; if(!(cin &gt;&gt; n)) return false; v = (1 + n)*n / 2; if(v &amp; 1) &#123; cout &lt;&lt; 0 &lt;&lt; endl; &#125; else &#123; v /= 2; memset(dp,0,sizeof(dp)); dp[0] = 1; for(int i = 1;i &lt;= n;i++) &#123; ZeroOnePack(i,i); &#125; cout &lt;&lt; dp[v] / 2 &lt;&lt; endl; &#125; return true;&#125;int main() &#123; cin.tie(0); cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"}]},{"title":"2016-08-07 ~ 2016-08-09 学习报告","date":"2016-08-10T04:30:10.000Z","path":"/post/Study/2016_08_07-2016_08_09.html","text":"题目： HDU 5112.A Curious Matt HDU 5119.Happy Matt Friends HDU 5120.Intersection HDU 5122.K.Bro Sorting HDU 1502.Regular Words HDU 1025.Constructing Roads In JGShining’s Kingdom HDU 3008.Warcraft HDU 1074.Doing Homework HDU 1224.Free DIY Tour HDU 1227.Fast Food","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"DP46","date":"2016-08-09T04:28:20.000Z","path":"/post/Project/dp46.html","text":"46道动态规划题 VJudge专题 DP46(上) DP46(下) 序号 OJ 题号 题目 题解 0 HDU 2955 Robberies 题解 1 HDU 1864 最大报销额 题解 2 HDU 1231 最大连续子序列 题解 3 HDU 1003 Max Sum 题解 4 HDU 1506 Largest Rectangle in a Histogram 题解 5 HDU 1505 City Game 题解 6 HDU 2602 Bone Collector 题解 7 HDU 1087 Super Jumping! Jumping! Jumping! 题解 8 HDU 2571 命运 题解 9 HDU 1069 Monkey and Banana 题解 10 HDU 1171 Big Event in HDU 题解 11 HDU 2084 数塔 题解 12 HDU 1176 免费馅饼 题解 13 HDU 1203 I NEED A OFFER! 题解 14 HDU 2159 FATE 题解 15 HDU 2577 How to Type 题解 16 HDU 2844 HDU 2844.Coins 题解 17 HDU 2845 Beans 题解 18 HDU 2870 Largest Submatrix 题解 19 HDU 2830 Matrix Swapping II 题解 20 HDU 1257 最少拦截系统 题解 21 HDU 1159 Common Subsequence 题解 22 HDU 1421 搬寝室 题解 23 HDU 1058 Humble Numbers 题解 24 HDU 1789 Doing Homework again 题解 25 HDU 1978 How many ways 题解 26 HDU 2191 悼念512汶川大地震遇难同胞——珍惜现在，感恩生活 题解 27 HDU 1114 Piggy-Bank 题解 28 HDU 1024 Max Sum Plus Plus 题解 29 HDU 1106 FatMouse’s Speed 题解 30 HDU 1025 Constructing Roads In JGShining’s Kingdom 题解 31 HDU 1078 FatMouse and Cheese 题解 32 HDU 1081 To The Max 题解 33 HDU 2059 龟兔赛跑 题解 34 HDU 1158 Employment Planning 题解 35 HDU 1059 Dividing 题解 36 HDU 1080 Human Gene Functions 题解 37 HDU 1074 Doing Homework 题解 38 HDU 1224 Free DIY Tour 题解 39 HDU 1422 重温世界杯 题解 40 HDU 1300 Pearls 题解 41 HDU 1501 Zipper 题解 42 HDU 1227 Fast Food 题解 43 HDU 3008 Warcraft 题解 44 HDU 1502 Regular Words 题解 45 HDU 1503 Advanced Fruits 题解","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"}]},{"title":"HDU 1227.Fast Food","date":"2016-08-09T04:10:29.000Z","path":"/post/HDU/1227.html","text":"题目 Description The fastfood chain McBurger owns several restaurants along a highway. Recently, they have decided to build several depots along the highway, each one located at a restaurant and supplying several of the restaurants with the needed ingredients. Naturally, these depots should be placed so that the average distance between a restaurant and its assigned depot is minimized. You are to write a program that computes the optimal positions and assignments of the depots. To make this more precise, the management of McBurger has issued the following specification: You will be given the positions of n restaurants along the highway as n integers d1 &lt; d2 &lt; … &lt; dn (these are the distances measured from the company’s headquarter, which happens to be at the same highway). Furthermore, a number k (k &lt;= n) will be given, the number of depots to be built. The k depots will be built at the locations of k different restaurants. Each restaurant will be assigned to the closest depot, from which it will then receive its supplies. To minimize shipping costs, the total distance sum, defined as must be as small as possible. Write a program that computes the positions of the k depots, such that the total distance sum is minimized. Input The input file contains several descriptions of fastfood chains. Each description starts with a line containing the two integers n and k. n and k will satisfy 1 &lt;= n &lt;= 200, 1 &lt;= k &lt;= 30, k &lt;= n. Following this will n lines containing one integer each, giving the positions di of the restaurants, ordered increasingly. The input file will end with a case starting with n = k = 0. This case should not be processed. Output For each chain, first output the number of the chain. Then output a line containing the total distance sum. Output a blank line after each test case. Sample Input 6 356121920270 0 Sample Output Chain 1Total distance sum = 8 题解看上去毫无思路,不过按照动态规划的套路,应该是这样的解法用 dp[i][j] 表示 i 个仓库,前 j 个饭店的最小值 那么新建的仓库应该建在 1 和 j 中间(选择 k 把原仓库控制区间分成两个)如果用 Min[i][j] 表示在 i 和 j 中间建仓库的最小距离应该有 dp[i][j] = min{ dp[i-1][k] + Min[k+1][j] } 如果是偶数个饭点,仓库应该建在中间两个饭店中间的任意位置如果是奇数个饭店,仓库应该建在中间饭店的位置这样可以保证距离最短 先用 O(n2) 的时间算出来 Min[i][j]然后 O(n3) 的时间算出来 dp[i][j] 对于状态转移方程的正确性的解释对于需要计算的 dp[i][j] 其必然是有 i-1 个仓库再加上一个仓库得到可能存在的极端情况是,两端饭店离得非常远,为了保证最近,因此 i-1 将仓库建在中间位置而可以建 i 个饭店时,可以将饭店分别建在两端当 k 为最右面的左半部分饭店时,恰好将中间距离给跳掉,因此为最优解对于多个仓库的情况,可以将其类比为该种情况 代码Fast Food代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;const int INF = 0x7FFFFFFF / 2;const int maxn = 205;const int maxk = 35;int kase = 1;int restaurants[maxn];int dp[maxk][maxn];int Min[maxn][maxn];bool Do() &#123; memset(dp,0,sizeof(dp)); int n,m; cin &gt;&gt; n &gt;&gt; m; if(n == 0 &amp;&amp; m == 0) return false; for(int i = 1;i &lt;= n;i++) cin &gt;&gt; restaurants[i]; for(int i = 1;i &lt;= n;i++) &#123; for(int j = i;j &lt;= n;j++) &#123; if(i == j) &#123; Min[i][j] = 0; &#125; else &#123; int pos = restaurants[(i + j) / 2]; Min[i][j] = 0; for(int k = i;k &lt;= j;k++) &#123; Min[i][j] += abs(pos - restaurants[k]); &#125; &#125; &#125; &#125; for(int i = 1;i &lt;= m;i++) if(i == 1) &#123; for(int j = 1;j &lt;= n;j++) dp[1][j] = Min[1][j]; &#125; else &#123; for(int j = 1;j &lt;= n;j++) &#123; dp[i][j] = INF; for(int k = 1;k &lt; j;k++) &#123; dp[i][j] = min(dp[i][j],dp[i - 1][k] + Min[k + 1][j]); &#125; &#125; &#125; cout &lt;&lt; \"Chain \"&lt;&lt;kase++ &lt;&lt; endl &lt;&lt;\"Total distance sum = \"&lt;&lt;dp[m][n] &lt;&lt; endl&lt;&lt;endl; return true;&#125;int vs_main() &#123; cin.tie(0); std::cin.sync_with_stdio(false); while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"HDU 1224.Free DIY Tour","date":"2016-08-09T03:17:23.000Z","path":"/post/HDU/1224.html","text":"题目 Description Weiwei is a software engineer of ShiningSoft. He has just excellently fulfilled a software project with his fellow workers. His boss is so satisfied with their job that he decide to provide them a free tour around the world. It’s a good chance to relax themselves. To most of them, it’s the first time to go abroad so they decide to make a collective tour. The tour company shows them a new kind of tour circuit - DIY circuit. Each circuit contains some cities which can be selected by tourists themselves. According to the company’s statistic, each city has its own interesting point. For instance, Paris has its interesting point of 90, New York has its interesting point of 70, ect. Not any two cities in the world have straight flight so the tour company provide a map to tell its tourists whether they can got a straight flight between any two cities on the map. In order to fly back, the company has made it impossible to make a circle-flight on the half way, using the cities on the map. That is, they marked each city on the map with one number, a city with higher number has no straight flight to a city with lower number. Note: Weiwei always starts from Hangzhou(in this problem, we assume Hangzhou is always the first city and also the last city, so we mark Hangzhou both 1 and N+1), and its interesting point is always 0. Now as the leader of the team, Weiwei wants to make a tour as interesting as possible. If you were Weiwei, how did you DIY it Input The input will contain several cases. The first line is an integer T which suggests the number of cases. Then T cases follows.Each case will begin with an integer N(2 ≤ N ≤ 100) which is the number of cities on the map.Then N integers follows, representing the interesting point list of the cities.And then it is an integer M followed by M pairs of integers [Ai, Bi] (1 ≤ i ≤ M). Each pair of [Ai, Bi] indicates that a straight flight is available from City Ai to City Bi. Output For each case, your task is to output the maximal summation of interesting points Weiwei and his fellow workers can get through optimal DIYing and the optimal circuit. The format is as the sample. You may assume that there is only one optimal circuit. Output a blank line between two cases. Sample Input 230 70 9041 21 32 43 430 90 7041 21 32 43 4 Sample Output CASE 1#points : 90circuit : 1-&gt;3-&gt;1 CASE 2#points : 90circuit : 1-&gt;2-&gt;1 题解看题目还以为是图论,但是有非常关键的一点是,只能从序号低的城市到序号高的城市(是序号,不是感兴趣程度)然后就是非常直接的动态规划问题需要记录前驱结点 如果城市 i 到城市 j 有路,那么 dp[j] = dp[i] + value[j] 由于城市 n+1 就是城市 1 把这个特殊处理下即可 代码Free DIY Tour代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;const int maxn = 105;int value[maxn];bool Map[maxn][maxn];int dp[maxn];int last[maxn];stack&lt;int&gt; s;void Do() &#123; memset(Map,false,sizeof(Map)); memset(dp,false,sizeof(dp)); int n,m; cin &gt;&gt; n; for(int i = 1;i &lt;= n;i++) cin &gt;&gt; value[i]; value[n + 1] = 0; cin &gt;&gt; m; for(int i = 1;i &lt;= m;i++) &#123; int a,b; cin &gt;&gt; a &gt;&gt; b; Map[a][b] = true; &#125; for(int i = 1;i &lt;= n;i++) for(int j = i;j &lt;= n + 1;j++) if(Map[i][j]) if(dp[j] &lt; dp[i] + value[j]) &#123; dp[j] = dp[i] + value[j]; last[j] = i; &#125; last[1] = 0; cout &lt;&lt; \"points : \" &lt;&lt; dp[n + 1] &lt;&lt; endl; int k = n + 1; while(k) &#123; s.push(k); k = last[k]; &#125; cout &lt;&lt; \"circuit : \"; while(!s.empty()) &#123; int t = s.top(); s.pop(); if(t != 1) cout &lt;&lt; \"-&gt;\"; if(t == n + 1) t = 1; cout &lt;&lt; t; &#125; cout &lt;&lt; endl; return;&#125;int main() &#123; cin.tie(0); std::cin.sync_with_stdio(false); int T; cin &gt;&gt; T; for(int kase = 1;kase &lt;= T;kase++) &#123; if(kase != 1) cout &lt;&lt; endl; cout &lt;&lt; \"CASE \" &lt;&lt; kase &lt;&lt; \"#\" &lt;&lt; endl; Do(); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"HDU 1074.Doing Homework","date":"2016-08-09T02:00:59.000Z","path":"/post/HDU/1074.html","text":"题目 Description Ignatius has just come back school from the 30th ACM/ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test, 1 day for 1 point. And as you know, doing homework always takes a long time. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score. Input The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.Each test case start with a positive integer N(1&lt;=N&lt;=15) which indicate the number of homework. Then N lines follow. Each line contains a string S(the subject’s name, each string will at most has 100 characters) and two integers D(the deadline of the subject), C(how many days will it take Ignatius to finish this subject’s homework). Note: All the subject names are given in the alphabet increasing order. So you may process the problem much easier. Output For each test case, you should output the smallest total reduced score, then give out the order of the subjects, one subject in a line. If there are more than one orders, you should output the alphabet smallest one. Sample Input 23Computer 3 3English 20 1Math 3 23Computer 3 3English 6 3Math 6 3 Sample Output 2ComputerMathEnglish3ComputerEnglishMath HintIn the second test case, both Computer-&gt;English-&gt;Math and Computer-&gt;Math-&gt;English leads to reduce 3 points, but theword “English” appears earlier than the word “Math”, so we choose the first order. That is so-called alphabet order. 题解状态压缩动态规划在二进制情况下,第 i 位为 1 表示已做完 为 0 表示未做这样可以用最多 2^15 的数来表示所有情况 用 dp[i] 表示当前处于 i 状态循环判断其他科目是否已完成,如果未完成,将现在状态加上完成的状态记录为新状态 NewState由于需要记录所花费的时间,和前驱因此需要 min time last 三个变量dp[NewState].min &gt; dp[i].min + ReduceScore 循环所有的状态即可所有科目均为 1 就是最后答案然后根据前驱输出科目即可(由于本身科目是按照字典序的,并且只有严格小于会更新状态,因此最后答案必然是字典序最小的) 由于输出是逆序,需要用栈等结构倒过来输出 代码Doing Homework代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;const int INF = 0x7FFFFFFF / 2;const int maxn = 16;const int maxstate = (1 &lt;&lt; 15);int Deadline[maxn],Score[maxn];struct Node &#123; string Name; int Deadline; int Time;&#125;;struct Node2 &#123; int min; int time; int last;&#125;;Node Homework[maxn];Node2 dp[maxstate];stack&lt;string&gt; s;int SetI(int num,int i,bool flag) &#123; if(flag) return num | (1 &lt;&lt; i); else return num &amp; (0 &lt;&lt; i);&#125;bool GetI(int num,int i) &#123; return num &gt;&gt; i &amp; 1;&#125;int GetChange(int num1,int num2) &#123; int n = num1 ^ num2; int i = 0; while(n) &#123; if(n &amp; 1) return i; n &gt;&gt;= 1; i++; &#125; return 0;&#125;void Do() &#123; int n; cin &gt;&gt; n; int sum = 0; int mt = 0; for(int i = 0;i &lt; n;i++) cin &gt;&gt; Homework[i].Name &gt;&gt; Homework[i].Deadline &gt;&gt; Homework[i].Time; dp[0].min = 0; for(int i = 1;i &lt;= (1 &lt;&lt; n) - 1;i++) dp[i].min = INF; for(int i = 0;i &lt; (1 &lt;&lt; n) - 1;i++) &#123; for(int j = 0;j &lt; n;j++) if(!GetI(i,j)) &#123; int NewState = SetI(i,j,1); int Time = dp[i].time + Homework[j].Time; int ReduceScore = (Time &gt; Homework[j].Deadline) ? (Time - Homework[j].Deadline) : 0; if(dp[NewState].min &gt; dp[i].min + ReduceScore) &#123; dp[NewState].min = dp[i].min + ReduceScore; dp[NewState].time = Time; dp[NewState].last = i; &#125; &#125; &#125; cout&lt;&lt;dp[(1 &lt;&lt; n) - 1].min&lt;&lt;endl; int k = (1 &lt;&lt; n) - 1; while(k) &#123; int pos = GetChange(k,dp[k].last); s.push(Homework[pos].Name); k = dp[k].last; &#125; while(!s.empty()) &#123; cout &lt;&lt; s.top() &lt;&lt; endl; s.pop(); &#125; return;&#125;int main() &#123; cin.tie(0); std::cin.sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--) Do(); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"栈(stack)","slug":"Stack","permalink":"https://www.oyohyee.com/tags/Stack/"},{"name":"状态压缩","slug":"State-compression","permalink":"https://www.oyohyee.com/tags/State-compression/"},{"name":"状压dp","slug":"State-compression-DP","permalink":"https://www.oyohyee.com/tags/State-compression-DP/"}]},{"title":"HDU 3008.Warcraft","date":"2016-08-08T11:48:23.000Z","path":"/post/HDU/3008.html","text":"题目 Description Have you ever played the Warcraft It doesn’t matter whether you have played it !We will give you such an experience.There are so many Heroes in it,but you could only choose one of them.Each Hero has his own skills.When such a Skill is used ,it costs some MagicValue,but hurts the Boss at the same time.Using the skills needs intellegence,one should hurt the enemy to the most when using certain MagicValue. Now we send you to complete such a duty to kill the Boss(So cool~~).To simplify the problem:you can assume the LifeValue of the monster is 100, your LifeValue is 100,but you have also a 100 MagicValue!You can choose to use the ordinary Attack(which doesn’t cost MagicValue),or a certain skill(in condition that you own this skill and the MagicValue you have at that time is no less than the skill costs),there is no free lunch so that you should pay certain MagicValue after you use one skill!But we are good enough to offer you a “ResumingCirclet”(with which you can resume the MagicValue each seconds),But you can’t own more than 100 MagicValue and resuming MagicValue is always after you attack.The Boss is cruel , be careful! Input There are several test cases,intergers n ,t and q (0&lt;n&lt;=100，1&lt;=t&lt;=5，q&gt;0) in the first line which mean you own n kinds of skills ,and the “ResumingCirclet” helps you resume t points of MagicValue per second and q is of course the hurt points of LifeValue the Boss attack you each time(we assume when fighting in a second the attack you show is before the Boss).Then n lines follow,each has 2 intergers ai and bi(0&lt;ai,bi&lt;=100).which means using i skill costs you ai MagicValue and costs the Boss bi LifeValue.The last case is n=t=q=0. Output Output an interger min (the minimun time you need to kill the Boss)in one line .But if you die(the LifeValue is no more than 0) ,output “My god”! Sample Input 4 2 2510 520 1030 2876 704 2 2510 520 1030 2877 700 0 0 Sample Output 4My god HintWhen fighting,you can only choose one kind of skill or just to use the ordinary attack in the whole second,the ordinary attack costs the Boss 1 points of LifeValue,the Boss can only use ordinary attack which costs a whole second at a time.Good Luck To You! 题解用 magic[i] hurt[i] 表示第 i 个技能的耗蓝和伤害( magic[0] = 0 hurt[0] = 1 代表普通攻击)用 dp[i][j] 表示第 i 秒后,剩下 j 点法力值能造成的最高伤害 很容易写出状态转移方程dp[i][j - magic[k]] = max{ dp[i-1][j] + hurt[k] } 由于每次只用到上一秒的数据,并且计算顺序比较混乱,可以采用滚动数组的方法(虽然直接写也不可能爆内存) 最后就是要注意 Boss 打你是否是正好打死,需要判断是否除尽 代码Warcraft代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;const int maxn = 105;int dp[2][maxn];int magic[maxn];int hurt[maxn];bool Do() &#123; int n,t,q; scanf(\"%d%d%d\",&amp;n,&amp;t,&amp;q); if(n == 0 &amp;&amp; t == 0 &amp;&amp; q == 0) return false; memset(dp,0,sizeof(dp)); for(int i = 1;i &lt;= n;i++) scanf(\"%d%d\",&amp;magic[i],&amp;hurt[i]); magic[0] = 0; hurt[0] = 1; int time = (100 % q == 0) ? 100 / q : 100 / q + 1; for(int i = 1;i &lt;= time;i++) &#123; int *thisdp = dp[i &amp; 1]; int *lastdp = dp[!(i &amp; 1)]; for(int j = 100;j &gt;= 0;j--) &#123; thisdp[j] = 0; if(j == 100) for(int k = 1;k &lt;= t;k++) lastdp[100] = max(lastdp[100],lastdp[100 - k]); else if(j - t &gt;= 0) lastdp[j] = lastdp[j - t]; else lastdp[j] = 0; &#125; for(int j = 100;j &gt;= t;j--) for(int k = 0;k &lt;= n;k++) if(j - magic[k] &gt;= 0) &#123; thisdp[j - magic[k]] = max( thisdp[j - magic[k]], lastdp[j] + hurt[k] ); if(thisdp[j - magic[k]] &gt;= 100) &#123; printf(\"%d\\n\",i); return true; &#125; &#125; &#125; printf(\"My god\\n\"); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"HDU 1025.Constructing Roads In JGShining's Kingdom","date":"2016-08-08T07:29:59.000Z","path":"/post/HDU/1025.html","text":"题目 Description JGShining’s kingdom consists of 2n(n is no more than 500,000) small cities which are located in two parallel lines. Half of these cities are rich in resource (we call them rich cities) while the others are short of resource (we call them poor cities). Each poor city is short of exactly one kind of resource and also each rich city is rich in exactly one kind of resource. You may assume no two poor cities are short of one same kind of resource and no two rich cities are rich in one same kind of resource. With the development of industry, poor cities wanna import resource from rich ones. The roads existed are so small that they’re unable to ensure the heavy trucks, so new roads should be built. The poor cities strongly BS each other, so are the rich ones. Poor cities don’t wanna build a road with other poor ones, and rich ones also can’t abide sharing an end of road with other rich ones. Because of economic benefit, any rich city will be willing to export resource to any poor one. Rich citis marked from 1 to n are located in Line I and poor ones marked from 1 to n are located in Line II. The location of Rich City 1 is on the left of all other cities, Rich City 2 is on the left of all other cities excluding Rich City 1, Rich City 3 is on the right of Rich City 1 and Rich City 2 but on the left of all other cities … And so as the poor ones. But as you know, two crossed roads may cause a lot of traffic accident so JGShining has established a law to forbid constructing crossed roads. For example, the roads in Figure I are forbidden. In order to build as many roads as possible, the young and handsome king of the kingdom - JGShining needs your help, please help him. ^_^ Input Each test case will begin with a line containing an integer n(1 ≤ n ≤ 500,000). Then n lines follow. Each line contains two integers p and r which represents that Poor City p needs to import resources from Rich City r. Process to the end of file. Output For each test case, output the result in the form of sample.You should tell JGShining what’s the maximal number of road(s) can be built. Sample Input 21 22 131 22 33 1 Sample Output Case 1:My king, at most 1 road can be built. Case 2:My king, at most 2 roads can be built. 题解跟着样例自己模拟,很容易可以看出是求最长上升子序列输入两个数 s 和 v先对 s 排序,再对 v 求最长上升子序列 由于数据较大,采用二分法求最长上升子序列( O(nlogn) )注意最后输出,如果结果大于 2 要把 road 变成 roads 如果采用 STL 的 lower_bound() 函数,需要注意它需要使用 &lt;要注意和前面 sort() 的区分 明明一眼看出算法,还坑了那么久…… 代码Constructing Roads In JGShining's Kingdom代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;const int maxn = 500005;int kase = 1;struct Node &#123; int s; int v; int right; //bool operator &lt; (const Node &amp;rhs)const &#123; //return s &lt; rhs.s; //&#125; bool operator &lt; (const Node &amp;rhs)const &#123; return v &lt; rhs.v; &#125; bool operator &gt; (const Node &amp;rhs)const &#123; return v &gt; rhs.v; &#125; static bool compare(Node &amp;a,Node &amp;b) &#123; return a.s &lt; b.s; &#125;&#125;;Node node[maxn];Node ans[maxn];bool Do() &#123; int n; if(scanf(\"%d\",&amp;n) == EOF) return false; for(int i = 1;i &lt;= n;i++) &#123; scanf(\"%d%d\",&amp;node[i].s,&amp;node[i].v); //dp[i] = 0; &#125; /* int ans = 0; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 0;j &lt; i;j++) if(node[i] &gt; node[j] || j == 0) &#123; dp[i] = max(dp[i],dp[j] + 1); &#125; ans = max(ans,dp[i]); &#125; */ sort(node + 1,node + 1 + n,Node::compare); ans[1] = node[1]; int len = 1; for(int i = 2; i &lt;= n; ++i) &#123; if(node[i] &gt; ans[len]) ans[++len] = node[i]; else &#123; Node *t = lower_bound(ans + 1,ans + 1 + len,node[i]); *(t) = node[i]; &#125; &#125; if(len == 1) printf(\"Case %d:\\nMy king, at most %d road can be built.\\n\\n\",kase++,len); else printf(\"Case %d:\\nMy king, at most %d roads can be built.\\n\\n\",kase++,len); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最长上升子序列","slug":"LIS","permalink":"https://www.oyohyee.com/tags/LIS/"},{"name":"二分","slug":"Division","permalink":"https://www.oyohyee.com/tags/Division/"}]},{"title":"HDU 1502.Regular Words","date":"2016-08-08T02:15:08.000Z","path":"/post/HDU/1502.html","text":"题目 Description Consider words of length 3n over alphabet {A, B, C} . Denote the number of occurences of A in a word a as A(a) , analogously let the number of occurences of B be denoted as B(a), and the number of occurenced of C as C(a) . Let us call the word w regular if the following conditions are satisfied: A(w)=B(w)=C(w) ;if c is a prefix of w , then A(c)&gt;= B(c) &gt;= C(c) .For example, if n = 2 there are 5 regular words: AABBCC , AABCBC , ABABCC , ABACBC and ABCABC . Regular words in some sense generalize regular brackets sequences (if we consider two-letter alphabet and put similar conditions on regular words, they represent regular brackets sequences). Given n , find the number of regular words. Input There are mutiple cases in the input file. Each case contains n (0 &lt;= n &lt;= 60 ). There is an empty line after each case. Output Output the number of regular words of length 3n . There should be am empty line after each case. Sample Input 2 3 Sample Output 5 42 题解求 n 个以 “ABC” 为顺序的字符串,能拼成的字符串个数对于一个已知的字符串,新的字符可以插到其任意一个字符后形成新的字符串dp[i][j][k] 表示有 i 个 A j 个 B k 个 C 的字符串个数dp[i][j][k] = dp[i-1][j][k] + dp[i][j-1][k] + dp[i][j][k-1]要保证字符串格式正确,必须有 i &gt;= j &gt;= k 数比较大,需要高精度算法来运算由于只有60组数据,可以打表输出 代码Regular Words代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;string dp[65] = &#123;\"1\",\"1\",\"5\",\"42\",\"462\",\"6006\",\"87516\",\"1385670\",\"23371634\",\"414315330\",\"7646001090\",\"145862174640\",\"2861142656400\",\"57468093927120\",\"1178095925505960\",\"24584089974896430\",\"521086299271824330\",\"11198784501894470250\",\"243661974372798631650\",\"5360563436201569896300\",\"119115896614816702500900\",\"2670926804331443293626900\",\"60386171228363065768956000\",\"1375596980582110638216817680\",\"31554078431506568639711925552\",\"728440733705121725605657358256\",\"16916012593818937850175820875056\",\"394984727560107218767652172156480\",\"9269882950945137003216002357575872\",\"218589820552932101591964442689934272\",\"5177405669064206309480641678873685136\",\"123139887106265725065261170839575261246\",\"2940211742938376804365727956142799686970\",\"70461309651358512358741033490151564263034\",\"1694426732092192797198296281548882854896770\",\"40879953049935966764838175153044218787509460\",\"989318124094680800242093703952690318964293660\",\"24011992526103689868224096174884123328708261100\",\"584414956558400574946623386902564355477176447080\",\"14261150342358043298392602404780869211095488665940\",\"348876433985002864104580005170614922408018905657020\",\"8555006509113973886896694412506009110609925390878620\",\"210257823823361408953856390159370731312558948560177500\",\"5178713915261459187808923452167773648813573133021584000\",\"127816663734641521693312994768720558317819058630953008000\",\"3160890723051037742300958639363743464856851891194511344000\",\"78316111638147520232116305011469771592038383559489541704000\",\"1943917771018304520047172570820410402016667020494472553010000\",\"48334523581589010102952513742546024844918906756931542442556400\",\"1203813957908516875152358489329058054078745007110871474716375280\",\"30029983483935083858438698423851117882968874317657169412268673840\",\"750270153399794678576435057573545926324276055884108148422050727840\",\"18772482769028405636917719941593858764528793976890630506115671775200\",\"470373947038907707302405010980987131831213397364392909428995307126880\",\"11802109943885320655951253002795677125946808879324767545672973160638080\",\"296516920131524804299707608337156053506400465189952712435084509896783040\",\"7459203321130790040650176332416188852363369960068846727881499803410725440\",\"187875141510304732204453155491218970539216498205240765481036372897711988800\",\"4737637890492057297860769571861620074038072983555206964113320603342642320960\",\"119605940186192921945993199027326146131452990076639651225155962772912609414400\",\"3022912056752362939484322031260179006906680462576858197252183463144268821651200\"&#125;;bool Do() &#123; int n; if(scanf(\"%d\",&amp;n) == EOF) return false; cout &lt;&lt; dp[n]&lt;&lt;endl&lt;&lt;endl; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"高精度算法","slug":"High-precision","permalink":"https://www.oyohyee.com/tags/High-precision/"},{"name":"打表","slug":"List","permalink":"https://www.oyohyee.com/tags/List/"}]},{"title":"HDU 5122.K.Bro Sorting","date":"2016-08-07T08:52:54.000Z","path":"/post/HDU/5122.html","text":"题目 Description Matt’s friend K.Bro is an ACMer. Yesterday, K.Bro learnt an algorithm: Bubble sort. Bubble sort will compare each pair of adjacent items and swap them if they are in the wrong order. The process repeats until no swap is needed. Today, K.Bro comes up with a new algorithm and names it K.Bro Sorting. There are many rounds in K.Bro Sorting. For each round, K.Bro chooses a number, and keeps swapping it with its next number while the next number is less than it. For example, if the sequence is “1 4 3 2 5”, and K.Bro chooses “4”, he will get “1 3 2 4 5” after this round. K.Bro Sorting is similar to Bubble sort, but it’s a randomized algorithm because K.Bro will choose a random number at the beginning of each round. K.Bro wants to know that, for a given sequence, how many rounds are needed to sort this sequence in the best situation. In other words, you should answer the minimal number of rounds needed to sort the sequence into ascending order. To simplify the problem, K.Bro promises that the sequence is a permutation of 1, 2, . . . , N . Input The first line contains only one integer T (T ≤ 200), which indicates the number of test cases. For each test case, the first line contains an integer N (1 ≤ N ≤ 10 6). The second line contains N integers a i (1 ≤ a i ≤ N ), denoting the sequence K.Bro gives you. The sum of N in all test cases would not exceed 3 × 10 6. Output For each test case, output a single line “Case #x: y”, where x is the case number (starting from 1), y is the minimal number of rounds needed to sort the sequence. Sample Input 255 4 3 2 155 1 2 3 4 Sample Output Case #1: 4Case #2: 1 HintIn the second sample, we choose “5” so that after the rst round, sequence becomes “1 2 3 4 5”, and the algorithm completes. 题解求最少要将几个数往后移动到没有比它小能使数组排好序最初看到题,觉得是最长上升子序列使了下都是 TLE 换种思路理解题意,计算比后面数大的数的个数 从后往前扫,如果当前数比最前数小,那么记录最小数,否则就将计数器加一最后计数器记下的数就是答案 这样可以用 O(n) 的时间算出答案,只需要维护一个变量记录最小的数,一个变量计数即可 代码K.Bro Sorting代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;const int maxn = 1000005;int a[maxn];inline int read_int() &#123; char c; bool fs = false; int ans = 0; while(c = getchar(),!(c &gt;= '0'&amp;&amp;c &lt;= '9')) if(c == '-') fs = true; while(c &gt;= '0'&amp;&amp;c &lt;= '9') &#123; ans *= 10; ans += (int)c - '0'; c = getchar(); &#125; return fs ? -ans : ans;&#125;void Do() &#123; int n = read_int(); int Max = 0; bool flag = false; for(int i = 1;i &lt;= n;i++) &#123; a[i] = read_int(); &#125; int ans = 0; int Min = n + 1; for(int i = n;i &gt;= 1;i--) if(Min &gt; a[i]) Min = a[i]; else ans++; printf(\"%d\\n\",ans);&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); for(int i = 1;i &lt;= T;i++) &#123; printf(\"Case #%d: \",i); Do(); &#125; return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"HDU 5120.Intersection","date":"2016-08-07T08:40:29.000Z","path":"/post/HDU/5120.html","text":"题目 Description Matt is a big fan of logo design. Recently he falls in love with logo made up by rings. The following figures are some famous examples you may know. A ring is a 2-D figure bounded by two circles sharing the common center. The radius for these circles are denoted by r and R (r &lt; R). For more details, refer to the gray part in the illustration below. Matt just designed a new logo consisting of two rings with the same size in the 2-D plane. For his interests, Matt would like to know the area of the intersection of these two rings. Input The first line contains only one integer T (T ≤ 10 5), which indicates the number of test cases. For each test case, the first line contains two integers r, R (0 ≤ r &lt; R ≤ 10). Each of the following two lines contains two integers x i, y i (0 ≤ x i, y i ≤ 20) indicating the coordinates of the center of each ring. Output For each test case, output a single line “Case #x: y”, where x is the case number (starting from 1) and y is the area of intersection rounded to 6 decimal places. Sample Input 22 30 00 02 30 05 0 Sample Output Case #1: 15.707963Case #2: 2.250778 题解纯数学公式推导题由于牵扯的小数,需要使用 double 进行运算由于会涉及浮点误差因此在比较大小的时候需要注意把较大数加上一个偏移量 貌似用海伦公式会出现问题,最好用余弦定理 总共有三种情况 完全相离,面积为 0 中心重合,面积就是大圆减小圆 其他情况,需要4部分相加减计算得出 代码Intersection代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;const int maxn = 45;const int maxm = 1000005;const double pi = 3.141592653589;int a[maxn];int dp[maxn][maxm];struct O &#123; double x; double y; double r; O(double x,double y,double r) &#123; this-&gt;x = x; this-&gt;y = y; this-&gt;r = r; &#125;&#125;;inline double Ha(double a,double b,double c) &#123; double p = (a + b + c) / 2; double ans = sqrt(p*(p - a)*(p - b)*(p - c)); return ans;&#125;inline double distance(double x1,double y1,double x2,double y2) &#123; double ans = sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2)); return ans;&#125;inline double Sshanxing(double r,double h) &#123; double th = asin(h / r); return th * r *r / 2;&#125;inline double Ssanjiao(double h,double r) &#123; return sqrt(r*r - h*h)*h / 2;&#125;inline double Syuan(double r) &#123; return pi*r*r;&#125;inline double S(O o1,O o2) &#123; double dis = distance(o1.x,o1.y,o2.x,o2.y); if(dis + 1e-8 &gt; o2.r + o1.r) return 0; if(dis &lt; fabs(o2.r - o1.r) + 1e-8) &#123; double r = min(o1.r,o2.r); return pi * r * r; &#125; double costh1 = (o1.r*o1.r + dis*dis - o2.r*o2.r) / (2 * o1.r*dis); double costh2 = (o2.r*o2.r + dis*dis - o1.r*o1.r) / (2 * o2.r*dis); double th1 = acos(costh1); double th2 = acos(costh2); return th1*o1.r*o1.r + th2*o2.r*o2.r - o1.r*dis*sin(th1); /*double h = Ha(o1.r,o2.r,dis) / dis * 2; double S1 = Sshanxing(o1.r,h) - Ssanjiao(h,o1.r); double S2 = Sshanxing(o2.r,h) - Ssanjiao(h,o2.r); double s = (S1 + S2) * 2; return s;*/&#125;void Do() &#123; double r,R; double x1,x2,y1,y2; scanf(\"%lf%lf\",&amp;r,&amp;R); scanf(\"%lf%lf\",&amp;x1,&amp;y1); scanf(\"%lf%lf\",&amp;x2,&amp;y2); O o1x(x1,y1,r); O o1d(x1,y1,R); O o2x(x2,y2,r); O o2d(x2,y2,R); double ans = S(o1d,o2d) - S(o1x,o2d) - S(o1d,o2x) + S(o1x,o2x); printf(\"%.6f\\n\",ans);&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); for(int i = 1;i &lt;= T;i++) &#123; printf(\"Case #%d: \",i); Do(); &#125; return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"}]},{"title":"HDU 5119.Happy Matt Friends","date":"2016-08-07T07:02:56.000Z","path":"/post/HDU/5119.html","text":"题目 Description Matt has N friends. They are playing a game together. Each of Matt’s friends has a magic number. In the game, Matt selects some (could be zero) of his friends. If the xor (exclusive-or) sum of the selected friends’magic numbers is no less than M , Matt wins. Matt wants to know the number of ways to win. Input The first line contains only one integer T , which indicates the number of test cases. For each test case, the first line contains two integers N, M (1 ≤ N ≤ 40, 0 ≤ M ≤ 10 6). In the second line, there are N integers ki (0 ≤ k i ≤ 10 6), indicating the i-th friend’s magic number. Output For each test case, output a single line “Case #x: y”, where x is the case number (starting from 1) and y indicates the number of ways where Matt can win. Sample Input 23 21 2 33 31 2 3 Sample Output Case #1: 4Case #2: 2 HintIn the rst sample, Matt can win by selecting:friend with number 1 and friend with number 2. The xor sum is 3.friend with number 1 and friend with number 3. The xor sum is 2.friend with number 2. The xor sum is 2.friend with number 3. The xor sum is 3.Hence, the answer is 4. 题解动态规划问题选取任意个人,使所有人的数异或后大于 m 求有多少种选法用 dp[i][j] 表示前 i 个人中选取任一个异或和为 j 的选法个数 如果不选择第 i 个人,则有 dp[i][j] = dp[i-1][j] 如果选择第 i 个人,则有 dp[i][j^a[i]] = dp[i-1][j] 计算后从 m 开始计算总共有多少即可 代码Happy Matt Friends代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;bitset&gt;using namespace std;const int maxn = 45;const int maxm = 1000005;int a[maxn];int dp[maxn][maxm];void Do() &#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); memset(dp,0,sizeof(dp)); for(int i = 1;i &lt;= n;i++)&#123; scanf(\"%d\",&amp;a[i]); &#125; dp[0][0] = 1; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 0;j &lt; maxm;j++) &#123; dp[i][j] += dp[i - 1][j]; dp[i][j ^ a[i]] += dp[i - 1][j]; &#125; &#125; long long ans = 0; for(int i = m;i &lt;= maxm;i++) ans += dp[n][i]; printf(\"%lld\\n\",ans);&#125;int main()&#123; int T; scanf(\"%d\",&amp;T); for(int i = 1;i &lt;= T;i++) &#123; printf(\"Case #%d: \",i); Do(); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"HDU 5112.A Curious Matt","date":"2016-08-07T06:51:46.000Z","path":"/post/HDU/5112.html","text":"题目 Description There is a curious man called Matt. One day, Matt’s best friend Ted is wandering on the non-negative half of the number line. Matt finds it interesting to know the maximal speed Ted may reach. In order to do so, Matt takes records of Ted’s position. Now Matt has a great deal of records. Please help him to find out the maximal speed Ted may reach, assuming Ted moves with a constant speed between two consecutive records. Input The first line contains only one integer T, which indicates the number of test cases. For each test case, the first line contains an integer N (2 ≤ N ≤ 10000),indicating the number of records. Each of the following N lines contains two integers t i and x i (0 ≤ t i, x i ≤ 10 6), indicating the time when this record is taken and Ted’s corresponding position. Note that records may be unsorted by time. It’s guaranteed that all t i would be distinct. Output For each test case, output a single line “Case #x: y”, where x is the case number (starting from 1), and y is the maximal speed Ted may reach. The result should be rounded to two decimal places. Sample Input 32 21 13 430 31 52 0 Sample Output Case #1: 2.00Case #2: 5.00 HintIn the rst sample, Ted moves from 2 to 4 in 1 time unit. The speed 2/1 is maximal.In the second sample, Ted moves from 5 to 0 in 1 time unit. The speed 5/1 is maximal. 题解求最快速度相邻时间段速度看做一样的,按照时间排序求出最大的速度即可 代码A Curious Matt代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 10005;struct Node &#123; int x; int t; bool operator &lt; (const Node &amp;rhs)const &#123; return t &lt; rhs.t; &#125;&#125;;Node node[maxn];void Do() &#123; int n; scanf(\"%d\",&amp;n); for(int i = 1;i &lt;= n;i++) &#123; scanf(\"%d%d\",&amp;node[i].t,&amp;node[i].x); &#125; sort(node + 1,node + 1 + n); double Max = 0.0; for(int i = 2;i &lt;= n;i++) &#123; Max = max(Max, abs( (double) (node[i].x - node[i-1].x) / (node[i].t - node[i-1].t) ) ); &#125; printf(\"%.2f\\n\",Max);&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); for(int i = 1;i &lt;= T;i++) &#123; printf(\"Case #%d: \",i); Do(); &#125; return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"2016-08-04 ~ 2016-08-06 学习报告","date":"2016-08-07T06:30:10.000Z","path":"/post/Study/2016_08_04-2016_08_06.html","text":"题目： HDU 1078.FatMouse and Cheese HDU 1081.To The Max HDU 1422.重温世界杯 HDU 2059.龟兔赛跑 HDU 1158.Employment Planning HDU 1501.Zipper HDU 1503.Advanced Fruits","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"HDU 1503.Advanced Fruits","date":"2016-08-06T07:17:33.000Z","path":"/post/HDU/1503.html","text":"题目 Description The company “21st Century Fruits” has specialized in creating new sorts of fruits by transferring genes from one fruit into the genome of another one. Most times this method doesn’t work, but sometimes, in very rare cases, a new fruit emerges that tastes like a mixture between both of them.A big topic of discussion inside the company is “How should the new creations be called “ A mixture between an apple and a pear could be called an apple-pear, of course, but this doesn’t sound very interesting. The boss finally decides to use the shortest string that contains both names of the original fruits as sub-strings as the new name. For instance, “applear” contains “apple” and “pear” (APPLEar and apPlEAR), and there is no shorter string that has the same property. A combination of a cranberry and a boysenberry would therefore be called a “boysecranberry” or a “craboysenberry”, for example. Your job is to write a program that computes such a shortest name for a combination of two given fruits. Your algorithm should be efficient, otherwise it is unlikely that it will execute in the alloted time for long fruit names. Input Each line of the input contains two strings that represent the names of the fruits that should be combined. All names have a maximum length of 100 and only consist of alphabetic characters. Input is terminated by end of file. Output For each test case, output the shortest name of the resulting fruit on one line. If more than one shortest name is possible, any one is acceptable. Sample Input apple peachananas bananapear peach Sample Output appleachbananaspearch 题解很明显,需要用到&gt;最长公共子序列&lt;的内容在输出字符串时,除了最长公共子序列的字符,还要输出其经过的字符结合最长公共子序列的图 代码Advanced Fruits代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 205;char a[maxn],b[maxn],c[maxn];//最长公共子序列//输入字符串a 及其长度 字符串b 及其长度 保存最长公共子序列的数组//字符从0开始int LCS(char *a,char *b,char s[] = NULL) &#123; int len1 = strlen(a); int len2 = strlen(b); char *aa = a - 1; char *bb = b - 1; //声明二维数组 int * m = new int[(len1 + 1)*(len2 + 1)]; int **dp = new int *[len1 + 1]; for(int i = 0;i &lt;= len1;i++) dp[i] = m + i*(len2 + 1); //初始化 for(int i = 0;i &lt;= len1;i++) dp[i][0] = 0; for(int i = 0;i &lt;= len2;i++) dp[0][i] = 0; //动态规划 for(int i = 1;i &lt;= len1;i++) for(int j = 1;j &lt;= len2;j++) if(aa[i] == bb[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j],dp[i][j - 1]); //如果c未传值 if(s == NULL) return dp[len1][len2]; //逆序推出一条符合串 int ans = dp[len1][len2]; int x = len1; int y = len2; int it = ans; int pos = len1 + len2 - it; s[pos] = '\\0'; while(x || y) &#123; if(x - 1 &gt;= 0 &amp;&amp; dp[x - 1][y] == it) &#123; s[--pos] = aa[x--]; continue; &#125; if(y - 1 &gt;= 0 &amp;&amp; dp[x][y - 1] == it) &#123; s[--pos] = bb[y--]; continue; &#125; s[--pos] = aa[x]; --it; x--; y--; &#125; return ans;&#125;bool Do() &#123; if(scanf(\"%s%s\",a,b) == EOF) return false; LCS(a,b,c); printf(\"%s\\n\",c); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最长公共子序列","slug":"LCS","permalink":"https://www.oyohyee.com/tags/LCS/"}]},{"title":"HDU 1501.Zipper","date":"2016-08-06T06:22:25.000Z","path":"/post/HDU/1501.html","text":"题目 Description Given three strings, you are to determine whether the third string can be formed by combining the characters in the first two strings. The first two strings can be mixed arbitrarily, but each must stay in its original order. For example, consider forming “tcraete” from “cat” and “tree”: String A: catString B: treeString C: tcraete As you can see, we can form the third string by alternating characters from the two strings. As a second example, consider forming “catrtee” from “cat” and “tree”: String A: catString B: treeString C: catrtee Finally, notice that it is impossible to form “cttaree” from “cat” and “tree”. Input The first line of input contains a single positive integer from 1 through 1000. It represents the number of data sets to follow. The processing for each data set is identical. The data sets appear on the following lines, one data set per line. For each data set, the line of input consists of three strings, separated by a single space. All strings are composed of upper and lower case letters only. The length of the third string is always the sum of the lengths of the first two strings. The first two strings will have lengths between 1 and 200 characters, inclusive. Output For each data set, print: Data set n: yes if the third string can be formed from the first two, or Data set n: no if it cannot. Of course n should be replaced by the data set number. See the ## Sample Output below for an example. Sample Input 3cat tree tcraetecat tree catrteecat tree cttareeSample OutputData set 1: yesData set 2: yesData set 3: no 题解用 dp[i][j] 表示字符串 a 的前 i 个字符和 字符串 b 的前 j 个字符能否组成字符串 c 的前 i+j 个字符在以下情况 dp[i][j] 为 true a[i] == c[i+j] 并且 dp[i-1][j] == true b[j] == c[i+j] 并且 dp[i][j-1] == true 注意边界值的问题即可最后由于 a 和 b 长度为 200 因此 c 应该长度为 400 代码Zipper代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 405;char a[maxn],b[maxn],c[maxn];bool dp[maxn][maxn];void Do() &#123; scanf(\"%s%s%s\",a + 1,b + 1,c + 1); memset(dp,false,sizeof(dp)); a[0] = b[0] = c[0] = ' '; int lena = strlen(a) - 1; int lenb = strlen(b) - 1; if(lena + lenb != strlen(c) - 1) &#123; printf(\"no\"); return; &#125; for(int i = 0;i &lt;= lena;i++) if(false == (dp[i][0] = (a[i] == c[i] &amp;&amp; (i == 0 || dp[i - 1][0])))) break; for(int j = 0;j &lt;= lenb;j++) if(false == (dp[0][j] = (b[j] == c[j] &amp;&amp; (j == 0 || dp[0][j - 1])))) break; for(int i = 1;i &lt;= lena;i++) for(int j = 1;j &lt;= lenb;j++) dp[i][j] = (dp[i - 1][j] &amp;&amp; a[i] == c[i + j]) || (dp[i][j - 1] &amp;&amp; b[j] == c[i + j]); if(dp[lena][lenb]) printf(\"yes\"); else printf(\"no\"); //printf(\" *%s*%s*%s* \",a,b,c); return;&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); for(int i = 1;i &lt;= T;i++) &#123; printf(\"Data set %d: \",i); Do(); putchar('\\n'); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"HDU 1158.Employment Planning","date":"2016-08-05T09:08:16.000Z","path":"/post/HDU/1158.html","text":"题目 Description A project manager wants to determine the number of the workers needed in every month. He does know the minimal number of the workers needed in each month. When he hires or fires a worker, there will be some extra cost. Once a worker is hired, he will get the salary even if he is not working. The manager knows the costs of hiring a worker, firing a worker, and the salary of a worker. Then the manager will confront such a problem: how many workers he will hire or fire each month in order to keep the lowest total cost of the project. Input The input may contain several data sets. Each data set contains three lines. First line contains the months of the project planed to use which is no more than 12. The second line contains the cost of hiring a worker, the amount of the salary, the cost of firing a worker. The third line contains several numbers, which represent the minimal number of the workers needed each month. The input is terminated by line containing a single ‘0’. Output The output contains one line. The minimal total cost of the project. Sample Input 34 5 610 9 110 Sample Output 199 题解每个月需要一定人数的工人干活,因此需要雇佣一定的人雇佣新工人需要钱,每个月工资也需要钱,解雇工人也需要钱根据每个月需要的工人数,合理解雇、雇佣工人,使总钱数最少 按照样例第一个月 雇佣 10 人 雇佣费用 10*4=40 工资 10*5=50 共计 90第二个月 不改变人数 工资 10*5=50 共计 50 总计 140第三个月 雇佣 1 人 雇佣费用 1*4=4 工资 11*5=55 共计 `59 总计 199 用 dp[i][j] 来记录第 i 个月雇佣 j 个工人需要的最少的钱数则有 dp[i][j] = min{ dp[i-1][k] }其中 k 是上一个月可能雇佣的人数(大于等于上个月需要的人数) 又自己把自己绕进去了,做题效率低到爆 代码Employment Planning代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int INF = 0x7FFFFFFF / 2;const int maxn = 13;const int maxp = 10000;int p[maxn];int dp[maxn][maxp];int n;int h,s,f;int GetMoney(int ss,int vv) &#123; if(ss &gt; vv) return (ss - vv) * f + vv * s; return (vv - ss) * h + vv * s;&#125;bool Do() &#123; scanf(\"%d\",&amp;n); if(n == 0) return false; scanf(\"%d%d%d\",&amp;h,&amp;s,&amp;f); int mp = 0; for(int i = 1;i &lt;= n;i++) &#123; scanf(\"%d\",&amp;p[i]); mp = max(mp,p[i]); &#125; p[0] = 0; memset(dp,-1,sizeof(dp)); dp[0][0] = 0; for(int i = 1;i &lt;= n;i++) for(int j = p[i];j &lt;= mp;j++) &#123; int Min = INF; for(int k = p[i - 1];k &lt;= mp;k++) if(dp[i - 1][k] != -1) Min = min(Min,dp[i-1][k] + GetMoney(k,j)); dp[i][j] = Min; &#125; int ans = INF; for(int i = 1;i &lt;= mp;i++) if(dp[n][i] != -1) ans = min(ans,dp[n][i]); printf(\"%d\\n\",ans); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"HDU 2059.龟兔赛跑","date":"2016-08-05T03:09:49.000Z","path":"/post/HDU/2059.html","text":"题目 Description 据说在很久很久以前，可怜的兔子经历了人生中最大的打击——赛跑输给乌龟后，心中郁闷，发誓要报仇雪恨，于是躲进了杭州下沙某农业园卧薪尝胆潜心修炼，终于练成了绝技，能够毫不休息得以恒定的速度(VR m/s)一直跑。兔子一直想找机会好好得教训一下乌龟，以雪前耻。最近正值HDU举办50周年校庆，社会各大名流齐聚下沙，兔子也趁此机会向乌龟发起挑战。虽然乌龟深知获胜希望不大，不过迫于舆论压力，只能接受挑战。比赛是设在一条笔直的道路上，长度为L米，规则很简单，谁先到达终点谁就算获胜。无奈乌龟自从上次获胜以后，成了名龟，被一些八卦杂志称为“动物界的刘翔”，广告不断，手头也有了不少积蓄。为了能够再赢兔子，乌龟不惜花下血本买了最先进的武器——“”小飞鸽”牌电动车。这辆车在有电的情况下能够以VT1 m/s的速度“飞驰”，可惜电池容量有限，每次充满电最多只能行驶C米的距离，以后就只能用脚来蹬了，乌龟用脚蹬时的速度为VT2 m/s。更过分的是，乌龟竟然在跑道上修建了很多很多（N个)的供电站，供自己给电动车充电。其中，每次充电需要花费T秒钟的时间。当然，乌龟经过一个充电站的时候可以选择去或不去充电。比赛马上开始了，兔子和带着充满电的电动车的乌龟并列站在起跑线上。你的任务就是写个程序，判断乌龟用最佳的方案进军时，能不能赢了一直以恒定速度奔跑的兔子。 Input 本题目包含多组测试，请处理到文件结束。每个测试包括四行：第一行是一个整数L代表跑道的总长度第二行包含三个整数N，C，T，分别表示充电站的个数，电动车冲满电以后能行驶的距离以及每次充电所需要的时间第三行也是三个整数VR，VT1，VT2，分别表示兔子跑步的速度，乌龟开电动车的速度，乌龟脚蹬电动车的速度第四行包含了N(N&lt;=100)个整数p1,p2…pn,分别表示各个充电站离跑道起点的距离，其中0&lt;p1&lt;p2&lt;…&lt;pn&lt;L其中每个数都在32位整型范围之内。 Output 当乌龟有可能赢的时候输出一行 “What a pity rabbit!”。否则输出一行”Good job,rabbit!”;题目数据保证不会出现乌龟和兔子同时到达的情况。 Sample Input 1003 20 55 8 210 40 601003 60 55 8 210 40 60 Sample Output Good job,rabbit!What a pity rabbit! 题解将起点看成一个充电站,则对于每个位置,可以转换成寻找到该点用时最少的充电站对于每个充电站,都有充电和不充电两种状态用 dp[i] 表示到充电站 i 的最少用时dp[i] = min(dp[i],dp[j] + t)其中 t 是充电站 j 到 充电站 i 的时间 最需要注意的是 double 和 int 之间的互相转换倒不如读入的时候直接读入 double 代码龟兔赛跑代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const double INF = 0x7FFFFFFF / 2;const int maxc = 105;int p[maxc];double dp[maxc];inline int toint(double n) &#123; return (int)(n + 0.01);&#125;bool Do() &#123; int L,N,C,T,VR,VT1,VT2; if(scanf(\"%d%d%d%d%d%d%d\",&amp;L,&amp;N,&amp;C,&amp;T,&amp;VR,&amp;VT1,&amp;VT2) == EOF) return false; for(int i = 1;i &lt;= N;i++) scanf(\"%d\",&amp;p[i]); p[0] = 0; p[N + 1] = L; sort(p + 1,p + 1 + N); for(int i = 1;i &lt;= N + 1;i++) &#123; dp[i] = INF; for(int j = 0;j &lt; i;j++) &#123; int dis = p[i] - p[j]; if(dis &lt;= C) &#123; dp[i] = min(dp[i],dp[j] + (double)dis / VT1); &#125; else &#123; dp[i] = min(dp[i],dp[j] + (double)C / VT1 + (double)(dis - C) / VT2); &#125; &#125; dp[i] += T; &#125; double ans = dp[N + 1] - T; if(ans &lt; (double)L / VR) printf(\"What a pity rabbit!\\n\"); else printf(\"Good job,rabbit!\\n\"); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"HDU 1081.To The Max","date":"2016-08-04T09:49:47.000Z","path":"/post/HDU/1081.html","text":"题目 Description Given a two-dimensional array of positive and negative integers, a sub-rectangle is any contiguous sub-array of size 1 x 1 or greater located within the whole array. The sum of a rectangle is the sum of all the elements in that rectangle. In this problem the sub-rectangle with the largest sum is referred to as the maximal sub-rectangle. As an example, the maximal sub-rectangle of the array: 0 -2 -7 09 2 -6 2-4 1 -4 1-1 8 0 -2 is in the lower left corner: 9 2-4 1-1 8 and has a sum of 15. Input The input consists of an N x N array of integers. The input begins with a single positive integer N on a line by itself, indicating the size of the square two-dimensional array. This is followed by N 2 integers separated by whitespace (spaces and newlines). These are the N 2 integers of the array, presented in row-major order. That is, all numbers in the first row, left to right, then all numbers in the second row, left to right, etc. N may be as large as 100. The numbers in the array will be in the range [-127,127]. Output Output the sum of the maximal sub-rectangle. Sample Input 40 -2 -7 0 9 2 -6 2-4 1 -4 1 -18 0 -2 Sample Output 15 题解题目让求最大的矩形区域的权值和 不看二维,单看一维,就是最大连续子序列dp[i] = max(dp[i-1]+a[i] , a[i]) 而拓展到二维,可以先将它压缩成一维用 O(n2) 的时间遍历取起始行和终止行,将其压缩成一行用 O(n) 的时间复杂付求取最大连续子序列最终总的时间复杂度是 O(n3) 代码To The Max代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int INF = 0x7FFFFFFF;const int maxn = 105;const int delta[] = &#123;1,-1,0,0&#125;;int Map[maxn][maxn];int dp[maxn];int sum[maxn][maxn];int n;int DP(int s,int v) &#123; int Max = -INF; for(int i = 1;i &lt;= n;i++) &#123; int t = sum[v][i] - sum[s][i]; dp[i] = max(dp[i - 1] + t,t); Max = max(Max,dp[i]); &#125; return Max;&#125;bool Do() &#123; if(scanf(\"%d\",&amp;n) == EOF) return false; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= n;j++) &#123; scanf(\"%d\",&amp;Map[i][j]); sum[i][j] = sum[i - 1][j] + Map[i][j]; &#125; int Max = -INF; for(int i = 1;i &lt;= n;i++) for(int j = 0;j &lt; i;j++) &#123; Max = max(Max,DP(j,i)); &#125; printf(\"%d\\n\",Max); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"HDU 1078.FatMouse and Cheese","date":"2016-08-04T09:49:39.000Z","path":"/post/HDU/1078.html","text":"题目 Description FatMouse has stored some cheese in a city. The city can be considered as a square grid of dimension n: each grid location is labelled (p,q) where 0 &lt;= p &lt; n and 0 &lt;= q &lt; n. At each grid location Fatmouse has hid between 0 and 100 blocks of cheese in a hole. Now he’s going to enjoy his favorite food. FatMouse begins by standing at location (0,0). He eats up the cheese where he stands and then runs either horizontally or vertically to another location. The problem is that there is a super Cat named Top Killer sitting near his hole, so each time he can run at most k locations to get into the hole before being caught by Top Killer. What is worse – after eating up the cheese at one location, FatMouse gets fatter. So in order to gain enough energy for his next run, he has to run to a location which have more blocks of cheese than those that were at the current hole. Given n, k, and the number of blocks of cheese at each grid location, compute the maximum amount of cheese FatMouse can eat before being unable to move. Input There are several test cases. Each test case consists of a line containing two integers between 1 and 100: n and kn lines, each with n numbers: the first line contains the number of blocks of cheese at locations (0,0) (0,1) … (0,n-1); the next line contains the number of blocks of cheese at locations (1,0), (1,1), … (1,n-1), and so on.The input ends with a pair of -1’s. Output For each test case output in a line the single integer giving the number of blocks of cheese collected. Sample Input 3 11 2 510 11 612 12 7-1 -1 Sample Output 37 题解每次最多移动 k 格,并且保证移动后的位置的权值一定大于原位置求出能获得的最大和 移动方向一定是上、下、左、右四个方向,如果移动5格,不会有先 3 格再 2 格的情况 用 dp[i][j] 表示格子 (i,j) 能达到的最大的值有明确的递推关系,每个格子的值应该是能到达他的所有格子的最大的那个加上该格子本身的值没有明确的递推顺序,由于每一次移动可以向任意方向,因此没有一个确定的递推顺序 因此应该使用记忆化搜索 剩下就是直接模板即可 代码FatMouse and Cheese代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 105;const int delta[] = &#123;1,-1,0,0&#125;;int Map[maxn][maxn];int dp[maxn][maxn];int n,k;int DFS(int x,int y) &#123; if(dp[x][y] == 0) &#123; for(int t = 1;t &lt;= k;t++) //移动距离t //for(int i = 0;i &lt;= k;i++) //x轴移动距离i for(int o = 0;o &lt; 4;o++) &#123; //移动方向 int xx = x + delta[o] * t;//移动后的坐标 int yy = y + delta[3 - o] * t; if(xx &gt;= 0 &amp;&amp; xx &lt; n&amp;&amp;yy &gt;= 0 &amp;&amp; yy &lt; n) if(Map[x][y] &lt; Map[xx][yy]) dp[x][y] = max(DFS(xx,yy),dp[x][y]); &#125; dp[x][y] += Map[x][y]; &#125; return dp[x][y];&#125;bool Do() &#123; scanf(\"%d%d\",&amp;n,&amp;k); if(n == -1 &amp;&amp; k == -1) return false; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; n;j++) &#123; scanf(\"%d\",&amp;Map[i][j]); dp[i][j] = 0; &#125; printf(\"%d\\n\",DFS(0,0)); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"DFS","slug":"DFS","permalink":"https://www.oyohyee.com/tags/DFS/"},{"name":"记忆化搜索","slug":"Memory-Search","permalink":"https://www.oyohyee.com/tags/Memory-Search/"}]},{"title":"HDU 1422.重温世界杯","date":"2016-08-04T09:49:17.000Z","path":"/post/HDU/1422.html","text":"题目 Description 世界杯结束了,意大利人连本带利的收回了法国人6年前欠他们的债,捧起了大力神杯,成就了4星意大利.世界杯虽然结束了,但是这界世界杯给我们还是留下许多值得回忆的东西.比如我们听到了黄名嘴的3分钟激情解说,我们懂得了原来可以向同一个人出示3张黄牌，我们还看到了齐达内的头不仅能顶球还能顶人…………介于有这么多的精彩,xhd决定重温德国世界杯,当然只是去各个承办世界杯比赛的城市走走看看.但是这需要一大比钱,幸运的是xhd对世界杯的热爱之情打动了德国世界杯组委会,他们将提供xhd在中国杭州和德国任意世界杯承办城市的往返机票,并说服了这些城市在xhd到达这座城市时为他提供一笔生活费以便他在那里参观时用,当参观完时剩余的钱也将留给xhd,但当生活费不够时他们将强行结束xhd的这次德国之行,除了这个,他们还有一个条件,xhd只能根据他们所给的路线参观.比如有3座城市a,b,c,他们给定了a-b-c-a的路线,那么xhd只有3种参观顺序abc,bca,cab.由于各个城市所提供的生活费和在那里的花费都不同,这使xhd很头痛,还好我们事先知道了这笔生活费和花费.请问xhd最多能顺利参观几座城市 Input 每组输入数据分两行,第一行是一个正整数n(1&lt;=n&lt;=100000),表示有n座城市.接下来的一行按照给定的路线顺序的输出这n个城市的生活费和花费,w1,l1,w2,l2,……,wn,ln,其中wi,li分别表示第i个城市的生活费和花费,并且它们都是正整数. Output 对应每组数据输出最多能参观的城市数. Sample Input 33 2 3 4 2 233 2 3 4 2 3 Sample Output 32 题解题目有一点需要注意的是必须按照他的旅行顺序,一旦钱不够就结束旅行,可以循环旅行 根据一旦钱不够就结束旅行可以联想到连续子序列问题由于只是简单的钱数的判断,因此可以通过模拟实现重要的是处理循环问题 最早想的是通过取余来保证在范围内,然后循环一次后来发现这样做会存在比较麻烦的问题,或许可以解决,但是代码量较大 因此换成开成两倍的数组,如果结果大于 n , 将其重置为 n 即可 代码重温世界杯代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int INF = 0x7FFFFFFF;const int maxn = 100005;int delta[2*maxn];int Money[2*maxn];int dp[2*maxn];int n;inline int standard(int i) &#123; if(i &lt; 0) return i + n; else if(i &gt;= n) return i - n; else return i;&#125;bool Do() &#123; if(scanf(\"%d\",&amp;n) == EOF) return false; bool flag = true; int Maxpos = 0;//能结余最多钱的城市，从它开始 for(int i = 1;i &lt;= n;i++) &#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); delta[i] = delta[n+i] = a - b; if(delta[i] &lt; 0) flag = false; if(delta[Maxpos] &lt; delta[i]) Maxpos = i; &#125; if(flag) &#123; printf(\"%d\\n\",n); return true; &#125; if(delta[Maxpos] &lt; 0) &#123; printf(\"%d\\n\",0); return true; &#125; int Max = 0; for(int i = 1;i &lt;= 2*n;i++) &#123; if(Money[i-1] + delta[i] &lt; 0) &#123; Money[i] = 0; dp[i] = 0; &#125; else &#123; Money[i] = Money[i-1] + delta[i]; dp[i] = dp[i-1] + 1; Max = max(Max,dp[i]); &#125; &#125; Max = min(Max,n); printf(\"%d\\n\",Max); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"2016-08-01 ~ 2016-08-03 学习报告","date":"2016-08-04T02:30:10.000Z","path":"/post/Study/2016_08_01-2016_08_03.html","text":"题目： AOJ 225.Human Gene FunctionsPOJ 1080.Human Gene FunctionsHDU 1080.Human Gene Functions HDU 1978.How many ways HDU 1059.Dividing HDU 1300.Pearls HDU 2191.悼念512汶川大地震遇难同胞——珍惜现在，感恩生活 HDU 1114.Piggy-Bank HDU 1024.Max Sum Plus Plus HDU 1106.FatMouse’s Speed AOJ 309.The Tower of Babylon AOJ 315.Humble Numbers AOJ 224.Treats for the CowsPOJ 3186.Treats for the Cows AOJ 261.货币兑换","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"AOJ 261.货币兑换","date":"2016-08-03T08:22:02.000Z","path":"/post/AOJ/261.html","text":"题目 Description 招商银行遇到一位很奇怪的顾客。这位顾客起初用一些人民兑换了另一种货币，然后不断地用一种货币兑换另一种货币，最后又换回人民币。令人惊奇的是，最后换回的人民币居然比他最初带来的多了一些。例如这样一个兑换过程：假设1单位人民币兑换6.89单位火星币，1单位火星币兑换0.18单位水星币，1单位水星币兑换0.81单位人民币。我们用1.20单位人民兑换得8.27单位火星币，然后用这8.27单位火星币兑换得1.49单位水星币，最后用1.49单位水星币兑换到1.21单位人民币。奇迹就这样发生了。聪明的你一定已经发现了，这都是四舍五入的功劳。当然这种事情在现实中是不可能的，但我们还是来研究一下这个问题。假设共有n种货币，编号从1到n。我们最初持有m单位的货币1。已知各种货币之间兑换比率，每次兑换后都四舍五入到小数点后两位。请问兑换k次且换回到货币1后，最多能让我们持有的货币增加多少单位？ Input 输入包含多组数据。 每组数据第一行包含两个整数：n (1≤n≤100), k (0≤k≤100)，第二行为一个实数m (0ij单位的货币j，注意，不一定能反向兑换。若aij=0，则表示不能直接用货币i兑换货币j。显然不能用货币i换货币i，这样没有意义。 输入以n=k=0结束。 Output 对每组数据输出我们持有的货币1最多能增值多少，精确到小数点后两位。如果不可能增值，则输出”0.00” Sample Input 3 31.200.00 6.89 0.000.00 0.00 0.180.81 0.00 0.001 01.000.000 0 Sample Output 0.010.00 题解与其说是动态规划,不如说这道题是 贪心+模拟用计算器跟着样例走一遍就能明白题意 dp[i][j] 表示兑换 j 次且此时为货币 i 的最大钱数因此初始时为 dp[1][0]最后结果为 dp[1][k] 每次状态转移为 dp[i][j] = max{ dp[t][j] } (1&lt;=t&lt;=n)根据转移方程应该先遍历 j 再遍历 i 时间复杂度为 O(n3) 最后要注意如果不能赚钱要输出 0.00 代码货币兑换代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 105;const int maxk = 105;double hl[maxn][maxn];double dp[maxn][maxk];inline double standard(double a) &#123; return (double)((int)(a * 100 + 0.5)) / 100;&#125;bool Do() &#123; int n,k; scanf(\"%d%d\",&amp;n,&amp;k); if(n == 0 &amp;&amp; k == 0) return false; scanf(\"%lf\",&amp;dp[1][0]); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= n;j++) scanf(\"%lf\",&amp;hl[i][j]); for(int j = 1;j &lt;= k;j++) for(int i = 1;i &lt;= n;i++) &#123; dp[i][j] = 0; for(int t = 1;t &lt;= n;t++) &#123; dp[i][j] = max(standard(dp[t][j - 1] * hl[t][i]),dp[i][j]); &#125; &#125; if(dp[1][k] - dp[1][0] &lt; 0.0) printf(\"0.00\\n\"); else printf(\"%.2f\\n\",dp[1][k] - dp[1][0]); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"POJ 3186.Treats for the Cows","date":"2016-08-03T07:48:41.000Z","path":"/post/POJ/3186.html","text":"原题,具体看&gt;AOJ 224.Treats for the Cows&lt;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"AOJ 224.Treats for the Cows","date":"2016-08-03T07:37:24.000Z","path":"/post/AOJ/224.html","text":"题目 Description FJ has purchased N (1 &lt;= N &lt;= 2000) yummy treats for the cows who get money for giving vast amounts of milk. FJ sells one treat per day and wants to maximize the money he receives over a given period time. The treats are interesting for many reasons:The treats are numbered 1..N and stored sequentially in single file in a long box that is open at both ends. On any day, FJ can retrieve one treat from either end of his stash of treats.Like fine wines and delicious cheeses, the treats improve with age and command greater prices.The treats are not uniform: some are better and have higher intrinsic value. Treat i has value v(i) (1 &lt;= v(i) &lt;= 1000).Cows pay more for treats that have aged longer: a cow will pay v(i)*a for a treat of age a.Given the values v(i) of each of the treats lined up in order of the index i in their box, what is the greatest value FJ can receive for them if he orders their sale optimally The first treat is sold on day 1 and has age a=1. Each subsequent day increases the age by 1. Input Line 1: A single integer, N Lines 2..N+1: Line i+1 contains the value of treat v(i) Output Line 1: The maximum revenue FJ can achieve by selling the treats Sample Input 513152 Sample Output 43 HintExplanation of the sample: Five treats. On the first day FJ can sell either treat #1 (value 1) or treat #5 (value 2). FJ sells the treats (values 1, 3, 1, 5, 2) in the following order of indices: 1, 5, 2, 3, 4, making 1x1 + 2x2 + 3x3 + 4x1 + 5x5 = 43. 题解题目是要不断从两段取数,乘上取得次序,最后所有数加起来和最大按照样例,就是 前( 1 ) 后( 2 ) 前( 3 ) 前( 1 ) 后( 5 )最后最大为 43 看上去似乎没思路,不过可以先看下关系每一次从前或后取,压根不连续很难找到状态转移方程为了连续可以倒着想这道题从后往前找,也即向外拓展 dp[i][j] 表示 i 到 j 的最大值它来自于 dp[i+1][j] 和 dp[i][j-1] 向外拓展有 dp[i][j] = max{ dp[i + 1][j] + a[i] * (n - j + i) , dp[i][j - 1] + a[j] * (n - j + i) } 根据动态规划到达一个状态其之前的状态必须已经到达, i 应该逆序便利, j 正序遍历 代码Treats for the Cows代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 2005;int a[maxn];int dp[maxn][maxn];bool Do() &#123; int n; if(scanf(\"%d\",&amp;n) == EOF) return false; for(int i = 1;i &lt;= n;i++) scanf(\"%d\",&amp;a[i]); for(int i = n;i &gt;= 1;i--) for(int j = i;j &lt;= n;j++) &#123; if(i == j) &#123; dp[i][i] = a[i] * n; &#125; else &#123; dp[i][j] = max( dp[i + 1][j] + a[i] * (n - j + i), dp[i][j - 1] + a[j] * (n - j + i) ); &#125; &#125; printf(\"%d\\n\",dp[1][n]); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"AOJ 315.Humble Numbers","date":"2016-08-03T03:46:59.000Z","path":"/post/AOJ/315.html","text":"原题,具体看&gt;HDU 1058.Humble Numbers&lt;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"丑数","slug":"Ugly-number","permalink":"https://www.oyohyee.com/tags/Ugly-number/"}]},{"title":"AOJ 309.The Tower of Babylon","date":"2016-08-03T03:42:31.000Z","path":"/post/AOJ/309.html","text":"题目 Description A number whose only prime factors are 2,3,5 or 7 is called a humble number. The sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 24, 25, 27, … shows the first 20 humble numbers.Write a program to find and print the nth element in this sequence. Input The input consists of one or more test cases. Each test case consists of one integer n with 1 &lt;= n &lt;= 5842. Input is terminated by a value of zero (0) for n. Output For each test case, print one line saying “The nth humble number is number.”. Depending on the value of n, the correct suffix “st”, “nd”, “rd”, or “th” for the ordinal number nth has to be used like it is shown in the ## Sample Output. Sample Input 123411121321222310010005842 Sample OutputThe 1st humble number is 1.The 2nd humble number is 2.The 3rd humble number is 3.The 4th humble number is 4.The 11th humble number is 12.The 12th humble number is 14.The 13th humble number is 15.The 21st humble number is 28.The 22nd humble number is 30.The 23rd humble number is 32.The 100th humble number is 450.The 1000th humble number is 385875.The 5842nd humble number is 2000000000. 题解原题,具体看&gt;HDU 1069.Monkey and Banana&lt; 代码The Tower of Babylon代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 35;int kase = 0;struct Node &#123; int x,y,h; Node(int x = 0,int y = 0,int h = 0) &#123; this-&gt;x = min(x,y); this-&gt;y = max(x,y); this-&gt;h = h; &#125; bool operator &lt; (const Node &amp;rhs)const &#123; if(x == rhs.x) return y &lt; rhs.y; else return x &lt; rhs.x; &#125; static bool cmp(Node &amp;a,Node &amp;b) &#123; return (a.x &lt; b.x &amp;&amp; a.y &lt; b.y); &#125;&#125;;Node S[3 * maxn];int dp[3 * maxn];bool Do() &#123; int n; scanf(\"%d\",&amp;n); if(n == 0) return false; printf(\"Case %d: maximum height = \",++kase); for(int i = 0;i &lt; n;i++) &#123; int x,y,z; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); S[i * 3 + 1] = Node(x,y,z); S[i * 3 + 2] = Node(y,z,x); S[i * 3 + 3] = Node(z,x,y); &#125; sort(S,S + 3 * n + 1); int Max = 0; for(int i = 1;i &lt;= 3 * n;i++) &#123; dp[i] = 0; for(int j = 0;j &lt; i;j++) &#123; if(Node::cmp(S[j],S[i])) &#123; dp[i] = max(dp[i],dp[j] + S[i].h); &#125; &#125; Max = max(Max,dp[i]); &#125; printf(\"%d\\n\",Max); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"最长上升子序列","slug":"LIS","permalink":"https://www.oyohyee.com/tags/LIS/"}]},{"title":"HDU 1106.FatMouse's Speed","date":"2016-08-03T03:25:15.000Z","path":"/post/HDU/1106.html","text":"题目 Description FatMouse believes that the fatter a mouse is, the faster it runs. To disprove this, you want to take the data on a collection of mice and put as large a subset of this data as possible into a sequence so that the weights are increasing, but the speeds are decreasing. Input Input contains data for a bunch of mice, one mouse per line, terminated by end of file. The data for a particular mouse will consist of a pair of integers: the first representing its size in grams and the second representing its speed in centimeters per second. Both integers are between 1 and 10000. The data in each test case will contain information for at most 1000 mice. Two mice may have the same weight, the same speed, or even the same weight and speed. Output Your program should output a sequence of lines of data; the first line should contain a number n; the remaining n lines should each contain a single positive integer (each one representing a mouse). If these n integers are m[1], m[2],…, m[n] then it must be the case that W[m[1]] &lt; W[m[2]] &lt; … &lt; W[m[n]] and S[m[1]] &gt; S[m[2]] &gt; … &gt; S[m[n]] In order for the answer to be correct, n should be as large as possible.All inequalities are strict: weights must be strictly increasing, and speeds must be strictly decreasing. There may be many correct outputs for a given input, your program only needs to find one. Sample Input 6008 13006000 2100500 20001000 40001100 30006000 20008000 14006000 12002000 1900 Sample Output 44597 题解&gt;最长上升子序列&lt;需要记录每一个老鼠的原始序号 然后按照重量排下序,套用最长上升子序列即可最后要输出任意一组序列用一个 last 数组记录每个位置的上一个字符的位置即可 读入坑了十几发……真的不能乱用 ++然而 VS 的逐步调试显示竟然没问题…… 代码FatMouse's Speed代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 1005;struct Node &#123; int n; int speed; int weight; bool operator &gt; (const Node&amp; rhs)const &#123; return (speed &gt; rhs.speed) &amp;&amp; (weight &lt; rhs.weight); &#125; bool operator &lt; (const Node&amp; rhs)const &#123; if(weight == rhs.weight) return speed &gt; rhs.speed; return weight &lt; rhs.weight; &#125;&#125;;Node mice[maxn];int dp[maxn];int last[maxn];stack&lt;int&gt; s;void Do() &#123; while(!s.empty()) s.pop(); memset(dp,0,sizeof(dp)); int n = 1; while(scanf(\"%d%d\",&amp;mice[n].weight,&amp;mice[n].speed) != EOF) &#123; mice[n].n = n; n++; &#125; n--; sort(mice + 1,mice + n + 1); int Maxpos = 1; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 0;j &lt; i;j++) if(mice[j] &gt; mice[i] || j == 0) if(dp[j] + 1 &gt; dp[i]) &#123; dp[i] = dp[j] + 1; last[i] = j; &#125; if(dp[Maxpos] &lt; dp[i]) Maxpos = i; &#125; printf(\"%d\\n\",dp[Maxpos]); int k = Maxpos; while(k) &#123; s.push(k); k = last[k]; &#125; while(!s.empty()) &#123; int t = s.top(); printf(\"%d\\n\",mice[t].n); s.pop(); &#125;&#125;int main() &#123; Do(); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最长上升子序列","slug":"LIS","permalink":"https://www.oyohyee.com/tags/LIS/"},{"name":"栈(stack)","slug":"Stack","permalink":"https://www.oyohyee.com/tags/Stack/"}]},{"title":"HDU 1024.Max Sum Plus Plus","date":"2016-08-02T01:46:53.000Z","path":"/post/HDU/1024.html","text":"题目 Description Now I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem. Given a consecutive number sequence S 1, S 2, S 3, S 4 … S x, … S n (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ S x ≤ 32767). We define a function sum(i, j) = S i + … + S j (1 ≤ i ≤ j ≤ n). Now given an integer m (m &gt; 0), your task is to find m pairs of i and j which make sum(i 1, j 1) + sum(i 2, j 2) + sum(i 3, j 3) + … + sum(i m, j m) maximal (i x ≤ i y ≤ j x or i x ≤ j y ≤ j x is not allowed). But I`m lazy, I don’t want to write a special-judge module, so you don’t have to ## Output m pairs of i and j, just output the maximal summation of sum(i x, j x)(1 ≤ x ≤ m) instead. ^_^ Input Each test case will begin with two integers m and n, followed by n integers S 1, S 2, S 3 … S n.Process to the end of file.OutputOutput the maximal summation described above in one line. Sample Input 1 3 1 2 32 6 -1 4 -2 3 -2 3 Sample Output 68 题解由于每个状态有两个数要考虑,因此考虑使用二元的动态规划dp[i][j] 表示到以第 i 个数字结尾,分成 j 组的最大和 当循环到数字 i 时,有以下几种情况: 将数字加入到已选取的组中dp[i][j] = dp[i - 1][j] + a[i] 将数字放到新的一组(上一组可能在之前的任意位置)dp[i][j] = max{dp[k][j - 1] + a[i]} 数据最大可能需要开 1000000 的数组,二维的 dp 开出来妥妥爆炸(按照题目,最坏情况下甚至需要 long long ) 先压缩内存首先可以看出来记录组数的这一维其实只用到了当前操作的和上一次操作的数据因此只需要 2*1000000 就足够存储数据了 然后是时间优化直接模拟上面的代码,显然时间复杂度是 O(n&lt;sup&gt;3&lt;/sup&gt;)可以看出我们需要的其实是上一次的数据到 i 的最大值(不包括 dp[i] )因此,在处理 dp[i] 时顺便维护最大值存储到数组里即可 具体操作如下( int 足以应付数据)核心部分LL Max;for(int j = 1;j &lt;= m;j++) &#123; Max = -INF; for(int i = j;i &lt;= n;i++) &#123; dp[i] = max(dp[i - 1] + a[i],dp1[i - 1] + a[i]); dp1[i - 1] = Max; Max = max(dp[i],Max); &#125;&#125; 代码Max Sum Plus Plus代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef int LL;const LL INF = 0x7FFFFFFF / 2;const int maxn = 1000005;const int maxm = 1000005;LL dp[maxm],dp1[maxm];int a[maxn];int v;bool Do() &#123; int n,m; if(scanf(\"%d%d\",&amp;m,&amp;n) == EOF) return false; dp[0] = dp1[0] = 0; for(int i = 1;i &lt;= n;i++) &#123; scanf(\"%d\",&amp;a[i]); dp[i] = 0; dp1[i] = 0; &#125; LL Max; for(int j = 1;j &lt;= m;j++) &#123; Max = -INF; for(int i = j;i &lt;= n;i++) &#123; dp[i] = max(dp[i - 1] + a[i],dp1[i - 1] + a[i]); dp1[i - 1] = Max; Max = max(dp[i],Max); &#125; &#125; printf(\"%d\\n\",Max); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"HDU 1114.Piggy-Bank","date":"2016-08-01T14:19:28.000Z","path":"/post/HDU/1114.html","text":"题目 Description Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid. But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs! Input The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 &lt;= E &lt;= F &lt;= 10000. On the second line of each test case, there is an integer number N (1 &lt;= N &lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 &lt;= P &lt;= 50000, 1 &lt;= W &lt;=10000). P is the value of the coin in monetary units, W is it’s weight in grams. Output Print exactly one line of output for each test case. The line must contain the sentence “The minimum amount of money in the piggy-bank is X.” where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line “This is impossible.”. Sample Input 310 11021 130 5010 11021 150 301 6210 320 4 Sample Output The minimum amount of money in the piggy-bank is 60.The minimum amount of money in the piggy-bank is 100.This is impossible. 题解&gt;背包问题-完全背包问题&lt;由于最后需要的是最小值,因此应该把模板里的 max 改成 min除了 dp[0] 外的所有初始值都应该是一个非常大的数 最后如果 dp[v] 是这个非常大的数,那么表示不能实现 代码Piggy-Bank代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int INF = 0x7FFFFFFF / 2;const int maxn = 10005;int dp[maxn];int v;void CompletePack(int cost,int weight) &#123; for(int i = cost; i &lt;= v; i++) dp[i] = min(dp[i],dp[i - cost] + weight);&#125;void Do() &#123; int a,b,n; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;n); v = b - a; for(int i = 1;i &lt;= v;i++) dp[i] = INF; dp[0] = 0; for(int i = 0;i &lt; n;i++) &#123; int c,w; scanf(\"%d%d\",&amp;w,&amp;c); CompletePack(c,w); &#125; if(dp[v] == INF) printf(\"This is impossible.\\n\"); else printf(\"The minimum amount of money in the piggy-bank is %d.\\n\",dp[v]); return;&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"}]},{"title":"HDU 2191.悼念512汶川大地震遇难同胞——珍惜现在，感恩生活","date":"2016-08-01T12:45:11.000Z","path":"/post/HDU/2191.html","text":"题目 Description 急！灾区的食物依然短缺！为了挽救灾区同胞的生命，心系灾区同胞的你准备自己采购一些粮食支援灾区，现在假设你一共有资金n元，而市场有m种大米，每种大米都是袋装产品，其价格不等，并且只能整袋购买。请问：你用有限的资金最多能采购多少公斤粮食呢？ 后记：人生是一个充满了变数的生命过程，天灾、人祸、病痛是我们生命历程中不可预知的威胁。月有阴晴圆缺，人有旦夕祸福，未来对于我们而言是一个未知数。那么，我们要做的就应该是珍惜现在，感恩生活——感谢父母，他们给予我们生命，抚养我们成人；感谢老师，他们授给我们知识，教我们做人感谢朋友，他们让我们感受到世界的温暖；感谢对手，他们令我们不断进取、努力。同样，我们也要感谢痛苦与艰辛带给我们的财富～ Input 输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。 Output 对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。 Sample Input 18 22 100 44 100 2 Sample Output 400 题解模板题 背包问题 - 多重背包问题 代码悼念512汶川大地震遇难同胞——珍惜现在，感恩生活代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 105;int dp[maxn];int v;void ZeroOnePack(int cost,int weight) &#123; for(int i = v; i &gt;= cost; i--) dp[i] = max(dp[i],dp[i - cost] + weight);&#125;void CompletePack(int cost,int weight) &#123; for(int i = cost; i &lt;= v; i++) dp[i] = max(dp[i],dp[i - cost] + weight);&#125;void MultiplePack(int cost,int weight,int n) &#123; if(cost * n &gt; v) &#123; CompletePack(cost,weight); &#125; else &#123; int k = 1; while(k &lt; n) &#123; ZeroOnePack(cost * k,weight * k); n -= k; k *= 2; &#125; ZeroOnePack(cost * n,weight * n); &#125;&#125;void Do() &#123; int n; scanf(\"%d%d\",&amp;v,&amp;n); memset(dp,0,sizeof(dp)); for(int i = 0;i &lt; n;i++) &#123; int c,w,num; scanf(\"%d%d%d\",&amp;c,&amp;w,&amp;num); MultiplePack(c,w,num); &#125; printf(\"%d\\n\",dp[v]); return;&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"}]},{"title":"HDU 1300.Pearls","date":"2016-08-01T12:17:36.000Z","path":"/post/HDU/1300.html","text":"原题,具体看&gt;POJ 1260.Pearls&lt;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"}]},{"title":"HDU 1059.Dividing","date":"2016-08-01T12:10:50.000Z","path":"/post/HDU/1059.html","text":"原题,具体看&gt;AOJ 182.Dividing&lt;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"}]},{"title":"HDU 1978.How many ways","date":"2016-08-01T11:47:11.000Z","path":"/post/HDU/1978.html","text":"题目 Description 这是一个简单的生存游戏，你控制一个机器人从一个棋盘的起始点(1,1)走到棋盘的终点(n,m)。游戏的规则描述如下：1.机器人一开始在棋盘的起始点并有起始点所标有的能量。2.机器人只能向右或者向下走，并且每走一步消耗一单位能量。3.机器人不能在原地停留。4.当机器人选择了一条可行路径后，当他走到这条路径的终点时，他将只有终点所标记的能量。 如上图，机器人一开始在(1,1)点，并拥有4单位能量，蓝色方块表示他所能到达的点，如果他在这次路径选择中选择的终点是(2,4) 点，当他到达(2,4)点时将拥有1单位的能量，并开始下一次路径选择，直到到达(6,6)点。我们的问题是机器人有多少种方式从起点走到终点。这可能是一个很大的数，输出的结果对10000取模。 Input 第一行输入一个整数T,表示数据的组数。对于每一组数据第一行输入两个整数n,m(1 &lt;= n,m &lt;= 100)。表示棋盘的大小。接下来输入n行,每行m个整数e(0 &lt;= e &lt; 20)。 Output 对于每一组数据输出方式总数对10000取模的结果. Sample Input 16 64 5 6 6 4 32 2 3 1 7 21 1 4 6 2 75 8 4 3 9 57 6 6 2 1 53 1 1 3 7 2 Sample Output 3948 题解觉得题目的叙述有歧义,一开始一直在纠结是不是 初始能量 - 移动步数 = 终点能量 题意就是到每个格子后,只能走格子上的数字的步数直接 DFS + 记忆化搜索 最后记得取模 代码How many ways代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 105;const int MOD = 10000;int Map[maxn][maxn];int dp[maxn][maxn];int n,m;int DP(int x,int y) &#123; if(x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= m) return 0; if(dp[x][y] == 0) &#123; int k = Map[x][y]; for(int i = x;i &lt;= x + k&amp;&amp;i &lt; n;i++) for(int j = y;j &lt;= y + k - (i-x) &amp;&amp; j &lt; m;j++) if(i != x || j != y) dp[x][y] = (dp[x][y] + DP(i,j))%MOD; &#125; return dp[x][y];&#125;void Do() &#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) scanf(\"%d\",&amp;Map[i][j]); memset(dp,0,sizeof(dp)); dp[n - 1][m - 1] = 1; printf(\"%d\\n\",DP(0,0)); return;&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"记忆化搜索","slug":"Memory-Search","permalink":"https://www.oyohyee.com/tags/Memory-Search/"}]},{"title":"HDU 1080.Human Gene Functions","date":"2016-08-01T08:08:36.000Z","path":"/post/HDU/1080.html","text":"原题,具体看&gt;AOJ 225.Human Gene Functions&lt;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"POJ 1080.Human Gene Functions","date":"2016-08-01T08:08:36.000Z","path":"/post/POJ/1080.html","text":"原题,具体看&gt;AOJ 225.Human Gene Functions&lt;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"AOJ 225.Human Gene Functions","date":"2016-08-01T08:02:37.000Z","path":"/post/AOJ/225.html","text":"题目 Description It is well known that a human gene can be considered as a sequence, consisting of four nucleotides, which are simply denoted by four letters, A, C, G, and T. Biologists have been interested in identifying human genes and determining their functions, because these can be used to diagnose human diseases and to design new drugs for them. A human gene can be identified through a series of time-consuming biological experiments, often with the help of computer programs. Once a sequence of a gene is obtained, the next job is to determine its function.One of the methods for biologists to use in determining the function of a new gene sequence that they have just identified is to search a database with the new gene as a query. The database to be searched stores many gene sequences and their functions – many researchers have been submitting their genes and functions to the database and the database is freely accessible through the Internet. A database search will return a list of gene sequences from the database that are similar to the query gene.Biologists assume that sequence similarity often implies functional similarity. So, the function of the new gene might be one of the functions that the genes from the list have. To exactly determine which one is the right one another series of biological experiments will be needed. Your job is to make a program that compares two genes and determines their similarity as explained below. Your program may be used as a part of the database search if you can provide an efficient one.Given two genes AGTGATG and GTTAG, how similar are they One of the methods to measure the similarityof two genes is called alignment. In an alignment, spaces are inserted, if necessary, in appropriate positions ofthe genes to make them equally long and score the resulting genes according to a scoring matrix. For example, one space is inserted into AGTGATG to result in AGTGAT-G, and three spaces are inserted into GTTAG to result in –GT–TAG. A space is denoted by a minus sign (-). The two genes are now of equallength. These two strings are aligned: AGTGAT-G-GT–TAG In this alignment, there are four matches, namely, G in the second position, T in the third, T in the sixth, and G in the eighth. Each pair of aligned characters is assigned a score according to the following scoring matrix. denotes that a space-space match is not allowed. The score of the alignment above is (-3)+5+5+(-2)+(-3)+5+(-3)+5=9. Of course, many other alignments are possible. One is shown below (a different number of spaces are inserted into different positions): AGTGATG-GTTA-G This alignment gives a score of (-3)+5+5+(-2)+5+(-1) +5=14. So, this one is better than the previous one. As a matter of fact, this one is optimal since no other alignment can have a higher score. So, it is said that thesimilarity of the two genes is 14. Input The input consists of T test cases. The number of test cases ) (T is given in the first line of the input file. Each test case consists of two lines: each line contains an integer, the length of a gene, followed by a gene sequence. The length of each gene sequence is at least one and does not exceed 100. Output The output should print the similarity of each test case, one per line. Sample Input 27 AGTGATG5 GTTAG7 AGCTATT9 AGCTTTAAA Sample Output 1421 题解类似&gt;AOJ 173.编辑距离&lt; 总共三种情况 两个基因链都增加基因(能够完全匹配或者不匹配但是比空基因更接近)dp[i][j] = dp[i - 1][j - 1] + w[ita][itb]; 基因 A 上填补空位dp[i][j] = max(dp[i][j],dp[i - 1][j] + w[ita][4]); 基因 B 上填补空位dp[i][j] = max(dp[i][j],dp[i][j - 1] + w[4][itb]); 最后注意边界值的问题即可 代码Human Gene Functions代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef int LL;const int INF = 0x7FFFFFFF;const int maxn = 105;int lena,lenb;char a[maxn],b[maxn],lcs[maxn];int dp[maxn][maxn];int w[5][5] = &#123; &#123;5,-1,-2,-1,-3&#125;, &#123;-1,5,-3,-2,-4&#125;, &#123;-2,-3,5,-2,-2&#125;, &#123;-1,-2,-2,5,-1&#125;, &#123;-3,-4,-2,-1,-INF&#125;&#125;;inline int m(char c) &#123; switch(c) &#123; case 'A': return 0; case 'C': return 1; case 'G': return 2; case 'T': return 3; default: return 4; &#125;&#125;void Do() &#123; scanf(\"%d%s%d%s\",&amp;lena,a,&amp;lenb,b); dp[0][0] = 0; for(int i = 1;i &lt;= lena;i++) dp[i][0] = dp[i - 1][0] + w[m(a[i - 1])][4]; for(int i = 1;i &lt;= lenb;i++) dp[0][i] = dp[0][i - 1] + w[4][m(b[i - 1])]; for(int i = 1;i &lt;= lena;i++) for(int j = 1;j &lt;= lenb;j++) &#123; int ita = m(a[i - 1]),itb = m(b[j - 1]); dp[i][j] = dp[i - 1][j - 1] + w[ita][itb]; dp[i][j] = max(dp[i][j],dp[i - 1][j] + w[ita][4]); dp[i][j] = max(dp[i][j],dp[i][j - 1] + w[4][itb]); &#125; printf(\"%d\\n\",dp[lena][lenb]);&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"2016-07-29 ~ 2016-07-31 学习报告","date":"2016-08-01T04:30:10.000Z","path":"/post/Study/2016_07_29-2016_07_31.html","text":"题目： AOJ 36.Alphacode AOJ 103.BUY LOW, BUY LOWER AOJ 173.编辑距离 AOJ 182.Dividing AOJ 189.最长递增子序列","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"2016-07-26 ~ 2016-07-28 学习报告","date":"2016-07-31T17:30:10.000Z","path":"/post/Study/2016_07_26-2016_07_28.html","text":"题目： AOJ 36.Alphacode AOJ 49.Investment AOJ 64.数字三角形问题 AOJ 153.Redraiment的走法 AOJ 169.找零钱","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"AOJ 182.Dividing","date":"2016-07-31T12:28:10.000Z","path":"/post/AOJ/182.html","text":"题目 Description Marsha and Bill own a collection of marbles. They want to split the collection among themselves so that both receive an equal share of the marbles. This would be easy if all the marbles had the same value, because then they could just split the collection in half. But unfortunately, some of the marbles are larger, or more beautiful than others. So, Marsha and Bill start by assigning a value, a natural number between one and six, to each marble. Now they want to divide the marbles so that each of them gets the same total value. Unfortunately, they realize that it might be impossible to divide the marbles in this way (even if the total value of all marbles is even). For example, if there are one marble of value 1, one of value 3 and two of value 4, then they cannot be split into sets of equal value. So, they ask you to write a program that checks whether there is a fair partition of the marbles. Input Each line in the input file describes one collection of marbles to be divided. The lines contain six non-negative integers n1 , . . . , n6 , where ni is the number of marbles of value i. So, the example from above would be described by the input-line “1 0 1 2 0 0”. The maximum total number of marbles will be 20000.The last line of the input file will be “0 0 0 0 0 0”; do not process this line. Output For each collection, output “Collection #k:”, where k is the number of the test case, and then either “Can be divided.” or “Can’t be divided.”.Output a blank line after each test case. Sample Input 1 0 1 2 0 01 0 0 0 1 10 0 0 0 0 0 Sample Output Collection #1:Can’t be divided. Collection #2:Can be divided. 题解&gt;背包问题-多重背包&lt; 模板题 如果总数一半容量的背包能正好填满就是能平分 代码Dividing代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;int kase = 1;const int maxn = 7;const int maxv = 500000;int a[maxn];int dp[maxv];int v;void ZeroOnePack(int cost,int weight) &#123; for(int i = v; i &gt;= cost; i--) dp[i] = max(dp[i],dp[i - cost] + weight);&#125;void CompletePack(int cost,int weight) &#123; for(int i = cost; i &lt;= v; i++) dp[i] = max(dp[i],dp[i - cost] + weight);&#125;void MultiplePack(int cost,int weight,int n) &#123; if(cost * n &gt; v) &#123; CompletePack(cost,weight); &#125; else &#123; int k = 1; while(k &lt; n) &#123; ZeroOnePack(cost * k,weight * k); n -= k; k *= 2; &#125; ZeroOnePack(cost * n,weight * n); &#125;&#125;bool Do() &#123; int sum = 0; for(int i = 1;i &lt;= 6;i++) &#123; scanf(\"%d\",&amp;a[i]); sum += a[i] * i; &#125; if(sum == 0) return false; printf(\"Collection #%d:\\n\",kase++); if(sum % 2) &#123; printf(\"Can't be divided.\\n\\n\"); return true; &#125; v = sum / 2; memset(dp,0,sizeof(dp)); for(int i = 1;i &lt;= 6;i++) MultiplePack(i,i,a[i]); if(dp[v] == v) printf(\"Can be divided.\\n\\n\"); else printf(\"Can't be divided.\\n\\n\"); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"}]},{"title":"AOJ 189.最长递增子序列","date":"2016-07-31T11:57:32.000Z","path":"/post/AOJ/189.html","text":"题目 Description 有n个互不相同的整数an若存在一个数列bm其中对于任何1 &lt; i &lt; m满足bi &lt; bi+1 且 abi &lt; abi+1则称abn为an的一个递增子序列试求出给定序列的最长递增子序列长度 Input 本题由多组数据组成，以EOF结束第2N+1行 整数n，代表数组长度，1 &lt;= n &lt;= 7000第2N+2行 n个整数ai，0 &lt;= ai &lt;=231-1 Output 对于每组数据输出一行结果，代表最长递增序列长度 Sample Input 31 2 3103 18 7 14 10 12 23 41 16 24 Sample Output 36 题解模板题&gt;最长上升子序列&lt; 代码最长递增子序列代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.com かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std; typedef unsigned int LL; const int maxn = 7005; LL a[maxn];LL dp[maxn]; inline LL max(LL a,LL b) &#123; return a &gt; b ? a : b;&#125; bool Do() &#123; LL n; if(scanf(\"%u\",&amp;n) == EOF) return false; for(LL i = 1;i &lt;= n;i++) &#123; scanf(\"%u\",&amp;a[i]); dp[i] = 0; &#125; LL Max = 0; for(LL i = 1;i &lt;= n;i++) &#123; for(LL j = 0;j &lt; i;j++) if(a[i] &gt; a[j] || j == 0) dp[i] = max(dp[i],dp[j] + 1); Max = max(Max,dp[i]); &#125; printf(\"%u\\n\",Max); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"最长上升子序列","slug":"LIS","permalink":"https://www.oyohyee.com/tags/LIS/"}]},{"title":"AOJ 173.编辑距离","date":"2016-07-31T11:30:38.000Z","path":"/post/AOJ/173.html","text":"题目 Description 假设字符串的基本操作仅为：删除一个字符、插入一个字符和将一个字符修改成另一个字符这三种操作。我们把进行了一次上述三种操作的任意一种操作称为进行了一步字符基本操作。下面我们定义两个字符串的编辑距离：对于两个字符串a和b，通过上述的基本操作，我们可以把a变成b或b变成a，那么字符串a变成字符串b需要的最少基本字符操作步数称为字符串a和字符串b的编辑距离。例如：a=”ABC”,b=”CBCD”,则a与b的编辑距离为2。你的任务就是：编一个快速的程序来计算任意两个字符串的编辑距离。 Input 输入包含多组测试数据。每组测试数据一行，为字符串A和字符串B。字符串的长度不大于1024，且全为字母。 Output 编辑距离。 Sample Input ABC CBCD Sample Output 2 题解数据包括两个字符串,类似于最长公共子序列的形式可以类似的使用一个二维的 dp[i][j] 来表示字符串 a 的前 i 个字符和字符串 b 的前 j 个字符的最短编辑距离 当我们计算 dp[i][j] 时,显然我们已经有了 dp[i][j-1] 、 dp[i-1][j] 、 dp[i-1][j-1] 如果 a[i] == b[j] (对应的字符相等),则加上这两个字符,对答案无影响也即 dp[i][j] = dp[i-1][j-1]同时,也可以是 a 或 b 少一个字符的情况下增加一个字符,即 dp[i][j] = min(dp[i][j-1],dp[i-1][j]) + 1 如果 a[i] != b[j] (对应的字符不同),则需要进行修改操作有3种修改方式: 修改字符:将其中一个字符变成另一个字符即 dp[i][j] = dp[i-1][j-1] + 1 增删字符(a):将字符串 a 的字符删掉可以理解为:字符串 a 少一个字符时,加上 b 对应的字符即 dp[i][j] = dp[i-1][j] + 1 增删字符(a):将字符串 b 的字符删掉可以理解为:字符串 b 少一个字符时,加上 a 对应的字符即 dp[i][j] = dp[i][j-1] + 1 同时如果两个字符的长度差为 delta 则编辑距离最少为 delta 注意好边界值即可 一开始迷之TLE,即使AC了也无法理解 代码编辑距离代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef unsigned int LL;const int maxn = 1050;char a[maxn],b[maxn];LL dp[maxn][maxn];bool Do() &#123; if(scanf(\"%s%s\",a,b) == EOF) return false; LL lena = strlen(a); LL lenb = strlen(b); for(unsigned int i = 1;i &lt;= lena;i++) for(unsigned int j = 1;j &lt;= lenb;j++) &#123; int ita = i - 1; int itb = j - 1; LL delta = (i &gt; j) ? (i - j) : (j - i); LL Min = min(dp[i][j - 1],dp[i - 1][j]) + 1; if(a[ita] == b[itb]) &#123; dp[i][j] = min(dp[i - 1][j - 1],Min); &#125; else &#123; dp[i][j] = min(dp[i - 1][j - 1] + 1,Min); &#125; dp[i][j] = max(dp[i][j],delta); &#125; printf(\"%u\\n\",dp[lena][lenb]); return true;&#125;int main() &#123; dp[0][0] = 0; for(int i = 1;i &lt; maxn;i++) dp[0][i]=dp[i][0] = i; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"AOJ 103.BUY LOW, BUY LOWER","date":"2016-07-31T08:16:18.000Z","path":"/post/AOJ/103.html","text":"题目 Description The advice to “buy low” is half the formula to success in the bovine stock market.To be considered a great investor you must also follow this problems’ advice: “Buy low; buy lower” Each time you buy a stock, you must purchase it at a lower price than the previous time you bought it. The more times you buy at a lower price than before, the better! Your goal is to see how many times you can continue purchasing at ever lower prices. You will be given the daily selling prices of a stock (positive 16-bit integers) over a period of time. You can choose to buy stock on any of the days. Each time you choose to buy, the price must be strictly lower than the previous time you bought stock. Write a program which identifies which days you should buy stock in order to maximize the number of times you buy. Here is a list of stock prices: Day 1 2 3 4 5 6 7 8 9 10 11 12Price 68 69 54 64 68 64 70 67 78 62 98 87 The best investor (by this problem, anyway) can buy at most four times if each purchase is lower then the previous purchase. One four day sequence (there might be others) of acceptable buys is: Day 2 5 6 10Price 69 68 64 62 Input Line 1: N (1 &lt;= N &lt;= 5000), the number of days for which stock prices are given Lines 2..etc: A series of N space-separated integers, ten per line except the final line which might have fewer integers. Output Two integers on a single line: The length of the longest sequence of decreasing prices The number of sequences that have this length (guaranteed to fit in 31 bits) In counting the number of solutions, two potential solutions are considered the same (and would only count as one solution) if they repeat the same string of decreasing prices, that is, if they “look the same” when the successive prices are compared. Thus, two different sequence of “buy” days could produce the same string of decreasing prices and be counted as only a single solution. Sample Input 1268 69 54 64 68 64 70 67 78 6298 87 Sample Output 4 2 题解对于每组数据需要输出两个数据,第一个非常明显是最长下降子序列参照&gt;最长上升子序列&lt; 重点在于第二问:满足最长上升子序列的序列个数(非重复)按照最长上升子序列的思路,有 dp[i] == dp[j] + 1 &amp;&amp; a[i] &lt; a[j]对于满足上面式子的显然是最长上升子序列的一部分 用 cnt[i] 记录,到第 i 个数的最长上升子序列的个数(重复)最后将所有 dp[i] 为最长上升子序列的 cnt[i] 加起来就是个数(重复) 而题目要求是非重复,需要考虑判重对于 a[i] == a[j] 的情况,可以忽略比当前 j 小的 j 的情况也即,从大到小循环,发现 a[i] == a[j] ,直接跳出 解释不清,逐步调试看代码吧 代码BUY LOW, BUY LOWER代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 5005;int a[maxn];int dp[maxn];int cnt[maxn];bool Do() &#123; int n; if(scanf(\"%d\",&amp;n) == EOF) return false; for(int i = 1;i &lt;= n;i++) &#123; scanf(\"%d\",&amp;a[i]); &#125; memset(dp,0,sizeof(dp)); memset(cnt,0,sizeof(cnt)); cnt[0] = 1; int Max = 0; for(int i = 1;i &lt;= n;i++) &#123; for(int j = i - 1;j &gt;= 0;j--) if(a[j] &gt; a[i] || j == 0) dp[i] = max(dp[i],dp[j] + 1); Max = max(dp[i],Max); &#125; for(int i = 1;i &lt;= n;i++) &#123; for(int j = i - 1;j &gt;= 0;j--) &#123; if(a[i] == a[j]) break; if(dp[i] == dp[j] + 1 &amp;&amp; (a[i] &lt;= a[j] || j == 0)) &#123; cnt[i] += cnt[j]; &#125; &#125; &#125; int num = 0; for(int i = 1;i &lt;= n;i++) &#123; if(Max == dp[i]) num += cnt[i]; &#125; printf(\"%d %d\\n\",Max,num); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"最长上升子序列","slug":"LIS","permalink":"https://www.oyohyee.com/tags/LIS/"}]},{"title":"AOJ 36.Alphacode","date":"2016-07-29T15:56:25.000Z","path":"/post/AOJ/36.html","text":"题目 Description Alice and Bob need to send secret messages to each other and are discussing ways to encode their messages: Alice: “Let’s just use a very simple code: We’ll assign ‘A’ the code word 1, ‘B’ will be 2, and so on down to ‘Z’ being assigned 26.”Bob: “That’s a stupid code, Alice. Suppose I send you the word ‘BEAN’ encoded as 25114. You could decode that in many different ways!”Alice: “Sure you could, but what words would you get Other than ‘BEAN’, you’d get ‘BEAAD’, ‘YAAD’, ‘YAN’, ‘YKD’ and ‘BEKD’. I think you would be able to figure out the correct decoding. And why would you send me the word ‘BEAN’ anyway ”Bob: “OK, maybe that’s a bad example, but I bet you that if you got a string of length 500 there would be tons of different decodings and with that many you would find at least two different ones that would make sense.”Alice: “How many different decodings “Bob: “Jillions!” For some reason, Alice is still unconvinced by Bob’s argument, so she requires a program that will determine how many decodings there can be for a given string using her code. Input Input will consist of multiple input sets. Each set will consist of a single line of digits representing a valid encryption (for example, no line will begin with a 0). There will be no spaces between the digits. An input line of ‘0’ will terminate the input and should not be processed Output For each input set, output the number of possible decodings for the input string. All answers will be within the range of a long variable. Sample Input 25114111111111133333333330 Sample Output 6891 题解显然,这种问题具有递推的性质用 dp[i] 表示到第 i 个字符的可能个数那么可以发现以下规律: 如果第 i 个数可以和第 i-1 个数连起来构成一个合法的数( 1~26 )那么,它有两种计算情况: 不和前面的数连起来,将他单独看作一个数,有 dp[i-1] 种可能 和前面的数连起来,共同构成一个数这与上一个数( i-1 )单独看作一个数的数量一样,即 dp[i-2] 所以 dp[i] = dp[i-1] + dp[i-2] 如果第 i 个数不能和第 i-1 个数连起来构成一个合法的数那么,显然只有一种情况,就是将第 i 个数,单独看成一个,也即 dp[i] = dp[i-1] 另外需要额外考虑 0 的情况,由于 0 必定要和前面的数字结合到一起因此可以先遍历一遍,处理 0 的情况 代码Alphacode代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.com かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std; const int maxn = 50005;char s[maxn];int dp[maxn];int ss[maxn]; bool Do() &#123; scanf(\"%s\",s); if(s[0] == '0') return false; int len = strlen(s); int pos = 1; for(int i = 0;i &lt; len;i++) &#123; ss[pos] = s[i] - '0'; if(ss[pos] == 0) &#123; ss[pos - 1] = ss[pos - 1] * 10 + ss[pos]; &#125; else &#123; pos++; &#125; &#125; memset(dp,0,sizeof(dp)); dp[0] = dp[1] = 1; for(int i = 2;i &lt; pos;i++) &#123; int num = ss[i - 1]; int k = ss[i]; while(k) &#123; num *= 10; k /= 10; &#125; num += (ss[i]); if(num &lt;= 26) dp[i] = dp[i - 1] + dp[i - 2]; else dp[i] = dp[i - 1]; &#125; printf(\"%d\\n\",dp[pos - 1]); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"AOJ 169.找零钱","date":"2016-07-28T11:50:18.000Z","path":"/post/AOJ/169.html","text":"题目 Description 我们知道人民币有1、2、5、10、20、50、100这几种面值。现在给你n(1≤n≤250)元，让你计算换成用上面这些面额表示且总数不超过100张，共有几种。比如4元，能用4张1元、2张1元和1张2元、2张2元，三种表示方法。 Input 输入有多组，每组一行，为一个整合n。输入以0结束。 Output 输出该面额有几种表示方法。 Sample Input 140 Sample Output 13 题解类似于&gt;AOJ 808.算法期末考试D(整数拆分)&lt;最初想用完全背包问题求解,不过由于还要保证使用的钱数不超过 100 ,可以用 DFS 来计算 由于只有 1~205 ,可以使用打表法来输出 代码找零钱代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int money[] = &#123;1,2,5,10,20,50,100&#125;;const int ans[] = &#123;0,1,2,2,3,4,5,6,7,8,11,12,15,16,19,22,25,28,31,34,41,44,51,54,61,68,75,82,89,96,109,116,129,136,149,162,175,188,201,214,236,249,271,284,306,328,350,372,394,416,451,473,508,530,565,600,635,670,705,740,793,828,881,916,969,1022,1075,1128,1181,1234,1311,1364,1441,1494,1571,1648,1725,1802,1879,1956,2064,2141,2249,2326,2434,2542,2650,2758,2866,2974,3121,3229,3376,3484,3631,3778,3925,4072,4219,4366,4563,4709,4905,5051,5247,5442,5637,5832,6027,6221,6476,6669,6924,7116,7369,7622,7875,8127,8378,8628,8954,9202,9526,9772,10094,10415,10735,11054,11371,11686,12093,12406,12810,13119,13520,13920,14318,14713,15106,15497,15998,16384,16880,17262,17754,18243,18729,19212,19692,20169,20776,21246,21847,22311,22905,23495,24081,24663,25240,25812,26539,27103,27821,28375,29083,29786,30483,31174,31859,32538,33398,34065,34913,35567,36401,37228,38048,38859,39662,40458,41465,42245,43234,43997,44970,45933,46885,47828,48762,49686,50851,51754,52899,53781,54903,56013,57111,58197,59271,60332,61671,62705,64018,65026,66309,67578,68833,70073,71296,72503,74029,75206,76699,77839,79297,80738,82159,83562,84944,86308,88035,89360,91045,92327,93970,95593,97191,98768,100318,101850,103791,105272,107162,108595,110434,112250,114034,115795,117525,119231,121396,123044,125152,126740,128786,130806,132787,134743,136660,138547,140953&#125;;int v;int num;void DFS(int a,int pos,int cnt) &#123; if(a &lt; 0 || cnt&gt;100) return; if(a == 0 ) &#123; num++; return; &#125; int tMoney = money[pos]; if(pos &lt; 0) return; for(int j = a / tMoney;j &gt;= 0;j--) &#123; DFS(a - j * tMoney,pos - 1,cnt + j); &#125;&#125;bool Do() &#123; scanf(\"%d\",&amp;v); if(v == 0) return false; /* num = 0; DFS(v,sizeof(money) / sizeof(int) - 1,0); printf(\"%d\\n\",num); */ printf(\"%d\\n\",ans[v]); return true;&#125;int main() &#123; /* for(int i = 1;i &lt;= 250;i++) &#123; num = 0; DFS(i,sizeof(money) / sizeof(int) - 1,0); printf(\"%d,\",num); &#125; */ while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"DFS","slug":"DFS","permalink":"https://www.oyohyee.com/tags/DFS/"},{"name":"打表","slug":"List","permalink":"https://www.oyohyee.com/tags/List/"}]},{"title":"AOJ 153.Redraiment的走法","date":"2016-07-28T11:47:33.000Z","path":"/post/AOJ/153.html","text":"题目 Description Redraiment是个聪明人，总是以奇怪的思考方法思考问题，但不知道为什么，他的解答总是最最巧妙，我们隆重地称他为诡异人！有一天Jesse不经意中发现，诡异人的走路方法很特别，于是特别关注了他的走路规则。他发现诡异人总是往高处走，但走的步数总是最多，不知道为什么？你能替Jesse研究研究他最多走的步数吗？发现了你也会是个聪明人!^_^ Input There has several test cases. Each case start with an integer n(0 &lt; n ≤10000), then follows n integers hi, each seperated by a space. 1 ≤ hi ≤ 100),which represents the height of the place. Output For each case output a line with the max number of the steps he can go . Sample Input 51 2 3 4 562 5 1 5 4 5 Sample Output 53 Hint6个点的高度各为 2 5 1 5 4 5如从第1格开始走,最多为3步, 2 4 5从第2格开始走,最多只有1步,5而从第3格开始走最多有3步,1 4 5从第5格开始走最多有2步,4 5 题解 模板题&gt;最长上升子序列&lt; 代码Redraiment的走法代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 10005;int dp[maxn];int a[maxn];bool Do() &#123; int n; if(scanf(\"%d\",&amp;n) == EOF) return false; for(int i = 1;i &lt;= n;i++) scanf(\"%d\",&amp;a[i]); memset(dp,0,sizeof(dp)); int Max = 0; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 0;j &lt; i;j++) if(a[j] &lt; a[i] || j == 0) dp[i] = max(dp[i],dp[j] + 1); Max = max(Max,dp[i]); &#125; printf(\"%d\\n\",Max); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"最长上升子序列","slug":"LIS","permalink":"https://www.oyohyee.com/tags/LIS/"}]},{"title":"AOJ 64.数字三角形问题","date":"2016-07-28T11:41:16.000Z","path":"/post/AOJ/64.html","text":"题目 Description 73 88 1 02 7 4 44 5 2 6 5(Figure 1) Figure 1 shows a number triangle. Write a program that calculates the highest sum of numbers passed on a route that starts at the top and ends somewhere on the base. Each step can go either diagonally down to the left or diagonally down to the right. Input Your program is to read from standard input. The first line contains one integer N: the number of rows in the triangle. The following N lines describe the data of the triangle. The number of rows in the triangle is &gt; 1 but &lt;= 100. The numbers in the triangle, all integers, are between 0 and 99. Output Your program is to write to standard output. The highest sum is written as an integer. Sample Input Original Transformed573 88 1 02 7 4 44 5 2 6 5 Sample Output Original Transformed30 题解原题&gt;AOJ 806.算法期末考试B(动态规划)&lt;&gt;HDU 2084.数塔&lt; 代码数字三角形问题代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/ かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std; //DEBUG MODE#define debug 0 //循环#define REP(n) for(int o=0;o&lt;n;o++) const int maxn = 1000; int Map[maxn][maxn]; bool Do() &#123; int n; if(scanf(\"%d\",&amp;n) == EOF) return false; memset(Map,0,sizeof(Map)); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= i;j++) scanf(\"%d\",&amp;Map[i][j]); for(int i = n - 1;i &gt; 0;i--) for(int j = 1;j &lt;= i;j++) Map[i][j] += max(Map[i + 1][j],Map[i + 1][j + 1]); printf(\"%d\\n\",Map[1][1]); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"AOJ 49.Investment","date":"2016-07-28T11:38:15.000Z","path":"/post/AOJ/49.html","text":"题目 Description John never knew he had a grand-uncle, until he received the notary’s letter. He learned that his late grand-uncle had gathered a lot of money, somewhere in South-America, and that John was the only inheritor.John did not need that much money for the moment. But he realized that it would be a good idea to store this capital in a safe place, and have it grow until he decided to retire. The bank convinced him that a certain kind of bond was interesting for him.This kind of bond has a fixed value, and gives a fixed amount of yearly interest, payed to the owner at the end of each year. The bond has no fixed term. Bonds are available in different sizes. The larger ones usually give a better interest. Soon John realized that the optimal set of bonds to buy was not trivial to figure out. Moreover, after a few years his capital would have grown, and the schedule had to be re-evaluated.Assume the following bonds are available: Value Annualinterest4000 4003000 250 With a capital of e10 000 one could buy two bonds of $4 000, giving a yearly interest of $800. Buying two bonds of $3 000, and one of $4 000 is a better idea, as it gives a yearly interest of $900. After two years the capital has grown to $11 800, and it makes sense to sell a $3 000 one and buy a $4 000 one, so the annual interest grows to $1 050. This is where this story grows unlikely: the bank does not charge for buying and selling bonds. Next year the total sum is $12 850, which allows for three times $4 000, giving a yearly interest of $1 200.Here is your problem: given an amount to begin with, a number of years, and a set of bonds with their values and interests, find out how big the amount may grow in the given period, using the best schedule for buying and selling bonds. Input The first line contains a single positive integer N which is the number of test cases. The test cases follow.The first line of a test case contains two positive integers: the amount to start with (at most $1 000 000), and the number of years the capital may grow (at most 40).The following line contains a single number: the number d (1 &lt;= d &lt;= 10) of available bonds.The next d lines each contain the description of a bond. The description of a bond consists of two positive integers: the value of the bond, and the yearly interest for that bond. The value of a bond is always a multiple of $1 000. The interest of a bond is never more than 10% of its value Output For each test case, output – on a separate line – the capital at the end of the period, after an optimal schedule of buying and selling. Sample Input 110000 424000 4003000 250 Sample Output 14050 题解背包问题-完全背包 读入数据后直接套用模板 由于: 必定是 1000 的整数倍,因此可以先除以 1000 来减轻内存压力 每年都要重新存一次,因此每一年的本金都不一样 代码Investment代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std; const int maxn = 500005; int dp[maxn];int value[maxn],per[maxn];int v; void CompletePack(int cost,int weight) &#123; for(int i = cost; i &lt;= v; i++) dp[i] = max(dp[i],dp[i - cost] + weight);&#125; bool Do() &#123; int n,m,p; if(scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;p) == EOF) return false; for(int i = 1;i &lt;= p;i++) scanf(\"%d%d\",&amp;value[i],&amp;per[i]); v = n / 1000; while(m--) &#123; memset(dp,0,sizeof(dp)); for(int i = 1;i &lt;= p;i++) CompletePack(value[i] / 1000,per[i]); n += dp[v]; v = n / 1000; &#125; printf(\"%d\\n\",n); return true;&#125; int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"}]},{"title":"2016-07-23 ~ 2016-07-25 学习报告","date":"2016-07-25T17:49:10.000Z","path":"/post/Study/2016_07_23-2016_07_25.html","text":"题目： HDU 2845.Beans AOJ 275.Charm Bracelet AOJ 524.桂园食堂 HDU 2870.Largest Submatrix HDU 2830.Matrix Swapping II HDU 1257.最少拦截系统 HDU 1159.Common Subsequence HDU 1421.搬寝室 HDU 1058.Humble Numbers HDU 1789.Doing Homework again","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"HDU 1789.Doing Homework again","date":"2016-07-25T04:15:06.000Z","path":"/post/HDU/1789.html","text":"题目 Description Ignatius has just come back school from the 30th ACM/ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test. And now we assume that doing everyone homework always takes one day. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score. Input The input contains several test cases. The first line of the input is a single integer T that is the number of test cases. T test cases follow.Each test case start with a positive integer N(1&lt;=N&lt;=1000) which indicate the number of homework.. Then 2 lines follow. The first line contains N integers that indicate the deadlines of the subjects, and the next line contains N integers that indicate the reduced scores. Output For each test case, you should output the smallest total reduced score, one line per test case. Sample Input 333 3 310 5 131 3 16 2 371 4 6 4 2 4 33 2 1 7 6 5 4 Sample Output 035 题解贪心算法 分高的作业一定要写 分数一样的优先写时间晚的 作业尽可能晚写符合这三个条件即可 算法Doing Homework again代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 1005;const int maxt = 900000;int Deadline[maxn],Score[maxn];struct Node &#123; int Deadline; int Score; bool operator &lt; (const Node &amp;rhs)const &#123; if(Score == rhs.Score) return Deadline &gt; rhs.Deadline; else return Score &gt; rhs.Score; &#125;&#125;;Node node[maxn];int Time[maxt];bool Do() &#123; int n; scanf(\"%d\",&amp;n); int sum = 0; int mt = 0; for(int i = 1;i &lt;= n;i++) &#123; scanf(\"%d\",&amp;node[i].Deadline); mt = max(mt,node[i].Deadline); &#125; for(int i = 1;i &lt;= n;i++) &#123; scanf(\"%d\",&amp;node[i].Score); sum += node[i].Score; &#125; sort(node + 1,node + 1 + n); for(int i = 0;i &lt;= mt + 1;i++) Time[i] = i; int ans = 0; for(int i = 1;i &lt;= n;i++) &#123; int k = node[i].Deadline; int t = Time[k]; while(!(t == k || t == 0 || k == 0)) &#123; k = Time[k]; t = Time[t]; &#125; if(t == k &amp;&amp; t != 0) &#123; Time[k]--; ans += node[i].Score; &#125; &#125; printf(\"%d\\n\",sum - ans); return true;&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"}]},{"title":"丑数","date":"2016-07-24T16:31:59.000Z","path":"/post/Algorithm/Ugly_number.html","text":"所谓丑数，就是不能被2，3，5，7以外的其他素数整除的数。1，2，3，4，5，6，7，8，9，10，12，14，15，16，18是最前面的15个丑数。 百度百科丑数 根据唯一素数分解定理,类似于筛法求素数的方法,即可求出所有素数 如果采用筛法求素数的思路,需要开两个数组,而实际由于我们并不需要这些 由于由每个丑数分别乘上 2 , 3 , 5 , 7 可以得到所有丑数,可以分别对每个丑数乘上这四个数,在找到新丑数的同时找到新的因子重点在于判重,由于 2*3 和 3*2 这种情况会被重复计算,因此可以采取用 4 个“指针”,来分别记录对 4 个数的下标,每次将新的丑数取最小的那个,而后将结果中与新的丑数相同的下标全部后移这样在排序的同时做到了判重 const int maxn = 5842 + 1;int dp[maxn];int i1 = 1,i2 = 1,i3 = 1,i4 = 1; int n = 1; dp[1] = 1; while(n &lt; maxn) &#123; dp[++n] = min(min(2 * dp[i1],3 * dp[i2]),min(5 * dp[i3],7 * dp[i4])); if(dp[n] == 2 * dp[i1]) i1++; if(dp[n] == 3 * dp[i2]) i2++; if(dp[n] == 5 * dp[i3]) i3++; if(dp[n] == 7 * dp[i4]) i4++; &#125;","tags":[{"name":"丑数","slug":"Ugly-number","permalink":"https://www.oyohyee.com/tags/Ugly-number/"}]},{"title":"HDU 1058.Humble Numbers","date":"2016-07-24T16:24:33.000Z","path":"/post/HDU/1058.html","text":"题目 Description A number whose only prime factors are 2,3,5 or 7 is called a humble number. The sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 24, 25, 27, … shows the first 20 humble numbers. Write a program to find and print the nth element in this sequence Input The input consists of one or more test cases. Each test case consists of one integer n with 1 &lt;= n &lt;= 5842. Input is terminated by a value of zero (0) for n. Output For each test case, print one line saying “The nth humble number is number.”. Depending on the value of n, the correct suffix “st”, “nd”, “rd”, or “th” for the ordinal number nth has to be used like it is shown in the Sample Output. Sample Input 1234111213212223100100058420 Sample OutputThe 1st humble number is 1.The 2nd humble number is 2.The 3rd humble number is 3.The 4th humble number is 4.The 11th humble number is 12.The 12th humble number is 14.The 13th humble number is 15.The 21st humble number is 28.The 22nd humble number is 30.The 23rd humble number is 32.The 100th humble number is 450.The 1000th humble number is 385875.The 5842nd humble number is 2000000000. 题解&gt;丑数&lt;丑数部分直接套用公式即可,这道题难点明明是英语……st 、 nd 、 rd 、 th 花的时间比丑数都多…… 代码Humble Numbers代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 5843;int dp[maxn];char *c[] = &#123;\"\",\"st\",\"nd\",\"rd\"&#125;;bool Do() &#123; int n; scanf(\"%d\",&amp;n); if(n == 0) return false; char t[3]=\"th\"; if(n % 10 == 1 &amp;&amp; n % 100 != 11) t[0] = 's',t[1]='t'; else if(n % 10 == 2 &amp;&amp; n % 100 != 12) t[0] = 'n',t[1] = 'd'; else if(n % 10 == 3 &amp;&amp; n % 100 != 13) t[0] = 'r',t[1] = 'd'; printf(\"The %d%s humble number is %d.\\n\",n,t,dp[n]); return true;&#125;int main() &#123; int i1 = 1,i2 = 1,i3 = 1,i4 = 1; int n = 1; dp[1] = 1; while(n &lt; maxn) &#123; dp[++n] = min(min(2 * dp[i1],3 * dp[i2]),min(5 * dp[i3],7 * dp[i4])); if(dp[n] == 2 * dp[i1]) i1++; if(dp[n] == 3 * dp[i2]) i2++; if(dp[n] == 5 * dp[i3]) i3++; if(dp[n] == 7 * dp[i4]) i4++; &#125; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"丑数","slug":"Ugly-number","permalink":"https://www.oyohyee.com/tags/Ugly-number/"}]},{"title":"HDU 1421.搬寝室","date":"2016-07-24T15:46:30.000Z","path":"/post/HDU/1421.html","text":"题目 Description 搬寝室是很累的,xhd深有体会.时间追述2006年7月9号,那天xhd迫于无奈要从27号楼搬到3号楼,因为10号要封楼了.看着寝室里的n件物品,xhd开始发呆,因为n是一个小于2000的整数,实在是太多了,于是xhd决定随便搬2*k件过去就行了.但还是会很累,因为2*k也不小是一个不大于n的整数.幸运的是xhd根据多年的搬东西的经验发现每搬一次的疲劳度是和左右手的物品的重量差的平方成正比(这里补充一句,xhd每次搬两件东西,左手一件右手一件).例如xhd左手拿重量为3的物品,右手拿重量为6的物品,则他搬完这次的疲劳度为(6-3)^2 = 9.现在可怜的xhd希望知道搬完这2*k件物品后的最佳状态是怎样的(也就是最低的疲劳度),请告诉他吧. Input 每组输入数据有两行,第一行有两个数n,k(2&lt;=2*k&lt;=n&lt;2000).第二行有n个整数分别表示n件物品的重量(重量是一个小于2^15的正整数). Output 对应每组输入数据,输出数据只有一个表示他的最少的疲劳度,每个一行. Sample Input 2 11 3 Sample Output 4 题解如果想要使疲劳值最小,就要让平方最小,就要让差最小明显的思路就是先排序,最优的解必定在相邻的两个数种获得 直观点可以维护一个数组记录相邻两个数的差值,并且按照从小到大排序,然后找出不重复的前 k 组不过这个排序比较麻烦 换一种思路,我们对于一个差值,有选和不选两种思路用 dp[i][j] 表示前 i 个数中选取 j 组的最小疲劳值不选则有: dp[i][j] = dp[i-1][j]选择则有: dp[i][j] = dp[i-2][j-1] + delta^2取较小值即可 dp[i][j] = min(dp[i - 1][j] , dp[i - 2][j - 1] + (a[i] - a[i - 1])*(a[i] - a[i - 1])) 为了防止 int 溢出,可以将最大值除 2 代码搬寝室代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int INF = 0x7FFFFFFF/2;const int maxn = 2005;int a[maxn];int dp[maxn][maxn / 2];bool Do() &#123; int n,k; if(scanf(\"%d%d\",&amp;n,&amp;k) == EOF) return false; dp[0][0] = 0; for(int i = 0;i &lt;= n;i++) for(int j = 1;j &lt;= k;j++) dp[i][j] = INF; for(int i = 1;i &lt;= n;i++) scanf(\"%d\",&amp;a[i]); sort(a + 1,a + 1 + n); for(int i = 2;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= k;j++) &#123; dp[i][j] = min( dp[i - 1][j], dp[i - 2][j - 1] + (a[i] - a[i - 1])*(a[i] - a[i - 1]) ); &#125; &#125; printf(\"%d\\n\",dp[n][k]); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"HDU 1159.Common Subsequence","date":"2016-07-24T15:00:28.000Z","path":"/post/HDU/1159.html","text":"题目 Description A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt;x1, x2, …, xm&gt; another sequence Z = &lt;z1, z2, …, zk&gt; is a subsequence of X if there exists a strictly increasing sequence &lt;i1, i2, …, ik&gt; of indices of X such that for all j = 1,2,…,k, xij = zj. For example, Z = &lt;a, b, f, c&gt; is a subsequence of X = &lt;a, b, c, f, b, c&gt; with index sequence &lt;1, 2, 4, 6&gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y.The program Input is from a text file. Each data set in the file contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct. For each set of data the program prints on the standard ## Output the length of the maximum-length common subsequence from the beginning of a separate line. Sample Input abcfbc abfcabprogramming contestabcd mnp Sample Output 420 题解&gt;最长公共子序列&lt;模板题,基本上看输入输出就足够了…… 代码Common Subsequence代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 1005;//最长公共子序列//输入字符串a 及其长度 字符串b 及其长度 保存最长公共子序列的数组//字符从0开始int LCS(char *a,char *b,char s[] = NULL) &#123; int len1 = strlen(a); int len2 = strlen(b); char *aa = a - 1; char *bb = b - 1; //声明二维数组 int * m = new int[(len1 + 1)*(len2 + 1)]; int **dp = new int *[len1 + 1]; for(int i = 0;i &lt;= len1;i++) dp[i] = m + i*(len2 + 1); //初始化 for(int i = 0;i &lt;= len1;i++) dp[i][0] = 0; for(int i = 0;i &lt;= len2;i++) dp[0][i] = 0; //动态规划 for(int i = 1;i &lt;= len1;i++) for(int j = 1;j &lt;= len2;j++) if(aa[i] == bb[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j],dp[i][j - 1]); /*for(int i = 0;i &lt;= len1;i++)&#123; for(int j = 0;j &lt;= len2;j++) printf(\"%d\\t\",dp[i][j]); printf(\"\\n\"); &#125;*/ //如果c未传值 if(s == NULL) return dp[len1][len2]; //逆序推出一条符合串 int ans = dp[len1][len2]; int x = len1; int y = len2; int it = ans; s[it] = '\\0'; while(it) &#123; if(dp[x - 1][y] == it) &#123; x--; continue; &#125; if(dp[x][y - 1] == it) &#123; y--; continue; &#125; s[--it] = aa[x]; x--; y--; &#125; return ans;&#125;char a[maxn],b[maxn];bool Do() &#123; if(scanf(\"\\n%s%s\",a,b) == EOF) return false; printf(\"%d\\n\",LCS(a,b)); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最长公共子序列","slug":"LCS","permalink":"https://www.oyohyee.com/tags/LCS/"}]},{"title":"HDU 1257.最少拦截系统","date":"2016-07-24T12:44:27.000Z","path":"/post/HDU/1257.html","text":"题目 Description 某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.怎么办呢 多搞几套系统呗!你说说倒蛮容易,成本呢 成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统. Input 输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是不大于30000的正整数,用空格分隔) Output 对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统. Sample Input 8 389 207 155 300 299 170 158 65 Sample Output 2 题解看到题目,非严格递减的序列,尽可能少(每个序列尽可能长)显然是 &gt;最长上升子序列&lt; 最早的想法是,求一次最长非下降子序列然后看看有多少个 dp 值与前一个不是增加关系不过这种方法存在问题 WA 后来换了下思路,直接求最长上升子序列就行相当于找出每个导弹的第一个(最高的)那发导弹 代码最少拦截系统代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 1005;int a[maxn];int dp[maxn];bool vis[maxn];bool Do() &#123; int n; if(scanf(\"%d\",&amp;n) == EOF) return false; for(int i = 1;i &lt;= n;i++) scanf(\"%d\",&amp;a[i]); memset(dp,false,sizeof(dp)); for(int i = 1;i &lt;= n;i++) for(int j = 0;j &lt; i;j++) if(a[j] &lt; a[i] || j == 0) dp[i] = max(dp[i],dp[j] + 1); int Max = 0; for(int i = 1;i &lt;= n;i++) Max = max(Max,dp[i]); printf(\"%d\\n\",Max); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最长上升子序列","slug":"LIS","permalink":"https://www.oyohyee.com/tags/LIS/"}]},{"title":"HDU 2830.Matrix Swapping II","date":"2016-07-23T17:11:10.000Z","path":"/post/HDU/2830.html","text":"题目 Description Given an N * M matrix with each entry equal to 0 or 1. We can find some rectangles in the matrix whose entries are all 1, and we define the maximum area of such rectangle as this matrix’s goodness. We can swap any two columns any times, and we are to make the goodness of the matrix as large as possible. Input There are several test cases in the input. The first line of each test case contains two integers N and M (1 ≤ N,M ≤ 1000). Then N lines follow, each contains M numbers (0 or 1), indicating the N * M matrix Output Output one line for each test case, indicating the maximum possible goodness. Sample Input 3 41011100100013 4101010010001 Sample Output 42 翻译 背景 在一个由 0 和 1 填充的 N * M 的矩形,我们可以从其中找到一些矩形矩阵的为 1 的方格,将其能达到的最大面积称为最大面积我们可以任意交换两列方格,从而使能够达到的面积更大 输入输入包括多组数据每组第一行是两个整数 N 和 M ( 1&lt;=N,M&lt;=1000 )接下来 N 行每行有 M 个数,构成 N * M 的矩阵 输出在一行中输出最大的矩形 题解可以看出是&gt;最大矩形问题&lt;的修改版 由于每一列都可以移动,我们在每次计算以第 i 行为低的矩阵时,应该尽可能把图形移动成能够获得更大面积矩形的情况稍微画下可以发现,有序排列每个宽度为 1 的小矩形是最优解因此可以先对以 i 为底的矩形的高排序,再计算最大矩形 代码Matrix Swapping II代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 1005;bool Map[maxn][maxn];int H[maxn][maxn];int Left[maxn];int Right[maxn];int MaxMatrix(bool Matrix[maxn][maxn],int n,int m,bool target) &#123; memset(H,0,sizeof(H)); memset(Left,0,sizeof(Left)); memset(Right,0,sizeof(Right)); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; if(Matrix[i][j] == target) &#123; if(Matrix[i - 1][j]) H[i][j] = H[i - 1][j] + 1; else H[i][j] = 1; &#125; &#125; int Max = 0; for(int i = 1;i &lt;= n;i++) &#123; sort(H[i] + 1,H[i] + 1 + m); for(int j = 1;j &lt;= m;j++) &#123; //if(Matrix[i][j] == target) &#123; int t = j; while(t &gt; 1 &amp;&amp; H[i][j] &lt;= H[i][t - 1]) t = Left[t - 1]; Left[j] = t; //&#125; &#125; for(int j = m;j &gt;= 1;j--) &#123; //if(Matrix[i][j] == target) &#123; int t = j; while(t &lt; m &amp;&amp; H[i][j] &lt;= H[i][t + 1]) t = Right[t + 1]; Right[j] = t; //&#125; &#125; for(int j = 1;j &lt;= m;j++) &#123; //if(Matrix[i][j] == target) &#123; int S = H[i][j] * (Right[j] - Left[j] + 1); Max = max(Max,S); //&#125; &#125; &#125; return Max;&#125;bool Do() &#123; int n,m; if(scanf(\"%d%d\",&amp;n,&amp;m) == EOF) return false; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; char t; scanf(\"\\n%c\",&amp;t); Map[i][j] = (t == '1'); &#125; int ans = MaxMatrix(Map,n,m,true); printf(\"%d\\n\",ans); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最大矩形","slug":"Max-Rectangle","permalink":"https://www.oyohyee.com/tags/Max-Rectangle/"}]},{"title":"最大矩形","date":"2016-07-23T17:04:00.000Z","path":"/post/Algorithm/Max_Rectangle.html","text":"最大矩形是动态规划问题的一部分 对于一个二维的图,可以将其看成由许多宽度为 1 的小矩形组成的每次可以以一行为基底,求出最低到这一行的矩形的最大面积先求出从这一行开始的矩形的往上能达到的最远距离(高),将其称为一个小矩形再分别对每个小矩形求取其左侧和右侧没有高于它的最远距离(宽)根据宽和高即可求出这个小矩形往外拓展能达到的最大矩形,最后求出所有小矩形中最大的那个值即可 &gt;参考&lt; 最大矩形代码备份int H[maxn][maxn];int Left[maxn];int Right[maxn];int MaxMatrix(bool Matrix[maxn][maxn],int n,int m,bool target) &#123; memset(H,0,sizeof(H)); memset(Left,0,sizeof(Left)); memset(Right,0,sizeof(Right)); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; if(Matrix[i][j] == target) &#123; if(Matrix[i - 1][j]) H[i][j] = H[i - 1][j] + 1; else H[i][j] = 1; &#125; &#125; int Max = 0; for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= m;j++) &#123; if(Matrix[i][j] == target) &#123; int t = j; while(t &gt; 1 &amp;&amp; H[i][j] &lt;= H[i][t - 1]) t = Left[t - 1]; Left[j] = t; &#125; &#125; for(int j = m;j &gt;= 1;j--) &#123; if(Matrix[i][j] == target) &#123; int t = j; while(t &lt; m &amp;&amp; H[i][j] &lt;= H[i][t + 1]) t = Right[t + 1]; Right[j] = t; &#125; &#125; for(int j = 1;j &lt;= m;j++) &#123; if(Matrix[i][j] == target) &#123; int S = H[i][j] * (Right[j] - Left[j] + 1); Max = max(Max,S); &#125; &#125; &#125; return Max;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"最大矩形","slug":"Max-Rectangle","permalink":"https://www.oyohyee.com/tags/Max-Rectangle/"}]},{"title":"HDU 2870.Largest Submatrix","date":"2016-07-23T16:58:26.000Z","path":"/post/HDU/2870.html","text":"题目 Description Now here is a matrix with letter ‘a’,’b’,’c’,’w’,’x’,’y’,’z’ and you can change ‘w’ to ‘a’ or ‘b’, change ‘x’ to ‘b’ or ‘c’, change ‘y’ to ‘a’ or ‘c’, and change ‘z’ to ‘a’, ‘b’ or ‘c’. After you changed it, what’s the largest submatrix with the same letters you can make Input The input contains multiple test cases. Each test case begins with m and n (1 ≤ m, n ≤ 1000) on line. Then come the elements of a matrix in row-major order on m lines each with n letters. The input ends once EOF is met. Output For each test case, output one line containing the number of elements of the largest submatrix of all same letters. Sample Input 2 4abcwwxyz Sample Output 3 题解可以看出是&gt;最大矩形问题&lt;由于 w 、 x 、 y 、 z 都可以转换成 a 、 b 、 c可以得知,最后结果必定在转换成 a 、 b 、 c 中选择 分别转换成 a 、 b 、 c ,分别求取最大矩形,最大的那个就是答案 代码Largest Submatrix代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 1005;char Mapa[maxn][maxn];char Mapb[maxn][maxn];char Mapc[maxn][maxn];int H[maxn][maxn];int Left[maxn][maxn];int Right[maxn][maxn];int MaxMatrix(char Matrix[maxn][maxn],int n,int m,char target) &#123; memset(H,0,sizeof(H)); memset(Left,0,sizeof(Left)); memset(Right,0,sizeof(Right)); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; if(Matrix[i][j] == target) &#123; if(Matrix[i - 1][j]) H[i][j] = H[i - 1][j] + 1; else H[i][j] = 1; &#125; &#125; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; if(Matrix[i][j] == target) &#123; int t = j; while(t &gt;= 1 &amp;&amp; H[i][j] &lt;= H[i][t - 1]) t = Left[i][t - 1]; Left[i][j] = t; &#125; &#125; for(int i = 1;i &lt;= n;i++) for(int j = m;j &gt;= 1;j--) &#123; if(Matrix[i][j] == target) &#123; int t = j; while(t &lt;= m &amp;&amp; H[i][j] &lt;= H[i][t + 1]) t = Right[i][t + 1]; Right[i][j] = t; &#125; &#125; int Max = 0; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; if(Matrix[i][j] == target) &#123; int S = H[i][j] * (Right[i][j] - Left[i][j] + 1); Max = max(Max,S); &#125; &#125; return Max;&#125;bool Do() &#123; int n,m; if(scanf(\"%d%d\",&amp;n,&amp;m) == EOF) return false; int a = 0,b = 0,c = 0; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; char t; scanf(\"\\n%c\",&amp;t); Mapa[i][j] = (t == 'w' || t == 'y' || t == 'z') ? 'a' : t; Mapb[i][j] = (t == 'w' || t == 'x' || t == 'z') ? 'b' : t; Mapc[i][j] = (t == 'x' || t == 'y' || t == 'z') ? 'c' : t; &#125; int ans = 0; ans = max(ans,MaxMatrix(Mapa,n,m,'a')); ans = max(ans,MaxMatrix(Mapb,n,m,'b')); ans = max(ans,MaxMatrix(Mapc,n,m,'c')); printf(\"%d\\n\",ans); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最大矩形","slug":"Max-Rectangle","permalink":"https://www.oyohyee.com/tags/Max-Rectangle/"}]},{"title":"AOJ 524.桂园食堂","date":"2016-07-23T16:52:53.000Z","path":"/post/AOJ/524.html","text":"Description 食堂对大家来说一点都不陌生,每次打菜的时候我们几乎看重两样:价钱和味道.现在你来到了桂园二楼打菜,假设你的卡里的钱为m,现在食堂里有n种菜,每种菜的价格分别为Pi,用Li来衡量你心中的每种菜的味道,我们称之为满意值.那你本次打菜最满意的值是多少呢 假设你的饭量足够大,并且你不会打两份一样的菜. Input 有多组测试数据,对于每组数据第一行:n m为一个整数和一个一位小数(即小数点后只保留一位)分别代表菜的种类和你的卡里的钱(0&lt;=n&lt;=100,0&lt;=m&lt;=1000)接下来有n行,每行代表两个一位小数Pi和Li(0&lt;=Pi&lt;=10,0&lt;=Li&lt;=10)输入到文件结束 Output 每组数据输出一个一位小数,代表最大满意值 Sample Input 2 10.01.5 9.93.5 8.03 2.01.5 9.02.0 8.82.5 0.0 Sample Output 17.99.0 题解模板题,01背包问题注意考虑浮点误差 代码桂园食堂代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.com かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std; const int maxn = 10005;double dp[maxn];int v; void ZeroOnePack(int cost,double weight) &#123; for(int i = v; i &gt;= cost; i--) dp[i] = max(dp[i],dp[i - cost] + weight);&#125; bool Do() &#123; int n,m; double mt; if(scanf(\"%d%lf\",&amp;n,&amp;mt) == EOF) return false; m = (int)(mt * 10+0.5); v = m; memset(dp,0,sizeof(dp)); for(int i = 1;i &lt;= n;i++) &#123; double p,l; scanf(\"%lf%lf\",&amp;p,&amp;l); ZeroOnePack((int)(p*10+0.5),l); &#125; printf(\"%.1f\\n\",dp[m]); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"}]},{"title":"AOJ 275.Charm Bracelet","date":"2016-07-23T16:47:38.000Z","path":"/post/AOJ/275.html","text":"# 题目 Description Bessie has gone to the mall’s jewelry store and spies a charm bracelet. Of course, she’d like to fill it with the best charms possible from the N (1 ≤ N ≤ 3,402) available charms. Each charm i in the supplied list has a weight Wi (1 ≤ Wi ≤ 400), a ‘desirability’ factor Di (1 ≤ Di ≤ 100), and can be used at most once. Bessie can only support a charm bracelet whose weight is no more than M (1 ≤ M ≤ 12,880). Given that weight limit as a constraint and a list of the charms with their weights and desirability rating, deduce the maximum possible sum of ratings. Input Line 1: Two space-separated integers: N and M Lines 2..N+1: Line i+1 describes charm i with two space-separated integers: Wi and Di Output Line 1: A single integer that is the greatest sum of charm desirabilities that can be achieved given the weight constraints Sample Input 4 61 42 63 122 7 Sample Output 23 题解模板题,01背包问题 代码Charm Bracelet代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.com かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std; const int maxn = 20000;int dp[maxn];int v; void ZeroOnePack(int cost,int weight) &#123; for(int i = v; i &gt;= cost; i--) dp[i] = max(dp[i],dp[i - cost] + weight);&#125; bool Do() &#123; int n,m; if(scanf(\"%d%d\",&amp;n,&amp;m) == EOF) return false; v = m; memset(dp,0,sizeof(dp)); for(int i = 1;i &lt;= n;i++) &#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); ZeroOnePack(a,b); &#125; printf(\"%d\\n\",dp[m]); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"}]},{"title":"最大不连续子序列","date":"2016-07-22T17:55:00.000Z","path":"/post/Algorithm/MUS.html","text":"按照 最大连续子序列 的命名,来命名 最大不连续子序列 ( Maximum Uncontinuous Subsequence ) 其意思是,在一串数中,在所有数都不相邻的子序列里,找出和最大的子序列 根据动态规划的思想,用 dp[i] 表示前 i 个数中,最大不连续子序列那么对于第 i 个数,有选择和不选择两种情况如果选择,那么就不能选择第 i-1 个数,此时有 dp[i] = dp[i-2] + num如果不选择,那么它应该等于上一个最大不连续子序列,有 dp[i] = dp[i-1] 也即 dp[i] = max(dp[i-1],dp[i-2]+num) 由于通常 i&gt;=1 因此需要特殊考虑 i==1 和 i==2 的情况 void MUS(int *dp,int *num,int n)&#123; dp[1] = num[1]; dp[2] = max(num[1],num[2]); for(int i=3;i&lt;=n;i++)&#123; dp[i] = max(dp[i-1],dp[i-2]+num[i]); &#125;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"最大不连续子序列","slug":"MUS","permalink":"https://www.oyohyee.com/tags/MUS/"}]},{"title":"HDU 2845.Beans","date":"2016-07-22T17:47:51.000Z","path":"/post/HDU/2845.html","text":"题目 Description Bean-eating is an interesting game, everyone owns an M*N matrix, which is filled with different qualities beans. Meantime, there is only one bean in any 1*1 grid. Now you want to eat the beans and collect the qualities, but everyone must obey by the following rules: if you eat the bean at the coordinate(x, y), you can’t eat the beans anyway at the coordinates listed (if exiting): (x, y-1), (x, y+1), and the both rows whose abscissas are x-1 and x+1. Now, how much qualities can you eat and then get Input There are a few cases. In each case, there are two integer M (row number) and N (column number). The next M lines each contain N integers, representing the qualities of the beans. We can make sure that the quality of bean isn’t beyond 1000, and 1&lt;=M*N&lt;=200000. Output For each case, you just output the MAX qualities you can eat and then get. Sample Input 4 611 0 7 5 13 978 4 81 6 22 41 40 9 34 16 1011 22 0 33 39 6 Sample Output 242 翻译 背景 吃豆子是一个有趣的游戏,每个人都拥有一个 M * N 矩阵,这里充满了不同质量豆子每个网格中只有一个豆子任务是收集最多的豆子但必须遵守以下规则:如果吃了坐标是 (x,y) 的豆子,则不能吃以下坐标的豆子(如果存在):(x,y-1) , (x,y + 1) ,横坐标为 x - 1 , x + 1 的两行 输入多组数据输入每组数据先输入格数 M 、 N 分别代表 M 行 N 列接下来 M 行每行有 N 个数,代表这个格子豆子的质量豆子的质量小于 10001&lt;=N*M&lt;=200000 题解&gt;最大不连续子序列&lt; 对于每一行,需要找出该行的最大不连续子序列记录下每行这个最大的值 再对于整个图,在每行的最大值中,找出最大不连续子序列此时求得的数,就是我们需要的答案 代码Beans代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 200005;int numt[maxn];int num[maxn];int dp[maxn];int N,M;bool Do() &#123; if(scanf(\"%d%d\",&amp;N,&amp;M) == EOF) return false; memset(dp,0,sizeof(dp)); for(int i = 1;i &lt;= N;i++) &#123; for(int j = 1;j &lt;= M;j++) &#123; int temp; scanf(\"%d\",&amp;temp); if(j &lt;= 2) &#123; if(j == 1) numt[j] = temp; else numt[j] = max(numt[1],temp); &#125; else &#123; numt[j] = max(numt[j - 1],numt[j - 2] + temp); &#125; &#125; num[i] = numt[M]; &#125; dp[1] = num[1]; dp[2] = max(num[1],num[2]); for(int i = 3;i &lt;= N;i++) &#123; dp[i] = max(dp[i - 1],dp[i - 2] + num[i]); &#125; printf(\"%d\\n\",dp[N]); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最大不连续子序列","slug":"MUS","permalink":"https://www.oyohyee.com/tags/MUS/"}]},{"title":"2016-07-20 ~ 2016-07-22 学习报告","date":"2016-07-22T16:59:10.000Z","path":"/post/Study/2016_07_21-2016_07_22.html","text":"题目： HDU 2577.How to Type HDU 2844.Coins","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"HDU 2844.Coins","date":"2016-07-22T15:54:30.000Z","path":"/post/HDU/2844.html","text":"题目 Description Whuacmers use coins.They have coins of value A1,A2,A3…An Silverland dollar. One day Hibix opened purse and found there were some coins. He decided to buy a very nice watch in a nearby shop. He wanted to pay the exact price(without change) and he known the price would not more than m.But he didn’t know the exact price of the watch. You are to write a program which reads n,m,A1,A2,A3…An and C1,C2,C3…Cn corresponding to the number of Tony’s coins of value A1,A2,A3…An then calculate how many prices(form 1 to m) Tony can pay use these coins. Input The input contains several test cases. The first line of each test case contains two integers n(1 ≤ n ≤ 100),m(m ≤ 100000).The second line contains 2n integers, denoting A1,A2,A3…An,C1,C2,C3…Cn (1 ≤ Ai ≤ 100000,1 ≤ Ci ≤ 1000). The last test case is followed by two zeros. Output For each test case output the answer on a single line. Sample Input 3 101 2 4 2 1 12 51 4 2 10 0 Sample Output 84 翻译 背景 武汉大学的 ACMer 喜欢用硬币,他们有不同价值的 A1 、 A2 、 A3 的硬币.一天, Hibix 想用他的前买个表,他只知道可以正好用自己的硬币在不超过 m 元的情况下买下这个表,但是他忘记了表的价格你要写一个程序读入硬币的价值 A1 、 A2 、 A3 …… 和硬币的数量 C1 、 C2 、 C3 ……计算出 Hibix 能用自己的硬币组成多少不同的钱数 输入输入包括多组数据每组数据先输入 n 和 m 分别表示硬币的种类数和最多的钱数( n&lt;=100 m&lt;=100000 )接下来一行有 2n 个数, A1 、 A2 …… An 和 C1 、 C2 …… Cn 分别表示硬币 i 的价值和数量 输出对于每组数据在一行里输出答案 题解&gt;多重背包问题&lt; 直接套用模板即可用 dp[i] 表示在钱数最多为 i 的情况下,能拼成的最大钱数 整个计算完成后,循环一遍得出不同的数据数,也即种类数 代码Coins代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 105;const int maxm = 100005;int v;int dp[maxm];void ZeroOnePack(int cost,int weight) &#123; for(int i = v; i &gt;= cost; i--) dp[i] = max(dp[i],dp[i - cost] + weight);&#125;void CompletePack(int cost,int weight) &#123; for(int i = cost; i &lt;= v; i++) dp[i] = max(dp[i],dp[i - cost] + weight);&#125;void MultiplePack(int cost,int weight,int n) &#123; if(cost * n &gt; v) &#123; CompletePack(cost,weight); &#125; else &#123; int k = 1; while(k &lt; n) &#123; ZeroOnePack(cost * k,weight * k); n -= k; k *= 2; &#125; ZeroOnePack(cost * n,weight * n); &#125;&#125;int value[maxn];int number[maxn];bool Do() &#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); if(n == 0 &amp;&amp; m == 0) return false; for(int i = 1;i &lt;= n;i++) scanf(\"%d\",&amp;value[i]); for(int i = 1;i &lt;= n;i++) scanf(\"%d\",&amp;number[i]); v = m; memset(dp,0,sizeof(dp)); for(int i = 1;i &lt;= n;i++) &#123; MultiplePack(value[i],value[i],number[i]); &#125; int cnt = 0; for(int i = 1;i &lt;= m;i++) &#123; if(dp[i] != dp[i - 1]) cnt++; &#125; printf(\"%d\\n\",cnt); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"HDU 2577.How to Type","date":"2016-07-20T03:34:26.000Z","path":"/post/HDU/2577.html","text":"题目 Description Pirates have finished developing the typing software. He called Cathy to test his typing software. She is good at thinking. After testing for several days, she finds that if she types a string by some ways, she will type the key at least. But she has a bad habit that if the caps lock is on, she must turn off it, after she finishes typing. Now she wants to know the smallest times of typing the key to finish typing a string. Input The first line is an integer t (t&lt;=100), which is the number of test case in the input file. For each test case, there is only one string which consists of lowercase letter and upper case letter. The length of the string is at most 100. Output For each test case, you must output the smallest times of typing the key to finish typing this string. Sample Input 3PiratesHDUacmHDUACM Sample Output 888 Hint The string “Pirates”, can type this way, Shift, p, i, r, a, t, e, s, the answer is 8. The string “HDUacm”, can type this way, Caps lock, h, d, u, Caps lock, a, c, m, the answer is 8 The string “HDUACM”, can type this way Caps lock h, d, u, a, c, m, Caps lock, the answer is 8 翻译 背景 海盗们开发了打字软件他们让善于思考的凯西来测试他的打字软件测试了几天后,她发现她可以用不同的方式打不同的字母( Caps lock 、 shift )但她有个坏习惯,如果使用大写锁定( Caps lock ),打完后必须要关掉它现在她想知道输入一个字符串的最小完成时间 输入第一行是数据数 t ( t&lt;=100 )接下来 t 行每行是一个只有大小写字母的字符串 输出对于每组数据,在一行内输出最少花费的时间(按键数) 提示对于 Pirates 可以这样输入 shift p i r a t e s 这样输入,共需要 8 个键对于 HDUacm 可以这样输入 Cap Lock h d u Cap Lock a c m 这样输入,共需要 8 个键对于 HDUACM 可以这样输入 Cap Lock h d u a c m Cap Lock 这样输入,共需要 8 个键 题解自然,作为动态规划的题目,这道题可以使用动态规划求解,但是模拟相对会更快一点 首先,对于一个字符,需要判断大小写,同时需要一个变量记录 Cap Lock 是否开启,一个变量记录上一个字符如果 Cap Lock 关闭,字符是小写;或者 Cap Lock 开启,字符是大写,直接把记录 +1 即可如果 Cap Lock 和要输入的字符不同,就需要分类判断了由于开始和最后 Cap Lock 是关闭的,要想维持这种状态必须需要按下两次 Cap Lock如果只是一个键的键入,就不应该用 Cap Lock ,而是应该用 shift而两个键时,两种方法效果相同,不过为了下一个字符的方便,还是变成 Cap Lock不管是大写中有一个小写还是小写中有一个大写,都应该符合这些 字符输入完后,还需要判断 Cap Lock 的状态在 AAa 形式的情况下,由于按照上面的情况,采取了使用 shift 的方法来保证最优(如果后面还有字符)然而最后一个字符关掉 Cap Lock 才是最好的选择因此,如果 Cap Lock 打开,并且最后一个字符是大写时,我们需要额外一次按键来保证关闭 Cap Lock 代码How to Type代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;inline bool islower(char c) &#123; return (c &gt;= 'a'&amp;&amp;c &lt;= 'z');&#125;inline bool isupper(char c) &#123; return (c &gt;= 'A'&amp;&amp;c &lt;= 'Z');&#125;bool Do() &#123; int dp=0; bool Cap = false; char c = getchar(),last = 'a'; while(!(islower(c) || isupper(c))) c=getchar(); while(islower(c) || isupper(c)) &#123; if(islower(c)) &#123; //字符是小写 if(Cap) &#123; if(islower(last)) &#123; dp += 1; Cap = false; &#125; else &#123; dp += 2; &#125; &#125; else &#123; dp++; &#125; &#125; else &#123; if(Cap) &#123; dp++; &#125; else &#123; if(isupper(last)) &#123; dp++; Cap = true; &#125; else &#123; dp += 2; &#125; &#125; &#125; last = c; c = getchar(); &#125; if(Cap) if(isupper(last)) dp++; printf(\"%d\\n\",dp); return true;&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"2016-07-17 ~ 2016-07-19 学习报告","date":"2016-07-19T17:49:10.000Z","path":"/post/Study/2016_07_17-2016_07_19.html","text":"题目： HDU 1176.免费馅饼 HDU 1203.I NEED A OFFER! HDU 2159.FATE","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"HDU 2159.FATE","date":"2016-07-19T17:32:25.000Z","path":"/post/HDU/2159.html","text":"题目 Description 最近xhd正在玩一款叫做FATE的游戏，为了得到极品装备，xhd在不停的杀怪做任务。久而久之xhd开始对杀怪产生的厌恶感，但又不得不通过杀怪来升完这最后一级。现在的问题是，xhd升掉最后一级还需n的经验值，xhd还留有m的忍耐度，每杀一个怪xhd会得到相应的经验，并减掉相应的忍耐度。当忍耐度降到0或者0以下时，xhd就不会玩这游戏。xhd还说了他最多只杀s只怪。请问他能升掉这最后一级吗？ Input 输入数据有多组，对于每组数据第一行输入n，m，k，s(0 &lt; n,m,k,s &lt; 100)四个正整数。分别表示还需的经验值，保留的忍耐度，怪的种数和最多的杀怪数。接下来输入k行数据。每行数据输入两个正整数a，b(0 &lt; a,b &lt; 20)；分别表示杀掉一只这种怪xhd会得到的经验值和会减掉的忍耐度。(每种怪都有无数个) Output 输出升完这级还能保留的最大忍耐度，如果无法升完这级输出-1。 Sample Input 10 10 1 101 110 10 1 91 19 10 2 101 12 2 Sample Output 0-11 题解&gt;背包问题-完全背包问题&lt; 用 dp[i] 表示使用 i 点疲劳值能得到的最大经验数 按照完全背包问题的模板, cost 就是用去的疲劳值, weight 就是获得的经验值疲劳最多只能用输入的疲劳总量 如果全部打最值得怪都不能升级,就输出 -1最后从大往小筛,找到第一个 dp[i] 小于需要的经验数的情况此时 i+1 就是在满足升级的条件下能保留的最大疲劳值 其中获得大于等于经验值的情况中,消耗最少的疲劳时背包思路计算是否有解是贪心的思路 代码FATE代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 10005;int v;int dp[maxn];//dp[i] 表示 用掉i点忍耐度能得到的最多的经验值void CompletePack(int cost,int weight) &#123; for(int i = cost; i &lt;= v; i++) dp[i] = max(dp[i],dp[i - cost] + weight);&#125;bool Do() &#123; int exp,lp,n,maxnum; if(scanf(\"%d%d%d%d\",&amp;exp,&amp;lp,&amp;n,&amp;maxnum)==EOF) return false; memset(dp,0,sizeof(dp)); v = lp; double cheapest = 0; for(int i = 1;i &lt;= n;i++) &#123; int getexp,lostlp; scanf(\"%d%d\",&amp;getexp,&amp;lostlp); cheapest = max(cheapest,(double)getexp / lostlp); CompletePack(lostlp,getexp); &#125; if(cheapest*maxnum &lt; exp) &#123; printf(\"-1\\n\"); &#125; else &#123; for(int i = lp;i &gt;= 0;i--) &#123; if(dp[i] &lt; exp) &#123; printf(\"%d\\n\",lp-i-1); break; &#125; &#125; &#125; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"}]},{"title":"HDU 1203.I NEED A OFFER!","date":"2016-07-19T09:10:39.000Z","path":"/post/HDU/1203.html","text":"题目 Description Speakless很早就想出国，现在他已经考完了所有需要的考试，准备了所有要准备的材料，于是，便需要去申请学校了。要申请国外的任何大学，你都要交纳一定的申请费用，这可是很惊人的。Speakless没有多少钱，总共只攒了n万美元。他将在m个学校中选择若干的（当然要在他的经济承受范围内）。每个学校都有不同的申请费用a（万美元），并且Speakless估计了他得到这个学校offer的可能性b。不同学校之间是否得到offer不会互相影响。“I NEED A OFFER”，他大叫一声。帮帮这个可怜的人吧，帮助他计算一下，他可以收到至少一份offer的最大概率。（如果Speakless选择了多个学校，得到任意一个学校的offer都可以）。 Input 输入有若干组数据，每组数据的第一行有两个正整数n,m(0&lt;=n&lt;=10000,0&lt;=m&lt;=10000)后面的m行，每行都有两个数据ai(整型),bi(实型)分别表示第i个学校的申请费用和可能拿到offer的概率。输入的最后有两个0。 Output 每组数据都对应一个输出，表示Speakless可能得到至少一份offer的最大概率。用百分数表示，精确到小数点后一位。 Sample Input 10 34 0.14 0.25 0.30 0 Sample Output 44.0% Hint You should use printf(“%%”) to print a ‘%’. 题解&gt;背包问题 - 01背包问题&lt; 根据数学的概率问题,至少获得一个的概率为 1 - (1 - 成功概率1) * (1 - 成功概率2) 类推直接套用模板即可 代码I NEED A OFFER!代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 10005;int v;double dp[maxn];void ZeroOnePack(int cost,double weight) &#123; for(int i = v; i &gt;= cost; i--) dp[i] = max(dp[i],1-((1 - dp[i - cost]) * (1-weight)));&#125;bool Do() &#123; int n; scanf(\"%d%d\",&amp;v,&amp;n); if(n == 0 &amp;&amp; v == 0) return false; memset(dp,0,sizeof(dp)); for(int i = 1;i &lt;= n;i++) &#123; int cost; double p; scanf(\"%d%lf\",&amp;cost,&amp;p); ZeroOnePack(cost,p); &#125; printf(\"%.1f%%\\n\",dp[v]*100); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"}]},{"title":"删除手机 My Knox","date":"2016-07-19T04:47:01.000Z","path":"/post/Writing/myknox.html","text":"三星有个软件远近闻名,它就是让无数三星用户 root 后失去保修的“恶棍” —— Knox 在三星的新机型上,都安装有 Knox 客观来说, My Knox 是一个非常棒的安全软件文件加密,手机找回,在网页上看手机电量……各种功能应有尽有当然,这些功能许多软件都能做到,它最厉害的是它的“顽固” 百度云、360安全卫士什么的都有找回功能,但是别人把软件卸掉后你就无能为力了 而 My Knox 不同,它卸载不掉！！！！！！ 不管是服务,还是什么地方,但凡或许能卸载它的地方,要么就是压根没有,要么就是灰色不能按状态 据说即使 root 了,想卸载它也需要删掉 7 个文件 但是,三星怎么可能那么流氓呢?毕竟三星不是百度,不是360,不是小米 如果你手贱打开了 My Knox ,发现卸载不掉之后,按照以下方法 等待账户激活邮件打开 My Knox 的时候会让你填一个邮箱,进邮箱等待激活邮件可能会等的稍微久一点 激活 输入密码 在 My Knox 官网 登陆(是 My Knox 不是 Knox) 最下面有个删除 Knox点击后,手机上的 My Knox 会在几秒后消失 讲道理,其实 My Knox 是个挺不错的软件的,然而我要 root","tags":[{"name":"Android","slug":"Android","permalink":"https://www.oyohyee.com/tags/Android/"},{"name":"三星(SAMSUNG)","slug":"SAMSUNG","permalink":"https://www.oyohyee.com/tags/SAMSUNG/"},{"name":"C5","slug":"C5","permalink":"https://www.oyohyee.com/tags/C5/"}]},{"title":"HDU 1176.免费馅饼","date":"2016-07-18T17:19:29.000Z","path":"/post/HDU/1176.html","text":"题目 Description 都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标： 为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼） Input 输入数据有多组。每组数据的第一行为以正整数n(0&lt;n&lt;100000)，表示有n个馅饼掉在这条小径上。在结下来的n行中，每行有两个整数x,T(0&lt;T&lt;100000),表示在第T秒有一个馅饼掉在x点上。同一秒钟在同一点上可能掉下多个馅饼。n=0时输入结束。 Output 每一组输入数据对应一行输出。输出一个整数m，表示gameboy最多可能接到m个馅饼。提示：本题的输入数据量比较大，建议用scanf读入，用cin可能会超时。 Sample Input 65 14 16 17 27 28 30 Sample Output 4 题解非常标准的动态规划问题用 dp[t][x] 表示 t 秒 pos 位置能得到的最大馅饼数pie[t][x] 表示 t 秒 pos 位置的馅饼数量对于 t 秒 pos 位置,其最多能拿到的馅饼数来自于 max(dp[t-1[pos-1],dp[t-1][pos],dp[t-1][pos+1]) + pie[t][pos]也即 dp[t][pos] = max(dp[t-1[pos-1],dp[t-1][pos],dp[t-1][pos+1]) + pie[t][pos] 而显然,类似背包问题的一维数组一样,我们其实并不需要保存一个 maxt=100000 的数组分别用 dp dp2 两个数组交替记录即可 最后,由于不知道最后的位置在哪,因此应该找出 0~10 中最大的数输出 代码免费馅饼代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxT = 100005;const int maxpos = 11;int pie[maxT][maxpos];int *dp;int *dp2;bool Do() &#123; int n; scanf(\"%d\",&amp;n); if(n == 0) return false; memset(pie,0,sizeof(pie)); memset(dp,0,maxpos * sizeof(int)); memset(dp2,0,maxpos * sizeof(int)); int maxt = 0; for(int i = 1;i &lt;= n;i++) &#123; int t,x; scanf(\"%d%d\",&amp;x,&amp;t); pie[t][x] += 1; maxt = max(maxt,t); &#125; for(int i = 1;i &lt;= maxt;i++) &#123; for(int j = 0;j &lt; maxpos;j++) &#123; if(i == 1 &amp;&amp; !(j == 4 || j == 5 || j == 6)) continue; dp2[j] = dp[j] + pie[i][j]; if(j - 1 &gt;= 0) dp2[j] = max(dp2[j],dp[j - 1] + pie[i][j]); if(j + 1 &lt;= maxpos - 1) dp2[j] = max(dp2[j],dp[j + 1] + pie[i][j]); &#125; int *temp = dp; dp = dp2; dp2 = temp; &#125; int Max = 0; for(int i = 0;i &lt; maxpos;i++) Max = max(Max,dp[i]); printf(\"%d\\n\",Max); return true;&#125;int main() &#123; dp = new int[maxpos]; dp2 = new int[maxpos]; while(Do()); delete[]dp; delete[]dp2; return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"2016-07-14 ~ 2016-07-16 学习报告","date":"2016-07-16T16:20:10.000Z","path":"/post/Study/2016_07_14-2016_07_16.html","text":"题目： HDU 1069.Monkey and Banana Codeforces 697A.Pineapple Incident Codeforces 697B.Barnicle HDU 1171.Big Event in HDU HDU 2084.数塔 AOJ 785.棋盘完美覆盖 AOJ 786.数字序列 AOJ 787.阶乘中找数","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"AOJ 787.阶乘中找数","date":"2016-07-16T09:36:33.000Z","path":"/post/AOJ/787.html","text":"题目 Description 问题描述：统计n阶乘中数字p的个数 Input 多组数据，每组数据只有一行，为两个正整数n,p (n&lt;=800,0&lt;=p&lt;=9) Output 输出为两行，一行为n!， 另一行为n! 中数字p的个数 Sample Input 10 8 Sample Output 36288002 题解第一次把 800 看成 8000 ,优化高精度优化了好久 代码阶乘中找数代码备份/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/ かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std; #define REP(n) for(int o=0;o&lt;n;o++)class bigNumber &#123;public: int num[10001]; bigNumber() &#123; init(); &#125; void init() &#123; memset(num,0,sizeof(num)); &#125; bigNumber operator = (const bigNumber&amp; rhs) &#123; init(); REP(rhs.num[0] + 1)num[o] = rhs.num[o]; return *this; &#125; bigNumber operator = (long long rhs) &#123; init(); int i = 1; while(rhs) &#123; num[i] = rhs % 10; rhs /= 10; i++; &#125; num[0] = i - 1; return *this; &#125; bool operator &lt; (const bigNumber rhs)const &#123; if(num[0] != rhs.num[0])return (num[0]&lt;rhs.num[0]); REP(num[0]) &#123; int temp = num[0] - o; if(num[temp] != rhs.num[temp])return (num[temp]&lt;rhs.num[temp]); &#125; return 0; &#125; bool operator &gt; (const bigNumber rhs)const &#123; if(num[0] != rhs.num[0])return (num[0]&gt;rhs.num[0]); REP(num[0]) &#123; int temp = num[0] - o; if(num[temp] != rhs.num[temp])return (num[temp]&gt;rhs.num[temp]); &#125; return 0; &#125; bool operator == (const bigNumber rhs)const &#123; return !(*this&gt;rhs || *this&lt;rhs); &#125; bool operator &lt;= (const bigNumber rhs)const &#123; return *this&lt;rhs || *this == rhs; &#125; bigNumber operator + (const bigNumber rhs)const &#123; bigNumber temp; int len; len = num[0]&gt;rhs.num[0] ? num[0] : rhs.num[0]; len++; REP(len) &#123; temp.num[o + 1] += num[o + 1] + rhs.num[o + 1]; temp.num[o + 2] += temp.num[o + 1] / 10; temp.num[o + 1] %= 10; &#125; REP(len) &#123; if(temp.num[len - o] != 0) &#123; temp.num[0] = len - o; break; &#125; &#125; return temp; &#125; bigNumber operator + (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 + temp2; &#125; bigNumber operator * (const bigNumber rhs)const &#123; bigNumber temp; int len; len = num[0] + rhs.num[0]; //len++; for(int i = 1;i &lt;= num[0];i++) &#123; for(int j = 1;j &lt;= rhs.num[0];j++) &#123; temp.num[i + j - 1] += num[i] * rhs.num[j]; temp.num[i + j] += temp.num[i + j - 1] / 10; temp.num[i + j - 1] %= 10; &#125; &#125; REP(len) &#123; if(temp.num[len - o] != 0) &#123; temp.num[0] = len - o; break; &#125; &#125; return temp; &#125; bigNumber operator * (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 * temp2; &#125; bigNumber operator - (const bigNumber rhs)const &#123; bigNumber temp,a,b; temp = max(*this,rhs); b = min(*this,rhs); a = temp; temp = 0; int len = a.num[0]; REP(len) &#123; temp.num[o + 1] += 10 + a.num[o + 1] - b.num[o + 1]; temp.num[o + 2]--; temp.num[o + 2] += temp.num[o + 1] / 10; temp.num[o + 1] %= 10; &#125; REP(len) &#123; if(temp.num[len - o] != 0) &#123; temp.num[0] = len - o; break; &#125; &#125; return temp; &#125; bigNumber operator - (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 - temp2; &#125; bigNumber operator / (const bigNumber rhs)const &#123; bigNumber a; int it = num[0]; bigNumber d; bigNumber c; while(it&gt;0) &#123; a = (d * 10) + num[it]; c = c * 10; int t; REP(9) &#123; if(a &lt; rhs * (o + 1)) &#123; t = o; break; &#125; t = 9; &#125; c = c + t; d = a - rhs*t; it--; &#125; return c; &#125; bigNumber operator / (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 / temp2; &#125; bigNumber operator % (const bigNumber rhs)const &#123; bigNumber a; int it = num[0]; bigNumber d; bigNumber c; while(it&gt;0) &#123; a = (d * 10) + num[it]; c = c * 10; int t; REP(9) &#123; if(a &lt; rhs * (o + 1)) &#123; t = o; break; &#125; t = 9; &#125; c = c + t; d = a - rhs*t; it--; &#125; return d; &#125; bigNumber operator % (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 % temp2; &#125; void p() &#123; if(num[0] == 0) printf(\"0\"); REP(num[0]) &#123; printf(\"%d\",num[num[0] - o]); &#125; &#125;&#125;; bigNumber ans; bool Do() &#123; int n,p; if(scanf(\"%d%d\",&amp;n,&amp;p) == EOF) return false; ans = 1; int cnt = 0; for(int i = 2;i &lt;= n;i++) &#123; ans = ans * i; &#125; REP(ans.num[0]) &#123; printf(\"%d\",ans.num[ans.num[0] - o]); if(ans.num[ans.num[0] - o] == p)cnt++; &#125; printf(\"\\n%d\\n\",cnt); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"高精度算法","slug":"High-precision","permalink":"https://www.oyohyee.com/tags/High-precision/"}]},{"title":"AOJ 786.数字序列","date":"2016-07-16T09:23:06.000Z","path":"/post/AOJ/786.html","text":"题目 Description f(1) =1；f(2)=1；f(n)=(A*f(n-1)+B*f(n-2)) mod 7给定A,B和n时，计算f(n) Input 包含多组数据，每组测试数据占一行，包括3个整数，分别为A,B和n,其中：1&lt;=A,B&lt;=100, 1&lt;=n&lt;=100,000,000, 输入3个0表示输入结束。 Output 对于每组测试数据输出一个f(n)值，并且占一行。 Sample Input 1 1 31 2 100 0 0 Sample Output 25 题解每组 A 、 B 都不同,而 n 最大 100000000记忆化搜索没法用,直接计算绝对会超时,因此,找规律 先随便跑几个数据,看下规律很容易发现最后数列会是循环的,但是循环的区间不一样长 理解下很容易明白对于 f(n)=(A\\*f(n-1)+B\\*f(n-2)) mod 7根据同余定理可以拆分成 f(n)=(A*f(n-1)) mod 7 + (B*f(n-2)) mod 7两部分都只有7种情况,因此很容易就会出现规律,并且最长区间也只有 49 先运行一遍找到循环区间,然后直接取余映射到循环范围内即可 代码数字序列代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/ かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std; const int maxn = 50;int f[maxn];int A,B; bool flag[maxn][maxn]; bool Do() &#123; int n; scanf(\"%d%d%d\",&amp;A,&amp;B,&amp;n); if(A == 0 &amp;&amp; B == 0 &amp;&amp; n == 0) return false; A %= 7; B %= 7; memset(f,0,sizeof(f)); memset(flag,false,sizeof(flag)); f[1] = f[2] = 1; int T; for(int i = 3;;i++) &#123; int a = (A*f[i - 1]) % 7; int b = (B*f[i - 2]) % 7; f[i] = (a + b) % 7; if(flag[a][b]) &#123; T = i - 3; break; &#125; flag[a][b] = true; &#125; printf(\"%d\\n\",f[n = (n % T) ? (n % T) : T]); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"}]},{"title":"AOJ 785.棋盘完美覆盖","date":"2016-07-16T09:09:09.000Z","path":"/post/AOJ/785.html","text":"题目 Description 问题描述:有2×n的一个长方形棋盘,用一些1×2的骨牌铺满方格.例如:n=3时,在2×3的棋盘上用1×2的骨牌覆盖,共有3种铺法。问题求解:编写一个程序,试对给出的任意一个n(n&gt;0),输出铺法总数. Input 输入包括多组数据，每组数据占一行，且只有一个整数n (0&lt;=n&lt;=42),表示2*n的棋盘,当n=0时表示输入结束。 Output 输出一行结果，为一个整数，表示棋盘完美覆盖方案数。 Sample Input 80 Sample Output 34 题解显然,这道题可以使用某种神奇的数学规律来求解先找下规律 n 1 2 3 4 5 6 7 8 num 1 2 3 5 8 13 21 34 就是斐波那契数列f[n] = f[n-1] + f[n-2] 理解下原理最后的方块只有两种情况: 竖着放一列 横着两个放两列 分别对应 最后两列一个竖着放,考虑前面 n-1 列的情况( f[n-1] ) 最后两列全部竖着放,考虑前面 n-2 列的情况( f[n-2] ) 因此,将两种情况加起来就是答案 代码棋盘完美覆盖代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/ かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std; const int maxn = 45;int f[maxn] = &#123;1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170&#125;;void F(int i=2) &#123; if(i == maxn) return; f[i] = f[i - 1] + f[i - 2]; F(i + 1);&#125;; bool Do() &#123; int n; scanf(\"%d\",&amp;n); if(n == 0) return false; printf(\"%d\\n\",f[n]); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"打表","slug":"List","permalink":"https://www.oyohyee.com/tags/List/"}]},{"title":"HDU 2084.数塔","date":"2016-07-15T17:05:11.000Z","path":"/post/HDU/2084.html","text":"题目 Description 在讲述DP算法的时候，一个经典的例子就是数塔问题，它是这样描述的： 有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？ 已经告诉你了，这是个DP的题目，你能AC吗 Input 输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 &lt;= N &lt;= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。 Output 对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。 Sample Input 1573 88 1 02 7 4 44 5 2 6 5 Sample Output 30 题解&gt;AOJ 806.算法期末考试B(动态规划)&lt;原题 代码数塔代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 1000;int Map[maxn][maxn];bool Do() &#123; int n; if(scanf(\"%d\",&amp;n) == EOF) return false; memset(Map,0,sizeof(Map)); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= i;j++) scanf(\"%d\",&amp;Map[i][j]); for(int i = n - 1;i &gt; 0;i--) for(int j = 1;j &lt;= i;j++) Map[i][j] += max(Map[i + 1][j],Map[i + 1][j + 1]); printf(\"%d\\n\",Map[1][1]); return true;&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"HDU 1171.Big Event in HDU","date":"2016-07-15T02:57:49.000Z","path":"/post/HDU/1171.html","text":"题目 Description Nowadays, we all know that Computer College is the biggest department in HDU. But, maybe you don’t know that Computer College had ever been split into Computer College and Software College in 2002.The splitting is absolutely a big event in HDU! At the same time, it is a trouble thing too. All facilities must go halves. First, all facilities are assessed, and two facilities are thought to be same if they have the same value. It is assumed that there is N (0&lt;N&lt;1000) kinds of facilities (different value, different kinds). Input Input contains multiple test cases. Each test case starts with a number N (0 &lt; N &lt;= 50 – the total number of different facilities). The next N lines contain an integer V (0&lt;V&lt;=50 –value of facility) and an integer M (0&lt;M&lt;=100 –corresponding number of the facilities) each. You can assume that all V are different.A test case starting with a negative integer terminates input and this test case is not to be processed. Output For each case, print one line containing two integers A and B which denote the value of Computer College and Software College will get respectively. A and B should be as equal as possible. At the same time, you should guarantee that A is not less than B. Sample Input 210 120 1310 120 230 1-1 Sample Output 20 1040 40 翻译 背景 我们知道现在计算机学院是 HDU 最大的院系,但是你可能不知道在2002年,计算机学院被分为计算机学院和软件学院两个院系这次院系分离是 HDU 的大事,同时它还导致了许多问题许多东西都要分成两份首先,所有设施已经被评估过,如果两个设施的值不同,那么就被看作两个不同的设施所有设施被分为 N 个种类( 0&lt;N&lt;1000 ) 输入 输入包括多组数据每组数据开始有一个整数 N ( 0&lt;N&lt;=50 ) ,表示设施种类的数目接下来 N 行每行有一个值 V ( 0&lt;V&lt;=50 ),表示设施的编号一个整数 M ( 0&lt;M&lt;=100 ),表示设施的数目当 N 为负数时表示输入结束 输出 对于每组数据,在一行内输出两个整数 A 、 B分别表示计算机学院和软件学院的设施数目,两个数应该尽可能相等,并且 A 不少于 B 题解题目要求就是对东西进行平均分配如果一个东西有偶数个,那么直接除以 2 就是最好的分配方案然而对于 5 210 1 最优解是把值为 5 的分给一个人 可以感受到背包问题 使用 dp[i][j] 记录在不大于遍历到设施 i 同时已经得到的设施总数为 j 的情况下的最大值其中, j 小于等于所有设施总数的一半 那么……这不就是 &gt;多重背包问题&lt;么 魔改了好久背包问题,最好发现就是模板……求心理阴影面积 最后从所有设施总数的一半往小筛选,第一个不是 0 的就是软件学院的设施数,总数减去它就是计算机学院的设施数 数据范围有点迷,一会 1000 一会 50 往大的开吧 代码Big Event in HDU代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 1000;const int maxv = 300000;const int INF = 0x7fffffff;int dp[maxv];int value[maxn],num[maxn];int Max;int v;void ZeroOnePack(int cost,int weight) &#123; for(int i = v; i &gt;= cost; i--) dp[i] = max(dp[i],dp[i - cost] + weight);&#125;void CompletePack(int cost,int weight) &#123; for(int i = cost; i &lt;= v; i++) dp[i] = max(dp[i],dp[i - cost] + weight);&#125;void MultiplePack(int cost,int weight,int n) &#123; if(cost * n &gt; v) &#123; CompletePack(cost,weight); &#125; else &#123; int k = 1; while(k &lt; n) &#123; ZeroOnePack(cost * k,weight * k); n -= k; k *= 2; &#125; ZeroOnePack(cost * n,weight * n); &#125;&#125;bool Do() &#123; int n; scanf(\"%d\",&amp;n); if(n &lt; 0) return false; Max = 0; for(int i = 1;i &lt;= n;i++) &#123; scanf(\"%d%d\",&amp;value[i],&amp;num[i]); Max += value[i] * num[i]; &#125; v = Max / 2; memset(dp,0,sizeof(dp)); for(int i = 1;i &lt;= n;i++) &#123; MultiplePack(value[i],value[i],num[i]); &#125; int ans = 0; for(int i = v;i &gt;= 0;i--) &#123; if(dp[i] != 0) &#123; ans = dp[i]; break; &#125; &#125; printf(\"%d %d\\n\",Max - ans,ans); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"}]},{"title":"Codeforces 697B.Barnicle","date":"2016-07-14T18:00:01.000Z","path":"/post/Codeforces/697B.html","text":"题目 Description Barney is standing in a bar and starring at a pretty girl. He wants to shoot her with his heart arrow but he needs to know the distance between him and the girl to make his shot accurate. Barney asked the bar tender Carl about this distance value, but Carl was so busy talking to the customers so he wrote the distance value (it’s a real number) on a napkin. The problem is that he wrote it in scientific notation. The scientific notation of some real number x is the notation of form AeB, where A is a real number and B is an integer and x = A × 10B is true. In our case A is between 0 and 9 and B is non-negative. Barney doesn’t know anything about scientific notation (as well as anything scientific at all). So he asked you to tell him the distance value in usual decimal representation with minimal number of digits after the decimal point (and no decimal point if it is an integer). See the ## Output format for better understanding. Input The first and only line of input contains a single string of form a.deb where a, d and b are integers and e is usual character ‘e’ (0 ≤ a ≤ 9, 0 ≤ d &lt; 10100, 0 ≤ b ≤ 100) — the scientific notation of the desired distance value. a and b contain no leading zeros and d contains no trailing zeros (but may be equal to 0). Also, b can not be non-zero if a is zero. OutputPrint the only real number x (the desired distance value) in the only line in its decimal notation. Thus if x is an integer, print it’s integer value without decimal part and decimal point and without leading zeroes. Otherwise print x in a form of p.q such that p is an integer that have no leading zeroes (but may be equal to zero), and q is an integer that have no trailing zeroes (and may not be equal to zero). Examplesinput 8.549e2 output854.9 input8.549e3 output8549 input0.33e0 output0.33 题解由于 b 最大可能为 10^100 因此应该使用字符串来记录读入完后判断小数点的位置,如果超过了 b 的位数,还需要在后面补上 0 代码Barnicle代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 35;double pow(int a,int b) &#123; if(b == 0) return 1; return pow(a,b - 1) * a;&#125;bool Do() &#123; char b[105]; int a,d; if(scanf(\"%d\",&amp;a) == EOF) return false; char c=getchar(); int pos = 0; c = getchar(); while(c != 'e') &#123; b[pos++] = c; c = getchar(); &#125; scanf(\"%d\",&amp;d); putchar(a + '0'); for(int i = 0;i &lt; pos;i++) &#123; if(i == d) putchar('.'); putchar(b[i]); &#125; for(int i = pos;i &lt; d;i++) putchar('0'); putchar('\\n'); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"Codeforces 697A.Pineapple Incident","date":"2016-07-14T17:54:01.000Z","path":"/post/Codeforces/697A.html","text":"题目 Description Ted has a pineapple. This pineapple is able to bark like a bulldog! At time t (in seconds) it barks for the first time. Then every s seconds after it, it barks twice with 1 second interval. Thus it barks at times t, t + s, t + s + 1, t + 2s, t + 2s + 1, etc. Barney woke up in the morning and wants to eat the pineapple, but he can’t eat it when it’s barking. Barney plans to eat it at time x (in seconds), so he asked you to tell him if it’s gonna bark at that time. Input The first and only line of input contains three integers t, s and x (0 ≤ t, x ≤ 109, 2 ≤ s ≤ 109) — the time the pineapple barks for the first time, the pineapple barking interval, and the time Barney wants to eat the pineapple respectively. Output Print a single “YES” (without quotes) if the pineapple will bark at time x or a single “NO” (without quotes) otherwise in the only line of output. Examplesinput 3 10 4 outputNO input3 10 3 outputYES input3 8 51 outputYES input3 8 52 outputYES Note In the first and the second sample cases pineapple will bark at moments 3, 13, 14, …, so it won’t bark at the moment 4 and will bark at the moment 3. In the third and fourth sample cases pineapple will bark at moments 3, 11, 12, 19, 20, 27, 28, 35, 36, 43, 44, 51, 52, 59, …, so it will bark at both moments 51 and 52. 题解遍历一下会不会在 x 的时候叫即可 代码Pineapple Incident代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 35;bool Do() &#123; int t,s,x; if(scanf(\"%d%d%d\",&amp;t,&amp;s,&amp;x) == EOF) return false; bool flag = true; for(int i = 0;;i++) &#123; int time = t + i*s; if(x == time) &#123; printf(\"YES\\n\"); break; &#125; if(i != 0) &#123; int time = t + i*s + 1; if(x == time) &#123; printf(\"YES\\n\"); break; &#125; &#125; if(x &lt; time) &#123; printf(\"NO\\n\"); break; &#125; &#125; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"2016-07-11 ~ 2016-07-13 学习报告","date":"2016-07-13T16:20:10.000Z","path":"/post/Study/2016_07_11-2016_07_13.html","text":"题目： HDU 1087.Super Jumping! Jumping! Jumping! HDU 2571.命运","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"HDU 1069.Monkey and Banana","date":"2016-07-12T07:42:48.000Z","path":"/post/HDU/1069.html","text":"题目 Description A group of researchers are designing an experiment to test the IQ of a monkey. They will hang a banana at the roof of a building, and at the mean time, provide the monkey with some blocks. If the monkey is clever enough, it shall be able to reach the banana by placing one block on the top another to build a tower and climb up to get its favorite food. The researchers have n types of blocks, and an unlimited supply of blocks of each type. Each type-i block was a rectangular solid with linear dimensions (xi, yi, zi). A block could be reoriented so that any two of its three dimensions determined the dimensions of the base and the other dimension was the height. They want to make sure that the tallest tower possible by stacking blocks can reach the roof. The problem is that, in building a tower, one block could only be placed on top of another block as long as the two base dimensions of the upper block were both strictly smaller than the corresponding base dimensions of the lower block because there has to be some space for the monkey to step on. This meant, for example, that blocks oriented to have equal-sized bases couldn’t be stacked. Your job is to write a program that determines the height of the tallest tower the monkey can build with a given set of blocks. Input The input file will contain one or more test cases. The first line of each test case contains an integer n,representing the number of different blocks in the following data set. The maximum value for n is 30.Each of the next n lines contains three integers representing the values xi, yi and zi.Input is terminated by a value of zero (0) for n. Output For each test case, print one line containing the case number (they are numbered sequentially starting from 1) and the height of the tallest possible tower in the format “Case case: maximum height = height”. Sample Input 110 20 3026 8 105 5 571 1 12 2 23 3 34 4 45 5 56 6 67 7 7531 41 5926 53 5897 93 2384 62 6433 83 270 Sample Output Case 1: maximum height = 40Case 2: maximum height = 21Case 3: maximum height = 28Case 4: maximum height = 342 翻译 背景 一组研究人员设计了一个实验来测试智商的猴子他们在屋顶挂一个香蕉,同时,提供给猴子一些方块足够聪明的猴子,应当能通过堆方块,爬上屋顶拿到香蕉 研究人员有n种方块,每种有无限个第 i 种方块是一个长方体,各边长度为(xi,yi,zi)方块可以任意放置,也即可以用 xi , yi , zi 中任意一个当作高 确保能通过叠加方块可以到达屋顶问题在于,在向上搭时,每个方块必须放在比它小的方块上面,这是为了确保猴子有空间来当作阶梯向上爬这也就意味着,接触面大小相同的方块不能被摞在一起 你的工作是编写一个程序,计算根据所给的方块最高能够达到多高的高度 输入 输入包括多组数据每组数据的第一行包括一个整数 n 表示方块的种类数( n &lt;= 30 )接下来 n 行每行有三个数 xi , yi , zi当 n==0 时表示输入结束 输出 对于每组数据,在一行内输出 Case case: maximum height = height其中 case 从 1 开始, height 表示最大的高度 题解先粗略排下序,采用最长上升子序列的思路 将每个方块看作3个面,分别以3条棱做高,来描述一个方块的底面用 dp[i] 表示 面 i 作为最上面的方块的底面的情况下能达到最高的高度对于每个方块,找到所有比它大的方块,试试放上去后能达到什么高度,存上最高的那个 要判断两个方块是否满足一个能放到另一个上面,要判断是否严格小于由于位于结构体里,所以使用了静态函数关键词 static判断方框是否严格小于static bool cmp(Node &amp;a,Node &amp;b) &#123; return (a.x &lt; b.x &amp;&amp; a.y &lt; b.y);&#125; 有一点很重要 sort 函数使用的小于不能这样写！！ 比如有 (5,10) 、 (11,2) 、 (3,4) 按照上面的定义前一个都“小于”后一个,但是第三个却“小于”第一个 要让前面的思路成立,我们要把数据排序成每一个可能比它小的都放在它前面因此可以先按照两个数中较小的排序,再按照较大的那个排序这样可以确保每个比当前数据小的数据都在当前数据前面 代码Monkey and Banana代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 35;int kase = 0;struct Node &#123; int x,y,h; Node(int x = 0,int y = 0,int h = 0) &#123; this-&gt;x = min(x,y); this-&gt;y = max(x,y); this-&gt;h = h; &#125; bool operator &lt; (const Node &amp;rhs)const &#123; if(x == rhs.x) return y &lt; rhs.y; else return x &lt; rhs.x; &#125; static bool cmp(Node &amp;a,Node &amp;b) &#123; return (a.x &lt; b.x &amp;&amp; a.y &lt; b.y); &#125;&#125;;Node S[3 * maxn];int dp[3 * maxn];bool Do() &#123; int n; scanf(\"%d\",&amp;n); if(n == 0) return false; printf(\"Case %d: maximum height = \",++kase); for(int i = 0;i &lt; n;i++) &#123; int x,y,z; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); S[i * 3 + 1] = Node(x,y,z); S[i * 3 + 2] = Node(y,z,x); S[i * 3 + 3] = Node(z,x,y); &#125; sort(S,S + 3 * n + 1); int Max = 0; for(int i = 1;i &lt;= 3 * n;i++) &#123; dp[i] = 0; for(int j = 0;j &lt; i;j++) &#123; if(Node::cmp(S[j],S[i])) &#123; dp[i] = max(dp[i],dp[j] + S[i].h); &#125; &#125; Max = max(Max,dp[i]); &#125; printf(\"%d\\n\",Max); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最长上升子序列","slug":"LIS","permalink":"https://www.oyohyee.com/tags/LIS/"}]},{"title":"HDU 2571.命运","date":"2016-07-12T05:48:23.000Z","path":"/post/HDU/2571.html","text":"题目 Description 穿过幽谷意味着离大魔王lemon已经无限接近了！可谁能想到，yifenfei在斩杀了一些虾兵蟹将后，却再次面临命运大迷宫的考验，这是魔王lemon设下的又一个机关。要知道，不论何人，若在迷宫中被困1小时以上，则必死无疑！可怜的yifenfei为了去救MM，义无返顾地跳进了迷宫。让我们一起帮帮执着的他吧！命运大迷宫可以看成是一个两维的方格阵列，如下图所示： yifenfei一开始在左上角，目的当然是到达右下角的大魔王所在地。迷宫的每一个格子都受到幸运女神眷恋或者痛苦魔王的诅咒，所以每个格子都对应一个值，走到那里便自动得到了对应的值。现在规定yifenfei只能向右或者向下走，向下一次只能走一格。但是如果向右走，则每次可以走一格或者走到该行的列数是当前所在列数倍数的格子，即：如果当前格子是（x,y），下一步可以是（x+1,y），(x,y+1)或者(x,y*k) 其中k&gt;1。为了能够最大把握的消灭魔王lemon，yifenfei希望能够在这个命运大迷宫中得到最大的幸运值。 Input 输入数据首先是一个整数C，表示测试数据的组数。每组测试数据的第一行是两个整数n,m，分别表示行数和列数(1&lt;=n&lt;=20,10&lt;=m&lt;=1000)；接着是n行数据，每行包含m个整数，表示n行m列的格子对应的幸运值K ( |k|&lt;100 )。 Output 请对应每组测试数据输出一个整数，表示yifenfei可以得到的最大幸运值。 Sample Input 13 89 10 10 10 10 -10 10 1010 -11 -1 0 2 11 10 -20-11 -11 10 11 2 10 -10 -10 Sample Output 52 题解动态规划问题对于 (x,y) 可以由以下点到达 (x-1,y) (x,y-1) (x,k) 其中 k 是 y 的因数 那么,有dp[i][j] = max{ dp[i-1][j] , dp[i][j-1] , dp[i][k] } + Map[i][j]( k 是 y 的因数, Map[i][j] 是 (i,j) 的权值) 对于 i == 1 的情况需要特别处理 3 5-1 -1 -1 -1 -1-1 -1 -1 -1 -1-1 -1 -1 -1 -1 应该输出 -4 而不是 -3 dp部分for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; if(i == 1) if(j == 1) dp[i][j] = Map[i][j]; else dp[i][j] = dp[1][1] + Map[i][j]; else dp[i][j] = dp[i - 1][j] + Map[i][j]; for(int k = 1;k &lt; j;k++) if(j % k == 0 || k == j - 1) dp[i][j] = max(dp[i][j],dp[i][k] + Map[i][j]); &#125; 代码命运代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 25;const int maxm = 1005;int Map[maxn][maxm];int dp[maxn][maxm];void Do() &#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) scanf(\"%d\",&amp;Map[i][j]); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; if(i == 1) if(j == 1) dp[i][j] = Map[i][j]; else dp[i][j] = dp[1][1] + Map[i][j]; else dp[i][j] = dp[i - 1][j] + Map[i][j]; for(int k = 1;k &lt; j;k++) if(j % k == 0 || k == j - 1) dp[i][j] = max(dp[i][j],dp[i][k] + Map[i][j]); &#125; printf(\"%d\\n\",dp[n][m]);&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"Minecraft 服务器联机","date":"2016-07-12T05:00:46.000Z","path":"/post/Writing/MC.html","text":"联机真的是挺麻烦的~记录下过程,同时也作为服务器的进服指南~ 获得账号 进入 Minecraft官网 注册 支付宝付款 OK~ 进入游戏由于国内 MC 的火爆,有许多非官方启动器有各种 Mod 的强力整合例如 MinecraftElf (百度云下载) 运行后可以一键下载各种整合包 运行时会自动安装 Java 联机Minecraft 的精髓在于红石与联机联机有两种方法 局域网联机 服务器联机 局域网联机如果本身就处在局域网中,一个玩家新建一个世界后,点击 esc 选择 对局域网开放 其他同局域网的直接点多人游戏,就能看到好友的世界了 联在同个世界有以下方法 在同一个网吧中 wifi共享连接 Hamachi 远程局域网联机最好的办法应该是使用 Hamachi然而 Hamachi 被墙掉了~联机变得非常麻烦 服务器联机搜索一下可以找到很多 Minecraft 开服器如果有电脑是通过路由器连接网络的话,可以直接在路由器设置端口映射否则就需要一些软件来设置了常见的有 花生壳、nat123 花生壳的经过测试可以看到服务器,但是进不去用 nat123 可以进服务器不过域名比较难记想要绑定自己的域名还需要充值一次 以下内容请确保有基本的端口常识和自行百度的能力仅仅提供一个大致流程 在&gt;网上&lt;找到要开的服务器的服务端包 随便找个&gt;开服器&lt; 将服务器放到服务端的文件夹内自动搜索运行目录,保存 在文件配置等地方设置好参数记下 服务器端口号 25565 (可以是自己设置的其他的) 然后映射端口 如果有路由器的话,直接在路由器控制面板映射本地端口就行 否则,下载并安装 nat123 新建映射 全端口映射 或者 非网站映射 全端口映射 全端口映射需要别人也下载 nat123 才行,参照下面的部分 如图设置即可 外网域名我绑定到了自己的域名上,他给的实在太难记 非网站映射 非网站映射别人直接填服务器地址就能登陆,不过貌似有限速 映射后搭网站能正常访问,进服务器能搜到但是很难进去 同上 剩下的就是开服了~本机的话直接 127.0.0.1 可以无延迟进服务器,不过为了测试是否开服成功,最好还是用下面的方法,“正常”进一下服务器 分布式服务器这样做是不对的！！ GitHub是用来同步代码的！！！不是让你弄游戏的！！！自己的电脑自然不能24小时开着由于每次改变的只有地图,如果别人开这个服务器的话,只需要同步一下地图文件就行了要说同步,自然是 Git 了在 GitHub 新建代码仓库,在服务器的文件夹 git init 然后 push 到仓库里这样每次开服前 pull 下,结束后 push 下哪个小伙伴想玩就可以随时开服了 进入我的服务器私人服务器,外人还是不要进了点击链接加入群【我的世界与你的世界】：http://jq.qq.com/?_wv=1027&amp;k=2GEB1RI 连接服务器有两种方法 mc.oyohyee.com:15661 local.oyohyee.com 第一种方法直接输入即可,不过由于会很慢第二种方法需要额外安装软件 下面是第二种方法的具体情况 下载并安装 nat123 忽略登陆窗口 进入安装目录,找到 nat123visitor.exe 打开后输入域名: local.oyohyee.com端口: 25565 最后多人游戏服务器地址填 local.oyohyee.com 即可","tags":[{"name":"Minecraft","slug":"Minecraft","permalink":"https://www.oyohyee.com/tags/Minecraft/"}]},{"title":"最大上升子序列(最大递增子段和)","date":"2016-07-11T19:07:41.000Z","path":"/post/Algorithm/MIS.html","text":"没有找到相似的叫法,网上能搜到的有: 最大递增子段和 最大上升子段和 不过我更倾向于最大递增子段和因为其算法与&gt;动态规划版的最大上升子序列&lt;如出一辙 根据名字可以看出,最大上升子序列的意义为: 找出一个数列的递增子列中,和最大的那个子列 采用动态规划的解法:用 a[i] 来存储数列的第 i 个数用 dp[i] 来记录到数列的第 i 个数(选取它的情况下) 对于数列中的第 i 个数,显然有 i 种可能: 1. 子序列上一个是 1 2. 子序列上一个是 2 3. 子序列上一个是 3 4. 子序列上一个是 4 …… i. 从 i 开始 而显然,由于子序列要上升,因此如果 a[j] &lt;= a[i] 这种情况可以直接跳过的 也即 dp[i] = max{ dp[j]+a[i] } (j&lt;i &amp;&amp; a[j]&lt;a[i]) 由于最后可以从任意地方结束,因此答案不是 dp[n] 而是 dp[] 中最大的值可以维护一个 Max 变量 数据为 1~na[0] 表示起点,初始化为 0 MISint Max = 0;a[0] = 0;for(int i = 0;i &lt;= n;i++) &#123; dp[i] = 0; for(int j = 0;j &lt; i;j++) if(a[i] &gt; a[j]) dp[i] = max(dp[i],dp[j] + a[i]); Max = max(Max,dp[i]);&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"最大上升子序列","slug":"MIS","permalink":"https://www.oyohyee.com/tags/MIS/"}]},{"title":"HDU 1087.Super Jumping! Jumping! Jumping!","date":"2016-07-11T18:03:48.000Z","path":"/post/HDU/1087.html","text":"题目 Description Nowadays, a kind of chess game called “Super Jumping! Jumping! Jumping!” is very popular in HDU. Maybe you are a good boy, and know little about this game, so I introduce it to you now. The game can be played by two or more than two players. It consists of a chessboard（棋盘）and some chessmen（棋子）, and all chessmen are marked by a positive integer or “start” or “end”. The player starts from start-point and must jumps into end-point finally. In the course of jumping, the player will visit the chessmen in the path, but everyone must jumps from one chessman to another absolutely bigger (you can assume start-point is a minimum and end-point is a maximum.). And all players cannot go backwards. One jumping can go from a chessman to next, also can go across many chessmen, and even you can straightly get to end-point from start-point. Of course you get zero point in this situation. A player is a winner if and only if he can get a bigger score according to his jumping solution. Note that your score comes from the sum of value on the chessmen in you jumping path.Your task is to output the maximum value according to the given chessmen list. Input Input contains multiple test cases. Each test case is described in a line as follow:N value_1 value_2 …value_NIt is guarantied that N is not more than 1000 and all value_i are in the range of 32-int.A test case starting with 0 terminates the input and this test case is not to be processed. Output For each case, print the maximum according to rules, and one line one case. Sample Input 3 1 3 24 1 2 3 44 3 3 2 10 Sample Output 4103 翻译 背景 现在,在航电有一种叫做“超级跳！跳！跳！”的游戏非常流行或许你这么爱学习的孩子对这个游戏知道的不多,我来给你介绍下~ 游戏需要不少于两个玩家,包括一个棋盘和一些棋子,并且每一个棋子都有一个正数或者 “start” 、 “end” 标记玩家从 “start” 标记的棋子开始,结束于 “end” 标记的棋子玩家可以跳到比当前棋子大的棋子上(将开始棋子看作最小,终点棋子看作最大)玩家不能往回跳并且可以跳任意的距离得分为跳到的棋子的总和也就是说玩家可以直接从起点跳到终点(0分)你的就是计算出最多能得到多少分(跳多少次) 输入 输入包括多组数据(以 0 结束)每组数据第一个数 N ( N&lt;=1000 )代表棋子个数而后 N 个数分别代表棋子上的数(32位的 int ) 输出 对于每组数据,在一行内输出最大值 题解从一组数据中选择出一组递增的子序列,使子序列和最大也即找出&gt;最大上升子序列&lt;用 dp[i] 表示跳到第 i 个棋子能达到的最大分数有 dp[i] = max{ dp[j]+a[i] } (j&lt;i &amp;&amp; a[j]&lt;a[i]) 最后可以在任一棋子跳出,就需要找出 dp[] 中的最大值 使用最大上升子序列来计算 dp[] 最大上升子序列int Max = 0;a[0] = 0;for(int i = 0;i &lt;= n;i++) &#123; dp[i] = 0; for(int j = 0;j &lt; i;j++) if(a[i] &gt; a[j]) dp[i] = max(dp[i],dp[j] + a[i]); Max = max(Max,dp[i]);&#125; 代码Jumping! Jumping! Jumping!代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 1005;int a[maxn];int dp[maxn];bool Do() &#123; int n; scanf(&quot;%d&quot;,&amp;n); if(n == 0) return false; for(int i = 1;i &lt;= n;i++) scanf(&quot;%d&quot;,&amp;a[i]); int Max = 0; a[0] = 0; for(int i = 0;i &lt;= n;i++) &#123; dp[i] = 0; for(int j = 0;j &lt; i;j++) if(a[i] &gt; a[j]) dp[i] = max(dp[i],dp[j] + a[i]); Max = max(Max,dp[i]); &#125; printf(&quot;%d\\n&quot;,Max); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最大上升子序列","slug":"MIS","permalink":"https://www.oyohyee.com/tags/MIS/"}]},{"title":"2016-07-08 ~ 2016-07-10 学习报告","date":"2016-07-10T17:20:10.000Z","path":"/post/Study/2016_07_08-2016_07_10.html","text":"题目： AOJ 774.石油探测 AOJ 775.迷宫问题 AOJ 776.马的走法 AOJ 777.平方个数 AOJ 778.乘积为n个1的数字游戏 AOJ 780.分解质因数 AOJ 784.平面分隔问题","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"AOJ 784.平面分隔问题","date":"2016-07-10T16:37:15.000Z","path":"/post/AOJ/784.html","text":"题目 Description 在平面上画n条封闭的曲线，各曲线之间两两相交于两点，并且三条封闭的曲线都不相交于一点，求这样的n条曲线将平面分为多少个区域。 Input 输入包括多组数据，每组数据占一行，且只有一个整数n(0&lt;=n&lt;=1000)，当n=0时表示输入结束。 Output 对每组测试数据输出一行结果，结果为一个整数，表示这n条曲线将平面划分成的区域数。 Sample Input 130 Sample Output 28 题解根据数学关系得出:a[n] = a[n - 1] + 2*(n - 1) 记忆化搜索然后计算即可 代码平面分隔问题代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.com かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std; const int maxn = 1005; int Dp[maxn];int dp(int n) &#123; return Dp[n] = Dp[n]?Dp[n]:dp(n - 1) + 2*(n - 1);&#125; bool Do() &#123; int n; scanf(\"%d\",&amp;n); if(n==0) return false; printf(\"%d\\n\",dp(n)); return true;&#125; int main() &#123; Dp[1] = 2; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"记忆化搜索","slug":"Memory-Search","permalink":"https://www.oyohyee.com/tags/Memory-Search/"}]},{"title":"AOJ 780.分解质因数","date":"2016-07-10T16:30:08.000Z","path":"/post/AOJ/780.html","text":"题目 Description 给出一个正整数m, 将其分解成质数相乘的形式，即 m=m1m2m3….mk. 其中mi为质数，并且满足m1&lt;=m2&lt;=m3&lt;=….&lt;=mk。若m本身就是质数，则直接输出m=m即可。 Input 输入包括多组测试数据，每组测试数据占一行，并且只有一个正整数m，当m=0时，表示输入结束。 Output 对每组测试数据输出一个结果，并占一行。 Sample Input 12523100 Sample Output 12=2*2*35=52310=2*3*5*7*11 题解第一步首先是要得到一个质数表使用 &gt;筛法求质数&lt; 得到质数表后,从小到大试除每一个质数(可以相等) 每有一个满足就输出这个数即可 代码分解质因数代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.com かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std; const int maxn = 1000005; int prime[maxn] = &#123;0&#125;,num_prime = 0;bool isNotPrime[maxn] = &#123;1,1&#125;; void Prime() &#123; for(long i = 2;i &lt; maxn;i++) &#123; if(!isNotPrime[i])prime[num_prime++] = i; for(int j = 0;j &lt; num_prime&amp;&amp;i*prime[j] &lt; maxn;j++) &#123; isNotPrime[i*prime[j]] = true; if(!(i%prime[j]))break; &#125; &#125;&#125; bool Do() &#123; int n; scanf(\"%d\",&amp;n); if(n == 0) return false; printf(\"%d=\",n); if((n &lt; maxn) &amp;&amp; (!isNotPrime[n] || n == 1)) &#123; printf(\"%d\\n\",n); &#125; else &#123; bool first = true; for(int i = 0;i &lt; num_prime &amp;&amp; n&gt;1;i++) &#123; while(!(n%prime[i])) &#123; if(!first) printf(\"*\"); first = false; printf(\"%d\",prime[i]); n /= prime[i]; &#125; &#125; printf(\"\\n\"); &#125; return true;&#125; int main() &#123; Prime(); while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"质数","slug":"Prime","permalink":"https://www.oyohyee.com/tags/Prime/"}]},{"title":"778.乘积为n个1的数字游戏","date":"2016-07-09T10:40:27.000Z","path":"/post/AOJ/778.html","text":"题目 Description 两位计算机爱好者在进行“积为n个1的数字游戏”，其中一位给定一个正整数p(约定整数p为个位数字不是5的奇数)，另一位寻求正整数q，使得p与q之积全是1组成的整数。 Input 第1行是测试数据的组数t，每组测试数据占1行，每行包括一个个位数字不是5的奇数p。 Output 对应每组测试数据输出共1行，每行输出两个整数，之间有一个空格分隔，一个是满足条件的整数q, 另一个是p与q之积的1的个数，输入数据保证一定有解，如果有多组解，请输出1最少的一个解。 Sample Input 311989 Sample Output 1 212345679 9124843945068664169787765293383270911360799 44 题解看着是高精度计算,但是模拟下可以发现不需要高精度计算只需要提取出高精度计算的除法的一部分即可 如果能除尽就代表已经找到了答案,否则就将余数乘 10 加 1 当作被除数如此循环下去 代码乘积为n个1的数字游戏代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.com かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std; void Do() &#123; int p; scanf(\"%d\",&amp;p); int k; int a = 0; bool flag = false; for(k = 1;;k++) &#123; a = a * 10 + 1; if(a &lt; p) &#123; if(flag) printf(\"0\"); continue; &#125; int b = a / p; int c = a % p; printf(\"%d\",b); flag = true; if(c == 0) &#123; printf(\" %d\\n\",k); break; &#125; a = c; &#125;&#125; int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[]},{"title":"AOJ 777.平方个数","date":"2016-07-09T10:36:16.000Z","path":"/post/AOJ/777.html","text":"题目 Description 对给定的整数X, 统计出小于等于X的整数中满足这样条件的正整数的个数，其平方数为一个9位数，并且其各位数字各不同。 Input 第1行 是测试数据的组数t，每组测试数据占一行，每行包括一个位长为5位的正整数X. Output 对应每组测试数据输出共t行，每行为满足条件的数的个数。 Sample Input 21000060000 Sample Output 083 题解平方是 9 位数的数满足 [10000,31622]判断 10000 ~ min(n,31622) 之间所有的数的平方 对于每个数判断每一位是不是相同即可 要注意,题目要求是小于等于 代码平方个数代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.com かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std; bool vis[10];void Do() &#123; int n; scanf(\"%d\",&amp;n); int cnt = 0; for(int i = 10000;i &lt;= 31622 &amp;&amp; i &lt;= n;i++) &#123; memset(vis,false,sizeof(vis)); bool flag = true; int k = i*i; while(k) &#123; if(vis[k % 10]) &#123; flag = false; break; &#125; vis[k % 10] = true; k /= 10; &#125; if(flag) cnt++; &#125; printf(\"%d\\n\",cnt);&#125; int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[]},{"title":"AOJ 776.马的走法","date":"2016-07-09T10:23:30.000Z","path":"/post/AOJ/776.html","text":"题目 Description 在一个4×5的棋盘上，输入马的起始位置坐标(纵，横)位置，求马能返回初始位置的所有不同走法的总数(马走过的位置不能重复，马走“日”字)。 Input 输入只有一行，包括两个整数，既马的起始位置坐标x和y值，并且，这个坐标一定在4×5的小棋盘上，即 0 Output 一个整数，为能返回到初始位置的所有不同走法的总数。 Sample Input 2 21 11 3 Sample Output 459615084772 题解对于一个马有 8 种跳法 由于在每一种方案中不能重复跳同一格,但是调整次序达到相同效果看作不同跳法 因此需要一个数组记录是否跳过某个点,采用DFS算法,开始递归时标记该点,结束这个递归时取消标记 每次向 8 个方向拓展即可 由于只有 4 * 5 的格子可以直接打表 代码打表#include &lt;cstdio&gt;const int ans[4][5] = &#123; &#123;1508,3457,4772,3457,1508&#125;, &#123;3551,4596,5460,4596,3551&#125;, &#123;3551,4596,5460,4596,3551&#125;, &#123;1508,3457,4772,3457,1508&#125;&#125;;int vx,vy;bool Do() &#123; if(scanf(\"%d%d\",&amp;vx,&amp;vy) == EOF) return false; printf(\"%d\\n\",ans[vx-1][vy-1]); return true;&#125;int main() &#123; while(Do()); return 0;&#125; 马的走法代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 105;const int delta[] = &#123;-1,-1,1,1,2,-2,2,-2&#125;;bool vis[10][10];int vx,vy;int cnt;void DFS(int x,int y) &#123; if(x == vx&amp;&amp;y == vy) &#123; cnt++; if(cnt) return; &#125; if(vis[x][y]) return; vis[x][y] = true; for(int i = 0;i &lt; 8;i++) &#123; int xx = x + delta[i]; int yy = y + delta[7 - i]; if(!(xx &gt;= 1 &amp;&amp; xx &lt;= 4 &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= 5)) continue; DFS(xx,yy); &#125; vis[x][y] = false;&#125;bool Do() &#123; if(scanf(\"%d%d\",&amp;vx,&amp;vy) == EOF) return false; memset(vis,false,sizeof(vis)); cnt = -1; DFS(vx,vy); printf(\"%d\\n\",cnt); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"DFS","slug":"DFS","permalink":"https://www.oyohyee.com/tags/DFS/"}]},{"title":"AOJ 775.迷宫问题","date":"2016-07-09T10:20:39.000Z","path":"/post/AOJ/775.html","text":"题目 Description 由M行N列的方格构成一个迷宫，相邻方格之间可能是相通的，也可能有隔墙，各方格位置由对应坐标确定。在（1,1）处由入口，在（M,N）处有一个出口，在入口和出口之间有路相通，求从入口到出口的最短路径，若无法到达，输出“-1” Input 第1行有两个整数，M，N(2&lt;=M，N&lt;=10)， 接下来是M*N的0,1矩阵 0表示通路，1表示墙（数据保证入口和出口为通路）。 Output 输出最短路径 Sample Input 6 80 0 1 0 0 0 1 11 0 0 0 1 0 0 00 0 0 1 1 0 1 11 1 0 1 0 0 0 00 0 0 0 0 1 0 11 0 1 0 0 0 0 0 Sample Output 12 题解最短路问题,使用BFS求解即可 代码迷宫问题代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.com かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std; const int maxn = 105;const int delta[] = &#123;-1,1,0,0&#125;; int Map[maxn][maxn];bool vis[maxn][maxn];int dis[maxn][maxn]; bool Do() &#123; int m,n; if(scanf(\"%d%d\",&amp;n,&amp;m)==EOF) return false; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) scanf(\"%d\",&amp;Map[i][j]); memset(vis,false,sizeof(vis)); queue&lt;pair&lt;int,int&gt; &gt; Q; vis[1][1] = true; Q.push(pair&lt;int,int&gt;(1,1)); dis[1][1] = 0; dis[n][m] = -1; while(!Q.empty()) &#123; int x = Q.front().first; int y = Q.front().second; Q.pop(); if(x == n &amp;&amp; y == m) break; for(int i = 0;i &lt; 4;i++) &#123; int xx = x + delta[i]; int yy = y + delta[3 - i]; if(!(xx &gt;= 1 &amp;&amp; x &lt;= n&amp;&amp;yy &gt;= 1 &amp;&amp; yy &lt;= m)) continue; if(vis[xx][yy]) continue; if(Map[xx][yy]) continue; vis[xx][yy] = true; dis[xx][yy] = dis[x][y] + 1; Q.push(pair&lt;int,int&gt;(xx,yy)); &#125; &#125; printf(\"%d\\n\",dis[n][m]); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"}]},{"title":"AOJ 774.石油探测","date":"2016-07-09T09:51:57.000Z","path":"/post/AOJ/774.html","text":"题目 Description 地质探测公司负责探测地下石油资源，每次在一块矩形的区域上查找。探测人员用把这块矩形区域分成 了N X M个正方形小块，然后对每个正方形小块分别进行分析，经过分析之后，为每个小块都做了一个标记，如果一个小块地下发现有石油，则用“@”标记,否则用”.标记”。如果两个含有石油的小块是相邻的，那么它们属于同一块石油地，这里的相邻包括水平，垂直，或者对角相邻。给定一块已经标记过的矩形区域，你的任务是找出这块区域上的石油地的个数 Input 本题有多组输入数据。对于每一组输入数据，第一行输入两个数M，N，（1&lt;=M,N&lt;=100）,接下来是M行，每行含有N个字符,每个字符要么是“@”,要么是”*”。 Output 对于每组数据，输出一行，包含一个整数,它表示石油的地块数 Sample Input 1 1*3 5*@*@***@***@*@*1 8@@****@*5 5****@*@@*@*@**@@@@*@@@**@0 0 Sample Output 0122 题解POJ 1562 Oil Deposits 的中文版 读入后遍历所有位置,如果从未访问过并且有油井,则记录同时递归遍历其相邻所有位置放置访问标记 这道题在AOJ上的输入结束不是 0 0应该使用 EOF 判断 代码石油探测代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.com かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std; const int maxn = 105; char Map[maxn][maxn];int cnt;int m,n; void DFS(int i,int j) &#123; Map[i][j] = '*'; for(int d1 = -1;d1 &lt;= 1;d1++) for(int d2 = -1;d2 &lt;= 1;d2++) if(!(d1 == 0 &amp;&amp; d2 == 0)) if(i + d1 &gt;= 0 &amp;&amp; i + d1 &lt; n &amp;&amp; j + d2 &gt;= 0 &amp;&amp; j + d2 &lt; m) if(Map[i + d1][j + d2] == '@') DFS(i + d1,j + d2);&#125; bool Do() &#123; if(scanf(\"%d%d\",&amp;n,&amp;m) == EOF) return false; if(m == 0 || n == 0) return false; cnt = 0; for(int i = 0;i &lt; n;i++) scanf(\"\\n%s\",&amp;Map[i]); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) if(Map[i][j] == '@') &#123; cnt++; DFS(i,j); &#125; printf(\"%d\\n\",cnt); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"DFS","slug":"DFS","permalink":"https://www.oyohyee.com/tags/DFS/"}]},{"title":"2016-07-05 ~ 2016-07-07 学习报告","date":"2016-07-07T15:42:23.000Z","path":"/post/Study/2016_07_05-2016_07_07.html","text":"题目： HDU 1505.City Game HDU 2602.Bone Collector","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"HDU 2602.Bone Collector","date":"2016-07-07T15:13:20.000Z","path":"/post/HDU/2602.html","text":"题目 Description Many years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave …The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the maximum of the total value the bone collector can get Input The first line contain a integer T , the number of cases.Followed by T cases , each case three lines , the first line contain two integer N , V, (N &lt;= 1000 , V &lt;= 1000 )representing the number of bones and the volume of his bag. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone. Output One integer per line representing the maximum of the total value (this number will be less than 231). Sample Input 15 101 2 3 4 55 4 3 2 1 Sample Output 14 翻译 描述 很多年前,在 Teddy 的家乡有一个“集骨者”的传说“集骨者”会收集各种各样的骨头,狗、牛……他甚至会进入坟墓来获取骨头“集骨者”有一个容量为 V 的背包,显然在他的旅行中,这就是他放骨头的地方不同的骨头价值不同,体积也不同,现在给你每一个骨头的价值和体积,你能计算出在容量许可范围能,最多能收集多大价值的骨头么? 输入第一行是 T 数据组数每组数据有一个 N 、 V ( N &lt;= 1000, V &lt;= 1000)分别是骨头的数量和背包的最大容量接下来一行有 N 个整数,表示骨头的价值下面一行也有 N 个整数,表示骨头的体积 输出一行不超过232的整数 题解标准的&gt;背包问题 - 01背包问题&lt; 标准到不能更标准的01背包问题 代码Bone Collector代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 1005;int v,n;int dp[maxn];int value[maxn];int vol[maxn];void ZeroOnePack(int cost,int weight) &#123; for(int i = v; i &gt;= cost; i--) dp[i] = max(dp[i],dp[i - cost] + weight);&#125;void Do() &#123; scanf(\"%d%d\",&amp;n,&amp;v); for(int i = 1;i &lt;= n;i++) scanf(\"%d\",&amp;value[i]); for(int i = 1;i &lt;= n;i++) scanf(\"%d\",&amp;vol[i]); memset(dp,0,sizeof(dp)); for(int i = 1;i &lt;= n;i++) ZeroOnePack(vol[i],value[i]); printf(\"%d\\n\",dp[v]);&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"HDU 1505.City Game","date":"2016-07-07T15:00:00.000Z","path":"/post/HDU/1505.html","text":"题目 Description Bob is a strategy game programming specialist. In his new city building game the gaming environment is as follows: a city is built up by areas, in which there are streets, trees,factories and buildings. There is still some space in the area that is unoccupied. The strategic task of his game is to win as much rent money from these free spaces. To win rent money you must erect buildings, that can only be rectangular, as long and wide as you can. Bob is trying to find a way to build the biggest possible building in each area. But he comes across some problems – he is not allowed to destroy already existing buildings, trees, factories and streets in the area he is building in. Each area has its width and length. The area is divided into a grid of equal square units.The rent paid for each unit on which you’re building stands is 3$. Your task is to help Bob solve this problem. The whole city is divided into K areas. Each one of the areas is rectangular and has a different grid size with its own length M and width N.The existing occupied units are marked with the symbol R. The unoccupied units are marked with the symbol F. Input The first line of the input contains an integer K – determining the number of datasets. Next lines contain the area descriptions. One description is defined in the following way: The first line contains two integers-area length M&lt;=1000 and width N&lt;=1000, separated by a blank space. The next M lines contain N symbols that mark the reserved or free grid units,separated by a blank space. The symbols used are: R – reserved unit F – free unit In the end of each area description there is a separating line. Output For each data set in the input print on a separate line, on the standard output, the integer that represents the profit obtained by erecting the largest building in the area encoded by the data set. Sample Input 25 6R F F F F FF F F F F FR R R F F FF F F F F FF F F F F F 5 5R R R R RR R R R RR R R R RR R R R RR R R R R Sample Output 450 翻译 描述 Bob 是一个战略游戏制作人.在他新的城市建设游戏中,游戏设定如下:城市按照包括街道、树木、工厂、建筑的区域建设,同时有部分空闲的区域战略目标是从空闲地域赢取尽可能多的钱为了获得租金,你需要尽可能大地建筑长方形的房屋区域.Bob在尝试寻求一个能够在每个区域能尽可能多建的方案但是他遇到了困难——他不能摧毁已经建好的区域 每个区域有宽度和高度,区域被分成多个相同的正方形单元,每个单元的租金为3$ 你的任务是帮助Bob解决这个问题.整个城市分成 K 个区域.每一个区域都是长方形的并且面积不同已经有建筑的区域标记为 R ,未建筑的区域标记为 F 输入 第一行包括一个整数 K 表示区域的数目接下来的区域进行描述每个区域由 M 、 N 开始,分别代表区域的宽和高( M、N &lt;= 1000 )接下来 M 行每行有 N 个字符,用符号:R - 已使用区域F - 空闲区域每个区域结尾有一个空行 输出 对于每组数据将能够赚取的最多的钱数输出在一行中 题解在一块区域内求取最大矩形和 &gt;HDU 1506.Largest Rectangle in a Histogram&lt; 类似 以每一层为基线运算上面的题即可 多计算一个高度即可 最后的最大面积要 *3 代码City Game代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 1005;bool Map[maxn][maxn];int H[maxn][maxn];int Left[maxn][maxn];int Right[maxn][maxn];//int S[maxn][maxn];void Do() &#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); memset(Map,0,sizeof(Map)); memset(H,0,sizeof(H)); memset(Left,0,sizeof(Left)); memset(Right,0,sizeof(Right)); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; char temp; scanf(\"\\n%c\",&amp;temp); if(temp == 'R') Map[i][j] = false; else Map[i][j] = true; &#125; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; if(Map[i][j]) &#123; if(Map[i - 1][j]) H[i][j] = H[i - 1][j] + 1; else H[i][j] = 1; &#125; &#125; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; if(Map[i][j]) &#123; int t = j; while(t &gt;= 1 &amp;&amp; H[i][j] &lt;= H[i][t - 1]) t = Left[i][t - 1]; Left[i][j] = t; &#125; &#125; for(int i = 1;i &lt;= n;i++) for(int j = m;j &gt;= 1;j--) &#123; if(Map[i][j]) &#123; int t = j; while(t &lt;= m &amp;&amp; H[i][j] &lt;= H[i][t + 1]) t = Right[i][t + 1]; Right[i][j] = t; &#125; &#125; int Max = 0; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) &#123; if(Map[i][j]) &#123; int S = H[i][j]*(Right[i][j] - Left[i][j] + 1); Max = max(Max,S); &#125; &#125; printf(\"%d\\n\",Max*3);&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最大矩形","slug":"Max-Rectangle","permalink":"https://www.oyohyee.com/tags/Max-Rectangle/"}]},{"title":"2016-07-02 ~ 2016-07-04 学习报告","date":"2016-07-04T16:20:10.000Z","path":"/post/Study/2016_07_02-2016_07_04.html","text":"题目： AOJ 767.统计字符数 AOJ 768.密码问题 AOJ 769.大数加法 AOJ 770.大整数乘法 AOJ 771.大整数除法 AOJ 772.完美立方 AOJ 773.数字三角形 HDU 1506.Largest Rectangle in a Histogram Codeforces 639A.Bear and Displayed Friends Codeforces 639B.Bear and Forgotten Tree 3","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"Codeforces 639B.Bear and Forgotten Tree 3","date":"2016-07-04T16:01:17.000Z","path":"/post/Codeforces/639B.html","text":"题目 Description A tree is a connected undirected graph consisting of n vertices and n - 1 edges. Vertices are numbered 1 through n. Limak is a little polar bear and Radewoosh is his evil enemy. Limak once had a tree but Radewoosh stolen it. Bear is very sad now because he doesn’t remember much about the tree — he can tell you only three values n, d and h: The tree had exactly n vertices.The tree had diameter d. In other words, d was the biggest distance between two vertices.Limak also remembers that he once rooted the tree in vertex 1 and after that its height was h. In other words, h was the biggest distance between vertex 1 and some other vertex.The distance between two vertices of the tree is the number of edges on the simple path between them. Help Limak to restore his tree. Check whether there exists a tree satisfying the given conditions. Find any such tree and print its edges in any order. It’s also possible that Limak made a mistake and there is no suitable tree – in this case print “-1”. Input The first line contains three integers n, d and h (2 ≤ n ≤ 100 000, 1 ≤ h ≤ d ≤ n - 1) — the number of vertices, diameter, and height after rooting in vertex 1, respectively. Output If there is no tree matching what Limak remembers, print the only line with “-1” (without the quotes). Otherwise, describe any tree matching Limak’s description. Print n - 1 lines, each with two space-separated integers – indices of vertices connected by an edge. If there are many valid trees, print any of them. You can print edges in any order. Sample Input Input 5 3 2 Output 1 21 33 43 5 Input 8 5 2 Output -1 Input 8 4 2 Output 4 85 72 38 12 15 61 5 题解这道题的解只需要输出任意一组解即可输入的 n 、 d 、 h 分别是节点数、最大距离、从 1 的最大距离由于不需要考虑解的输出问题因此我们可以只考虑最简单的情况 例如第一组样例( 5 3 2 )我们先考虑 h 从 1 开始最远要连到 2因此连接 1 -&gt; 2 、 2 -&gt; 3又由于最远只能连接到 3 ,除去已经连接的 2 应该有 连接长度不超过 h 并且与 h 加起来不超过 d可以继续连接 d-h 长度 1 -&gt; 4 最后将没有连接的节点都连接到 1 分析下 需要输出 0 的情况为 h * 2 &lt; d 即在满足从 1 出发的最远为 h 的情况下不可能最远为 d 而我们还可以额外考虑下 d == h 的情况如果 d == 1 &amp;&amp; h == 1 显然只有 n == 2 可能有解(画一下就能明白) 而其他情况(如 5 2 2 )可以发现,有如图的情况是合法的 考虑好这些情况即可~ 代码Bear and Forgotten Tree 3代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 150005;bool Do() &#123; int n,d,h; if(scanf(\"%d%d%d\",&amp;n,&amp;d,&amp;h) == EOF) return false; //printf(\"\\n%d %d %d\\n\",n,d,h); if(h * 2 &lt; d) &#123; printf(\"-1\\n\"); return true; &#125; if(d == h) &#123; if(d == 1 &amp;&amp; n != 2) &#123; printf(\"-1\\n\"); return true; &#125; int pos = 2; for(int i = 0;i &lt; h;i++) &#123; printf(\"%d %d\\n\",pos - 1,pos); pos++; &#125; while(pos &lt;= n) printf(\"2 %d\\n\",pos++); &#125; else &#123; int pos = 2; for(int i = 0;i &lt; h;i++) &#123; printf(\"%d %d\\n\",pos - 1,pos); pos++; &#125; for(int i = 0;i &lt; d - h;i++) &#123; if(i == 0) &#123; printf(\"1 %d\\n\",pos); &#125; else &#123; printf(\"%d %d\\n\",pos - 1,pos); &#125; pos++; &#125; while(pos &lt;= n) printf(\"1 %d\\n\",pos++); &#125; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"Codeforces 639A.Bear and Displayed Friends","date":"2016-07-04T16:00:07.000Z","path":"/post/Codeforces/639A.html","text":"题目 Description Limak is a little polar bear. He loves connecting with other bears via social networks. He has n friends and his relation with the i-th of them is described by a unique integer ti. The bigger this value is, the better the friendship is. No two friends have the same value ti. Spring is starting and the Winter sleep is over for bears. Limak has just woken up and logged in. All his friends still sleep and thus none of them is online. Some (maybe all) of them will appear online in the next hours, one at a time. The system displays friends who are online. On the screen there is space to display at most k friends. If there are more than k friends online then the system displays only k best of them — those with biggest ti. Your task is to handle queries of two types: “1 id” — Friend id becomes online. It’s guaranteed that he wasn’t online before.“2 id” — Check whether friend id is displayed by the system. Print “YES” or “NO” in a separate line.Are you able to help Limak and answer all queries of the second type? Input The first line contains three integers n, k and q (1 ≤ n, q ≤ 150000, 1 ≤ k ≤ min(6, n)) — the number of friends, the maximum number of displayed online friends and the number of queries, respectively. The second line contains n integers t1, t2, …, tn (1 ≤ ti ≤ 109) where ti describes how good is Limak’s relation with the i-th friend. The i-th of the following q lines contains two integers typei and idi (1 ≤ typei ≤ 2, 1 ≤ idi ≤ n) — the i-th query. If typei = 1 then a friend idi becomes online. If typei = 2 then you should check whether a friend idi is displayed. It’s guaranteed that no two queries of the first type will have the same idi becuase one friend can’t become online twice. Also, it’s guaranteed that at least one query will be of the second type (typei = 2) so the ## Output won’t be empty. OutputFor each query of the second type print one line with the answer — “YES” (without quotes) if the given friend is displayed and “NO” (without quotes) otherwise. Sample Input Input 4 2 8300 950 500 2001 32 42 31 11 22 12 22 3 Output NOYESNOYESYES Input 6 3 950 20 51 17 99 241 31 41 51 22 42 21 12 42 3 Output NOYESNOYES 题解题目大致意思就是查询好友是否在线如果好友超过限制,则下线友情度较低的好友 使用优先队列维护在线好友,如果超过限制就将好友出队 由于优先队列不能使用迭代器,因此额外维护一个布尔数组记录编号为 i 的好友是否在队列中 代码Bear and Displayed Friends代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 150005;int weight[maxn];struct Node &#123; int n; Node(int a) &#123; n = a; &#125; bool operator &lt; (const Node &amp;rhs)const &#123; return weight[n] &gt; weight[rhs.n]; &#125;&#125;;priority_queue&lt;Node&gt; Q;bool flag[maxn];void init() &#123; memset(flag,false,sizeof(flag)); while(!Q.empty()) Q.pop();&#125;bool Do() &#123; int n,k,q; if(scanf(\"%d%d%d\",&amp;n,&amp;k,&amp;q)==EOF) return false; init(); for(int i = 1;i &lt;= n;i++) scanf(\"%d\",&amp;weight[i]); for(int i = 0;i &lt; q;i++) &#123; int com; scanf(\"%d\",&amp;com); if(com == 1) &#123; int t; scanf(\"%d\",&amp;t); flag[t] = true; Q.push(Node(t)); while((int)Q.size() &gt; k) &#123; flag[Q.top().n] = false; Q.pop(); &#125; &#125; else &#123; int t; scanf(\"%d\",&amp;t); if(flag[t]) printf(\"YES\\n\"); else printf(\"NO\\n\"); &#125; &#125; //printf(\"\\n\"); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"HDU 1506.Largest Rectangle in a Histogram","date":"2016-07-03T17:30:15.000Z","path":"/post/HDU/1506.html","text":"题目 Description A histogram is a polygon composed of a sequence of rectangles aligned at a common base line. The rectangles have equal widths but may have different heights. For example, the figure on the left shows the histogram that consists of rectangles with the heights 2, 1, 4, 5, 1, 3, 3, measured in units where 1 is the width of the rectangles: http://acm.hdu.edu.cn/data/images/1506-1.gif Usually, histograms are used to represent discrete distributions, e.g., the frequencies of characters in texts. Note that the order of the rectangles, i.e., their heights, is important. Calculate the area of the largest rectangle in a histogram that is aligned at the common base line, too. The figure on the right shows the largest aligned rectangle for the depicted histogram. InputThe input contains several test cases. Each test case describes a histogram and starts with an integer n, denoting the number of rectangles it is composed of. You may assume that 1 &lt;= n &lt;= 100000. Then follow n integers h1, …, hn, where 0 &lt;= hi &lt;= 1000000000. These numbers denote the heights of the rectangles of the histogram in left-to-right order. The width of each rectangle is 1. A zero follows the input for the last test case. Output For each test case output on a single line the area of the largest rectangle in the specified histogram. Remember that this rectangle must be aligned at the common base line. Sample Input 7 2 1 4 5 1 3 34 1000 1000 1000 10000 Sample Output 84000 翻译 背景描述 直方图是在同一条底线上由多个正方形构成的图形.每个正方形宽度相同,但是高度可能不同.举例来说,如下图,用宽度为单位1,左侧的直方图有着高度分别为2,1,4,5,1,3,3 http://acm.hdu.edu.cn/data/images/1506-1.gif 通常,直方图被用作描述离散分布关系通常,使用直方图来表示离散分布例如:数据的频率注意数据的顺序另外:他们的高度也是很重要的计算最大矩形的面积直方图中常见的基线对齐.右边的图显示了直方图的最大矩形. 输入 输入包括多组数据每组数据描述了一个直方图。数据以n开始,表示了长方形的数目(1&lt;=n&lt;=100)而后包括n个整数h1,h2……hn(0&lt;=hn&lt;=1000000000)这些数据从左到右描述了长方形的高度长方形的宽度为1在所有数据的最后是一个0 输出 对于每组数据,在一行内输入一个整数,表示直方图最大的长方形面积长方形必须在底部的基线对齐 题解如果暴力枚举的话,需要枚举左边界 l 和右边界 r 同时要计算范围内高度的最小值时间复杂度是 O(n2) 由于是 dp 专题,尝试使用 dp 的思路求解首先要找到状态关系 对于 i 我们可以根据所有小于 i 已求得的数据来计算出 i 的结果如果自己数的话,可以将所有非递增的小矩形看成一个整体每组矩形里,最小的是小组内最后一个矩形维护 Begin、Min 两个数组,分别记录 i 对应的小组第一个元素的下标和小组最小的元素的值 对于新读入的 h只需要判断 i ( h 的下标)到每个 &lt;=i 的 Begin 组成的矩形即可 然而,仔细分析,发现这种方法还是超时,在最坏情况下其实是与暴力解法是一样的 换一种思路如果枚举高度计算每种高度所能达到的最大值,再找它的最大值 对于 i 在没有遇到比它高的数的前提下,尽可能向左向右拓展所能达到范围,就是这个高度所能取得的最大宽度而高度就是其本身高度 对于两个同样高度的矩形如果他们在同一区域,能拓展到对方,则相当于重复计算了一次如果不在同一区域,则相当于计算了两组数据 使用这种算法,在找好 l 和 r 数组后,只需要 O(n) 的时间 而如果直接生成 l 和 r 数组,时间复杂度又成了 O(n2)因此可以采用动态规划的思路类似上面只判断每一组端点的方法 先向左、向右刷一遍数组,对每个 i 跳着找到端点如果有一次遇到最坏情况,则必然有一个是最好情况与其对应因此尽管最坏是O(n2)但是实际运行会好很多 代码1506代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const int maxn = 100005;int l[maxn];int r[maxn];LL h[maxn];bool Do() &#123; int n; scanf(\"%d\",&amp;n); if(n == 0) return false; for(int i = 1;i &lt;= n;i++) scanf(\"%lld\",&amp;h[i]); h[0] = h[n + 1] = 0; for(int i = 1;i &lt;= n;i++) &#123; int t = i; while(t &gt; 1 &amp;&amp; h[i] &lt;= h[t - 1]) t = l[t - 1]; l[i] = t; &#125; for(int i = n;i &gt;= 1;i--) &#123; int t = i; while(t &lt; n &amp;&amp; h[i] &lt;= h[t + 1]) t = r[t + 1]; r[i] = t; &#125; LL Max = 0; for(int i = 1;i &lt;= n;i++) &#123; Max = max(Max,(r[i] - l[i] + 1)*h[i]); &#125; printf(\"%lld\\n\",Max); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"}]},{"title":"LOVELIVE! SUNSHINE 动画播出","date":"2016-07-03T13:52:35.000Z","path":"/post/Writing/llssanime.html","text":"昨天LOVELIVE! SUNSHINE动画播出 作为 LLer 自然还是要看下的。μ’s 的奇迹将由 Aqours 延续 惊喜首先来自贴吧LOVELIVE! 官方御用字幕组 LoveEcho! 出了字幕 不管动漫怎么样,仅仅是看在 LE 字幕组,也要看 千歌(高海千歌)家的 μ’s 海报,手机里 Snow Halation 经典的 届(とど)けて 这句的图片一切都仿佛在让 μ’s 的粉丝们尽快习惯 Aqours 在安利别人加入偶像部时,遇到了矢泽露比黑泽露比不管是从性格上还是造型上,都满满的妮姬的感觉 从天而降的中二少女善子(津岛善子)~呆萌的花阳丸(国木田花丸) 而后是已经反对成立偶像社团的学生会长(屈服吧少女,OP已经暴露了你)会长叫黑泽黛雅,是露比的姐姐.一个集 Eli 学生会长严肃和希副会长神棍的少女 而后千歌、曜(渡边曜)安利二人组去找了果南(松浦果南),给了果南出场的机会天上飞过大富豪小原鞠莉 回家路上的千歌,看到了一个面对大海的少女。 当然,这些都是次要的,重点在衣服！！！！音乃木坂校服！！！ 是的,你没看错,是 μ’s 们所在学校的校服!然后,少女一言不合就脱衣服~这就是来自音乃木坂的转校生樱内梨子当然这不是重点……作为音乃木坂学院的学生,竟然不知道 LOVELIVE 最终冠军、在东蛋演出、粉丝堵飞机场、你们学校的 μ’s ！！！！你忘掉了全校为了不影响 μ’s 演出而去铲雪、忘了没有 μ’s 你们学校就要废校么？？？？！！！！！！ 就算不关注这些,这可是你们的校服啊！！！！竟然都不知道！！！！你身上穿的是冬装,照片里是夏装啊！！！！ 然后……响起了熟悉的音乐 熟悉的旋律？？！！！ I say！！！Hey！ Hey！ Hey！ Start Dash！！Hey！ Hey！ Hey！ Start Dash！！ do bu Se noHi! Hi!Hi! Hi! Hi! Hi!Oh~ Hi!Oh~ Hi!Oh~ Hi!Oh~ Hi!Hi~ Hi~ Hi~ Hi~ Hi~ Hi~START! fu~ fu~fuwa~ fuwa~ fu~ fu~fuwa~ fuwa~ Hey！ Hey！ Hey！ Start Dash！！Hey！ Hey！ Hey！ Start Dash！！ 听完一本满足~~(我什么时候掏出了应援棒？？？)劳资在听歌千歌你别逼逼 剧情结束,全部人员出场完毕~~ 结尾 START:DASH!! 一本满足 新生的小鸟已经张开羽翼,凭借它宽大坚韧的翅膀高飞μ’s 的舞台已经座无虚席 而接下来是 Aqours 实现梦想的故事","tags":[{"name":"LOVELIVE","slug":"LOVELIVE","permalink":"https://www.oyohyee.com/tags/LOVELIVE/"}]},{"title":"AOJ 768.密码问题","date":"2016-07-03T08:15:57.000Z","path":"/post/AOJ/768.html","text":"题目 Description 有一种密码的工作原理是：首先选择一个单词作为密钥， 如TRAILBLAZERS，如果单词中有重复字母，则只保留第1个，其余几个丢弃。现在修改过的那个单词列于字母表下面，如下所示：A B C D E F G H I J K L M N O P Q R S T U V W X Y ZT R A I L B Z E S然后，用字母表中没出现的字母将密钥填充完整，得到：A B C D E F G H I J K L M N O P Q R S T U V W X Y ZT R A I L B Z E S C D F G H J K M N O P Q U V W X Y对信息加密时，将原文中的所有字母，按以上对应关系一一用密钥字母取代，因此使用这个密钥就可以对原文信息 进行加密。同样，也可以使用这个密钥进行解密。 Input输入有多组，每组数据的第一行为一个整数0、1、2, 1表示加密；2表示解密；0表示结束，并且不需要处理。若第一行为1或2， 则第二行为密钥单词，第三行为进行加密 或解密的原文或密文。其中密钥单词长度不超过15个字符，原文长度在200个字符以内。 Output 根据加密或解密的要求和密钥，输出加密 或解密的密文或原文。 Sample Input 1TRAILBLAZERSATTACK AT DAWN2TRAILBLAZERSTPPTAD TP ITVH0 Sample Output TPPTAD TP ITVHATTACK AT DAWN 题解首先建立好原文和密文字符的映射而后使用 getchar 一个一个读入字符数据的任意地方可能会有任意数量的空格 如果是空格直接输出 如果是换行(数据结束)返回 如果是字母根据映射输出 代码密码问题代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 20;const int maxm = 205;char key[maxn];char word[maxm];char KtoA[26];char AtoK[26];void GetMap() &#123; memset(KtoA,0,sizeof(KtoA)); memset(AtoK,0,sizeof(AtoK)); int pos = 0; int len = strlen(key); for(int i = 0;i &lt; len;i++) &#123; if(KtoA[key[i] - 'A'] == 0) &#123; KtoA[key[i] - 'A'] = pos + 'A'; AtoK[pos] = key[i]; pos++; &#125; &#125; for(int i=0;i &lt; 26;i++) &#123; if(KtoA[i] == 0) &#123; KtoA[i] = pos + 'A'; AtoK[pos++] = i + 'A'; &#125; &#125;&#125;bool Do() &#123; int com; scanf(\"%d\",&amp;com); if(com == 0) return false; scanf(\"\\n%s\",key); GetMap(); char c; int i = 0; while(!(((c = getchar()) &gt;= 'A'&amp;&amp;c &lt;= 'Z') || (c &gt;= 'a'&amp;&amp;c &lt;= 'z'))); while((c &gt;= 'A'&amp;&amp;c &lt;= 'Z') || (c &gt;= 'a'&amp;&amp;c &lt;= 'z')||c==' ') &#123; if(c == ' ') &#123; putchar(' '); &#125;else &#123; if(com == 1) &#123; putchar(AtoK[c-'A']); &#125; else &#123; putchar(KtoA[c - 'A']); &#125; &#125; c = getchar(); &#125; putchar('\\n'); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"AOJ 767.统计字符数","date":"2016-07-03T08:08:33.000Z","path":"/post/AOJ/767.html","text":"题目 Description 判断一个由a-z和A-Z字符组成的字符串中哪个字符出现的次数最多 Input第1行是测试数据的组数n，每组测试数据占1行，是一个由a-z和A-Z字符组成的字符串，每组测试数据之间有一个空行，每行数据不超过1000个字符且非空 Output n行，每行输出对应一个输入。一行输出包括出现次数最多的字符和该字符出现的次数，中间是一个空格。如果有多个字符出现的次数相同且最多，那么输出ASCII码最小的那一个字符 Sample Input 2AbbcccAdfadffasdf Sample Output c 3f 4 算法读一遍,统计下即可 代码统计字符数代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int INF = 0x7FFFFFFF;const int maxn = 500;int cnt[maxn];void Do() &#123; memset(cnt,0,sizeof(cnt)); char c = getchar(); while(!((c &gt;= 'a'&amp;&amp;c &lt;= 'z') || (c &gt;= 'A'&amp;&amp;c &lt;= 'Z'))) c = getchar(); while((c &gt;= 'a'&amp;&amp;c &lt;= 'z') || (c &gt;= 'A'&amp;&amp;c &lt;= 'Z')) &#123; cnt[c]++; c = getchar(); &#125; int ans,Max = 0; for(int i = 0;i &lt; maxn;i++) &#123; if(cnt[i] &gt; Max) &#123; ans = i; Max = cnt[i]; &#125; &#125; printf(\"%c %d\\n\",ans,Max);&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"AOJ 773.数字三角形","date":"2016-07-03T07:55:01.000Z","path":"/post/AOJ/773.html","text":"题目 Description 将a，b,c,d,e,f,这6个变量排成如图所示的三角形，这6个变量分别去[1,6]中的不同整数，且使三角形三条边上的变量之和相等。 ab fc d e Input多组输入 一个1-6之间的数a. Output 所有以a为顶的三角形,有多组的话按照abcdef排列字典序输出。 Sample Input 1 Sample Output &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;5 题解纯模拟5 个 for 循环注意每组解后都有空行最后一组的最后一个解后没有空行 代码数字三角形代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 1000;int a[6];bool visit[7];bool flag = false;bool Do() &#123; if(scanf(\"%d\",&amp;a[0]) == EOF) return false; memset(visit,false,sizeof(visit)); visit[a[0]] = true; for(a[1] = 1;a[1] &lt;= 6;a[1]++) &#123; if(visit[a[1]]) continue; visit[a[1]] = true; for(a[2] = 1;a[2] &lt;= 6;a[2]++) &#123; if(visit[a[2]]) continue; visit[a[2]] = true; for(a[3] = 1;a[3] &lt;= 6;a[3]++) &#123; if(visit[a[3]]) continue; visit[a[3]] = true; for(a[4] = 1;a[4] &lt;= 6;a[4]++) &#123; if(visit[a[4]]) continue; visit[a[4]] = true; for(a[5] = 1;a[5] &lt;= 6;a[5]++) &#123; if(visit[a[5]]) continue; visit[a[5]] = true; if((a[1] + a[2] == a[5] + a[4]) &amp;&amp; (a[0] + a[1] == a[3] + a[4]) &amp;&amp; (a[2] + a[3] == a[0] + a[5])) &#123; if(flag) &#123; printf(\"\\n\"); &#125; else &#123; flag = true; &#125; printf(\" %d\\n %d %d\\n %d %d %d\\n\",a[0],a[1],a[5],a[2],a[3],a[4]); &#125; visit[a[5]] = false; &#125; visit[a[4]] = false; &#125; visit[a[3]] = false; &#125; visit[a[2]] = false; &#125; visit[a[1]] = false; &#125; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"AOJ 772.完美立方","date":"2016-07-03T07:47:57.000Z","path":"/post/AOJ/772.html","text":"Description a³ = b³ + c³ + d³为完美立方等式。例如 12³ = 6³ + 8³ + 10³。对任意给出的正整数N(N≤100),寻找所有的四元组（a, b, c, d）,使得 a³ = b³ + c³ + d³, 其中 1 &lt; a, b, c, d ≤ N。 Input正整数N(N≤100) Output 每行输出一个完美立方，按照a的值从小到大依次输出。当两个完美立方等式中a相同，则依次按照b、c、d进行非降序排列输出，即b值小的先输出、然后c值小的先输出、然后d值小的先输出。 Sample Input 24 Sample Output Cube = 6, Triple = (3,4,5)Cube = 9, Triple = (1,6,8)Cube = 12, Triple = (6,8,10)Cube = 18, Triple = (2,12,16)Cube = 18, Triple = (9,12,15)Cube = 19, Triple = (3,10,18)Cube = 20, Triple = (7,14,17)Cube = 24, Triple = (12,16,20) 题解 4 重 for 循环 强行模拟即可 代码完美立方代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 1000;bool Do() &#123; int N; if(scanf(\"%d\",&amp;N) == EOF) return false; int a,b,c,d; for(a = 1;a &lt;= N;a++) &#123; int a3 = a*a*a; for(b = 1;b &lt;= N;b++) &#123; int b3 = b*b*b; if(a3 &lt; b3) break; for(c = b;c &lt;= N;c++) &#123; int c3 = c*c*c; if(a3 &lt; b3 + c3) break; for(d = c;d &lt;= N;d++) &#123; int d3 = d*d*d; if(a3 &lt; b3 + c3 + d3) break; if(a3 == b3 + c3 + d3) printf(\"Cube = %d, Triple = (%d,%d,%d)\\n\",a,b,c,d); &#125; &#125; &#125; &#125; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"AOJ 771.大整数除法","date":"2016-07-03T07:43:10.000Z","path":"/post/AOJ/771.html","text":"题目 Description 求两个大的正整数相除的商。 Input第1行是测试数据的组数n，每组测试数据占2行，第1行是被除数，第2行是除数。每组测试数据之间有一个空行，每行数据不超过100个字符。 Output n行，每组测试数据一行输出是相应的整数商。 Sample Input 324053373129633733590092604577420574392304964939303555957976607910827396462987192585318701752584429931160870372907079248971095012509790550883793197894100000000000000000000000000000000000000001000000000054096567750978508956870567980689709345465465756767686784354353451 Sample Output 010000000000000000000000000000005409656775097850895687056798068970934546546575676768678435435345 题解&gt;高精度算法&lt; 代码大整数除法代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.com かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std; #define REP(n) for(int o=0;o&lt;n;o++)#define Max(a,b) (a&gt;b?a:b)#define Min(a,b) (a&lt;b?a:b)const int maxn = 1000; class bigNumber &#123;private: int num[maxn + 1];public: bigNumber() &#123; init(); &#125; void init() &#123; memset(num,0,sizeof(num)); &#125; bigNumber operator = (const char *str) &#123; init(); num[0] = strlen(str); REP(num[0])num[num[0] - o] = str[o] - '0'; return *this; &#125; bigNumber operator = (const bigNumber&amp; rhs) &#123; init(); REP(rhs.num[0] + 1)num[o] = rhs.num[o]; return *this; &#125; bigNumber operator = (long long rhs) &#123; init(); int i = 1; while(rhs) &#123; num[i] = rhs % 10; rhs /= 10; i++; &#125; num[0] = i - 1; return *this; &#125; bool operator &lt; (const bigNumber rhs)const &#123; if(num[0] != rhs.num[0])return (num[0] &lt; rhs.num[0]); REP(num[0]) &#123; int temp = num[0] - o; if(num[temp] != rhs.num[temp])return (num[temp] &lt; rhs.num[temp]); &#125; return 0; &#125; bool operator &gt; (const bigNumber rhs)const &#123; if(num[0] != rhs.num[0])return (num[0] &gt; rhs.num[0]); REP(num[0]) &#123; int temp = num[0] - o; if(num[temp] != rhs.num[temp])return (num[temp] &gt; rhs.num[temp]); &#125; return 0; &#125; bool operator == (const bigNumber rhs)const &#123; return !(*this &gt; rhs || *this &lt; rhs); &#125; bool operator &lt;= (const bigNumber rhs)const &#123; return *this &lt; rhs || *this == rhs; &#125; bigNumber operator + (const bigNumber rhs)const &#123; bigNumber temp; int len; len = num[0] &gt; rhs.num[0] ? num[0] : rhs.num[0]; len++; REP(len) &#123; temp.num[o + 1] += num[o + 1] + rhs.num[o + 1]; temp.num[o + 2] += temp.num[o + 1] / 10; temp.num[o + 1] %= 10; &#125; REP(len) &#123; if(temp.num[len - o] != 0) &#123; temp.num[0] = len - o; break; &#125; &#125; return temp; &#125; bigNumber operator + (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 + temp2; &#125; bigNumber operator * (const bigNumber rhs)const &#123; bigNumber temp; int len; len = num[0] + rhs.num[0]; //len++; for(int i = 1;i &lt;= num[0];i++) &#123; for(int j = 1;j &lt;= rhs.num[0];j++) &#123; temp.num[i + j - 1] += num[i] * rhs.num[j]; temp.num[i + j] += temp.num[i + j - 1] / 10; temp.num[i + j - 1] %= 10; &#125; &#125; REP(len) &#123; if(temp.num[len - o] != 0) &#123; temp.num[0] = len - o; break; &#125; &#125; return temp; &#125; bigNumber operator * (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 * temp2; &#125; bigNumber operator - (const bigNumber rhs)const &#123; bigNumber temp,a,b; temp = Max(*this,rhs); b = Min(*this,rhs); a = temp; temp.init(); int len = a.num[0]; REP(len) &#123; temp.num[o + 1] += 10 + a.num[o + 1] - b.num[o + 1]; temp.num[o + 2]--; temp.num[o + 2] += temp.num[o + 1] / 10; temp.num[o + 1] %= 10; &#125; REP(len) &#123; if(temp.num[len - o] != 0) &#123; temp.num[0] = len - o; break; &#125; &#125; return temp; &#125; bigNumber operator - (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 - temp2; &#125; bigNumber operator / (const bigNumber rhs)const &#123; bigNumber a; int it = num[0]; bigNumber d; bigNumber c; while(it &gt; 0) &#123; a = (d * 10) + num[it]; c = c * 10; int t; REP(9) &#123; if(a &lt; rhs * (o + 1)) &#123; t = o; break; &#125; t = 9; &#125; c = c + t; d = a - rhs * t; it--; &#125; return c; &#125; bigNumber operator / (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 / temp2; &#125; bigNumber operator % (const bigNumber rhs)const &#123; bigNumber a; int it = num[0]; bigNumber d; bigNumber c; while(it &gt; 0) &#123; a = (d * 10) + num[it]; c = c * 10; int t; REP(9) &#123; if(a &lt; rhs * (o + 1)) &#123; t = o; break; &#125; t = 9; &#125; c = c + t; d = a - rhs*t; it--; &#125; return d; &#125; bigNumber operator % (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 % temp2; &#125; void p() &#123; if(num[0] == 0) printf(\"0\"); REP(num[0]) &#123; printf(\"%d\",num[num[0] - o]); &#125; &#125;&#125;; bigNumber a,b,c;char aa[maxn],bb[maxn];bool Do() &#123; scanf(\"\\n%s\\n%s\",aa,bb); a = aa; b = bb; c = a / b; c.p(); putchar('\\n'); return true;&#125; int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"高精度算法","slug":"High-precision","permalink":"https://www.oyohyee.com/tags/High-precision/"}]},{"title":"AOJ 770.大整数乘法","date":"2016-07-03T07:42:10.000Z","path":"/post/AOJ/770.html","text":"题目 Description 求两个不超过50位的非负数的积。 Input有两行，每行是一个不超过50位的非负整数，没有多余的前导0 Output 一行，即相乘后的结果。结果里不能有多余的前导0，即如果结果是0342，则输出342. Sample Input 1234567890098765432100 Sample Output 1219326311126352690000 题解&gt;高精度算法&lt; 代码大整数乘法代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)#define Max(a,b) (a&gt;b?a:b)#define Min(a,b) (a&lt;b?a:b)const int maxn = 10000;class bigNumber &#123;private: int num[maxn + 1];public: bigNumber() &#123; init(); &#125; void init() &#123; memset(num,0,sizeof(num)); &#125; bigNumber operator = (const char *str) &#123; init(); num[0] = strlen(str); REP(num[0])num[num[0] - o] = str[o] - '0'; return *this; &#125; bigNumber operator = (const bigNumber&amp; rhs) &#123; init(); REP(rhs.num[0] + 1)num[o] = rhs.num[o]; return *this; &#125; bigNumber operator = (long long rhs) &#123; init(); int i = 1; while(rhs) &#123; num[i] = rhs % 10; rhs /= 10; i++; &#125; num[0] = i - 1; return *this; &#125; bool operator &lt; (const bigNumber rhs)const &#123; if(num[0] != rhs.num[0])return (num[0] &lt; rhs.num[0]); REP(num[0]) &#123; int temp = num[0] - o; if(num[temp] != rhs.num[temp])return (num[temp] &lt; rhs.num[temp]); &#125; return 0; &#125; bool operator &gt; (const bigNumber rhs)const &#123; if(num[0] != rhs.num[0])return (num[0] &gt; rhs.num[0]); REP(num[0]) &#123; int temp = num[0] - o; if(num[temp] != rhs.num[temp])return (num[temp] &gt; rhs.num[temp]); &#125; return 0; &#125; bool operator == (const bigNumber rhs)const &#123; return !(*this &gt; rhs || *this &lt; rhs); &#125; bool operator &lt;= (const bigNumber rhs)const &#123; return *this &lt; rhs || *this == rhs; &#125; bigNumber operator + (const bigNumber rhs)const &#123; bigNumber temp; int len; len = num[0] &gt; rhs.num[0] ? num[0] : rhs.num[0]; len++; REP(len) &#123; temp.num[o + 1] += num[o + 1] + rhs.num[o + 1]; temp.num[o + 2] += temp.num[o + 1] / 10; temp.num[o + 1] %= 10; &#125; REP(len) &#123; if(temp.num[len - o] != 0) &#123; temp.num[0] = len - o; break; &#125; &#125; return temp; &#125; bigNumber operator + (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 + temp2; &#125; bigNumber operator * (const bigNumber rhs)const &#123; bigNumber temp; int len; len = num[0] + rhs.num[0]; //len++; for(int i = 1;i &lt;= num[0];i++) &#123; for(int j = 1;j &lt;= rhs.num[0];j++) &#123; temp.num[i + j - 1] += num[i] * rhs.num[j]; temp.num[i + j] += temp.num[i + j - 1] / 10; temp.num[i + j - 1] %= 10; &#125; &#125; REP(len) &#123; if(temp.num[len - o] != 0) &#123; temp.num[0] = len - o; break; &#125; &#125; return temp; &#125; bigNumber operator * (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 * temp2; &#125; bigNumber operator - (const bigNumber rhs)const &#123; bigNumber temp,a,b; temp = Max(*this,rhs); b = Min(*this,rhs); a = temp; temp.init(); int len = a.num[0]; REP(len) &#123; temp.num[o + 1] += 10 + a.num[o + 1] - b.num[o + 1]; temp.num[o + 2]--; temp.num[o + 2] += temp.num[o + 1] / 10; temp.num[o + 1] %= 10; &#125; REP(len) &#123; if(temp.num[len - o] != 0) &#123; temp.num[0] = len - o; break; &#125; &#125; return temp; &#125; bigNumber operator - (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 - temp2; &#125; bigNumber operator / (const bigNumber rhs)const &#123; bigNumber a; int it = num[0]; bigNumber d; bigNumber c; while(it &gt; 0) &#123; a = (d * 10) + num[it]; c = c * 10; int t; REP(9) &#123; if(a &lt; rhs * (o + 1)) &#123; t = o; break; &#125; t = 9; &#125; c = c + t; d = a - rhs*t; it--; &#125; return c; &#125; bigNumber operator / (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 / temp2; &#125; bigNumber operator % (const bigNumber rhs)const &#123; bigNumber a; int it = num[0]; bigNumber d; bigNumber c; while(it &gt; 0) &#123; a = (d * 10) + num[it]; c = c * 10; int t; REP(9) &#123; if(a &lt; rhs * (o + 1)) &#123; t = o; break; &#125; t = 9; &#125; c = c + t; d = a - rhs*t; it--; &#125; return d; &#125; bigNumber operator % (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 % temp2; &#125; void p() &#123; if(num[0] == 0) printf(\"0\"); REP(num[0]) &#123; printf(\"%d\",num[num[0] - o]); &#125; &#125;&#125;;bigNumber a,b,c;char aa[maxn],bb[maxn];bool Do() &#123; if(scanf(\"\\n%s\\n%s\",aa,bb)==EOF) return false; a = aa; b = bb; c = a * b; c.p(); putchar('\\n'); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"高精度算法","slug":"High-precision","permalink":"https://www.oyohyee.com/tags/High-precision/"}]},{"title":"AOJ 769.大数加法","date":"2016-07-03T07:30:22.000Z","path":"/post/AOJ/769.html","text":"题目 Description 求两个不超过200 位的非负整数的和。 Input有两行，每行是一个不超过200 位的非负整数，没有多余的前导0。 Output 一行，即相加后的结果。结果里不能有多余的前导 0，即如果结果是342，那么就不能输出为 0342 Sample Input 8888888888888888888833333333333333333333 Sample Output 122222222222222222221 题解&gt;高精度算法&lt; 输入有可能有前导0输出不能有前导0 套用上面的模板不过模板没有考虑输出0的情况,需要修改~ 代码大数加法代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)#define Max(a,b) (a&gt;b?a:b)#define Min(a,b) (a&lt;b?a:b)const int maxn = 10000;class bigNumber &#123;private: int num[maxn + 1];public: bigNumber() &#123; init(); &#125; void init() &#123; memset(num,0,sizeof(num)); &#125; bigNumber operator = (const char *str) &#123; init(); num[0] = strlen(str); REP(num[0])num[num[0] - o] = str[o] - '0'; return *this; &#125; bigNumber operator = (const bigNumber&amp; rhs) &#123; init(); REP(rhs.num[0] + 1)num[o] = rhs.num[o]; return *this; &#125; bigNumber operator = (long long rhs) &#123; init(); int i = 1; while(rhs) &#123; num[i] = rhs % 10; rhs /= 10; i++; &#125; num[0] = i - 1; return *this; &#125; bool operator &lt; (const bigNumber rhs)const &#123; if(num[0] != rhs.num[0])return (num[0] &lt; rhs.num[0]); REP(num[0]) &#123; int temp = num[0] - o; if(num[temp] != rhs.num[temp])return (num[temp] &lt; rhs.num[temp]); &#125; return 0; &#125; bool operator &gt; (const bigNumber rhs)const &#123; if(num[0] != rhs.num[0])return (num[0] &gt; rhs.num[0]); REP(num[0]) &#123; int temp = num[0] - o; if(num[temp] != rhs.num[temp])return (num[temp] &gt; rhs.num[temp]); &#125; return 0; &#125; bool operator == (const bigNumber rhs)const &#123; return !(*this &gt; rhs || *this &lt; rhs); &#125; bool operator &lt;= (const bigNumber rhs)const &#123; return *this &lt; rhs || *this == rhs; &#125; bigNumber operator + (const bigNumber rhs)const &#123; bigNumber temp; int len; len = num[0] &gt; rhs.num[0] ? num[0] : rhs.num[0]; len++; REP(len) &#123; temp.num[o + 1] += num[o + 1] + rhs.num[o + 1]; temp.num[o + 2] += temp.num[o + 1] / 10; temp.num[o + 1] %= 10; &#125; REP(len) &#123; if(temp.num[len - o] != 0) &#123; temp.num[0] = len - o; break; &#125; &#125; return temp; &#125; bigNumber operator + (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 + temp2; &#125; bigNumber operator * (const bigNumber rhs)const &#123; bigNumber temp; int len; len = num[0] + rhs.num[0]; //len++; for(int i = 1;i &lt;= num[0];i++) &#123; for(int j = 1;j &lt;= rhs.num[0];j++) &#123; temp.num[i + j - 1] += num[i] * rhs.num[j]; temp.num[i + j] += temp.num[i + j - 1] / 10; temp.num[i + j - 1] %= 10; &#125; &#125; REP(len) &#123; if(temp.num[len - o] != 0) &#123; temp.num[0] = len - o; break; &#125; &#125; return temp; &#125; bigNumber operator * (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 * temp2; &#125; bigNumber operator - (const bigNumber rhs)const &#123; bigNumber temp,a,b; temp = Max(*this,rhs); b = Min(*this,rhs); a = temp; temp.init(); int len = a.num[0]; REP(len) &#123; temp.num[o + 1] += 10 + a.num[o + 1] - b.num[o + 1]; temp.num[o + 2]--; temp.num[o + 2] += temp.num[o + 1] / 10; temp.num[o + 1] %= 10; &#125; REP(len) &#123; if(temp.num[len - o] != 0) &#123; temp.num[0] = len - o; break; &#125; &#125; return temp; &#125; bigNumber operator - (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 - temp2; &#125; bigNumber operator / (const bigNumber rhs)const &#123; bigNumber a; int it = num[0]; bigNumber d; bigNumber c; while(it &gt; 0) &#123; a = (d * 10) + num[it]; c = c * 10; int t; REP(9) &#123; if(a &lt; rhs * (o + 1)) &#123; t = o; break; &#125; t = 9; &#125; c = c + t; d = a - rhs*t; it--; &#125; return c; &#125; bigNumber operator / (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 / temp2; &#125; bigNumber operator % (const bigNumber rhs)const &#123; bigNumber a; int it = num[0]; bigNumber d; bigNumber c; while(it &gt; 0) &#123; a = (d * 10) + num[it]; c = c * 10; int t; REP(9) &#123; if(a &lt; rhs * (o + 1)) &#123; t = o; break; &#125; t = 9; &#125; c = c + t; d = a - rhs*t; it--; &#125; return d; &#125; bigNumber operator % (const long long rhs)const &#123; bigNumber temp1,temp2; temp1 = *this; temp2 = rhs; return temp1 % temp2; &#125; void p() &#123; if(num[0] == 0) printf(\"0\"); REP(num[0]) &#123; printf(\"%d\",num[num[0] - o]); &#125; &#125;&#125;;bigNumber a,b,c;char aa[maxn],bb[maxn];bool Do() &#123; if(scanf(\"\\n%s\\n%s\",aa,bb)==EOF) return false; a = aa; b = bb; c = a + b; c.p(); putchar('\\n'); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"高精度算法","slug":"High-precision","permalink":"https://www.oyohyee.com/tags/High-precision/"}]},{"title":"2016-06-29 ~ 2016-07-01 学习报告","date":"2016-07-01T16:10:10.000Z","path":"/post/Study/2016_06_29-2016_07_01.html","text":"题目： HDU 1864.最大报销额 HDU 1231.最大连续子序列 HDU 1003.Max Sum","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"HDU 1231.最大连续子序列","date":"2016-06-30T07:49:43.000Z","path":"/post/HDU/1231.html","text":"题目 Description 给定K个整数的序列{ N1, N2, …, NK }，其任意连续子序列可表示为{ Ni, Ni+1, …,Nj }，其中 1 &lt;= i &lt;= j &lt;= K。最大连续子序列是所有连续子序列中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和为20。在今年的数据结构考卷中，要求编写程序得到最大和，现在增加一个要求，即还需要输出该子序列的第一个和最后一个元素。 Input测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( &lt; 10000 )，第2行给出K个整数，中间用空格分隔。当K为0时，输入结束，该用例不被处理。 Output 对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。 Sample Input 6-2 11 -4 13 -5 -210-10 1 2 3 4 -5 -23 3 7 -2165 -8 3 2 5 01103-1 -5 -23-1 0 -20 Sample Output 20 11 1310 1 410 3 510 10 100 -1 -20 0 0 题解曾经做过&gt;类似的题目&lt;两种思路： 动态规划(这个专题要求的) 递归与分治(类似的题目使用的方法) 先测试之前的代码,可以AC换用动态规划 思路是:对于某一个值,可以选择将它加入到子序列里,或者选择从它开始一个新的子序列也即dp[i] = max(dp[i-1]+a[i] , a[i]) 然后查找dp中最大的值即可 其实我觉得处理起始和末尾才是最难的 末尾就是找到dp中最大值对应的下标指向的序列中的数字起始需要从末尾开始往前倒推 代码动态规划动态规划代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int INF = 0x7FFFFFFF;const int maxn = 10005;int dp[maxn];int a[maxn];bool Do() &#123; int n; scanf(\"%d\",&amp;n); if(n == 0) return false; memset(dp,0,sizeof(dp)); for(int i = 1;i &lt;= n;i++) &#123; scanf(\"%d\",&amp;a[i]); dp[i] = max(dp[i - 1] + a[i],a[i]); &#125; int begin,end = a[1],Max = dp[1],pos=1; for(int i = 1;i &lt;= n;i++) &#123; if(dp[i] &gt; Max) &#123; Max = dp[i]; end = a[i]; pos = i; &#125; &#125; int sum = 0; begin = a[pos]; for(int i = pos;i &gt; 0;i--) &#123; if(Max &gt; sum) &#123; sum += a[i]; begin = a[i]; &#125; else &#123; break; &#125; &#125; if(Max &gt;= 0) printf(\"%d %d %d\\n\",Max,begin,end); else printf(\"%d %d %d\\n\",0,a[1],a[n]); return true;&#125;int main() &#123; while(Do()); return 0;&#125; 递归与分治递归与分治代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 100005;//const int INF = (1 &lt;&lt; 31) - 1;const int INF = 0x7fffffff;int a[maxn];int dfs(int *a,int l,int r,int &amp;begin,int &amp;end) &#123; if(l == r) &#123; begin = end = l; return a[l]; &#125; if(l &gt; r) &#123; begin = end = -1; return -INF; &#125; int mid = (l + r) / 2; int Max; int ans; int tbegin,tend; begin = end = mid; //中间 int i; ans = 0; int maxl = 0; for(i = mid - 1;i &gt;= l;i--) &#123; ans += a[i]; if(ans &gt;= maxl) &#123; maxl = ans; begin = i; &#125; &#125; ans = 0; int maxr = 0; for(i = mid + 1;i &lt;= r;i++) &#123; ans += a[i]; if(ans &gt; maxr) &#123; maxr = ans; end = i; &#125; &#125; Max = maxl + a[mid] + maxr; //左侧 ans = dfs(a,l,mid - 1,tbegin,tend); if(ans &gt;= Max) &#123; Max = ans; begin = tbegin; end = tend; &#125; //右侧 ans = dfs(a,mid + 1,r,tbegin,tend); if(ans &gt; Max) &#123; Max = ans; begin = tbegin; end = tend; &#125; return Max;&#125;bool Do() &#123; int n,l,r; scanf(\"%d\",&amp;n); if(n== 0) return false; for(int i = 1;i &lt;= n;i++) scanf(\"%d\",&amp;a[i]); int ans = dfs(a,1,n,l,r); if(ans &gt;= 0) printf(\"%d %d %d\\n\",ans,a[l],a[r]); else printf(\"%d %d %d\\n\",0,a[1],a[n]); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"递归与分治","slug":"Recursion","permalink":"https://www.oyohyee.com/tags/Recursion/"},{"name":"最大连续子序列","slug":"MCS","permalink":"https://www.oyohyee.com/tags/MCS/"}]},{"title":"百度站长主动推动工具","date":"2016-06-29T17:11:53.000Z","path":"/post/Note/BaiduPush.html","text":"百度站长平台一直在推荐用它的主动推送功能 之前一直使用的是它的curl来推送,每次推送要先生成所有页面的索引,再用正则表达式替换一些需要替换的地方,存到urls.txt这已经不仅仅是麻烦了,用hexo本身就是为了方便,这反而更加麻烦了~因此,想使用post来完成推送 在网上能轻易找到许多推送的代码有Python、Java、PHP……Python需要各种模块,安装显得不是那么容易Java我压根没编译器PHP也需要自己先配置环境 而我又不会用C写POST 思来想去,我是有非常明确的代码思路的,只是不会写那么就是使用了世界上最好的中文编程语言易语言 简单直接的思路,虽然有5、6年没用过易语言了,但是基本上还是一遍写完编译通过(中文真方便) &gt;链接&lt;里面有个baidupush.exe和krnln.fnr下载它们即可~放在hexo根目录下即可 抽时间学习下C的POST,争取做一个C++版本的项目(才不是为了装逼呢)","tags":[{"name":"SEO","slug":"SEO","permalink":"https://www.oyohyee.com/tags/SEO/"},{"name":"工具","slug":"Tools","permalink":"https://www.oyohyee.com/tags/Tools/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.oyohyee.com/tags/Hexo/"},{"name":"易语言","slug":"E","permalink":"https://www.oyohyee.com/tags/E/"}]},{"title":"HDU 1864.最大报销额","date":"2016-06-29T11:19:28.000Z","path":"/post/HDU/1864.html","text":"题目 Description 现有一笔经费可以报销一定额度的发票。允许报销的发票类型包括买图书（A类）、文具（B类）、差旅（C类），要求每张发票的总额不得超过1000元，每张发票上，单项物品的价值不得超过600元。现请你编写程序，在给出的一堆发票中找出可以报销的、不超过给定额度的最大报销额。 Input测试输入包含若干测试用例。每个测试用例的第1行包含两个正数 Q 和 N，其中 Q 是给定的报销额度，N（&lt;=30）是发票张数。随后是 N 行输入，每行的格式为：m Type_1:price_1 Type_2:price_2 … Type_m:price_m其中正整数 m 是这张发票上所开物品的件数，Type_i 和 price_i 是第 i 项物品的种类和价值。物品种类用一个大写英文字母表示。当N为0时，全部输入结束，相应的结果不要输出。 Output 对每个测试用例输出1行，即可以报销的最大数额，精确到小数点后2位。 Sample Input 200.00 32 A:23.50 B:100.001 C:650.003 A:59.99 A:120.00 X:10.001200.00 22 B:600.00 A:400.001 C:200.501200.50 32 B:600.00 A:400.001 C:200.501 A:100.00100.00 0 Sample Output 123.501000.001200.50 题解首先要判断发票是不是能报销： 总额不超过1000 单项不超过600 只有A、B、C三种物品 如果发票不能报销直接忽略掉就行如果可以报销，就是01背包问题套用算法即可 由于钱数带小数,因此应该将钱数×100化为整数 然而这道题最关键的地方应该是动态内存吧题目里没有给具体的数据范围在OJ上试了下,不是溢出就是超内存没办法就用了new和delete 里面这部分不加上会报错(虽然我觉得不加貌似没问题)dp = NULL;while(dp == NULL) dp = new int[(int)(Q * 100) + 5]; 代码最大报销额代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;int *dp = NULL;int v;void ZeroOnePack(int cost,int weight) &#123; for(int i = v; i &gt;= cost; i--) dp[i] = max(dp[i],dp[i - cost] + weight);&#125;bool Do() &#123; double Q; int N; scanf(\"%lf%d\",&amp;Q,&amp;N); if(N == 0) return false; v = (int)(Q * 100); if(!dp) delete[] dp; dp = NULL; while(dp == NULL) dp = new int[(int)(Q * 100) + 5]; memset(dp,0,sizeof(int)*(int)(Q * 100) + 5); for(int i = 0;i &lt; N;i++) &#123; int m; scanf(\"%d\",&amp;m); double *money = new double[m + 5]; double A,B,C,sum; A = B = C = sum = 0; for(int j = 0;j &lt; m;j++) &#123; char t; scanf(\"\\n%c:%lf\",&amp;t,&amp;money[j]); sum += money[j]; if(t &gt;= 'A'&amp;&amp;t &lt;= 'C') &#123; switch(t) &#123; case 'A': A += money[j]; break; case 'B': B += money[j]; break; case 'C': C += money[j]; break; &#125; &#125; else &#123; sum += 1001; &#125; &#125; if(A &lt;= 600 &amp;&amp; B &lt;= 600 &amp;&amp; C &lt;= 600 &amp;&amp; sum &lt;= 1000) ZeroOnePack((int)(sum * 100),(int)(sum * 100)); &#125; printf(\"%.2f\\n\",(double)dp[v] / 100); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"},{"name":"动态内存","slug":"Memory","permalink":"https://www.oyohyee.com/tags/Memory/"}]},{"title":"2016-06-26 ~ 2016-06-28 学习报告","date":"2016-06-28T10:10:10.000Z","path":"/post/Study/2016_06_26-2016_06_28.html","text":"DP46专题 题目： HDU 2955.Robberies Codeforces 681A.A_Good_Contest Codeforces 681B.Economy Game HDU 1846.Brave Game 算法： 博弈","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"电阻色环练习工具","date":"2016-06-27T11:45:09.000Z","path":"/post/Note/Resistance_exercise.html","text":"突发奇想就像做一个电阻色环练习工具(不务正业系列) 使用HTML(Div+Css)+Javascript实现 采用Jquery的功能实现修改颜色的部分 没脸传Github ╮(╯-╰)╭ 遵守GPL协议 &gt;Demo&lt; 使用到的功能如下： 取0~1的随机数Math.random() 转换到整数parseInt() 检测点击事件$(document).ready(function()&#123; $(\"#\").click(function ()&#123; &#125;);&#125;; 修改控件内容$(\"#\").text(); 修改控件属性$(\"#\").attr(); 完整代码 HTML部分&lt;div style=\"background:#66ccff; width:100px; text-align:center;font-weight:bold\"&gt;&lt;font id=\"a1\" size=5px color=\"BLACK\"&gt;|&lt;/font&gt; &lt;font id=\"a2\" size=5px color=\"BLACK\"&gt;|&lt;/font&gt; &lt;font id=\"a3\" size=5px color=\"BLACK\"&gt;|&lt;/font&gt; &lt;font id=\"a4\" size=5px color=\"BLACK\"&gt;|&lt;/font&gt; &lt;font id=\"a5\" size=5px color=\"BLACK\"&gt;|&lt;/font&gt;&lt;/div&gt;&lt;p id=\"answer\"&gt;&lt;/p&gt;&lt;button id=\"do\"&gt;新数据&lt;/button&gt; &lt;button id=\"do2\"&gt;显示答案&lt;/button&gt; Javascript部分&lt;script src=\"https://code.jquery.com/jquery-3.0.0.min.js\"&gt;&lt;/script&gt;&lt;script language=\"javascript\"&gt;var sum = 0;var bit = 0;var delta = 0;var ColorIndex = new Array(\"BLACK\",\"BROWN\",\"RED\",\"ORANGE\",\"YELLOW\",\"GREEN\",\"BLUE\",\"PURPLE\",\"GREY\",\"WHITE\");var OIndex = new Array(0,1,2,3,4,5,6,7,8,9);var DeltaColorIndex = new Array(\"BROWN\",\"RED\",\"GREEN\",\"BLUE\",\"PURPLE\",\"GREY\",\"GOLD\",\"SILVER\",\"66CCFF\");var DeltaOIndex = new Array(1,2,0.5,0.25,0.1,0.05,5,10,20);Do();function rand(n)&#123; return parseInt(Math.random()*1000000)%(n+1);&#125;$(document).ready(function()&#123; $(\"#do\").click(Do); $(\"#do2\").click(function()&#123; $(\"#answer\").text(sum+\" × 10^\"+bit+\" Ω ± \"+delta+\"%\"); &#125;);&#125;);function Do()&#123; sum=0; bit=0; for(var i=0;i&lt;4;i++)&#123; index = rand(ColorIndex.length-1); var color = ColorIndex[index]; $(\"#a\"+(i+1)).attr(\"color\",color); if(i==0) sum+=OIndex[index]*100; if(i==1) sum+=OIndex[index]*10; if(i==2) sum+=OIndex[index]; if(i==3) bit=OIndex[index]; &#125; index = rand(DeltaColorIndex.length-1); var color = DeltaColorIndex[index]; $(\"#a5\").attr(\"color\",color); delta = DeltaOIndex[index]; $(\"#answer\").text(\"刮开查看答案\");&#125;&lt;/script&gt;","tags":[{"name":"javascript","slug":"Javascript","permalink":"https://www.oyohyee.com/tags/Javascript/"}]},{"title":"电工电子基础技能(一)","date":"2016-06-27T05:02:36.000Z","path":"/post/Note/El.html","text":"金工实习开始,也顺便记录下学习的内容吧~内附javascript的电阻色环练习程序 电阻(位)器 对于一个对电流有阻碍作用的元件如果阻值不能改变的,称为电阻器;可以改变的称为电位器单位:欧姆(Ω) 电阻器 当电流通过导体时,导体对电流的阻碍作用称为电阻。在电路中起电阻作用的元件叫做电阻器 电阻的型号命名方法：电阻是电路中最常用的元器件,其作用：限流、降压、负载等 国产电阻器的型号由四部分组成(不适用敏感电阻) 第一部分：主称,用字母表示,表示产品的名字。如R表示电阻,W表示电位器。 第二部分：材料 ,用字母表示,表示电阻体用什么材料组成,T-碳膜、H-合成碳膜、S-有机实心、N-无机实心、J-金属膜、Y-氮化膜、C-沉积膜、I-玻璃釉膜、X-线绕。 第三部分：分类,一般用数字表示,个别类型用字母表示,表示产品属于什么类型。1-普通、2-普通、3-超高频 、4-高阻、5-高温、6-精密、7-精密、8-高压、9-特殊、G-高功率、T-可调。 第四部分:序号,用数字表示,表示同类产品中不同品种,以区分产品的外型尺寸和性能指标等 例如：R T 1 1型普通碳膜电阻 电阻器的分类 1、线绕电阻器：通用线绕电阻器、精密线绕电阻器、大功率线绕电阻器、高频线绕电阻器 2、薄膜电阻器：碳膜电阻器、合成碳膜电阻器、金属膜电阻器、金属氧化膜电阻器、化学沉积膜电阻器、玻璃釉膜电阻器、金属氮化膜电阻器 3、实心电阻器：无机合成实心碳质电阻器、有机合成实心碳质电阻器。 4、敏感电阻器：压敏电阻器、热敏电阻器、光敏电阻器、力敏电阻器、气敏电阻器、湿敏电阻器。 主要特性参数 标称阻值：电阻器上面所标示的阻值 允许误差：标称阻值与实际阻值的差值跟标称阻值之比的百分数称阻值偏差，它表示电阻器的精度。允许误差与精度等级对应关系如下：±0.5%-0.05、±1%-0.1(或00)、±2%-0.2(或0)、±5%-Ⅰ级、±10%-Ⅱ级、±20%-Ⅲ级 额定功率：在正常的大气压力90-106.6KPa及环境温度为－55℃～＋70℃的条件下，电阻器长期工作所允许耗散的最大功率。 线绕电阻器额定功率系列为（W）：1/20、1/8、1/4、1/2、1、2、4、8、10、16、25、40、50、75、100、150、250、500 非线绕电阻器额定功率系列为（W）：1/20、1/8、1/4、1/2、1、2、5、10、25、50、100 4 额定电压：由阻值和额定功率换算出的电压。 最高工作电压：允许的最大连续工作电压。在低气压工作时，最高工作电压较低 - 温度系数：温度每变化1℃所引起的电阻值的相对变化。温度系数越小，电阻的稳定性越好。阻值随温度升高而增大的为正温度系数，反之为负温度系数 老化系数：电阻器在额定功率长期负荷下，阻值相对变化的百分数，它是表示电阻器寿命长短的参数 电压系数：在规定的电压范围内，电压每变化1伏，电阻器的相对变化量 噪声：产生于电阻器中的一种不规则的电压起伏，包括热噪声和电流噪声两部分，热噪声是由于导体内部不规则的电子自由运动，使导体任意两点的电压不规则变化。 电阻器阻值的标注方法 直标法:用阿拉伯数字和单位符号在电阻上直接标出,用百分数直接标出允许偏差的方法称为直标法这是最简单的标注方法,直接就能读到所需要的信息 文字符号法:用阿拉伯数字和文字符号有规律的组合,表示标称阻值和允许误差的方法称为文字符号法如： R51是51Ω 5R1是5.1Ω 5K1是5.1kΩ 色标法:用不同色环标注在电阻体上,表示标称阻值和允许误差的方法称为色标法。常见色标法有四色环和五色环两种这是最常见的标注方法按照最后一位是误差位,倒数第二位是乘数位,前几位是读数位读数例如：黑棕棕绿棕 表示 100 × 10^5 Ω ± 1% 通常,误差为棕色(1%)(五色环) 判断方向的方法有三种： 误差位与其他位的间距会稍远 误差位离引脚会稍远 正向读能读到一个符合规格的电阻(前几位为1~5、10~15),而反向不能 对照表如下： 颜色 代表的数字 乘数 误差 黑色 0 100 &nbsp; 棕色 1 101 (±1%) 红色 2 102 (±2%) 橙色 3 103 &nbsp; 黄色 4 104 &nbsp; 绿色 5 105 (±0.5%) 蓝色 6 106 (±0.25%) 紫色 7 107 (±0.10%) 灰色 8 108 (±0.05%) 白色 9 109 &nbsp; 金色 &nbsp; 10-1 ±5% 银色 &nbsp; 10-2 ±10% 无色 &nbsp; &nbsp; ±20% 色环练习完全拼凑的东西,没脸传Github╮(╯-╰)╭ &gt;开源&lt; > | | | | | > > 新数据 显示答案 var sum = 0; var bit = 0; var delta = 0; var ColorIndex = new Array(\"BLACK\",\"BROWN\",\"RED\",\"ORANGE\",\"YELLOW\",\"GREEN\",\"BLUE\",\"PURPLE\",\"GREY\",\"WHITE\"); var OIndex = new Array(0,1,2,3,4,5,6,7,8,9); var DeltaColorIndex = new Array(\"BROWN\",\"RED\",\"GREEN\",\"BLUE\",\"PURPLE\",\"GREY\",\"GOLD\",\"SILVER\",\"66CCFF\"); var DeltaOIndex = new Array(1,2,0.5,0.25,0.1,0.05,5,10,20); Do(); function rand(n){ return parseInt(Math.random()*1000000)%(n+1); } $(document).ready(function(){ $(\"#do\").click(Do); $(\"#do2\").click(function(){ $(\"#answer\").text(sum+\" × 10^\"+bit+\" Ω ± \"+delta+\"%\"); }); }); function Do(){ sum=0; bit=0; for(var i=0;i","tags":[{"name":"电工电子基础技能","slug":"Electrica","permalink":"https://www.oyohyee.com/tags/Electrica/"}]},{"title":"HDU 1846.Brave Game","date":"2016-06-26T13:19:54.000Z","path":"/post/HDU/1846.html","text":"题目 Description 十年前读大学的时候，中国每年都要从国外引进一些电影大片，其中有一部电影就叫《勇敢者的游戏》（英文名称：Zathura），一直到现在，我依然对于电影中的部分电脑特技印象深刻。今天，大家选择上机考试，就是一种勇敢（brave）的选择；这个短学期，我们讲的是博弈（game）专题；所以，大家现在玩的也是“勇敢者的游戏”，这也是我命名这个题目的原因。当然，除了“勇敢”，我还希望看到“诚信”，无论考试成绩如何，希望看到的都是一个真实的结果，我也相信大家一定能做到的~ 各位勇敢者要玩的第一个游戏是什么呢？很简单，它是这样定义的：1、 本游戏是一个二人游戏;2、 有一堆石子一共有n个；3、 两人轮流进行;4、 每走一步可以取走1…m个石子；5、 最先取光石子的一方为胜； 如果游戏的双方使用的都是最优策略，请输出哪个人能赢。 Input 输入数据首先包含一个正整数C(C&lt;=100)，表示有C组测试数据。每组测试数据占一行，包含两个整数n和m（1&lt;=n,m&lt;=1000），n和m的含义见题目描述。 Output 如果先走的人能赢，请输出“first”，否则请输出“second”，每个实例的输出占一行。 Sample Input 223 24 3 Sample Output firstsecond 题解专题拉措了……不过也算补了下知识点&gt;巴什博弈&lt; 直接套公式即可 代码Brave_Game代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;void Do() &#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); if(n % (m + 1) != 0) printf(\"first\\n\"); else printf(\"second\\n\");&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) &#123; Do(); &#125; return 0;&#125;","tags":[{"name":"博弈","slug":"Game","permalink":"https://www.oyohyee.com/tags/Game/"},{"name":"巴什博奕","slug":"Bash","permalink":"https://www.oyohyee.com/tags/Bash/"}]},{"title":"博弈","date":"2016-06-26T13:19:38.000Z","path":"/post/Algorithm/Game.html","text":"巴什博奕只有一堆n个物品,两个人轮流从这堆物品中取物,规定每次至少取一个,最多取m个.最后取光者得胜.若(m+1)%n，则先手必败，否则先手必胜 显然,如果n=m+1,那么由于一次最多只能取m个,所以,无论先取者拿走多少个,后取者都能够一次拿走剩余的物品,后者取胜.因此有取胜的法则：如果n=(m+1)r+s,(r为任意自然数,s≤m),那么先取者要拿走s个物品,如果后取者拿走k(≤m)个,那么先取者再拿走m+1-k个,结果剩下(m+1)(r-1)个,以后保持这样的取法,那么先取者肯定获胜.总之,要保持给对手留下(m+1)的倍数,就能最后获胜. 威佐夫博奕有两堆各若干个物品,两个人轮流从某一堆或同时从两堆中取同样多的物品,规定每次至少取一个,多者不限,最后取光者得胜.奇异局势下先手必败，非奇异局势下先手必胜。 这种情况下是颇为复杂的.我们用(ak,bk)(ak ≤bk ,k=0,1,2,…,n)表示两堆物品的数量并称其为局势如果甲面对(0,0),那么甲已经输了,这种局势我们称为奇异局势.前几个奇异局势是：(0,0)、(1,2)、(3,5)、(4,7)、(6,10)、(8,13)、(9,15)、(11,18)、(12,20).可以看出,a0=b0=0,ak是未在前面出现过的最小自然数,而bk= ak + k,奇异局势有如下三条性质： 任何自然数都包含在一个且仅有一个奇异局势中.由于ak是未在前面出现过的最小自然数,所以有ak &gt; ak-1 ,而bk= ak + k &gt; ak-1 + k-1 = bk-1 &gt; ak-1 .所以性质1.成立. 任意操作都可将奇异局势变为非奇异局势.事实上,若只改变奇异局势(ak,bk)的某一个分量,那么另一个分量不可能在其他奇异局势中,所以必然是非奇异局势.如果使(ak,bk)的两个分量同时减少,则由于其差不变,且不可能是其他奇异局势的差,因此也是非奇异局势. 采用适当的方法,可以将非奇异局势变为奇异局势. 假设面对的局势是(a,b),若b = a,则同时从两堆中取走a个物体,就变为了奇异局势(0,0)如果a = ak,b &gt; bk,那么,取走b - bk个物体,即变为奇异局势如果a = ak,b &lt; bk,则同时从两堆中拿走ak - ab - ak个物体,变为奇异局势( ab - ak , ab - ak+ b - ak)如果a &gt; ak,b= ak + k,则从第一堆中拿走多余的数量a - ak 即可如果a &lt; ak,b= ak + k,分两种情况,第一种,a=aj (j &lt; k),从第二堆里面拿走b - bj 即可第二种,a=bj (j &lt; k),从第二堆里面拿走b - aj 即可. 从如上性质可知,两个人如果都采用正确操作,那么面对非奇异局势,先拿者必胜；反之,则后拿者取胜. 那么任给一个局势(a,b),怎样判断它是不是奇异局势呢？我们有如下公式：ak = k(1+√5)/2 (下取整), bk= ak + k (k∈N)奇妙的是其中出现了有关黄金分割数的式子：(1+√5)/2 =1.618…,若两堆物品个数分别为x,y(x&lt;y)，则k=y-x，再判断x是否等于[(y-x)*( √5+1)/2]即可得知是否是奇异局势。 尼姆博弈有三堆各若干个物品,两个人轮流从某一堆取任意多的物品,规定每次至少取一个,多者不限,最后取光者得胜. 这种情况最有意思,它与二进制有密切关系,我们用(a,b,c)表示某种局势,首先(0,0,0)显然是奇异局势,无论谁面对奇异局势,都必然失败.第二种奇异局势是(0,n,n),只要与对手拿走一样多的物品,最后都将导致(0,0,0).仔细分析一下,(1,2,3)也是奇异局势,无论对手如何拿,接下来都可以变为(0,n,n)的情形.计算机算法里面有一种叫做按位模2加,也叫做异或的运算,我们用符号xor表示这种运算.这种运算和一般加法不同的一点是1+1=0.先看(1,2,3)的按位模2加的结果： 1 =二进制01Xor 2 =二进制10Xor 3 =二进制11———————0 =二进制00 对于奇异局势(0,n,n)也一样,结果也是0.任何奇异局势(a,b,c)都有a xor b xor c =0。该结论可以推广至若干堆，都是成立的如果我们面对的是一个非奇异局势(a,b,c),要如何变为奇异局势呢？假设a &lt; b&lt; c,我们只要将c 变为a xor b,即可,因为有如下的运算结果: a xor b xor (a xor b)=(a xor a) xor (b xor b)=0 xor 0=0.要将c 变为a xor b,只要从c中减去c-(a xor b)即可. Nim Staircase博奕:这个问题是尼姆博弈的拓展：游戏开始时有许多硬币任意分布在楼梯上，共n阶楼梯从地面由下向上编号为0到n。游戏者在每次操作时可以将楼梯j(1&lt;=j&lt;=n)上的任意多但至少一个硬币移动到楼梯j-1上。游戏者轮流操作，将最后一枚硬币移至地上（0号）的人获胜。算法：将奇数楼层的状态异或，和为0则先手必败，否则先手必胜。","tags":[{"name":"博弈","slug":"Game","permalink":"https://www.oyohyee.com/tags/Game/"},{"name":"巴什博奕","slug":"Bash","permalink":"https://www.oyohyee.com/tags/Bash/"},{"name":"威佐夫博奕","slug":"Wythoff","permalink":"https://www.oyohyee.com/tags/Wythoff/"},{"name":"尼姆博弈","slug":"Nim","permalink":"https://www.oyohyee.com/tags/Nim/"},{"name":"Nim Staircase博奕","slug":"Nim-Staircase","permalink":"https://www.oyohyee.com/tags/Nim-Staircase/"}]},{"title":"VPS搭建Git服务器及git pages","date":"2016-06-26T10:25:17.000Z","path":"/post/Note/VPS_hexo.html","text":"对比了以下腾讯云和阿里云,觉得个人更喜欢腾讯云一点腾讯云每天中午12点能够在官网上抢学生优惠一个月1元钱拿到 VPS 服务器练手专用 抢到后选择 65 的服务器(一个月),然后用抢到的 64 优惠券购买以后每个月记得去领一次优惠券即可(不用抢) 弄好后,选择了 Linux 系统的服务器既然是学习,再用 Windows 就没有意思了嘛~~~ 使用了 CentOS 7.2 64位初始化完成后,只需要 yum install git就可以在服务器上安装上 git同理可以安装 python nodejs 等内容安装好 nodejs 后,直接 npm install hexo -g就可以安装 hexo不过这个其实没必要,如果文章比较多,其实在服务器上跑生成会被系统强行杀死的 不过我们可以模仿 github 那样搭建自己的 gitpages 首先解决权限问题, git的操作最好给一个特定的用户我们新建一个 git 用户adduser gitpasswd 进入用户目录 /home/git这里有一个隐藏的文件夹 .ssh在这个文件夹里就是我们 ssh 相关的配置文件新建一个 authorized_keys 文件把我们本地的 id_rsa.pub 的内容放进去,这样服务器就会同意我们的电脑通过 ssh 连接进来所有文件的所有者和用户组都应该是 git ,并且权限也要设置好 然后在他的用户目录里新建一个文件夹作为我们的git库mkdir gitcd gitgit init --bare 这样我们的 git 服务器就搭建好了把本机的远程仓库地址填成 git@[vps地址]:[目录地址(以/home/git为根目录)]push 上去就行了 那么怎么显示出来呢我们可以再搭建一个 nginx每次推送上去后把文件复制到 nginx 的目录里 这就需要 git hooks 来实现了进入 git 服务器的目录里有一个 hooks 目录新建一个 post-receive 文件touch post-receive 然后内容改为#!/bin/bashecho BEGINrm -rf /home/git/hexogit clone /home/git/hexo.git /home/git/hexorm /home/git/task/urls.txtcp /home/git/hexo/urls.txt /home/git/task/urls.txtrm -rf /usr/share/nginx/hexo/*mv /home/git/hexo/* /usr/share/nginx/hexoecho BLOG FINISHgit push -u origin master -fecho FINISH 自己改为自己对应的目录 解释下内容 #!/bin/bash 告诉系统这个以 bash 形式运行文件rm -rf /home/git/hexogit clone /home/git/hexo.git /home/git/hexo删除并重新 clone 出博客(必须clone在git有权限操作的目录里) rm /home/git/task/urls.txtcp /home/git/hexo/urls.txt /home/git/task/urls.txt复制一份生成的所有文章的链接的文件(用于提交到百度站长,可以不要这两行) rm -rf /usr/share/nginx/hexo/*mv /home/git/hexo/* /usr/share/nginx/hexo删除 nginx 的网站目录下的文件,并将新的内容移动过去(git需要该目录的权限) 这样就完成了我们自己的 git pages 的搭建 git push -u origin master -f这个可以顺便把我们的博客推送到 github 和 Coding在 git 目录里设置下 remote 即可","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.oyohyee.com/tags/Linux/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.oyohyee.com/tags/Hexo/"},{"name":"Git","slug":"Git","permalink":"https://www.oyohyee.com/tags/Git/"},{"name":"VPS","slug":"VPS","permalink":"https://www.oyohyee.com/tags/VPS/"}]},{"title":"域名跳转","date":"2016-06-26T10:25:17.000Z","path":"/post/Note/UrlJump.html","text":"博客是搭建在Github和Coding上的Github的默认域名是ohyee.github.io,CNAME后会将强制跳转到绑定的域名上而Coding的默认域名是ohyee.coding.me,这个域名和绑定的域名都可以独立访问 也即：网站有两套独立的域名显然,这样会很“别扭”,搜索引擎会对两个域名分别收录一遍网站因此萌生了将ohyee.coding.me强制跳转到www.oyohyee.com的想法 由于在Git Pages和Coding Pages不能设置301重定向,因此使用javascript来实现跳转 首先是获取当前域名host = window.location.host;host2 = document.domain;url = window.location.href; 前两种方法获取根域名,帮助我们判断现在访问的是哪个域名最后一个是获取完整域名,用于接下来的跳转 在这里分别输出下三种方法调用出来的结果 host = window.location.host; host2 = document.domain; url = window.location.href; document.write(\"host=\"+host+\"\") document.write(\"host2=\"+host2+\"\") document.write(\"url=\"+url+\"\") 前两种方法在使用时是一样的,不过第一种在本地调试(localhost:4000)会返回localhost:4000,而第二种是localhost 如果获取到的host为ohyee.coding.me,则替换根域名部分window.location.href= url.replace(/ohyee.coding.me/,\"www.oyohyee.com\") 完整的代码域名跳转&lt;script language=\"javascript\"&gt; host = window.location.host if(host == \"ohyee.coding.me\") window.location.href = window.location.href.replace(/ohyee.coding.me/,\"www.oyohyee.com\")&lt;/script&gt; 效果展示&gt;http://ohyee.coding.me/&lt;","tags":[{"name":"javascript","slug":"Javascript","permalink":"https://www.oyohyee.com/tags/Javascript/"}]},{"title":"Codeforces 681B.Economy Game","date":"2016-06-26T05:55:27.000Z","path":"/post/Codeforces/681B.html","text":"题目 Description Kolya is developing an economy simulator game. His most favourite part of the development process is in-game testing. Once he was entertained by the testing so much, that he found out his game-coin score become equal to 0. Kolya remembers that at the beginning of the game his game-coin score was equal to n and that he have bought only some houses (for 1 234 567 game-coins each), cars (for 123 456 game-coins each) and computers (for 1 234 game-coins each). Kolya is now interested, whether he could have spent all of his initial n game-coins buying only houses, cars and computers or there is a bug in the game. Formally, is there a triple of non-negative integers a, b and c such that a × 1 234 567 + b × 123 456 + c × 1 234 = n? Please help Kolya answer this question. InputThe first line of the input contains a single integer n (1 ≤ n ≤ 109) — Kolya’s initial game-coin score. Output Print “YES” (without quotes) if it’s possible that Kolya spent all of his initial n coins buying only houses, cars and computers. Otherwise print “NO” (without quotes). Sample Input Input 1359257 Output YES Input 17851817 Output NO 题解暴力模拟妥妥的超时换用动态规划 dp[i]表示i是否满足当dp[i-1234]、dp[i-123456]、dp[i-1234567]中有任一个满足，则dp[i]满足 初始化dp[0]=0 由于n最大为1000000000,仍然是一个非常大的数字仅仅打表就需要3、4秒因此应该进一步优化 把1~1000000000输出发现:当n &gt;= 27406118时，所有的都是YES因此我们的计算量又小了一个数量级。 这时再打表可以瞬间输出答案 代码Codeforce 681B代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const long long A = 1234567;const long long B = 123456;const long long C = 1234;const int maxn = 27406118;bool dp[maxn];bool Do() &#123; int n; bool OK = false; if(scanf(\"%d\",&amp;n) == EOF) return false; /*for(long long i = 0;(i*C &lt;= n) &amp;&amp; !OK;i++) &#123; for(long long j = 0;(i*C + j*B &lt;= n) &amp;&amp; !OK;j++) &#123; for(long long k = 0;(i*C + j*B + k*A &lt;= n) &amp;&amp; !OK;k++) &#123; if(i*C + j*B + k*A == n) &#123; OK = true; printf(\"%lld %lld %lld \\n\",i,j,k); &#125; &#125; &#125; &#125;*/ if(n&gt;=maxn||dp[n]) printf(\"YES\\n\"); else printf(\"NO\\n\"); return true;&#125;int main() &#123; memset(dp,false,sizeof(dp)); dp[0] = true; for(int i = 1;i &lt; maxn;i++) &#123; if((i - A &gt;= 0 &amp;&amp; dp[i - A]) || (i - B &gt;= 0 &amp;&amp; dp[i - B]) || (i - C &gt;= 0 &amp;&amp; dp[i - C])) dp[i] = true; &#125; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"Codeforces 681A.A_Good_Contest","date":"2016-06-26T05:16:12.000Z","path":"/post/Codeforces/681A.html","text":"题目 Description Codeforces user’ handle color depends on his rating — it is red if his rating is greater or equal to 2400; it is orange if his rating is less than 2400 but greater or equal to 2200, etc. Each time participant takes part in a rated contest, his rating is changed depending on his performance. Anton wants the color of his handle to become red. He considers his performance in the rated contest to be good if he outscored some participant, whose handle was colored red before the contest and his rating has increased after it. Anton has written a program that analyses contest results and determines whether he performed good or not. Are you able to do the same? InputThe first line of the input contains a single integer n (1 ≤ n ≤ 100) — the number of participants Anton has outscored in this contest . The next n lines describe participants results: the i-th of them consists of a participant handle namei and two integers beforei and afteri ( - 4000 ≤ beforei, afteri ≤ 4000) — participant’s rating before and after the contest, respectively. Each handle is a non-empty string, consisting of no more than 10 characters, which might be lowercase and uppercase English letters, digits, characters «_» and «-» characters. It is guaranteed that all handles are distinct. Output Print «YES» (quotes for clarity), if Anton has performed good in the contest and «NO» (quotes for clarity) otherwise. Sample Input Input 3Burunduk1 2526 2537BudAlNik 2084 2214subscriber 2833 2749 Output YES Input 3Applejack 2400 2400Fluttershy 2390 2431Pinkie_Pie -2500 -2450 Output NO 题解名字没有用，只判断读入的分数a,b是不是满足a&gt;=2400 &amp;&amp; b&gt;a 代码Codeforce 681A代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;bool Do() &#123; int T; if(scanf(\"%d\",&amp;T) == EOF) return false; bool OK = false; for(int i = 0;i &lt; T;i++) &#123; int a,b; scanf(\"%*s%d%d\",&amp;a,&amp;b); if(!OK) if(a &gt;= 2400 &amp;&amp; b &gt; a) OK = true; &#125; if(OK) printf(\"YES\\n\"); else printf(\"NO\\n\"); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.oyohyee.com/tags/Codeforces/"}]},{"title":"HDU 2955.Robberies","date":"2016-06-26T04:40:39.000Z","path":"/post/HDU/2955.html","text":"题目 Description The aspiring Roy the Robber has seen a lot of American movies, and knows that the bad guys usually gets caught in the end, often because they become too greedy. He has decided to work in the lucrative business of bank robbery only for a short while, before retiring to a comfortable job at a university. For a few months now, Roy has been assessing the security of various banks and the amount of cash they hold. He wants to make a calculated risk, and grab as much money as possible. His mother, Ola, has decided upon a tolerable probability of getting caught. She feels that he is safe enough if the banks he robs together give a probability less than this. InputThe first line of input gives T, the number of cases. For each scenario, the first line of input gives a floating point number P, the probability Roy needs to be below, and an integer N, the number of banks he has plans for. Then follow N lines, where line j gives an integer Mj and a floating point number Pj .Bank j contains Mj millions, and the probability of getting caught from robbing it is Pj . Output For each test case, output a line with the maximum number of millions he can expect to get while the probability of getting caught is less than the limit set. Notes and Constraints0 &lt; T &lt;= 1000.0 &lt;= P &lt;= 1.00 &lt; N &lt;= 1000 &lt; Mj &lt;= 1000.0 &lt;= Pj &lt;= 1.0A bank goes bankrupt if it is robbed, and you may assume that all probabilities are independent as the police have very low funds. Sample Input 30.04 31 0.022 0.033 0.050.06 32 0.032 0.033 0.050.10 31 0.032 0.023 0.05 Sample Output 246 翻译 描述 有志盗贼Roy看了许多美国电影后，发现许多坏蛋被抓的原因是因为他们太贪心。他决定在退休前在一个利润丰厚的银行干一票大的。经过几个月，Roy已经从各方面评估了银行的各个方面，他想要做一个稳妥的冒险，然后尽可能抢到更多的钱。他的妈妈Ola，确定了一个能够容忍的被抓概率。如果被抓的概率大于这个数，那么Roy就不应该去抢劫。 输入 第一行输入T数据个数。对于每组数据，第一行给一个浮点数P(Roy被抓的概率需要小于这个数)，一个整数N(Roy打算抢劫的银行个数)接下来的N行，第j给了一个整数Mj(银行钱数)和一个浮点数Pj（被抓的概率） 输出 对于每一组数据，输出一行数。包含其在被抓几率允许范围内所能强到的最大钱数银行被抢看作独立事件，不互相影响 题解对于银行i,有钱Mi,被抓几率pi,不被抓的几率为1-p[i]有抢和不抢两种选择 因此，可以看出来这道题是01背包问题 但是这道题不能用普通的01背包问题思路(dp[i][j]表示抢劫前i个银行，在被抓几率不大于j时所能抢到最多的钱数)求解理由如下： 被抓几率是不知道有多少位的小数，不能直接用于下标 概率应该相乘，简单的乘除可能会造成重复问题 不能用被抓几率当作背包的下标 发散思维，可以将dp[i][j]看作抢劫前i个银行，在抢劫到j元时，最大的不被抓几率 也即dp[i] = max(dp[i],dp[i - m[i]] * (1-p[i])); 最后在将钱数从大往下筛选，第一个符合dp[i] &gt;= 1-P的就是答案 代码HDU_2955.Robberies代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 105;double P,p[maxn];int N,m[maxn];int v;double dp[maxn*maxn];void ZeroOnePack(int cost,double weight) &#123; for(int i = v; i &gt;= cost; i--) dp[i] = max(dp[i],dp[i - cost] * weight);&#125;void Do() &#123; //初始化数据 memset(dp,0,sizeof(dp)); dp[0] = 1; v = 0; //数据输入 scanf(\"%lf%d\",&amp;P,&amp;N); for(int i = 1;i &lt;= N;i++) &#123; scanf(\"%d%lf\",&amp;m[i],&amp;p[i]); v += m[i]; &#125; //dp for(int i = 1;i &lt;= N;i++) ZeroOnePack(m[i],1-p[i]); int ans; for(ans = v;ans &gt; 0;ans--) &#123; if(dp[ans] &gt;= 1-P) break; &#125; printf(\"%d\\n\",ans);&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) &#123; Do(); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"}]},{"title":"2016-06-23 ~ 2016-06-25 学习报告","date":"2016-06-25T10:10:10.000Z","path":"/post/Study/2016_06_23-2016_06_25.html","text":"这三天主要是尽可能AC之前没有AC的题目。 京胜杯的木条染色还是没AC 题目： HDU 1003.Max Sum POJ 3349.Snowflake Snow Snowflakes","tags":[{"name":"学习报告","slug":"Study","permalink":"https://www.oyohyee.com/tags/Study/"}]},{"title":"POJ 3349.Snowflake Snow Snowflakes","date":"2016-06-23T14:52:50.000Z","path":"/post/POJ/3349.html","text":"题目 Description You may have heard that no two snowflakes are alike. Your task is to write a program to determine whether this is really true. Your program will read information about a collection of snowflakes, and search for a pair that may be identical. Each snowflake has six arms. For each snowflake, your program will be provided with a measurement of the length of each of the six arms. Any pair of snowflakes which have the same lengths of corresponding arms should be flagged by your program as possibly identical. InputThe first line of input will contain a single integer n, 0 &lt; n ≤ 100000, the number of snowflakes to follow. This will be followed by n lines, each describing a snowflake. Each snowflake will be described by a line containing six integers (each integer is at least 0 and less than 10000000), the lengths of the arms of the snow ake. The lengths of the arms will be given in order around the snowflake (either clockwise or counterclockwise), but they may begin with any of the six arms. For example, the same snowflake could be described as 1 2 3 4 5 6 or 4 3 2 1 6 5. Output If all of the snowflakes are distinct, your program should print the message:No two snowflakes are alike.If there is a pair of possibly identical snow akes, your program should print the message:Twin snowflakes found. Sample Input 21 2 3 4 5 64 3 2 1 6 5 Sample Output Twin snowflakes found. 题解使用哈希表来存储雪花信息各位长度之和充当哈希函数当产生冲突时，检验是否相同，相同的话就按照要求输出，否则插入到哈希表里 对于一个指针，sizeof()返回是指针对应的数据类型的长度。如果是一个指向数组的指针，并不会返回数组长度 代码AC代码代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxl = 10000005;const int maxn = 100005;const int HashSize = maxn;int HashTable[HashSize];int Next[maxn];int Link[maxn][6];int pos;void Init() &#123; pos = 0; memset(Next,-1,sizeof(Next)); memset(HashTable,-1,sizeof(HashTable));&#125;//hashbool HashCmp(int a[6],int b[6]) &#123; for(int i = 0;i &lt; 6;i++) &#123; if(a[i] == b[0]) &#123; for(int k = 1;k == 1 || k == -1;k -= 2) &#123; for(int j = 1;j &lt; 6;j++) &#123; int n = (i + k*j + 6) % 6; if(a[n] != b[j]) break; else if(j == 5) return true; &#125; &#125; &#125; &#125; return false;&#125;int Hash(int a[6]) &#123; int sum = 0; for(int i = 0;i &lt; 6;i++) sum += a[i]; return sum%HashSize;&#125;bool HashInsert(int a[6]) &#123; int h = Hash(a); if(HashTable[h] == -1) &#123; memcpy(Link[pos],a,6 * sizeof(int)); HashTable[h] = pos++; &#125; else &#123; int k = HashTable[h]; int last = HashTable[h]; while(k != -1) &#123; if(HashCmp(a,Link[k])) return false; last = k; k = Next[k]; &#125; memcpy(Link[pos],a,6 * sizeof(int)); Next[last] = pos++; &#125; return true;&#125;bool Do() &#123; int n; scanf(\"%d\",&amp;n); Init(); bool Find = false; int a[6]; for(int o = 0;o &lt; n;o++) &#123; for(int i = 0;i &lt; 6;i++) scanf(\"%d\",&amp;a[i]); if(!HashInsert(a)) &#123; Find = true; break; &#125; &#125; if(Find) printf(\"Twin snowflakes found.\\n\"); else printf(\"No two snowflakes are alike.\\n\"); return false;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"},{"name":"哈希(hash)","slug":"Hash","permalink":"https://www.oyohyee.com/tags/Hash/"}]},{"title":"HDU 1003.Max Sum","date":"2016-06-23T08:48:03.000Z","path":"/post/HDU/1003.html","text":"题目 Description Given a sequence a[1],a[2],a[3]……a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14. InputThe first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line starts with a number N(1&lt;=N&lt;=100000), then N integers followed(all the integers are between -1000 and 1000). Output For each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line contains three integers, the Max Sum in the sequence, the start position of the sub-sequence, the end position of the sub-sequence. If there are more than one result, output the first one. Output a blank line between two cases. Sample Input 25 6 -1 5 4 -77 0 6 -1 1 -6 7 -5 Sample Output Case 1:14 1 4 Case 2:7 1 6 题解采用递归与分治的思路类似题目：AOJ 807.算法期末考试C(最大子序列和) 采用与上面题目类似的思路。在找到最大值(更大的值)时，记录子序列的首尾位置。 由于要输出第一个最大的子序列的位置。因此，如果有多组解，应该选取子序列头最小，子序列尾最大的序列。 因此，对于一次递归。当中间位置左侧不过中间位置最大时，只有中间位置左侧不过中间位置小于经过中间位置才更新；当经过中间位置不过中间位置最大时，经过中间位置小于中间位置右侧不过中间位置才更新。 需要特别处理只有剩下一个数的情况。 代码Max Sum代码备份/*By:OhYeeGithub:OhYeeBlog:http://www.oyohyee.com/Email:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;const int maxn = 100005;//const int INF = (1 &lt;&lt; 31) - 1;const int INF = 0x7fffffff;int a[maxn];int dfs(int *a,int l,int r,int &amp;begin,int &amp;end) &#123; if(l == r) &#123; begin = end = l; return a[l]; &#125; if(l &gt; r) &#123; begin = end = -1; return -INF; &#125; int mid = (l + r) / 2; int Max; int ans; int tbegin,tend; begin = end = mid; //中间 int i; ans = 0; int maxl = 0; for(i = mid - 1;i &gt;= l;i--) &#123; ans += a[i]; if(ans &gt;= maxl) &#123; maxl = ans; begin = i; &#125; &#125; ans = 0; int maxr = 0; for(i = mid + 1;i &lt;= r;i++) &#123; ans += a[i]; if(ans &gt; maxr) &#123; maxr = ans; end = i; &#125; &#125; Max = maxl + a[mid] + maxr; //左侧 ans = dfs(a,l,mid - 1,tbegin,tend); if(ans &gt;= Max) &#123; Max = ans; begin = tbegin; end = tend; &#125; //右侧 ans = dfs(a,mid + 1,r,tbegin,tend); if(ans &gt; Max) &#123; Max = ans; begin = tbegin; end = tend; &#125; return Max;&#125;void Do() &#123; int n,l,r; scanf(\"%d\",&amp;n); for(int i = 1;i &lt;= n;i++) scanf(\"%d\",&amp;a[i]); int ans = dfs(a,1,n,l,r); printf(\"%d %d %d\\n\",ans,l,r); return;&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); for(int i = 1;i &lt;= T;i++) &#123; if(i != 1) printf(\"\\n\"); printf(\"Case %d:\\n\",i); Do(); &#125; return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"递归与分治","slug":"Recursion","permalink":"https://www.oyohyee.com/tags/Recursion/"},{"name":"最大连续子序列","slug":"MCS","permalink":"https://www.oyohyee.com/tags/MCS/"}]},{"title":"KMP算法","date":"2016-06-17T19:22:16.000Z","path":"/post/Algorithm/KMP.html","text":"有这么一个神奇的算法KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。 百度百科KMP算法 字符串匹配算法，要求我们对于两个字符串a,b。找出字符串b在字符串a中第一次出现的位置。 例如在ABCABCABCDABC中寻找ABCABCD按照较为暴力的搜索方法，当我们搜索到 A B C A B C A B C D A B C A B C A B C D &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 发现最后一个不匹配，则我们应该改变起始位置，从头开始匹配 A B C A B C A B C D A B C &nbsp; A B C A B C D &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 显然，这样改变效率极为低下。因为当我们能够匹配到D，证明字符串前面一定是ABCABC因此，应该充分利用已经匹配过的部分，从而更快速地匹配。 这个神奇的算法叫做KMP算法对字符串b进行分析：假如我们匹配到D，字符串a一定有ABCABCX，这时，我们只需要从上一个ABC处继续匹配即可。即： A B C A B C A B C D A B C &nbsp; &nbsp; &nbsp; A B C A B C D &nbsp; &nbsp; &nbsp; 而这样做的原理是什么呢? 对于已经确定的ABCABC,需要找的应该是：尽可能找到一个最长的字符串满足从头开始到一个位置与从一个位置到最后匹配的地方相同 或者换种描述方式：尽可能少地舍弃已匹配字符串后面的部分，使剩下未舍弃的部分能够与已知部分后部相同 之所以要尽可能少舍弃已匹配部分，是因为匹配字符串是从前向后匹配的，因此字符串b前面部分必须是留下的； 之所以让剩下未舍弃的部分能够与已知部分后部相同，是因为下一位不匹配，匹配点应该后移，因此字符串b需要往后移，最后字符串a留下的是已匹配部分后面部分 可以发现，不管是字符串a已匹配部分的后半部分还是字符串b的前半部分，其实都应该在字符串b已匹配部分中。 也就是说，我们只需要找到字符串b已匹配部分中，从前往后一个一个加字符的所有字符串(前缀字符串)和从后往前一个一个加字符串的所有字符串(后缀字符串)即可 对ABCABC其有前缀字符串： A AB ABC ABCA ABCAB 有后缀字符串： C BC ABC CABC BCABC 可以看出，其前缀字符串和后缀字符串最长的匹配是ABC,长度为3 也就是说，当我们匹配到D发现不匹配时，我们保持在字符串a中的位置i不变，在字符串b中的位置j向前移动3个距离 由于匹配到j时，我们要找的最长匹配其实是到这个位置上一个位置的最长匹配，因此将字符串b中所有的最长匹配按照位置依次后移一位就是next数组 字符串b中的第一个字符没有前一个字符，因此应该特殊处理(如果到这里都没有匹配到，那么就意味着需要从0开始匹配，没有已匹配部分了)，可以将其记为-1 位置 0 1 2 3 4 5 6 7 8 9 字符串 A B C A B C A B C D 最长匹配 0 0 0 1 2 3 4 5 6 0 next[] -1 0 0 0 1 2 3 4 5 6 我只想知道怎么应付考试next数组的含义到该位置上一个位置字符串的前缀字符串和后缀字符串最大的匹配数如果每次都这样计算，显然计算量会非常大。 因此，可以采取其他方法计算next数组。 由于前缀字符串的第一个字符是确定的(总是字符串b的第一个字符)后缀字符串的最后一个字符也总是确定的(总是已匹配部分最后一个字符) 采用递推的思想，当我们计算next[j]时，next[j-1]必定是计算好的并且，next[j-1]对应的必定是j-1位置的字符的最大匹配数。如果在字符串中加上j位置的字符，相当于改变了后缀字符串的最后一个字符。如果要找新的字符串的最大匹配，只需要看旧的字符串最大匹配位置的下一个位置是不是和新的字符相同如果相同，那么必然直接将上一个最大匹配+1即可如果不相同，就找更短的那个匹配，查看它下一个位置的字符是否相同。 举个例子：对于char b[]=ABCABCD有： j=0，记录next[0]=-1 j=1，记录next[1]=0 j=2，查看b[next[2-1]](A)与b[2-1](B)。不相同，查看b[next[next[2-1]]](无意义)。记录next[2]=0 j=3，查看b[next[3-1]](A)与b[3-1](C)。不相同，查看b[next[next[3-1]]](无意义)。记录next[3]=0 j=4，查看b[next[4-1]](A)与b[4-1](A)。相同，记录next[4]=next[next[4-1]]+1(1) j=5，查看b[next[5-1]](B)与b[5-1](B)。相同，记录next[5]=next[next[5-1]]+1(2) j=6，查看b[next[6-1]](C)与b[6-1](C)。相同，记录next[6]=next[next[6-1]]+1(3) j=7，查看b[next[7-1]](A)与b[7-1](C)。相同，记录next[7]=next[next[7-1]]+1(4) j=8，查看b[next[8-1]](B)与b[8-1](C)。相同，记录next[8]=next[next[8-1]]+1(5) j=9，查看b[next[9-1]](C)与b[9-1](C)。相同，记录next[9]=next[next[9-1]]+1(6) 如果还有j=10(b[10]=E)，查看b[next[10-1]](A)与b[10-1](D)。不相同，查看b[next[next[10-1]]](A)不相同，查看b[next[next[next[10-1]]]](A)不相同，查看b[next[next[next[next[10-1]]]]](无意义)。记录next[10]=0 也即 位置 0 1 2 3 4 5 6 7 8 9 10 字符串 A B C A B C A B C D E next[] -1 0 0 0 1 2 3 4 5 6 0 按照学校的数据结构教材上，需要把next数组所有数加上1(从1开始的字符串) 代码实现待补充","tags":[{"name":"KMP","slug":"KMP","permalink":"https://www.oyohyee.com/tags/KMP/"}]},{"title":"算法期末考试","date":"2016-06-15T08:51:00.000Z","path":"/post/Project/AlgorithmFinalTest.html","text":"算法设计及其高效实现期末考试 全部是本学期算法课学到的内容：递归与分治、动态规划 全部是原题，不过当时写完也不知道对不对~ 这么一交题目，总在意想不到的小地方有问题~ 题目编号 题目链接 考点 题解链接 A 算法期末考试A 全排列问题 AOJ 805.算法期末考试A B 算法期末考试B 动态规划问题 AOJ 806.算法期末考试B C 算法期末考试C 最大子序列和问题 AOJ 807.算法期末考试C D 算法期末考试D 整数分解问题 AOJ 808.算法期末考试D","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"递归与分治","slug":"Recursion","permalink":"https://www.oyohyee.com/tags/Recursion/"}]},{"title":"AOJ 808.算法期末考试D(整数拆分)","date":"2016-06-15T08:31:14.000Z","path":"/post/AOJ/808.html","text":"题目 Description 将正整数n表示成一系列正整数之和：n=n1+n2+…+nk，其中n1≥n2≥…≥nk≥1，k≥1。正整数n的这种表示称为正整数n的划分。求正整数n的不同划分个数。例如正整数6有如下11种不同的划分：6；5+1；4+2，4+1+1；3+3，3+2+1，3+1+1+1；2+2+2，2+2+1+1，2+1+1+1+1；1+1+1+1+1+1。 Input多组输入EOF结束，每组输入包含一个数字n表示要拆分的数字(1&lt;=n&lt;=50) Output 对于每组输入，输出所有的拆分，每个拆分一行。对于每个拆分，先输出大的数字，再输出小的数字。对于所有拆分，先输出拆分中最大数较大的，最大数相等时先输出次大数较大的….这样的顺序，具体见样例 Sample Input 56 Sample Output 54+13+23+1+12+2+12+1+1+11+1+1+1+165+14+24+1+13+33+2+13+1+1+12+2+22+2+1+12+1+1+1+11+1+1+1+1+1 题解对于一个整数a我们对其进行拆分，可以从a里面分出小于a的所有自然数Ni。这时，我们还需要分解a-Ni，并且以后再分解出的数不能够超过Ni根据这个可以写出递归的函数每加深一层递归，就把当前选择的数记录下来，当递归到最后时输出即可 如果使用int数组记录，则会导致超时而显然算法上已经很难在优化了。应该使用char数组来记录数据，因为直接输出字符串，比循环拼接一群int要快` 要特别注意，如果当前要记录的数i满足i&gt;=10,那么我们将其转换成char时，需要逐位进行转换。 递归的终点是需要分解的数小于等于0当递归到需要分解的数为0时，输出 代码整数拆分代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/ かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std; const int maxn = 55*2*2;char flag[maxn]; void DFS(int a,int max,int pos) &#123; if(a &lt; 0) return; if(a == 0) &#123; /*for(int i = 0;i &lt; pos;i++) &#123; if(i) printf(\"+\"); printf(\"%d\",flag[i]); &#125; printf(\"\\n\");*/ flag[pos - 1] = '\\0'; printf(\"%s\\n\",flag); return; &#125; for(int i = max;i &gt;= 1;i--) &#123; //将整数i转化成char int pos2 = pos; int bit = 1; int j = i; while(j) &#123; j /= 10; bit *= 10; &#125; bit /= 10; j = i; while(bit) &#123; flag[pos2++] = (j / bit) + '0'; j %= bit; bit /= 10; &#125; //flag[pos] = i+'0'; flag[pos2++] = '+'; DFS(a - i,i,pos2); //flag[pos] = -1; &#125;&#125; bool Do() &#123; int n; if(scanf(\"%d\",&amp;n) == EOF) return false; DFS(n,n,0); return true;&#125; int main() &#123; while(Do()); /*for(int i = 5;i &lt;=6;i++) DFS(i,i,0);*/ return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"递归与分治","slug":"Recursion","permalink":"https://www.oyohyee.com/tags/Recursion/"}]},{"title":"AOJ 807.算法期末考试C(最大子序列和)","date":"2016-06-15T08:25:03.000Z","path":"/post/AOJ/807.html","text":"题目 Description 给一串整数a[1..n]，求出其和最大的子序列，即找出1&lt;=i&lt;=j&lt;=n（1&lt;=n&lt;=50000），使a[i]+a[i+1]+…+a[j]最大。 Input多组输入，EOF结束，每组输入包含两行，第一行有一个数字n表示有n个数字，第二行有n个数字，每个数字的绝对值小于1000。 Output 对于每组输入，输出最大子序列和 Sample Input 52 -3 -5 7 651 4 6 -9 10 Sample Output 1312 题解采用递归的思路来写 对于一列数a[]，其l到r之间的最大子序列和有如下可能对于mid=(l+r)/2 最大子序列和完全在mid左侧 最大子序列和完全在mid右侧 最大子序列和经过mid 那么，只需要用递归实现它即可。显然，前两种方法直接继续递归即可而最后一种可以分别向mid左侧和右侧进行循环，将两边所能达到的最大值与mid对应的值三个数相加 返回这三种情况的最大值即可 递归的终点是l&gt;r。此时，函数的意义不存在，返回值没有意义。我们可以返回-INF来确保不会对数据造成影响(INF是无穷大，或者说当前整数类型所能表示的最大数)当l==r时，我们应该返回这个相同的值 代码最大子序列和代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/ かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std; const int INF = 2&lt;&lt;30-1;const int maxn = 50005;int a[maxn]; int dfs(int *a,int l,int r) &#123; if(l == r) return a[l]; if(l &gt; r) return -INF; int mid = (l + r) / 2; int Max; int ans; //中间 ans = 0; int maxl = 0; for(int i = mid - 1;i &gt;= l;i--) &#123; ans += a[i]; if(ans &gt; maxl) maxl = ans; &#125; ans = 0; int maxr = 0; for(int i = mid + 1;i &lt;= r;i++) &#123; ans += a[i]; if(ans &gt; maxr) maxr = ans; &#125; Max = maxl + a[mid] + maxr; //左侧 Max = max(Max,dfs(a,l,mid - 1)); //右侧 Max = max(Max,dfs(a,mid + 1,r)); return Max;&#125; bool Do() &#123; int n; if(scanf(\"%d\",&amp;n) == EOF) return false; for(int i = 0;i &lt; n;i++) scanf(\"%d\",&amp;a[i]); printf(\"%d\\n\",dfs(a,0,n - 1)); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"递归与分治","slug":"Recursion","permalink":"https://www.oyohyee.com/tags/Recursion/"},{"name":"最大连续子序列","slug":"MCS","permalink":"https://www.oyohyee.com/tags/MCS/"}]},{"title":"AOJ 806.算法期末考试B(动态规划)","date":"2016-06-15T08:19:30.000Z","path":"/post/AOJ/806.html","text":"题目 Description 给定一个数塔，其存储形式为如下所示的下三角矩阵。在此数塔中，从顶部出发，在每一节点可以选择向下走还是向右下走，一直走到底层。请找出一条路径，使路径上的数值和最大。 Input多组输入，EOF结束，对于每组输入第一行为一个数字n表示数塔的高度，之后为n行，每行有1,2,3…n个数字（数字范围-100到100），表示数塔中的数字 Output 对于每组输入输出一行，表示最大值。 Sample Input 5912 1510 6 82 18 9 519 7 10 4 16 Sample Output 59 题解动态规划问题，将东西输入后从下往上刷(n-1 ~ 0)。计算到大第i层的第j个位置的最大值 dp[i][j] = dp[i][j] + max(dp[i+1][j],dp[i+1][j+1])即每一个位置应该与能到达它的最大位置相加 最后dp[0][0]就是答案 #代码期末算法考试B动态规划代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/ かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std; const int maxn = 1000; int Map[maxn][maxn]; bool Do() &#123; int n; if(scanf(\"%d\",&amp;n) == EOF) return false; memset(Map,0,sizeof(Map)); for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= i;j++) scanf(\"%d\",&amp;Map[i][j]); for(int i = n - 1;i &gt; 0;i--) for(int j = 1;j &lt;= i;j++) Map[i][j] += max(Map[i + 1][j],Map[i + 1][j + 1]); printf(\"%d\\n\",Map[1][1]); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"AOJ 805.算法期末考试A(全排列问题)","date":"2016-06-15T07:50:35.000Z","path":"/post/AOJ/805.html","text":"题目 Description 设计算法生成n个元素{r1,r2,…,rn}的全排列。n&lt;=10 Input包含多组输入EOF结束，每组输入包含一个只包含小写字母的字符串，长度不超过10. Output 输出这个字符串中所有字符的全排列，按照字典序输出。 Sample Input abc Sample Output abcacbbacbcacbacab 题解样例输出有问题 cbacab显然不是按照字典序的 不过，不管它。 由于需要按照字典序输出，因此不管输入的是abc还是cba答案都应该是一样的 因此，为了后面方便，可以使用sort先将字符串排成字典序 然后使用递推来找到所有的组合 可以将传一个已经参数char out[]表示已经这组输出前面部分的字符串每次将一个还没有输出过的数放进去即可 关于还没有输出过的数的判断按照我的思路应该是对于aa中的两个a应该是两个不同的字符也即输入 aa 输出的应该是 aaaa 不过貌似数据没有卡这一方面。 如果按照我的思路，那么可以用一个bool数组来记录该位置的数是否已经输出。 递归到最后一层，在字符串后面加上\\0，然后输出字符串即可。 代码全排列代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/ かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std; //const int INF = (2&lt;&lt;30)-1; const int maxn = 15;char s[maxn];bool flag[maxn];char out[maxn]; void DFS(char *s,int pos) &#123; int len = strlen(s); if(pos == len) &#123; out[pos] = '\\0'; printf(\"%s\\n\",out); &#125; for(int i = 0;i &lt; len;i++) &#123; if(!flag[i]) &#123; flag[i] = true; out[pos] = s[i]; DFS(s,pos+1); flag[i] = false; &#125; &#125;&#125; bool Do() &#123; if(scanf(\"%s\",s) == EOF) return false; int len = strlen(s); sort(s,s + len); memset(flag,false,sizeof(flag)); DFS(s,0); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"递归与分治","slug":"Recursion","permalink":"https://www.oyohyee.com/tags/Recursion/"},{"name":"全排列","slug":"ASP","permalink":"https://www.oyohyee.com/tags/ASP/"}]},{"title":"排序算法","date":"2016-06-14T12:03:11.000Z","path":"/post/Algorithm/Sort.html","text":"排序算法是非常基础的算法这篇文章里记录了 插入排序 直接插入排序 选择排序 简单选择排序 堆排序 交换排序 冒泡排序 快速排序 归并排序 基数排序 计数排序 STL qsort sort 其他排序算法 睡眠排序 插入排序直接插入排序对于一个数组，将数组中的数，按照大小插入到新数组的相应位置就是插入排序。对于其实现，有两种思路： 对内存进行优化 对时间进行优化 对内存进行优化由于对于两个数组，他们真正有效的大小恰好就是一个数组的大小。因此，我们可以记录一个标记，来保存新数组和老数组的界限。不过，如果一个数应该插入到最前端，则其他数需要依次后移，因此在排序降序数时显得会非常慢。 对速度进行优化最擅长插入操作的必然是链表依次，我们可以使用链表来存储新数组。这样我们可以在较短的时间内完成插入。如果需要的话，再用O(n)把链表转化成数组就行。 对速度优化的直接插入排序void InsertSort(int a[],int n) &#123; int *link = new int[n]; int *next = new int[n]; for(int i = 0;i &lt; n;i++) next[i] = -1; int pos = 0; link[pos++] = a[0]; int f = 0; for(int i = 1;i &lt; n;i++) &#123; if(link[f] &gt; a[i]) &#123; next[pos] = f; f = pos; &#125; else &#123; int t = f; while(next[t] != -1 &amp;&amp; a[i] &gt; link[next[t]]) t = next[t]; next[pos] = next[t]; next[t] = pos; &#125; link[pos++] = a[i]; &#125; int t = f; pos = 0; while(t != -1) &#123; a[pos++] = link[t]; t = next[t]; &#125; delete[] link; delete[] next;&#125; 选择排序简单选择排序简单选择排序和直接插入排序比较像，只是其目的是不停把数组中最小的放到最前面 简单选择排序void SelectSort(int a[],int n) &#123; for(int i = 0;i &lt; n - 1;i++) &#123; int Min = a[i + 1]; int pos = i + 1; for(int j = i;j &lt; n;j++) &#123; if(Min &gt; a[j]) &#123; Min = a[j]; pos = j; &#125; &#125; int temp = a[i]; a[i] = a[pos]; a[pos] = temp; &#125;&#125; 堆排序堆堆是一种数据结构，其有以下特性 堆总是一棵完全二叉树 对于大根堆，堆的每一个结点，总有父节点不小于其子结点 对于小根堆，堆的每一个结点，总有父节点不大于其子结点 因此，堆有着一定的顺序 使用堆进行排序根据堆天然的特性，对于一个大顶堆，我们可以直接将堆堆顶的元素放到数组尾部。 也即，对于给定的一个数组，先把它转化成一个大顶堆，然后每次取堆顶元素与数组尾部的元素(需要标记位置)交换位置。从堆顶开始重新调整堆的结点使其满足大顶堆的特性。 堆排序void AdjustHeap(int a[],int i,int n) &#123; int left = (i + 1) * 2 - 1; int right = (i + 1) * 2; int Max = i; if(left&lt;n &amp;&amp; a[left]&gt;a[Max]) &#123; Max = left; &#125; if(right&lt;n &amp;&amp; a[right]&gt;a[Max]) &#123; Max = right; &#125; if(i != Max) &#123; int temp = a[Max]; a[Max] = a[i]; a[i] = temp; AdjustHeap(a,Max,n); &#125;&#125;void HeapSort(int a[],int n) &#123; for(int i = n / 2;i &gt;= 0;i--) &#123; AdjustHeap(a,i,n); &#125; for(int i = 0;i &lt; n - 1;i++) &#123; int temp = a[0]; a[0] = a[n - 1 - i]; a[n - 1 - i] = temp; AdjustHeap(a,0,n - i - 1); &#125;&#125; 交换排序冒泡排序未优化的冒泡排序经典的排序算法，易于实现。 对于一组数据，从头开始循环，如果发现相邻的两个数，前面的数大于后面的数，则交换它们。这样，每一趟循环都能将最大的数放到最后。 优化的冒泡排序再分析冒泡排序的意义，我们可以知道，每一趟最后交换的位置就代表了该位置以后都已经排序完毕因此，我们可以记录下这一位置，每次循环只循环到上一次的位置即可。特别的，如果有一趟没有交换，则表示所有数据已排序完毕 优化的冒泡排序void BubbleSort(int a[],int n) &#123; int ThisSwapPosition = n;//本轮最后一个交换的位置 bool HasSwap = false; for(int i = 0;i &lt; n;i++) &#123; HasSwap = false; int LastSwapPosition = ThisSwapPosition;//上轮最后一个交换的位置 for(int j = 1;j &lt; LastSwapPosition;j++) &#123; if(a[j - 1] &gt; a[j]) &#123; int temp = a[j - 1]; a[j - 1] = a[j]; a[j] = temp; ThisSwapPosition = j; HasSwap = true;//本轮发生交换 &#125; &#125; if(!HasSwap) break; &#125;&#125; 快速排序一种非常快的交换排序。权衡空间和时间下非常好的一种排序算法。 有以下经典的例子 省图书馆看见两个志愿者需要把还回来的一堆书按顺序入架，管理员大妈给他们教的时候说：“你先在这堆书里拉出一本来，把比它号小的扔到一边，比它大的扔到另一边，然后剩下两堆继续这样整，这样排的快！”这是我见识过最惊艳的算法使用，没有之一！ 快速排序的思路是在待排序部分中取一个标准值，所有小于该标注的放在其左侧，大于标准值的放在其右侧。而后，分别对标准值左侧和右侧的部分进行快速排序。 在交换位置时，可以先不交换，而是先找大于标准值的，当找到后，再去找小于标准值的，当找够一组时交换它们。这样可以省去了额外的数组，同时保证的算法的速度。 快速排序void QuickSort(int a[],int l,int r) &#123; if(l &gt;= r) return; int left = l; int right = r; int mid = (a[l] + a[r] + a[(l + r) / 2]) / 3; bool move = false; while(left &lt; right) &#123; move = false; while(left &lt; right &amp;&amp; a[right] &gt; mid) &#123; right--; move = true; &#125; while(left &lt; right &amp;&amp; a[left] &lt; mid) &#123; left++; move = true; &#125; if(left &lt; right) &#123; int temp = a[right]; a[right] = a[left]; a[left] = temp; &#125; if(!move) right--; &#125; QuickSort(a,l,left); QuickSort(a,right + 1,r);&#125; 归并排序与快速排序类似，归并排序也是一种使用递归的排序算法。对于一个数组，先对其左半部分进行归并排序，再对其右半部份进行归并排序。最后将排序完的两部分合到一起。 归并排序void Merge(int a[],int l,int mid,int r) &#123; int pos1 = l;//左侧的指针 int pos2 = mid + 1;//右侧的指针 int *temp = new int[r - l + 1]; int pos = 0;//临时数组的指针 while(pos1 &lt;= mid || pos2 &lt;= r) &#123; if(pos1 &gt; mid) &#123; temp[pos++] = a[pos2++]; &#125; if(pos2 &gt; r) &#123; temp[pos++] = a[pos1++]; &#125; if(pos1 &lt;= mid&amp;&amp;pos2 &lt;= r) &#123; if(a[pos1] &lt;= a[pos2]) &#123; temp[pos++] = a[pos1++]; &#125; else &#123; temp[pos++] = a[pos2++]; &#125; &#125; &#125; //memcpy(a+l,temp,sizeof(temp)); for(int i = 0;i &lt;= r - l;i++) a[l + i] = temp[i];&#125;void MergeSort(int a[],int l,int r) &#123; if(l &lt; r) &#123; int mid = (l + r) / 2; MergeSort(a,l,mid); MergeSort(a,mid + 1,r); Merge(a,l,mid,r); &#125;&#125; 基数排序基数排序是一种特殊的桶排序。其使用了类似哈希(hash)的思想。首先采取一定的方法，对数据进行分类，再在每类中继续分类，最终达到排序完成。 而基数排序，通过每一位的数进行排序。先按照个位数的大小进行排序，再按照十位数的大小进行排序………… 不管是从高位开始排序，还是从低位开始，由于其之前的位已经按照顺序排好，因此当所有位排序完毕后就能得到排序好的数组。 计数排序void LSD(int a[],int n,int bit = 1) &#123; int bucket[10]; int rear[10]; int *link = new int[n]; int *next = new int[n]; bool flag = false; for(int i = 0;i &lt; 10;i++) bucket[i] = rear[i] = -1; for(int i = 0;i &lt; n;i++) next[i] = -1; int pos = 0; for(int i = 0;i &lt; n;i++) &#123; int h = a[i] / bit % 10; if(h) flag = true; if(bucket[h] == -1) &#123; bucket[h] = pos; &#125; else &#123; next[rear[h]] = pos; &#125; rear[h] = pos; link[pos++] = a[i]; &#125; if(flag) &#123; for(int bu = 0,pos = 0;pos &lt; n;bu++) &#123; int t = bucket[bu]; while(t != -1) &#123; a[pos++] = link[t]; t = next[t]; &#125; &#125; LSD(a,n,bit * 10); &#125; delete[] next; delete[] link;&#125; 计数排序最后就是速度超级快，耗用内存超级大，适用范围非常小的计数排序(使用数组排序)。 由于数组有着天然的顺序，我们可以用一个非常大的数组来记录数据，数组中的ai代表数字i在数据中有a[i]个 计数排序void ArraySort(int a[],int n) &#123; int Min = a[0]; int Max = a[0]; for(int i = 0;i &lt; n;i++) &#123; (a[i] &lt; Min) ? (Min = a[i]) : Min; (a[i] &gt; Max) ? (Max = a[i]) : Max; &#125; int *arr = new int[Max - Min + 1]; for(int i = 0;i &lt; Max - Min + 1;i++) arr[i] = 0; for(int i = 0;i &lt; n;i++) arr[a[i] - Min]++; int pos = 0; for(int i = 0;i &lt; Max - Min + 1 &amp;&amp; pos &lt; n;i++) for(int j = 0;j &lt; arr[i];j++) a[pos++] = i + Min; delete[]arr;&#125; STLqsortqsort使用的是快速排序，需要传入比较函数(compare) 其参数应该是两个void型的指针,返回值是int小于0(不交换)或大于0(交换) 如：整形的compareint cmp ( const void *a , const void *b )&#123; return *(int *)a - *(int *)b;&#125; char的compareint cmp( const void *a , const void *b )&#123; return *(char *)a - *(int *)b;&#125; double的compareint cmp( const void *a , const void *b )&#123; return *(double *)a &gt; *(double *)b ? 1 : -1;&#125; 结构体同上 sortsort是qsort的升级版，对于链表、向量都能够进行排序。根据数据量，还会有不同程度的优化。 传入参数的时候，前两个参数是待排序数据的首地址指针和尾地址指针。对于结构体可以自行写自己的比较函数来进行排序 由于非常广的适用性，因此在实际使用时，可能比不上特意为了具体情况而写的排序算法不过，与其自己写排序算法， 不如直接使用sort 以上排序算法的比较 生成随机数 ：冒泡排序0.2470s :归并排序0.0040s :快速排序0.0020s :堆排序 0.0050s :基数排序0.0010s :计数排序0.0000s :sort 0.0170s :qsort 0.0050s :插入排序0.1090s :选择排序0.1190s : 可以看出，除了冒泡排序、插入排序、选择排序这些思路比较直接的排序外，其他排序都相差不过 而当数据变得更大时，可以看出明显的差别 生成随机数 ：冒泡排序29.7050s :归并排序0.0440s :快速排序0.0200s :堆排序 0.0640s :基数排序0.0130s :计数排序0.0020s :sort 0.2340s :qsort 0.0590s :插入排序26.1630s :选择排序12.1710s : 虽然sort在众多排序中表现的并不是很好，但是作为一个能够直接使用的函数，其在真正使用时还是值得一用的。 测试用的代码sort#include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;memory&gt; #include &lt;algorithm&gt;#define random(x) (rand()%x) #define REP(n) for(int o=0;o&lt;n;o++) const bool SHOW = 0;const int size = 100000;const int MAX = 1000000;const int TIME = 10;int a[size];int b[size];int ans[size];long long start;//冒泡排序 void BubbleSort(int a[],int n) &#123; int ThisSwapPosition = n;//本轮最后一个交换的位置 bool HasSwap = false; for(int i = 0;i &lt; n;i++) &#123; HasSwap = false; int LastSwapPosition = ThisSwapPosition;//上轮最后一个交换的位置 for(int j = 1;j &lt; LastSwapPosition;j++) &#123; if(a[j - 1] &gt; a[j]) &#123; int temp = a[j - 1]; a[j - 1] = a[j]; a[j] = temp; ThisSwapPosition = j; HasSwap = true;//本轮发生交换 &#125; &#125; if(!HasSwap) break; &#125;&#125;//归并排序 void Merge(int a[],int l,int mid,int r) &#123; int pos1 = l;//左侧的指针 int pos2 = mid + 1;//右侧的指针 int *temp = new int[r - l + 1]; int pos = 0;//临时数组的指针 while(pos1 &lt;= mid || pos2 &lt;= r) &#123; if(pos1 &gt; mid) &#123; temp[pos++] = a[pos2++]; &#125; if(pos2 &gt; r) &#123; temp[pos++] = a[pos1++]; &#125; if(pos1 &lt;= mid&amp;&amp;pos2 &lt;= r) &#123; if(a[pos1] &lt;= a[pos2]) &#123; temp[pos++] = a[pos1++]; &#125; else &#123; temp[pos++] = a[pos2++]; &#125; &#125; &#125; //memcpy(a+l,temp,sizeof(temp)); for(int i = 0;i &lt;= r - l;i++) a[l + i] = temp[i];&#125;//对a[l]~a[r]排序 void MergeSort(int a[],int l,int r) &#123; if(l &lt; r) &#123; int mid = (l + r) / 2; MergeSort(a,l,mid); MergeSort(a,mid + 1,r); Merge(a,l,mid,r); &#125;&#125;//快速排序 void QuickSort(int a[],int l,int r) &#123; if(l &gt;= r) return; int left = l; int right = r; int mid = (a[l] + a[r] + a[(l + r) / 2]) / 3; bool move = false; while(left &lt; right) &#123; move = false; while(left &lt; right &amp;&amp; a[right] &gt; mid) &#123; right--; move = true; &#125; while(left &lt; right &amp;&amp; a[left] &lt; mid) &#123; left++; move = true; &#125; if(left &lt; right) &#123; int temp = a[right]; a[right] = a[left]; a[left] = temp; &#125; if(!move) right--; &#125; QuickSort(a,l,left); QuickSort(a,right + 1,r);&#125;//调整堆void AdjustHeap(int a[],int i,int n) &#123; int left = (i + 1) * 2 - 1; int right = (i + 1) * 2; int Max = i; if(left&lt;n &amp;&amp; a[left]&gt;a[Max]) &#123; Max = left; &#125; if(right&lt;n &amp;&amp; a[right]&gt;a[Max]) &#123; Max = right; &#125; if(i != Max) &#123; int temp = a[Max]; a[Max] = a[i]; a[i] = temp; AdjustHeap(a,Max,n); &#125;&#125;//堆排序void HeapSort(int a[],int n) &#123; for(int i = n / 2;i &gt;= 0;i--) &#123; AdjustHeap(a,i,n); &#125; for(int i = 0;i &lt; n - 1;i++) &#123; int temp = a[0]; a[0] = a[n - 1 - i]; a[n - 1 - i] = temp; AdjustHeap(a,0,n - i - 1); &#125;&#125;//基数排序 LSDvoid LSD(int a[],int n,int bit = 1) &#123; int bucket[10]; int rear[10]; int *link = new int[n]; int *next = new int[n]; bool flag = false; for(int i = 0;i &lt; 10;i++) bucket[i] = rear[i] = -1; for(int i = 0;i &lt; n;i++) next[i] = -1; int pos = 0; for(int i = 0;i &lt; n;i++) &#123; int h = a[i] / bit % 10; if(h) flag = true; if(bucket[h] == -1) &#123; bucket[h] = pos; &#125; else &#123; next[rear[h]] = pos; &#125; rear[h] = pos; link[pos++] = a[i]; &#125; if(flag) &#123; for(int bu = 0,pos = 0;pos &lt; n;bu++) &#123; int t = bucket[bu]; while(t != -1) &#123; a[pos++] = link[t]; t = next[t]; &#125; &#125; LSD(a,n,bit * 10); &#125; delete[] next; delete[] link;&#125;//计数排序void ArraySort(int a[],int n) &#123; int Min = a[0]; int Max = a[0]; for(int i = 0;i &lt; n;i++) &#123; (a[i] &lt; Min) ? (Min = a[i]) : Min; (a[i] &gt; Max) ? (Max = a[i]) : Max; &#125; int *arr = new int[Max - Min + 1]; for(int i = 0;i &lt; Max - Min + 1;i++) arr[i] = 0; for(int i = 0;i &lt; n;i++) arr[a[i] - Min]++; int pos = 0; for(int i = 0;i &lt; Max - Min + 1 &amp;&amp; pos &lt; n;i++) for(int j = 0;j &lt; arr[i];j++) a[pos++] = i + Min; delete[]arr;&#125;//qsortint comp(const void*a,const void*b) &#123; return *(int*)a - *(int*)b;&#125;//插入排序void InsertSort(int a[],int n) &#123; int *link = new int[n]; int *next = new int[n]; for(int i = 0;i &lt; n;i++) next[i] = -1; int pos = 0; link[pos++] = a[0]; int f = 0; for(int i = 1;i &lt; n;i++) &#123; if(link[f] &gt; a[i]) &#123; next[pos] = f; f = pos; &#125; else &#123; int t = f; while(next[t] != -1 &amp;&amp; a[i] &gt; link[next[t]]) t = next[t]; next[pos] = next[t]; next[t] = pos; &#125; link[pos++] = a[i]; &#125; int t = f; pos = 0; while(t != -1) &#123; a[pos++] = link[t]; t = next[t]; &#125; delete[] link; delete[] next;&#125;//选择排序void SelectSort(int a[],int n) &#123; for(int i = 0;i &lt; n - 1;i++) &#123; int Min = a[i + 1]; int pos = i + 1; for(int j = i;j &lt; n;j++) &#123; if(Min &gt; a[j]) &#123; Min = a[j]; pos = j; &#125; &#125; int temp = a[i]; a[i] = a[pos]; a[pos] = temp; &#125;&#125;void Do() &#123; //生成随机数 REP(size) a[o] = random(MAX); //输出随机数 printf(\"生成随机数 ： \"); if(SHOW) REP(size) printf(\"%d \",a[o]); printf(\"\\n\"); //测试1 - 冒泡排序 printf(\"冒泡排序\"); memcpy(b,a,sizeof(a)); start = clock(); BubbleSort(b,size); printf(\"%.4fs : \",double(clock() - start) / CLOCKS_PER_SEC); if(SHOW) REP(size) printf(\"%d \",b[o]); memcpy(ans,b,sizeof(b)); printf(\"\\n\"); //测试2 - 归并排序 printf(\"归并排序\"); memcpy(b,a,sizeof(a)); start = clock(); MergeSort(b,0,size - 1); printf(\"%.4fs : \",double(clock() - start) / CLOCKS_PER_SEC); if(SHOW) REP(size) printf(\"%d \",b[o]); if(memcmp(ans,b,sizeof(b)) != 0) printf(\"Wrong\"); printf(\"\\n\"); //测试3 - 快速排序 printf(\"快速排序\"); memcpy(b,a,sizeof(a)); start = clock(); QuickSort(b,0,size - 1); printf(\"%.4fs : \",double(clock() - start) / CLOCKS_PER_SEC); if(SHOW) REP(size) printf(\"%d \",b[o]); if(memcmp(ans,b,sizeof(b)) != 0) printf(\"Wrong\"); printf(\"\\n\"); //测试4 - 堆排序 printf(\"堆排序\\t\"); memcpy(b,a,sizeof(a)); start = clock(); HeapSort(b,size); printf(\"%.4fs : \",double(clock() - start) / CLOCKS_PER_SEC); if(SHOW) REP(size) printf(\"%d \",b[o]); if(memcmp(ans,b,sizeof(b)) != 0) printf(\"Wrong\"); printf(\"\\n\"); //测试5 - 基数排序 printf(\"基数排序\"); memcpy(b,a,sizeof(a)); start = clock(); LSD(b,size); printf(\"%.4fs : \",double(clock() - start) / CLOCKS_PER_SEC); if(SHOW) REP(size) printf(\"%d \",b[o]); if(memcmp(ans,b,sizeof(b)) != 0) printf(\"Wrong\"); printf(\"\\n\"); //测试6 - 计数排序 printf(\"计数排序\"); memcpy(b,a,sizeof(a)); start = clock(); ArraySort(b,size); printf(\"%.4fs : \",double(clock() - start) / CLOCKS_PER_SEC); if(SHOW) REP(size) printf(\"%d \",b[o]); if(memcmp(ans,b,sizeof(b)) != 0) printf(\"Wrong\"); printf(\"\\n\"); //测试7 - sort排序 printf(\"sort\\t\"); memcpy(b,a,sizeof(a)); start = clock(); std::sort(b,b + size); printf(\"%.4fs : \",double(clock() - start) / CLOCKS_PER_SEC); if(SHOW) REP(size) printf(\"%d \",b[o]); if(memcmp(ans,b,sizeof(b)) != 0) printf(\"Wrong\"); printf(\"\\n\"); //测试8 - qsort排序 printf(\"qsort\\t\"); memcpy(b,a,sizeof(a)); start = clock(); std::qsort(b,size,sizeof(int),comp); printf(\"%.4fs : \",double(clock() - start) / CLOCKS_PER_SEC); if(SHOW) REP(size) printf(\"%d \",b[o]); if(memcmp(ans,b,sizeof(b)) != 0) printf(\"Wrong\"); printf(\"\\n\"); //测试8 - 插入排序 printf(\"插入排序\"); memcpy(b,a,sizeof(a)); start = clock(); InsertSort(b,size); printf(\"%.4fs : \",double(clock() - start) / CLOCKS_PER_SEC); if(SHOW) REP(size) printf(\"%d \",b[o]); if(memcmp(ans,b,sizeof(b)) != 0) printf(\"Wrong\"); printf(\"\\n\"); //测试9 - 选择排序 printf(\"选择排序\"); memcpy(b,a,sizeof(a)); start = clock(); SelectSort(b,size); printf(\"%.4fs : \",double(clock() - start) / CLOCKS_PER_SEC); if(SHOW) REP(size) printf(\"%d \",b[o]); if(memcmp(ans,b,sizeof(b)) != 0) printf(\"Wrong\"); printf(\"\\n\"); printf(\"\\n\");&#125;int main() &#123; srand((int)time(0)); REP(TIME) Do(); return 0;&#125; 一些其他的奇怪的排序算法睡眠排序对于一组数，有最大值max，则在max毫秒内完成排序的排序算法。 思路：使用多线程处理每一个数，每个线程的任务是休眠其对应的数的时间，而后输出这样在所有线程休眠完毕后，即可获得排序好的数据。","tags":[{"name":"排序","slug":"Sort","permalink":"https://www.oyohyee.com/tags/Sort/"}]},{"title":"Sublime编译c++","date":"2016-06-10T10:41:23.000Z","path":"/post/Note/sublime_Run_cpp.html","text":"Sublime Text 2/3 是一款非常优秀的编辑器(虽然我推VS Code) 作为一款可以自由搭配的编辑器，我们可以用它一键编译cpp文件在网络上，我们可以找到许多的配置项，来帮助我们实现我们的目的。 针对编译后会生成难看的exe文件(如果目录都是cpp多么美妙)我们有一下解决方案： 根据观察，我们可以看出编译配置文件&#123; \"encoding\": \"utf-8\", \"working_dir\": \"$&#123;file_path&#125;\", \"shell_cmd\": \"g++ -Wall -std=c++0x $file_name -o $file_base_name\", \"file_regex\": \"^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\", \"selector\": \"source.c++,source.c\", \"encoding\":\"cp936\", \"variants\": [ &#123; \"name\": \"Run\", \"shell_cmd\": \"g++ -Wall -std=c++0x $file -o $file_base_name.exe &amp;&amp; start cmd /c \\\"$&#123;file_path&#125;/$&#123;file_base_name&#125;.exe &amp; pause\\\" \" &#125; ]&#125; 编译并运行exe使用的是cmd\"shell_cmd\": \"g++ -Wall -std=c++0x $file -o $file_base_name.exe &amp;&amp; start cmd /c \\\"$&#123;file_path&#125;/$&#123;file_base_name&#125;.exe &amp; pause\" \" 根据我们的知识，可以稍加修改，即可达到我们的目的 仿照前面的pause 我们在后面加上&amp; del /Q ${file_base_name}.exe 这样，我们运行后，程序会自己删除掉难看的exe文件 完整的Sublime-build文件&#123; \"encoding\": \"utf-8\", \"working_dir\": \"$&#123;file_path&#125;\", \"shell_cmd\": \"g++ -Wall -std=c++0x $file_name -o $file_base_name\", \"file_regex\": \"^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\", \"selector\": \"source.c++,source.c\", \"encoding\":\"cp936\", \"variants\": [ &#123; \"name\": \"Run\", \"shell_cmd\": \"g++ -Wall -std=c++0x $file -o $file_base_name.exe &amp;&amp; start cmd /c \\\"$&#123;file_path&#125;/$&#123;file_base_name&#125;.exe &amp; pause &amp; del /Q $&#123;file_base_name&#125;.exe\\\" \" &#125; ]&#125;","tags":[{"name":"Sublime","slug":"Sublime","permalink":"https://www.oyohyee.com/tags/Sublime/"},{"name":"C++","slug":"C","permalink":"https://www.oyohyee.com/tags/C/"}]},{"title":"791.水果篮子","date":"2016-06-09T06:08:29.000Z","path":"/post/AOJ/791.html","text":"题目 Description 西瓜的表弟小西瓜生病住院了，西瓜想去买一个水果篮子探望他。水果店里面有很多种类的水果篮子，价格相同，但是水果的搭配各不相同。西瓜突然想到了一个问题，现在水果店里面有这么N种水果，第i个水果单价是Pi元，西瓜手上有M元钱（钱不一定要花完，但也不能什么水果都没有），一共有几种搭配水果篮子的方法呢。 Input题目包含多组输入，EOF结束，数据最多不超过100组，对于每组数据，包含两行，第一行是两个整数N，M，表示水果的总数和西瓜手里的钱数。第二行包含N个整数，表示每种水果的单价。1 &lt;= N &lt;= 10, 1 &lt;= M &lt;= 200, 1 &lt;= Pi &lt;= M Output 对于每组输入，输出一行，表示有多少种搭配水果篮子的方法。 Sample Input 2 103 49 1005 6 9 13 4 5 3 9 8 Sample Output 71954041 题解&gt;背包问题 - 01背包问题&lt; 背包问题的计数问题 dp[i][j] 表示前i件水果在钱数为j时的可行的选择种类数目 则有 d[i][j] = (d[i-1][j] + 1) + d[i][j-price[i]] 分别代表买和不买这个物品 初始状态为dp[0][0] = 0(什么都买不了) 压缩成一维数组 d[j] += ((j - price[i] &gt;= 0) ? (d[j - price[i]] + 1) : 0); 代码水果篮子代码备份#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;stack&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)int N,M;//N水果数 M钱数const int maxn = 15;const int maxm = 205;long long d[maxm];int price[maxn];bool Do() &#123; if(scanf(\"%d%d\",&amp;N,&amp;M) == EOF) return false; REP(N) scanf(\"%d\",&amp;price[o + 1]); memset(d,0,sizeof(d)); for(int i = 1;i &lt;= N;i++) for(int j = 1;j &lt;= M;j++) d[j] += ((j - price[i] &gt;= 0) ? (d[j - price[i]] + 1) : 0); printf(\"%lld\\n\",d[M]); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"}]},{"title":"HFUT 1362.恶魔a+b(安徽省2016“京胜杯”程序设计大赛 I)","date":"2016-06-08T16:42:17.000Z","path":"/post/HFUT/1362.html","text":"题目 Description 相信大家都做过A+B问题，这个问题简直太简单了，以至于所有的程序员都会做这个题目。有一天，萌萌哒YZK学姐写了很久很久的代码，以至于在半睡半醒状态看到了恶魔。恶魔说：愚蠢的程序员啊，不要再做无谓的挣扎了，你再怎么写代码，也改变不了这个世界终将被我统治的结局。YZK学姐顿时觉得自己被侵犯了，为了程序员的尊严，她要求与恶魔进行决斗，决斗的形式就是写代码。恶魔给出了一个非常复杂的A+B问题，对于两个长度小于1000的26进制数，它们相加的结果是什么呢？两人谁先解决这个问题谁就获胜，你能帮助YZK学姐战胜恶魔吗？ Input 第一行一个整数T，代表测试数据组数，0&lt;T&lt;25。之后T行，每行两个长度不大于1000的字符串，仅包含a~z和小数点，a~z分别代表数字0~25。 Output 相加的结果，不能包含前后导零（即a）。 Sample Input 2b bb.b a.c Sample Output cb.d 题解可怕的模拟题 小数加减首先要以小数点为中心进行对齐操作 然后考虑进位 然后就是前导0和后导0的删除 细节非常多，测试数据时，要分别考虑： 整数部分(不)进位 小数部分(不)进位 整数部分(不)为0 小数部分(不)为0 有(无)前导0 有(无)后导0 这些情况的各种组合情况 遇到这种题，不用太慌张，写出代码后，写出各种测试数据，逐步调试来调试出正确的代码 给出一些输入和输出数据 输入 10z ba.z a.caaab ba.a a.aa b.ob a.ba.zzzzaa a.aabz.z b. b 输出 bab.bcab.ob.bb.aaazbbc.cc.c 代码恶魔a+b代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;const int maxn = 1005;char a_a[maxn];char a_b[maxn];char b_a[maxn];char b_b[maxn];char temp[2 * maxn];void Do() &#123; memset(a_a,0,sizeof(a_a)); memset(a_b,0,sizeof(a_b)); memset(b_a,0,sizeof(b_a)); memset(b_b,0,sizeof(b_b)); scanf(\"%s\",temp); sscanf(temp,\"%[a-z].%[a-z]\",a_a,a_b); scanf(\"%s\",temp); sscanf(temp,\"%[a-z].%[a-z]\",b_a,b_b); int xs = max(strlen(a_b),strlen(b_b)); int zs = max(strlen(a_a),strlen(b_a)); int size_a_a = strlen(a_a); int size_a_b = strlen(a_b); int size_b_a = strlen(b_a); int size_b_b = strlen(b_b); for(int i = 0;i &lt; size_a_a;i++) a_a[i] -= 'a'; for(int i = 0;i &lt; size_a_b;i++) a_b[i] -= 'a'; for(int i = 0;i &lt; size_b_a;i++) b_a[i] -= 'a'; for(int i = 0;i &lt; size_b_b;i++) b_b[i] -= 'a'; if(zs != size_a_a) &#123; int i; for(i = zs - 1;i &gt;= zs - size_a_a;i--) a_a[i] = a_a[i - zs + size_a_a]; for(;i &gt;= 0;i--) a_a[i] = 0; &#125; if(zs != size_b_a) &#123; int i; for(i = zs - 1;i &gt;= zs - size_b_a;i--) b_a[i] = b_a[i - zs + size_b_a]; for(;i &gt;= 0;i--) b_a[i] = 0; &#125; int jw = false; for(int i = xs - 1;i &gt;= 0;i--) &#123; a_b[i] += b_b[i] + jw; jw = false; if(a_b[i] &gt;= 26) &#123; a_b[i] %= 26; jw = true; &#125; &#125; for(int i = zs - 1;i &gt;= 0;i--) &#123; a_a[i] += b_a[i] + jw; jw = false; if(a_a[i] &gt;= 26) &#123; a_a[i] %= 26; jw = true; &#125; &#125; int zs_b = -1; for(int i = 0;i &lt; zs;i++) &#123; if(a_a[i] != 0) &#123; zs_b = i; break; &#125; &#125; int xs_e = -1; for(int i = xs - 1;i &gt;= 0;i--) &#123; if(a_b[i] != 0) &#123; xs_e = i; break; &#125; &#125; if(jw == false) &#123; if(zs_b == -1) &#123; putchar('a'); &#125; else &#123; for(int i = zs_b;i &lt; zs;i++) putchar(a_a[i] + 'a'); &#125; &#125; else &#123; putchar('b'); for(int i = 0;i &lt; zs;i++) putchar(a_a[i] + 'a'); &#125; if(xs_e != -1) &#123; putchar('.'); for(int i = 0;i &lt;= xs_e;i++) putchar(a_b[i] + 'a'); &#125; putchar('\\n');&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"HFUT","slug":"HFUT","permalink":"https://www.oyohyee.com/tags/HFUT/"},{"name":"京胜杯","slug":"JingShengBei","permalink":"https://www.oyohyee.com/tags/JingShengBei/"}]},{"title":"HFUT 1360.单身晚会(安徽省2016“京胜杯”程序设计大赛 H)","date":"2016-06-08T15:16:30.000Z","path":"/post/HFUT/1360.html","text":"题目 Description ​ZJ和ZCX在一起很久s了，两个人都互生爱意，最终决定喜结良缘，从此踏入浪漫的婚姻殿堂。但是，ZJ的好基友们想到以后ZJ就不能经常跟他们一起愉快的玩耍了，都觉得非常伤心难过，于是他们决定在最后一晚为ZJ开一场单身晚会，玩整晚紧张刺激的飞行棋。ZJ的好基友居住在城市的各个地方（每个地方不一定只有一个基友），他们需要从各个地方赶到其中一个朋友的家里来参加这最后的单身PARTY，ZJ被基友们的热情深深感动了，决定对基友们来时的路费进行报销。报销规则按照距离来计算。基友们为了帮ZJ省钱，决定在所有人走最短路径的情况下，总距离最小的人的家里开PARTY。ZJ想知道基友们走过的总距离是多少，然后他把总共需要报销的钱拿出来，就可以让基友们自己来分配了。但是他算了半天也没算出来总距离是多少，单身PARTY马上就开始了，你能帮帮他吗？ Input 第一行一个整数T，表示有T（T&lt;15）组数据每组数据的第一行基友数（包括ZJ）N（N&lt;100），路口P（2&lt;=P&lt;=100）,路口之间道路数C(1&lt;=C&lt;=1450)，（基友的编号为1…N，路口的编号为1…P）第二行到第N+1行：编号为1到N的基友们家所在的路口号。第N+2行到N+C+1行：每行有三个数：相连的路口A,B，路口间间距D（1&lt;=D&lt;=255），当然，连接是双向的。 Output 每组数据输出占一行，输出大家必须要走的最小距离和 Sample Input 13 4 52341 2 11 3 52 3 72 4 33 4 5 Sample Output 8 题解非常直白的模板题 题目叙述有误 在任意一个路口开晚会(可以在没有基友的路口开晚会)，使所有基友的总路程最小 写的时候，Floyd算法写的有误 用于遍历i和j的途径点的k应该在最外层循环(在最内层会有问题) 即for(int k = 1;k &lt;= p;k++) for(int i = 1;i &lt;= p;i++) for(int j = 1;j &lt;= p;j++) 代码单身晚会代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;const int maxn = 105;const int maxc = 1455;const int INF = 999999999;int GayHome[maxn];int Road[maxc][maxc];void Do() &#123; int n,p,c; scanf(\"%d%d%d\",&amp;n,&amp;p,&amp;c); for(int i = 1;i &lt;= p;i++) for(int j = 1;j &lt;= p;j++) Road[i][j] = INF; for(int i = 1;i &lt;= n;i++) scanf(\"%d\",&amp;GayHome[i]); for(int i = 0;i &lt; c;i++) &#123; int a,b,d; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;d); Road[a][b] = Road[b][a] = d; &#125; for(int i = 1;i &lt;= p;i++) Road[i][i] = 0; for(int k = 1;k &lt;= p;k++) for(int i = 1;i &lt;= p;i++) for(int j = 1;j &lt;= p;j++) Road[i][j] = min(Road[i][k] + Road[k][j],Road[i][j]); /*for(int i = 1;i &lt;= p;i++) &#123; for(int j = 1;j &lt;= p;j++) printf(\"%5d \",Road[i][j]); printf(\"\\n\"); &#125;*/ long long Min = INF; for(int i = 1;i &lt;= p;i++) &#123; long long sum = 0; for(int j = 1;j &lt;= n;j++) &#123; sum += Road[i][GayHome[j]]; &#125; Min = min(Min,sum); &#125; printf(\"%lld\\n\",Min);&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"Floyd","slug":"Floyd","permalink":"https://www.oyohyee.com/tags/Floyd/"},{"name":"HFUT","slug":"HFUT","permalink":"https://www.oyohyee.com/tags/HFUT/"}]},{"title":"安徽省2016“京胜杯”程序设计大赛(ACM安徽省省赛)","date":"2016-06-08T07:31:34.000Z","path":"/post/Project/JingShengBei.html","text":"作为旅游队，跟着去体验了下比赛环境~现场没做出来几道，有点可惜~ 题目可在&gt;合肥工业大学OJ提交&lt; 题号 题目名称 OJ题号 题解链接 A 砝码称重 1354 HFUT 1354.砝码称重 B 阵前第一功 1355 HFUT 1355.阵前第一功 C 箭无虚发 1358 HFUT 1358.箭无虚发 D 梯田AGAIN 1357 HFUT 1357.梯田AGAIN E 转啊转 1356 HFUT 1356.转啊转 F 吃在工大 1359 HFUT 1359.吃在工大 G 木条染色 1363 &nbsp; H 单身晚会 1360 HFUT 1360.单身晚会 I 恶魔a+b 1362 HFUT 1362.恶魔a+b J YZK的大别墅 1361 &nbsp; K 纸上谈兵 1364 &nbsp;","tags":[{"name":"京胜杯","slug":"JingShengBei","permalink":"https://www.oyohyee.com/tags/JingShengBei/"}]},{"title":"《魔兽》影评","date":"2016-06-08T00:21:47.000Z","path":"/post/Writing/WOW_Movie.html","text":"For the Horde!For the Azeroth! 学校一大群人组团去看魔兽，简直激动的不要不要的~之前寒假大家说6月会出魔兽电影(当时还没有出时间)，群里好多人都挺向往魔兽的宏大的，不过好多都没玩过或者好久都没玩了。于是就组了一波魔兽。相聚在了艾泽拉斯星球(格瑞姆巴托服务器) 从种族职业都分不清的小白就开始了魔兽世界的探险~ 说回电影。从几个月前，群里就时常讨论电影。学校旁边的影院放预售票后，立即就买好了票。凌晨0点的电影，从9点就开始慢慢地往电影院赶。一路上拼出租车的都是去看《魔兽》的~ 到了影院，放眼望去都是部落(人数上部落完全碾压联盟)，在众多WOWer中间，还有穿着漫威衣服的 入场后，又大概等了十分钟看广告。影片开始后全场寂静(觉得满满的神圣感)不过片头真的好长╮(╯-╰)╭ 觉得要把见过的所有制作的片头都给看完一遍到了腾讯的时候，全场卧槽然后电影就开始了 以下内容严重剧透 电影从兽人从德拉诺向艾泽拉斯进军开始(中间掺杂了杜隆坦两口调情(/▽＼=)，兽人手真大~)去黑暗之门的路上，看字幕有Lok’tar Ogar，不过没听到声音，觉得如果喊出来会更好点吧（毕竟整部电影觉得政治倾向还是挺偏联盟的，没看过的应该很容易就站联盟了）传送到艾泽拉斯后，伟大的先知萨尔就出生了(部落的新战士诞生了)。作为未来几部魔兽电影的主角，萨尔出生都那么与众不同。不过说好的“为什么是绿的？”呢？怎么觉得萨尔绿色的那么正常…… 随后的一段时间，就是艾泽拉斯风景展。铁炉堡、暴风城、桥下的鱼人(继腾讯后另一个全场轰动的地方)。作为一名在荆棘谷被联盟狗杀的走不动路的部落的勇士，我都在看到暴风城时感到一种激动与震撼。太特马棒了。不过和之前新闻里说的，还原暴风城街景相比，觉得真正在暴风城的街道上镜头几乎没有(说好的暴风城的任务布告牌呢，我还特意一个人躺尸去暴风城看暴风城内景呢。。(虽然后来建了联盟号)) 接着就是卡德加、麦迪文、洛萨………………一个一个登场 法爷真帅！法爷真帅！法爷真帅！ 不管是麦迪文还是卡德加施法都好帅~(然而整个影片基本上出场的的都是战士……) 另外，对于魔法，说好的什么什么规定传送只能传送到指定地方么，麦迪文、卡德加你们这样随便传送是违反基本法的好不好！！！传送门原来是要在地上画画的，长见识了~ 调查邪能的时候，卡德加放了一个防护罩(冰箱？为什么你能动？还能给别人加！！)麦迪文超长读条后秒杀全场！ 而后就是联盟部落(呸，人类和兽人)在丛林里的大战。(明明只是坐骑，又不是宝宝，攻击比主人都屌) 伽罗娜被俘(掌握一门外语是多么关键！) 一通感化后，伽罗娜愿意帮助人类阻止古尔丹的阴谋。(天花板上的地图只有东部王国~) 各族开会讨论抗击兽人(人类各国、矮人、血精灵)作为民主的会议，自然什么都没讨论出来，大家都为自己争取利益，最后不欢而散 杜隆坦请求和国王会面会面被打断，地里蹦出一群兽人麦迪文断线重连后放了技能保护国王，间接害死了洛萨的儿子(For the Azeroth) 麦迪文被彻底控制卡德加去达拉然寻求肯瑞托的帮助(这时候达拉然应该还不在空中吧)一群两眼冒光的老头一开始非常傲慢的训斥卡德加在卡德加说出黑暗之门和艾格文后又变成震惊脸(你们作为法师NPC不应该全知全能么，怎么看上去那么怂) 卡德加受到召唤，接了杀死麦迪文的任务 洛萨因为儿子被杀和麦迪文吵起来(开始不信任麦迪文)，被国王关到监狱里卡德加用变羊术变羊监狱守卫(变羊术只对头脑简单的人有效？)(影院第三次沸腾) 两个人组队下本刷BOSS麦迪文 杜隆坦与人类的奸情被当作叛变杜隆坦以自己换取整个霜狼氏族的安全临走时，杜隆坦给萨尔起了名字(就不是萨尔~就不是萨尔~就叫古伊尔~就叫古伊尔~)(好多观众默念萨尔，然而起的是古伊尔) 尽管牺牲了自己，然而并没有什么卵用霜狼氏族被屠，德拉卡抱着萨尔跑掉，最后为了保护萨尔牺牲。毁灭之锤救出杜隆坦，杜隆坦挑战古尔丹 古尔丹能站直！！古尔丹能站直！！古尔丹能站直！！ 毫无意外，古尔丹作弊使用法术(邪能)干掉了杜隆坦大家开始不满古尔丹(违反兽人战士决斗的规则)然而，古尔丹杀掉几个不满的兽人后就没人BB了 最后的大战打得稀里哗啦(然而战争场面不够宏大有点遗憾，完全没打出来类似《魔戒》的那种大场面) 麦迪文恢复自己的意识，回光返照把黑暗之门开到暴风城，帮助被俘的人民能够脱战不过撑了一小会就死了，人类军队被围。 国王莱恩让伽罗娜杀掉自己，获得荣誉从而能够活下去。最终伽罗娜同意了，获得了至高的荣誉，被兽人所接纳 洛萨赶到，一人一狮鹫杀入兽人队伍中(这里明明可以拍成大场面的，结果觉得成了狮鹫跳来跳去虐兽人) 洛萨与黑手对决，一招秒掉黑手，获得胜利，受到了兽人战士的尊敬。古尔丹想要杀掉洛萨，却由于违背战士精神没人鸟他~ 联盟成立，开始了对抗兽人的战争(真简陋的仪式) 最后，以萨尔被人类捡到为结尾~ 没有彩蛋没有彩蛋没有彩蛋 整部电影政治倾向偏联盟，部落除了个别角色外整体处于不太正面的形象上，而联盟则全部都是非常正面的形象 场面效果不够好?(或许是暴雪一直让人惊艳，这次没有显露出超时代的水平有点失望) 剧本与原著有改动。不过无伤大雅，个别地方衔接更自然了点~","tags":[{"name":"魔兽","slug":"WOW","permalink":"https://www.oyohyee.com/tags/WOW/"},{"name":"影评","slug":"Film-Reviem","permalink":"https://www.oyohyee.com/tags/Film-Reviem/"}]},{"title":"拓扑排序","date":"2016-06-07T09:13:18.000Z","path":"/post/Algorithm/TopoSort.html","text":"对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。 百度百科拓扑排序 举一个例子就是 学习《数据结构》前我们需要学习《C语言》学习《高数2》前我们需要学习《高数1》如何安排学习顺序？ 我们有以下学习顺序： 《高数1》 -&gt; 《高数2》 -&gt; 《C语言》 -&gt; 《数据结构》 《高数1》 -&gt; 《C语言》 -&gt; 《数据结构》 -&gt; 《高数2》 《高数1》 -&gt; 《C语言》 -&gt; 《高数2》 -&gt; 《数据结构》 …… 这种有着先行条件的排序就是拓扑排序。只有满足了先行条件，我们才能进行任务(到达结点)因此可以看作有向图同时，可以简单证明，如果存在环(1-&gt;2、2-&gt;1)显然是无解的。 对于拓扑排序，我们可以看成有向无环图(DAG) 普通的拓扑排序算法如下: 找出所有我们可以选择的结点(没有先行条件的结点(源)) 选择一个源，开始拓展。对于每一个访问到的结点，从图中删除这个结点和这个结点指向的边(使以它为先行条件的结点变成源) 重复以上过程 如果所有源都访问过后，还有未访问的结点，那么存在环(因为环中的结点永远无法访问) 带字典序的拓扑排序题目:&gt;吃在工大&lt; 当输出要求输出字典序最大解时，我们可以维护一个优先队列，队首是字典序最大的元素。 将所有的源放在优先队列里，每次拓展结点从优先队列取出 代码如下bool G[maxn][maxn];bool vis[maxn];int n;bool HasLoop() &#123; //判断是否存在环 for(int i = 1;i &lt;= n;i++) if(!vis[i]) return false; return true;&#125;bool IsStart(int k) &#123; //判断是否入度为0 for(int i = 1;i &lt;= n;i++) if(G[i][k]) return false; return true;&#125;bool TopoSort(int _n,int *ans) &#123; //拓扑排序 /* 参数: 邻接矩阵G[][] 顶点数目n 用于保存拓扑排序结果的数组 ans[] */ //输出结果下标初始化 int pos = 0; //已访问数组初始化 memset(vis,false,sizeof(vis)); //可被选择的数 priority_queue&lt;int&gt; Q; //判断i是否为源 for(int i = 1;i &lt;= n;i++) &#123; if(IsStart(i)) Q.push(i); &#125; while(!Q.empty()) &#123; int k = Q.top(); Q.pop(); if(vis[k]) continue; else vis[k] = true; //记录到结果中 ans[pos++] = k; for(int i = 1;i &lt;= n;i++) &#123; if(G[k][i]) &#123; //路径k~i存在 //删除路径 G[k][i] = false; //如果成为入度为0的点 if(IsStart(i)) Q.push(i); &#125; &#125; &#125; //判断是否有环 return HasLoop();&#125;","tags":[{"name":"排序","slug":"Sort","permalink":"https://www.oyohyee.com/tags/Sort/"},{"name":"拓扑排序","slug":"TopoSort","permalink":"https://www.oyohyee.com/tags/TopoSort/"}]},{"title":"HFUT 1359.吃在工大(安徽省2016“京胜杯”程序设计大赛 F)","date":"2016-06-07T09:07:37.000Z","path":"/post/HFUT/1359.html","text":"题目 Description JH和他的好朋友YZ两名程序员回访母校合工大，准备在这住一段日子，都说“玩在安大，吃在工大”，JH又是一名典型吃货，于是决定在工大食堂好好吃一段日子，但是，面对美食诱惑：黄焖鸡、风暴干锅、麻辣香锅、奥尔良烤翅…由于时间有限，JH不知道哪顿饭吃哪个菜好。于是YZ为了帮助他解决这个问题，也顺便考考他，给他出了一个问题：“黄焖鸡必须在干锅花菜前面吃，干锅牛肉必须在干锅鱿鱼前面吃….你按这个要求下，就知道吃的顺序啦”。JH抓抓头，分分钟写了个程序搞定，现在，让你来写写看？输出一组JH符合条件下吃的食物的序列。假设JH每顿只吃一种食物，且每顿吃的都不同，食物编号1到N。 Input先输入一个整数T，表示T（T&lt;50）组数据。每组数据第一行输出一个整数，N,M,分别表示有N种食物，总共有M个约束条件，接下来M行每行输入两个正整数a,b(n&gt;=a&gt;0,n&gt;=b&gt;0)，表示食物a必须在食物b之前吃。 Output 各组数据输出答案占一行，输出一组符合条件的序列（要求输出字典序最大的那一组），如果答案不存在，输出“-1”。 Sample Input 14 31 22 34 3 Sample Output 4 1 2 3 题解字典序的拓扑排序 普通的拓扑排序没有要求输出字典序最大的解，因此我们可以修改下来做 阅读以下内容，请确保已看过 &gt;拓扑排序&lt; 原本的拓扑排序，对于每一个源头，会尽可能将其遍历完再去遍历其他的源。 因此，当存在类似 5 -&gt; 3 -&gt; 12 -&gt; 4 的关系时，会先把5当作源头，遍历完再去遍历以2为源的链 5 -&gt; 3 -&gt; 1 -&gt; 2 -&gt; 4 而非我们想要的答案 5 -&gt; 3 -&gt; 2 -&gt; 4 -&gt; 1 我们可以用类似于Dijkstra的形式，维护一个优先队列 当一个点被访问后(记录到结果里后)，所有以它为前置元素的元素(删除该点后，所有的源)都可以被访问了。 因此，每次取出优先队列中最大的元素进行拓扑排序，即可获得我们想要的答案。 代码吃在工大代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comかしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;const int maxn = 1000;bool G[maxn][maxn];bool vis[maxn];int n;bool HasLoop() &#123; //判断是否存在环 for(int i = 1;i &lt;= n;i++) if(!vis[i]) return false; return true;&#125;bool IsStart(int k) &#123; //判断是否入度为0 for(int i = 1;i &lt;= n;i++) if(G[i][k]) return false; return true;&#125;bool TopoSort(int _n,int *ans) &#123; //拓扑排序 /* 参数: 邻接矩阵G[][] 顶点数目n 用于保存拓扑排序结果的数组 ans[] */ //输出结果下标初始化 int pos = 0; //已访问数组初始化 memset(vis,false,sizeof(vis)); //可被选择的数 priority_queue&lt;int&gt; Q; //判断i是否为源 for(int i = 1;i &lt;= n;i++) &#123; if(IsStart(i)) Q.push(i); &#125; while(!Q.empty()) &#123; int k = Q.top(); Q.pop(); if(vis[k]) continue; else vis[k] = true; //记录到结果中 ans[pos++] = k; for(int i = 1;i &lt;= n;i++) &#123; if(G[k][i]) &#123; //路径k~i存在 //删除路径 G[k][i] = false; //如果成为入度为0的点 if(IsStart(i)) Q.push(i); &#125; &#125; &#125; //判断是否有环 return HasLoop();&#125;void Do() &#123; memset(G,0,sizeof(G)); int m; scanf(\"%d%d\",&amp;n,&amp;m); for(int i = 0;i &lt; m;i++) &#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); G[a][b] = 1; &#125; int ans[maxn]; if(TopoSort(n,ans)) &#123; for(int i = 0;i &lt; n;i++) &#123; if(i) printf(\" \"); printf(\"%d\",ans[i]); &#125; &#125; else &#123; printf(\"-1\"); &#125; printf(\"\\n\");&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"排序","slug":"Sort","permalink":"https://www.oyohyee.com/tags/Sort/"},{"name":"拓扑排序","slug":"TopoSort","permalink":"https://www.oyohyee.com/tags/TopoSort/"},{"name":"HFUT","slug":"HFUT","permalink":"https://www.oyohyee.com/tags/HFUT/"},{"name":"京胜杯","slug":"JingShengBei","permalink":"https://www.oyohyee.com/tags/JingShengBei/"}]},{"title":"HFUT 1358.箭无虚发(安徽省2016“京胜杯”程序设计大赛 C)","date":"2016-06-06T17:56:02.000Z","path":"/post/HFUT/1358.html","text":"题目 Description JH苦练10年，终于成为了一个神箭手，在下山之前，大师兄YZ不放心，想考验他，只给他一定时间t，同时给他n支箭，最终根据他的表现，考虑他是否能下山。 对于每发一次箭，YZ给他4种成绩（优、良、中、差），JH有三种拉弓以及瞄准时间a ,b，c（a&gt;=b&gt;=c）分别能拿优，良，中等级，如果不拉弓不瞄（直接射），只能拿差（不能中靶）了。 现在JH想知道，在保证自己弹无虚发（不获得差）的情况下，最多能拿多少个优。 如果JH不能做到弹无虚发，输出Oh，my god! Input 输入数据包含T组: 对于每组数据，第一行为一个整数n，表示总共有n支箭。 （0&lt;n&lt;=1000） 之后n行，每行包含三个数字a，b，c，分别表示拿对应等级所需要花的时间。 (0&lt;c&lt;=b&lt;=a&lt;=1000) 之后一个数字t，表示JH有考核总时间为t (0&lt;=t&lt;=1e6) Output 对于每组输入，如果JH能箭无虚发，则输出一个数字x，表示最多能拿到的优的数量。如果不能，则输出Oh，my god! Sample Input 3 1 3 2 1 1 2 3 2 1 3 2 1 4 2 3 2 1 3 2 1 1 Sample Output 0 1 Oh,my god! 题解这道题不是DFS、不是状态压缩BFS，只是一道贪心算法！！ 由于优、良、中、差。更高的等级花费的时间一定大于等于比它低的等级，所以我们只需要记录 优 和 中 的时间 如果全部都是 中 都不能射完所有箭，那么肯定无法完成。应该输出&quot;Oh,my god!\\n&quot; 然后我们假设全部射出 优 评分，那么如果时间不够，我们应该将一个评价 优 变成评价 中为了保证最多的 优 ，我们需要尽可能在一次变换中多省出时间也即 将 优 和 中 时间差最大的那支箭替换掉 按照这个思路，读入后排序下即可。 代码HFUT 1358.箭无虚发.cpp代码备份/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 1005;struct Time &#123; int PTime,MTime; int delta; Time(int x=0,int y=0) &#123; PTime = x; MTime = y; delta = x - y; &#125; bool operator &lt; (const Time &amp;rhs)const &#123; return delta &gt; rhs.delta; &#125;&#125;;Time UseTime[maxn];void Do() &#123; int t,n,UT=0; scanf(\"%d\",&amp;n); int sum = 0; REP(n) &#123; int a,c; scanf(\"%d%*d%d\",&amp;a,&amp;c); sum += c; UT += a; UseTime[o] = Time(a,c); &#125; scanf(\"%d\",&amp;t); if(sum &gt; t) &#123; printf(\"Oh,my god!\\n\"); return; &#125; sort(UseTime,UseTime + n); int ans = n; for(int i = 0;UT &gt; t;i++) &#123; ans--; UT -= UseTime[i].delta; &#125; printf(\"%d\\n\",ans);&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"},{"name":"HFUT","slug":"HFUT","permalink":"https://www.oyohyee.com/tags/HFUT/"},{"name":"京胜杯","slug":"JingShengBei","permalink":"https://www.oyohyee.com/tags/JingShengBei/"}]},{"title":"Hexo博客搭建及迁移完成","date":"2016-06-06T16:39:53.000Z","path":"/post/Note/HexoBuild.html","text":"从0开始安装Hexo用了两天，迁移博客用了三天。纪念一下。 迁移至Hexo的原因之前使用的是博客园的博客。作为国内两大IT技术博客(另一个是CSDN，之前也用过，不过审核实在太烦人)的集中地，不得不说博客园有很多不错的地方。不过，与几乎所有博客一样，过多的限制了用户的自由。许多本来可以轻易更改的东西需要费很大功夫才能达到自己的目的。(真的觉得博客园的代码高亮真难看╮(╯-╰)╭)一直都挺向往GitHub的GitHub Pages搭建的博客的，于是终于下决心搞了下。 搭建GitHub Pages由于GitHub使用了挺长一段时间了，因此，注册什么的就不详细说了。 安装环境Hexo的安装需要Git和Node.js支持这些都可以在他们的官网上获取最新的安装包。链接：Git、Node.js下载并安装好后，可以尝试在控制台运行node -vnpm -v 指令来检查node.js和npm是否安装成功 安装Hexo安装完成后，就可以运行下面的命令开始安装Hexo了。npm install hexo -g 其中，-g指全局安装根据网速可能需要等待不同的时间安装完成后，进入我们要搭建博客的目录npm install hexo --save 将Hexo安装到目录中。而后运行npm install 安装可能需要的插件 安装完毕后，我们就搭建好了Hexo可以使用hexo s 而后访问localhost:4000测试如果能够看到页面，就证明安装完成 配置和上传Hexo有以下目录与文件 node_modules (Hexo的程序，用于生成页面) public (生成的页面文件，上传到git的就是这个文件夹内的内容) scaffolds (模板文件，使用hexo new命令时，会按照这个模板生成文件) source (资源文件，里面的_post存放文章，其他东西生成时会照搬到public) theme (主题文件，里面每一个文件夹都是一个主题。定义页面生成的样式) _config.yml (Hexo配置文件，我们主要操作的文件，里面定义各种变量，在生成页面会程序会根据不同变量生成不同形式的页面) db.json (数据库文件) package.json (插件数据库，只要有这个文件，运行npm install就会按照里面的内容安装插件) Hexo常用的命令如下 hexo clean 清楚public文件夹 hexo g 生成文件 hexo d 上传网站到git hexo s 运行本地服务器测试网站 hexo new 建立一个md文件(页面) 其中，可以hexo d -g在生成后发布 使用GitCafe(Coding)搭建双博客系统由于GitHub屏蔽了百度爬虫，同时访问速度稍微有点慢，我们可以搭建双系统来实现我们心目中的完美网站。按照正常的方式申请项目在_config.yml的deploy中，同时写入GitHub和GitCafe即可这样每次hexo d会同时上传到两边在域名dns解析里，再根据线路进行解析即可。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.oyohyee.com/tags/Hexo/"}]},{"title":"double的读入与输出","date":"2016-06-06T15:49:55.000Z","path":"/post/Note/double.html","text":"scanf函数是通过指针指向变量的。%f告诉scanf函数在所传地址位置上存储一个float型值，而%lf告诉scanf函数在所传地址位置上存储一个double型值。这里float和double的区别是非常重要的。如果给出了错误的转换说明，那么scanf函数将可能存储错误的字节数量（没有提到的是，float型的为模式可能不同于double型的位模式）。 TakuSegmentFault上的回答 因此，当输入时必须使用%lf来确保数据被正确存储 为了方便使用者，很多编译器默许了常见的错误，当使用printf(&quot;%lf&quot;,a)时，若a为double变量，编译器会自动把其修改为%f 而LLVM会警告并推荐修改为%f。 scanf()函数中不存在%lf，输入double用%lf输出用%f","tags":[{"name":"读入输出","slug":"IO","permalink":"https://www.oyohyee.com/tags/IO/"}]},{"title":"Test","date":"2016-06-03T12:29:03.000Z","path":"/post/Test.html","text":"Test Hexo post 测试加粗 测试斜体 测试标题1测试标题2测试标题3测试标题4测试标题5测试标题6 测试引用 测试引用 content [author[source]] [link] [source_link_title] Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 测试代码段 测试代码段 测试代码高亮 pullquote content jsfiddle gist iframe include_code slug slug raw content cq blah blah blah include&lt;cstdio&gt; TitleLink#include &lt;cstdio&gt;int main()&#123; printf(\"Hello World!\"); return 0;&#125; npm install hexo -g aaabbb","tags":[]},{"title":"Hello World","date":"2016-06-03T12:00:00.000Z","path":"/post/hello_world.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","tags":[]},{"title":"HFUT 1357.梯田AGAIN(安徽省2016“京胜杯”程序设计大赛 D)","date":"2016-05-30T12:05:00.000Z","path":"/post/HFUT/1357.html","text":"题目 Description 大家还记得去年的梯田吗？土豪YZK在一块小岛上有着一大片nm的梯田，每块11的田地都有它的高度。奴隶们不甘被YZK剥削，他们联合起来决定发动一场海啸淹掉YZK的部分梯田。奴隶们去年尝试了一下，结果发现，由于土质太过松软，水能够透过土地渗入到相邻的梯田，即对于海啸高度h，梯田中所有小于等于h的土地都会由于土质松软而被被淹没。 现在给你一个n*m的矩阵，代表梯田中每块田地的高度。然后给定q个询问，每个询问给定一个海啸高度h，问在此高度下，不被淹没的梯田数量是多少。 Input 第一行一个整数T，表示测试数据组数。对于每组测试数据： 第一行三个数字n，m，q，表示梯田的行数，列数和询问数。 之后n行，每行m个数字，表示每块田地的高度，梯田高度不大于1000000。 之后q行，每行给出一个海啸高度h，问大于这个高度的梯田有多少块。 0&lt;T&lt;20。 0&lt;n，m&lt;=200。 0&lt;=q&lt;1000。 0&lt;=h&lt;=1000000. Output 对于每个询问，给出一个整数，表示大于这个海啸高度的梯田数量。 Sample Input 22 2 21 23 4232 3 31 2 33 4 5045 Sample Output ​21610 题解题目比较容易理解，可以看出，整个梯田的大小可能是200*200，而询问的数量是1000，h的最大高度为1000000 因此，可以知道，在极限数据情况下，如果保存梯田中每块田的高度的话，会有大量的重复计算，会导致超时。 可以将每个高度的梯田的数目记录下来，采用记忆化搜索的方式来查询。 （比赛时的数据貌似比这个容易过） 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxh = 1000005;int cnt[maxh];int ans[maxh];int Max = -1;int Ans(int h) &#123; if(h &gt; Max) return 0; if(ans[h] == -1) ans[h] = cnt[h] + Ans(h + 1); return ans[h];&#125;void Do() &#123; memset(cnt,0,sizeof(cnt)); memset(ans,-1,sizeof(cnt)); Max = -1; int n,m,q; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;q); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) &#123; int temp; scanf(\"%d\",&amp;temp); Max = max(Max,temp); cnt[temp]++; &#125; REP(q) &#123; int h; scanf(\"%d\",&amp;h); printf(\"%d\\n\",Ans(h)-cnt[h]); &#125;&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"记忆化搜索","slug":"Memory-Search","permalink":"https://www.oyohyee.com/tags/Memory-Search/"},{"name":"HFUT","slug":"HFUT","permalink":"https://www.oyohyee.com/tags/HFUT/"},{"name":"京胜杯","slug":"JingShengBei","permalink":"https://www.oyohyee.com/tags/JingShengBei/"}]},{"title":"HFUT 1355.阵前第一功(安徽省2016“京胜杯”程序设计大赛 B)","date":"2016-05-30T11:45:00.000Z","path":"/post/HFUT/1355.html","text":"题目 Description A国每个国民都有一定战斗力，每年国家都要对人民的战斗力进行一次排序统计，他们的排序规矩是相同战斗力的排名一样，而且只占一个排序名额。比如，有5个人：100,100,90,90,70. 两个100的并列第一，称为第一战斗力，两个90的并列第二，称为第二战斗力，依次类推。。。现在你想查询第K战斗力是多少 Input 先输入一个整数T，表示T（T&lt;50）组数据。 每组第一行一个正整数N（1000&gt;N&gt;0），表示表示有N个人。接下里一行N个正整数ai(2^30&gt;=ai&gt;=0)，表示每个人的战斗力。 接下输入一个正整数K（N&gt;=K&gt;0）。（保证输入都合法） Output 输出第K战斗力,输出占一行 Sample Input 25100 90 90 100 702101 2 3 3 3 400 3 4 3 14 Sample Output 902 题解数据输入后，排序 从大到小找即可 不知道为什么当时比赛的时候死都AC不了 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 1005;int p[maxn];void Do() &#123; int n; scanf(\"%d\",&amp;n); REP(n) scanf(\"%d\",&amp;p[o]); int q; scanf(\"%d\",&amp;q); sort(p,p + n); int k = 1; int ans = p[n - 1]; for(int i = n - 1;i &gt;= 0;i--) &#123; if(ans != p[i]) &#123; ans = p[i]; k++; &#125; if(q == k) break; &#125; printf(\"%d\\n\",ans);&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"HFUT","slug":"HFUT","permalink":"https://www.oyohyee.com/tags/HFUT/"},{"name":"京胜杯","slug":"JingShengBei","permalink":"https://www.oyohyee.com/tags/JingShengBei/"}]},{"title":"HFUT 1356.转啊转(安徽省2016“京胜杯”程序设计大赛 E)","date":"2016-05-29T17:36:00.000Z","path":"/post/HFUT/1356.html","text":"题目 Description 在二维平面上，有一个固定的圆和一个固定的点（保证该点不在圆上），还有一个动点在圆上以角速度w绕圆心一直转。在t时刻，连接该动点与定点成一条直线k，求直线k被圆所截线段的长度（即直线k在圆内部分长度）。动点初始时刻在圆的三点钟方向（即与x轴正方向平行），并以逆时针方向绕圆转。 Input 先输入一个整数T，表示T（T&lt;50）组数据。每组数据一行七个实数a,b,r(r&gt;0),x,y,w(w&gt;=0),t(t&gt;=0) 分别表示圆的圆心坐标（a,b），半径r,固定点坐标(x,y)，角速度w,要查询的时刻t。上述所有数据的绝对值小于10000。 Output 输出答案占一行，保留2位小数。 Sample Input 11 1 1 3 1 3 0 Sample Output 2.00 Hint 角速度定义： 一个以弧度为单位的圆（一个圆周为2π,即：360度=2π),在单位时间内所走的弧度即为角速度。 题解纯粹的数学问题。 使用两点式、点到直线距离公式、勾股定理求解即可 要注意的是 double输入用%lf 输出用%f 不然会有奇妙的问题出现 double的读入与输出 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const double PI = 3.1415926;void Do() &#123; double a,b,r,x,y,w,t; scanf(\"%lf%lf%lf%lf%lf%lf%lf\",&amp;a,&amp;b,&amp;r,&amp;x,&amp;y,&amp;w,&amp;t); double xb = a + r * cos(w*t); double yb = b + r * sin(w*t); double A = y - yb; double B = xb - x; double C = x * yb - xb * y; double l = abs(A * a + B * b + C) / sqrt(A * A + B * B); double ans = 2 * sqrt(r * r - l * l); printf(\"%.2f\\n\",abs(ans));&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"HFUT","slug":"HFUT","permalink":"https://www.oyohyee.com/tags/HFUT/"},{"name":"京胜杯","slug":"JingShengBei","permalink":"https://www.oyohyee.com/tags/JingShengBei/"}]},{"title":"HFUT 1354.砝码称重(安徽省2016“京胜杯”程序设计大赛 A)","date":"2016-05-29T16:17:00.000Z","path":"/post/HFUT/1354.html","text":"题目 Description 小明非常喜爱物理，有一天，他对物理实验室中常用的弹簧拉力计产生了兴趣。实验室中有两种质量不同的砝码，小明分别用a个第一种砝码放在弹簧拉力计上和b个第二种砝码放在弹簧拉力计上，假设每增加单位重量的砝码，弹簧拉力计的长度增加1，那么两次称量弹簧拉力计的长度差是多少呢？（假设拉力计不发生非弹性形变） Input第一行一个整数T，表示有T组数据。 之后T行，每行数据包含四个正整数，分别表示第一种砝码重量a，第一种砝码数量b，第二种砝码重量c，第二种砝码数量d。 T&lt;25 0&lt;a,b,c,d&lt;=100 Output 对于每组数据，输出一个正整数，表示弹簧拉力计的长度差值。 Sample Input 31 2 3 41 4 2 21 3 2 1 Sample Output 1001 题解省赛第一题，水题 前两个数相乘减后两个数相乘取绝对值即可 代码","tags":[{"name":"HFUT","slug":"HFUT","permalink":"https://www.oyohyee.com/tags/HFUT/"},{"name":"京胜杯","slug":"JingShengBei","permalink":"https://www.oyohyee.com/tags/JingShengBei/"}]},{"title":"AOJ 331.汉诺塔","date":"2016-05-29T13:36:00.000Z","path":"/post/AOJ/331.html","text":"题目 Description 大家都听说过汉诺塔吧？有n个圆盘由小到大排列，套在a柱上，每次只能移动一个圆盘，而且只能大的在下，小的在上，让你把a柱上的圆盘移到b柱，给你一个多余的c柱，问你最少移动多少次才能完成任务。 Input 输入有多组数据，每组包括一个整数n(n&lt;=10000000)，表示初始状态下有n个圆盘，当输入的n为0时，程序结束，n为负的情况不作处理。 Output 对每个输入，对应一行输出，每行输出包括一个整数，即移动的最小次数，因为数目非常大，所以请对9973求余后再输出。 Sample Input 12340 Sample Output 13715 题解求n个圆盘的汉诺塔的最少移动次数 找规律得 ans = 2n-1 由于最后要对9973取模，因此使用快速幂取模算法 另外要额外注意：如果n是负数，不输出 代码//====================================================================/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)typedef long long LL;typedef long long LL;LL exp_mod(LL a,LL n,LL b) &#123; LL t; if(n == 0) return 1 % b; if(n == 1) return a % b; t = exp_mod(a,n / 2,b); t = t * t % b; if((n &amp; 1) == 1) t = t * a % b; return t;&#125;bool Do() &#123; int n; if(scanf(\"%d\",&amp;n),n == 0) return false; if(n &lt; 0) return true; printf(\"%lld\\n\",exp_mod(2,n,9973) - 1); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"快速幂取模","slug":"Raising-Modulo-Numbers","permalink":"https://www.oyohyee.com/tags/Raising-Modulo-Numbers/"}]},{"title":"AOJ 763.过河卒","date":"2016-05-20T16:42:00.000Z","path":"/post/AOJ/763.html","text":"题目 Description 在一个n*m的矩阵上，A点有一个过河卒，需要走到目标B点。卒行走的规则：只能向下或者向右。每一步能水平或者垂直移动一个点（纵横线的交叉点）的距离。计算从A 点能够到达B点的路径的条数。设行、列数为m和n, 2&lt;=m,n&lt;=20 Input 只有一行，包含4个整数，即B点坐标(x1,y1) 和 A点坐标(x2,y2)，保证A,B在地图内。 Output 一个整数，为路径的条数，答案对1000000007取模 Sample Input 6 6 3 2 Sample Output 35 Hint 可能走不到 题解递推（dp）或者组合数 最后答案记得取模 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/ かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std; //DEBUG MODE#define debug 0 //循环#define REP(n) for(int o=0;o&lt;n;o++) //初始化#define mst(a,n) memset(a,n,sizeof(a)) int Map[25][25];const int MOD = 1000000007; bool Do() &#123; int x1,y1,x2,y2; if(scanf(\"%d%d%d%d\",&amp;x1,&amp;y1,&amp;x2,&amp;y2) == EOF) return false; mst(Map,0); Map[x2][y2] = 1; for(int i = x2;i &lt;= x1;i++) for(int j = y2;j &lt;= y1;j++) if(!(i == x2&amp;&amp;j == y2)) Map[i][j] = (Map[i][j - 1] + Map[i - 1][j]) % MOD; printf(\"%d\\n\",Map[x1][y1]); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"}]},{"title":"AOJ 762.分数数列","date":"2016-05-20T16:40:00.000Z","path":"/post/AOJ/762.html","text":"题目 Description 一个数列的前6项为：1/2，3/5，4/7，6/10，8/13，9/15等，试求数列的第n项(n&lt;2000) Input 输入一个整数n(0&lt; n &lt; 2000) Output 输出数列的第n项 Sample Input 1980 Sample Output 3203/5183 题解找规律 对于第n项 分子为前n-1项未出现的自然数中最小的一个 分母为分子+n （真难找，感谢我瑞） 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/ かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std; //DEBUG MODE#define debug 0 //循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 6000;bool Has[maxn];bool Do() &#123; int n; if(scanf(\"%d\",&amp;n) == EOF) return false; memset(Has,false,sizeof(Has)); int last = 1; for(int i = 1;i &lt;= n;i++) &#123; int j; for(j = last;Has[j];j++); Has[j] = true; Has[j + i] = true; last = j; if(i == n) printf(\"%d/%d\\n\",j,j + i); &#125; return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"}]},{"title":"AOJ 761.Fibonacci序列","date":"2016-05-20T16:37:00.000Z","path":"/post/AOJ/761.html","text":"题目 Description Fibonacci 数列的另一种形式F(0)=7, F(1)=11 F(n)=F(n-1)+F(n-2) (n&gt;=2) Input 包括多行，每行有一个整数n(n&lt;1,00,000),当n&lt;0时表示输入结束 Output 对应输入的n,若序列的第n项能被3整数，则输出Yes，否则输出No. Sample Input 012345-1 Sample Output NoNoYesNoNoNo 题解递推+记忆化搜索即可 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/ かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std; //DEBUG MODE#define debug 0 //循环#define REP(n) for(int o=0;o&lt;n;o++) const int maxn = 100005;int f[maxn];int F(int n) &#123; if(f[n] == -1) &#123; f[n] = F(n - 1) + F(n - 2); &#125; return f[n];&#125; bool Do() &#123; int n; if(scanf(\"%d\",&amp;n),n&lt;0) return false; //printf(\"%d %d \",n,F(n)); printf((F(n) % 3) == 0 ? \"Yes\\n\" : \"No\\n\"); return true;&#125; int main() &#123; memset(f,-1,sizeof(f)); f[0] = 7; f[1] = 11; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"递推","slug":"Recurrence","permalink":"https://www.oyohyee.com/tags/Recurrence/"},{"name":"记忆化搜索","slug":"Memory-Search","permalink":"https://www.oyohyee.com/tags/Memory-Search/"}]},{"title":"AOJ 760.尾数相等的数","date":"2016-05-20T16:35:00.000Z","path":"/post/AOJ/760.html","text":"题目 Description 从键盘输入一个自然数K(1 &lt; K &lt; 99999999)，一定存在自然数M和N（M &lt; N），使得K的M次方和K的N次方均大于或等于1000，且它们的未尾三位数相等，则称M和N是一对“K尾相等数”。请编程序，输出K尾相等数中M+N最小值。 Input 每一行包含一组测试数据，每组测试数据包含一个位长小于10的正整数K. Output 对每组测试数据输出一行。每行包含2个正整数M和N,两数之间用一个空格分隔。 Sample Input 20125 Sample Output 3 42 4 题解模拟操作即可，关键在于由于数据较大，而我们需要的只有后三位，因此不断%1000即可 注意1次方就符合条件的情况，和小于1000的情况 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/ かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std; //DEBUG MODE#define debug 0 //循环#define REP(n) for(int o=0;o&lt;n;o++) //初始化#define mst(a) memset(a,-1,sizeof(a)) const int maxn = 1005;int visited[maxn]; bool Do() &#123; long long n; if(scanf(\"%lld\",&amp;n) == EOF) return false; mst(visited); int N,M,e = 1; long long k = n; while(k &lt; 1000) &#123; k *= n; e++; &#125; k %= 1000; for(int i = 0;;i++) &#123; if(visited[k] != -1) &#123; N = e + i; M = visited[k]; break; &#125; else &#123; visited[k] = e + i; &#125; k *= n; k %= 1000; &#125; printf(\"%d %d\\n\",M,N); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"POJ 1035.Spell checker","date":"2016-05-19T21:24:00.000Z","path":"/post/POJ/1035.html","text":"题目 Description You, as a member of a development team for a new spell checking program, are to write a module that will check the correctness of given words using a known dictionary of all correct words in all their forms.If the word is absent in the dictionary then it can be replaced by correct words (from the dictionary) that can be obtained by one of the following operations: deleting of one letter from the word; replacing of one letter in the word with an arbitrary letter; inserting of one arbitrary letter into the word. Your task is to write the program that will find all possible replacements from the dictionary for every given word. InputThe first part of the input file contains all words from the dictionary. Each word occupies its own line. This part is finished by the single character ‘#’ on a separate line. All words are different. There will be at most 10000 words in the dictionary.The next part of the file contains all words that are to be checked. Each word occupies its own line. This part is also finished by the single character ‘#’ on a separate line. There will be at most 50 words that are to be checked.All words in the input file (words from the dictionary and words to be checked) consist only of small alphabetic characters and each one contains 15 characters at most. Output Write to the output file exactly one line for every checked word in the order of their appearance in the second part of the input file. If the word is correct (i.e. it exists in the dictionary) write the message: “ is correct”. If the word is not correct then write this word first, then write the character ‘:’ (colon), and after a single space write all its possible replacements, separated by spaces. The replacements should be written in the order of their appearance in the dictionary (in the first part of the input file). If there are no replacements for this word then the line feed should immediately follow the colon. Sample Input iishashavebemymorecontestmetooifaward meawaremcontesthavooorifimre Sample Output me is correctaware: awardm: i my mecontest is correcthav: has haveoo: tooor:i is correctfi: imre: more me 题解给一些合法单词和一些待测的单词，如果待测单词合法，则输出“xx is correct”。 否则，输出删去、修改、增加一个字符后合法的单词 输出按照输入顺序 有个题解说用Trie树，写的一直WA、TLE 换用暴力解 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)int ok;int ldict,lstr;string temp;vector&lt;string&gt; dict;void replace(string dict) &#123; int count = 0; for(size_t i = 0; i &lt; dict.length(); i++) &#123; if(temp[i] != dict[i]) count++; if(count &gt; 1) return; &#125; ok = 1; cout &lt;&lt; \" \" + dict;&#125;void insert(string dict) &#123; string tmp; for(size_t i = 0; i &lt; temp.length(); i++) &#123; if(temp[i] != dict[i]) &#123; tmp = dict; tmp.insert(i,1,temp[i]); if(tmp == temp) &#123; ok = 1; cout &lt;&lt; \" \" + dict; &#125; return; &#125; &#125;&#125;void del(string dict) &#123; string tmp; for(size_t i = 0; i &lt; dict.length(); i++) &#123; if(temp[i] != dict[i]) &#123; tmp = dict; tmp.erase(i,1); if(tmp == temp) &#123; ok = 1; cout &lt;&lt; \" \" + dict; &#125; return; &#125; &#125;&#125;bool Do() &#123; while(1) &#123; if(!(cin &gt;&gt; temp)) return false; if(temp == \"#\") break; dict.push_back(temp); &#125; while(1) &#123; cin &gt;&gt; temp; if(temp == \"#\") break; ok = -1; lstr = temp.length(); for(size_t i = 0; i &lt; dict.size(); i++) &#123; if(dict[i] == temp) &#123; cout &lt;&lt; temp + \" is correct\"; ok = 0; break; &#125; &#125; if(ok &lt; 0) &#123; cout &lt;&lt; temp + ':'; for(size_t i = 0; i &lt; dict.size(); i++) &#123; ldict = dict[i].length(); if(lstr == ldict) &#123; replace(dict[i]); &#125; else if(lstr == ldict + 1) &#123; insert(dict[i]); &#125; else if(lstr == ldict - 1) &#123; del(dict[i]); &#125; &#125; &#125; cout &lt;&lt; endl; &#125; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"暴力","slug":"Violence","permalink":"https://www.oyohyee.com/tags/Violence/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"},{"name":"Trie树","slug":"Trie","permalink":"https://www.oyohyee.com/tags/Trie/"}]},{"title":"POJ 2299.Ultra-QuickSort","date":"2016-05-18T16:56:00.000Z","path":"/post/POJ/2299.html","text":"题目 Description In this problem, you have to analyze a particular sorting algorithm. The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence elements until the sequence is sorted in ascending order. For the input sequence9 1 0 5 4 , Ultra-QuickSort produces the output0 1 4 5 9 . Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence. InputThe input contains several test cases. Every test case begins with a line that contains a single integer n &lt; 500,000 – the length of the input sequence. Each of the the following n lines contains a single integer 0 ≤ a[i] ≤ 999,999,999, the i-th input sequence element. Input is terminated by a sequence of length n = 0. This sequence must not be processed. Output For every input sequence, your program prints a single line containing an integer number op, the minimum number of swap operations necessary to sort the given input sequence. Sample Input 59105431230 Sample Output 60 题解逆序数问题 采用归并排序的方法来将时间复杂度从O(n2)到O(nlogn) 要特别注意，由于数据非常大，因此最坏情况下答案是超出int范围的，要使用long long保存 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 500005;int a[maxn];long long ans;//将已经排好序的a[l]~a[mid] a[mid+1]~a[r]拼合起来void merge(int a[],int l,int mid,int r) &#123; int pos1 = l;//左侧的指针 int pos2 = mid + 1;//右侧的指针 int *temp = new int[r - l + 1]; int pos = 0;//临时数组的指针 while(pos1 &lt;= mid || pos2 &lt;= r) &#123; if(pos1 &gt; mid) &#123; temp[pos++] = a[pos2++]; &#125; if(pos2 &gt; r) &#123; temp[pos++] = a[pos1++]; &#125; if(pos1 &lt;= mid&amp;&amp;pos2 &lt;= r) &#123; if(a[pos1] &lt;= a[pos2]) &#123; temp[pos++] = a[pos1++]; &#125; else &#123; temp[pos++] = a[pos2++]; ans += mid - pos1 + 1;//交换 &#125; &#125; &#125; for(int i = 0;i &lt;= r - l;i++) a[l + i] = temp[i];&#125;//归并排序 对a[l]~a[r]排序void mergesort(int a[],int l,int r) &#123; if(l&lt;r) &#123; int mid = (l + r) / 2; mergesort(a,l,mid); mergesort(a,mid + 1,r); merge(a,l,mid,r); &#125;&#125;bool Do() &#123; int n; if(scanf(\"%d\",&amp;n),n == 0) return false; REP(n) scanf(\"%d\",&amp;a[o]); ans = 0; mergesort(a,0,n - 1); printf(\"%lld\\n\",ans); /*REP(n) printf(\"%d \",a[o]); printf(\"\\n\");*/ return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"},{"name":"逆序数","slug":"Inverse-number","permalink":"https://www.oyohyee.com/tags/Inverse-number/"}]},{"title":"POJ 2503.Babelfish","date":"2016-05-18T16:48:00.000Z","path":"/post/POJ/2503.html","text":"题目 Description You have just moved from Waterloo to a big city. The people here speak an incomprehensible dialect of a foreign language. Fortunately, you have a dictionary to help you understand them. InputInput consists of up to 100,000 dictionary entries, followed by a blank line, followed by a message of up to 100,000 words. Each dictionary entry is a line containing an English word, followed by a space and a foreign language word. No foreign word appears more than once in the dictionary. The message is a sequence of words in the foreign language, one word on each line. Each word in the input is a sequence of at most 10 lowercase letters. Output Output is the message translated to English, one word per line. Foreign words not in the dictionary should be translated as “eh”. Sample Input dog ogdaycat atcaypig igpayfroot ootfrayloops oopslay atcayittenkayoopslay Sample Output catehloops Hint Huge input and output,scanf and printf are recommended. 题解这道题的意思就是进行单词翻译 关键点在于： 读入数据 映射 由于数据存在一行两个单词和一行一个单词两种形式，因此，我们再读入时需要区分开。 另一方面，由于需要对单词进行映射，因此我们可以采用map，进行string对string的映射 最后输出时使用cout来输出（string格式） 如果需要进一步优化时间可以采用trie树 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 100005;const int maxm = 100;inline int read_string(char s[]) &#123; char c; int i = 0; //while(!(((c = getchar()) ==' ') || (c &gt;= 'a'&amp;&amp;c &lt;= 'z'))) // if(c == EOF) // return 0; if((c = getchar())== EOF) return 0; while((c == ' ') || (c &gt;= 'a'&amp;&amp;c &lt;= 'z')) &#123; s[i++] = c; c = getchar(); &#125; s[i] = '\\0'; return i;&#125;bool Do() &#123; char temp[maxm*2]; map&lt;string,string&gt; dict; map&lt;string,string&gt;::iterator it; char a[maxm],b[maxm]; while(read_string(temp)) &#123; if(strcmp(temp,\"\") == 0) break; sscanf(temp,\"%s %s\",a,b); dict[b] = a; &#125; while(scanf(\"\\n%s\",a) != EOF) &#123; cout &lt;&lt; (dict.count(a) ? dict[a] : \"eh\" )&lt;&lt; \"\\n\"; &#125; return false;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"字符串(string)","slug":"String","permalink":"https://www.oyohyee.com/tags/String/"},{"name":"映射(map)","slug":"Map","permalink":"https://www.oyohyee.com/tags/Map/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"},{"name":"Trie树","slug":"Trie","permalink":"https://www.oyohyee.com/tags/Trie/"}]},{"title":"POJ 1840.Eqs","date":"2016-05-18T15:34:00.000Z","path":"/post/POJ/1840.html","text":"题目 Description Consider equations having the following form:a1x1 3+ a2x2 3+ a3x3 3+ a4x4 3+ a5x5 3=0The coefficients are given integers from the interval [-50,50].It is consider a solution a system (x1, x2, x3, x4, x5) that verifies the equation, xi∈[-50,50], xi != 0, any i∈{1,2,3,4,5}. Determine how many solutions satisfy the given equation. InputThe only line of input contains the 5 coefficients a1, a2, a3, a4, a5, separated by blanks. Output The output will contain on the first line the number of the solutions for the given equation. Sample Input 37 29 41 43 47 Sample Output 654 题解求解五元三次方程。 暴力破解 枚举所有的可能。 直接暴力需要的时间非常巨大 1005=1010 而可以将一部分移向到另一侧有a1x13+a2x23=-(a3x33+a4x43+a5x53) 这样所需的时间就变成了1002+1003少了许多数量级 先枚举等式左侧的情况，在枚举等式右侧的情况。 使用一个数组来存储左侧得出一个数值的步骤数，如果等式右侧能得出这个数，则此为可行解 由于牵扯的数据巨大，因此数组可以开成unsigned char来保存 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 6250001*5;unsigned char cnt[maxn*2];bool Do() &#123; int a[5]; REP(5) if(scanf(\"%d\",&amp;a[o]) == EOF) return false; memset(cnt,0,sizeof(cnt)); //map&lt;long long,int&gt; m; for(int i = -50;i &lt;= 50;i++) for(int j = -50;j &lt;= 50;j++) if(i != 0 &amp;&amp; j != 0) &#123; long long temp = maxn + a[0] * i*i*i + a[1] * j*j*j; cnt[temp]++; &#125; int ans = 0; for(int i = -50;i &lt;= 50;i++) for(int j = -50;j &lt;= 50;j++) for(int k = -50;k &lt;= 50;k++) if(i != 0 &amp;&amp; j != 0 &amp;&amp; k != 0) &#123; long long temp = maxn -(a[2] * i*i*i + a[3] * j*j*j + a[4] * k*k*k); ans += cnt[temp]; &#125; printf(\"%d\\n\",ans); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"AOJ 759.会绕圈的数","date":"2016-05-15T15:29:00.000Z","path":"/post/AOJ/759.html","text":"题目 Description 任意一个正整数，把它的每一位数字都平方后相加得到一个数；将这个数的每一位数字再平方相加；依次进行就会产生循环现象。例如：1234。1ˆ2+2ˆ2+3ˆ2+4ˆ2=1+4+9+16=303ˆ2+0ˆ2=99ˆ2=818ˆ2+1ˆ2=64+1=656ˆ2+5ˆ2=36+25=616ˆ2+1ˆ2=36+1=373ˆ2+7ˆ2=9+49=585ˆ2+8ˆ2=25+64=898ˆ2+9ˆ2=64+81=1451ˆ2+4ˆ2+5ˆ2=1+16+25=424ˆ2+2ˆ2=16+4=202ˆ2+0ˆ2=4+0=44ˆ2=161ˆ2+6ˆ2=1+36=37由于前面已出现过37，这时就产生了循环。设计一个程序，对给定的一个数，打印出到出现循环为止的所有数。 Input 输入包括多组测试数据，每组测试数据占一行并且只有一个正整数m（m&lt;10000000）,当m=0时表示输入结束。 Output 对每组测试数据输出一行结果，结果中包括到第一次产生循环时的所有整数。 Sample Input 1234678348070 Sample Output 1234 30 9 81 65 61 37 58 89 145 42 20 4 16 3767834807 287 117 51 26 40 16 37 58 89 145 42 20 4 16 题解用一个函数来模拟操作即可 要注意的是输出格式 题目中每个数字后面都是三个空格 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/ かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std; //DEBUG MODE#define debug 0 //循环#define REP(n) for(int o=0;o&lt;n;o++) const int maxn = 1005;bool visited[maxn]; inline int sq(int n) &#123; int ans = 0; while(n) &#123; ans += (n % 10)*(n % 10); n /= 10; &#125; return ans;&#125; bool Do() &#123; int n; if(scanf(\"%d\",&amp;n),n == 0) return false; memset(visited,false,sizeof(visited)); int k = n; while(k&gt;maxn||!visited[k]) &#123; if(k &lt; maxn) visited[k] = true; printf(\"%d \",k); k = sq(k); &#125; printf(\"%d \\n\",k); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"AOJ 758.大数的位数","date":"2016-05-15T15:25:00.000Z","path":"/post/AOJ/758.html","text":"题目 Description 给出一个整数，确定这个数的阶乘的位数。 Input 多组数据，每行为一个大于等于1且小于等于107的整数n. Output 对应每个输入数据输出一个结果。 Sample Input 1020 Sample Output 719 题解两种方法可能可以实现： 抛去一定的精度来计算 采用数学公式计算 抛去一定的精度来计算对于第一种方法，我们可以得知，对于两个大数相乘，其较低位对结果的影响较小，因此我们可以舍弃一些数据 采用类似于科学记数法的形式来计算(a*10^b) 这种做法，当n较大时，会由于误差的累积导致错误。 采用数学公式计算而第二种方法可以采用一些数学公式计算 log10n! = log10(1*2*3*......*n) = log101+log102+log103+...+log10n 显然，等式右侧我们可以轻易得出。 而等式左侧，log10n的意义是n对10的对数，即10log10n=n 对于一个整数k，若10k&lt;n&lt;10k+1，我们可以得出结论，n是k位数 所以，大数n!的位数就是log10n!，由于int的向下取整性质，我们还要将这个数再加上1 虽然题目上说的最大值是107，然而，最大值至少是197(方法1WA) 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/ かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std; //DEBUG MODE#define debug 0 const int maxn = 10005;bool tree[maxn]; int bit(int n) &#123; int a = 1; int e = 0; for(int i = 1;i &lt;= n;i++) &#123; a *= i; while(a / 100000) &#123;//保证精度 a /= 10; e++; &#125; &#125; while(a) &#123;//转化为位数 a /= 10; e++; &#125; return e;&#125; //n! = 1*2*3*4*5*......*(n-1)*n//ln n! = ln 1+len2+......ln(n-1)+ln nint mathbit(int n) &#123; double ans = 0; for(int i = 1;i &lt;= n;i++) ans += log10(i); return (int)ans+1;&#125; bool Do() &#123; int n; if(scanf(\"%d\",&amp;n) == EOF) return false; printf(\"%d\\n\",mathbit(n)); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"}]},{"title":"AOJ 757.路边的树","date":"2016-05-15T15:00:00.000Z","path":"/post/AOJ/757.html","text":"题目 Description 长度为L的路边有一排树，相邻树间隔为1米，树种在整数点，0，1，2，….，L.现在马路上有一些区域修地铁，区域用起点和终止点表示。已知有M个区域要修地铁，区间之间可能重合的部分。现要把这些区域（包括端点处的两棵数）移走，计算些树移走后，马路上还有多少棵树。 Input 第一行有两个整数L(1&lt;=L&lt;=10000)和M(1&lt;=M&lt;=100),L代表马路的长度， M代表区域数。L和M之间用一个空格分隔开。接下来的M行，每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。 Output 输出包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。 Sample Input 500 3150 300100 200470 471 Sample Output 298 题解用数组来模拟道路，先把所有位置种上树(TRUE)，把需要砍掉的FALSE掉即可 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 10005;bool tree[maxn];bool Do() &#123; int L,M; if(scanf(\"%d%d\",&amp;L,&amp;M)==EOF) return false; memset(tree,true,sizeof(tree)); REP(M) &#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); for(int i = a;i &lt;= b;i++) tree[i] = false; &#125; int cnt = 0; for(int i = 0;i &lt;= L;i++) if(tree[i]) cnt++; printf(\"%d\\n\",cnt); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"AOJ 756.电梯","date":"2016-05-15T14:54:00.000Z","path":"/post/AOJ/756.html","text":"题目 Description 在城市的高层建筑物中，只有一部电梯，由N个正整数组成一个请求列表，列表中的数字表示电梯将在哪层停，电梯按列表顺序依次停靠。电梯每上行一层需要花6秒时间，每下行一层需要花4秒时间，电梯每停一次需要用时5秒。对于给定的请求列表，计算完成所有请求需要花费的时间，不考虑优先顺序，电梯从第0层开始，完成所有请求后又回到第0层。 Input 包含多组数据，每组数据占一行，其中第一个正整数N表示请求列表中有N个数据，接下来是N个整数，如果N=0,则表示输入结束。 Output 对每组数据，输出所有请求的总时间。 Sample Input 1 23 2 3 10 Sample Output 1741 题解直接模拟电梯的运行即可 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/ かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/ #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std; //DEBUG MODE#define debug 0 //循环#define REP(n) for(int o=0;o&lt;n;o++) bool Do() &#123; int n; if(scanf(\"%d\",&amp;n),n == 0) return false; int floor = 0; int ans = 0; REP(n) &#123; int temp; scanf(\"%d\",&amp;temp); if(temp &lt; floor) &#123; ans += 4 * (floor - temp); floor = temp; &#125; if(temp &gt; floor) &#123; ans += 6 * (temp - floor); floor = temp; &#125; &#125; //ans += floor * 4; ans += n * 5; printf(\"%d\\n\",ans); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"并查集","date":"2016-05-13T03:26:00.000Z","path":"/post/Algorithm/Union_Find.html","text":"当需要判断大量数据是否有联系时，可以使用并查集。 将所有数据看作一棵棵单独的树 每个树的根节点都是自己本身 如果两棵树有联系，我们就可以把其中一棵变成另一棵的叶子 这样， 只需要一个数组记录每个结点对应的根，只要两个结点的根相同，就说明他们在同一棵树上(有联系) 因为我们只需要知道根是谁，不需要知道这棵树上还有谁，因此，对于每棵树的叶子都直接连接到根上能够达到最快的访问速度 在访问的时候我们可以顺便进行一定程度的路径压缩 初始化时先把所有的uf[i]=i 连接时 uf[UF(a)] = UF(b); 这样就能把两个结点连到一棵树上(将a所在的树连接到b所在树的根上) //并查集int uf[maxn];int UF(int n) &#123; int t = uf[n]; while(t != uf[t]) t = uf[t]; return uf[n] = t;&#125;","tags":[{"name":"并查集","slug":"Union-Find","permalink":"https://www.oyohyee.com/tags/Union-Find/"}]},{"title":"POJ 1611.The Suspects","date":"2016-05-13T03:14:00.000Z","path":"/post/POJ/1611.html","text":"题目 Description 严重急性呼吸系统综合症( SARS), 一种原因不明的非典型性肺炎,从2003年3月中旬开始被认为是全球威胁。为了减少传播给别人的机会, 最好的策略是隔离可能的患者。在Not-Spreading-Your-Sickness大学( NSYSU), 有许多学生团体。同一组的学生经常彼此相通,一个学生可以同时加入几个小组。为了防止非典的传播,NSYSU收集了所有学生团体的成员名单。他们的标准操作程序(SOP)如下：一旦一组中有一个可能的患者, 组内的所有成员就都是可能的患者。然而,他们发现当一个学生被确认为可能的患者后不容易识别所有可能的患者。你的工作是编写一个程序, 发现所有可能的患者。 Input 输入文件包含多组数据。对于每组测试数据：第一行为两个整数n和m, 其中n是学生的数量, m是团体的数量。0 &lt; n &lt;= 30000，0 &lt;= m &lt;= 500。每个学生编号是一个0到n-1之间的整数，一开始只有0号学生被视为可能的患者。紧随其后的是团体的成员列表，每组一行。每一行有一个整数k，代表成员数量。之后,有k个整数代表这个群体的学生。一行中的所有整数由至少一个空格隔开。n = m = 0表示输入结束，不需要处理。 Output 对于每组测试数据, 输出一行可能的患者。 Sample Input 100 42 1 25 10 13 11 12 142 0 12 99 2200 21 55 1 2 3 4 51 00 0 Sample Output 411 题解并查集 将每个社团的第一个人看作队长， 其队员所在的分支与队长所在的分支连接上。 遍历所有学生， 与0在同一个分支的就是有可能感染的 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 30005;//并查集int uf[maxn];int UF(int n) &#123; int t = uf[n]; while(t != uf[t]) t = uf[t]; return uf[n] = t;&#125;bool Do() &#123; int n,m; if(scanf(\"%d%d\",&amp;n,&amp;m),m==0&amp;&amp;n==0) return false; //初始化并查集 REP(n) uf[o] = o; for(int i = 0;i &lt; m;i++) &#123; int num; scanf(\"%d\",&amp;num); int captain;//社团第一个设为组长 scanf(\"%d\",&amp;captain); REP(num-1) &#123; int temp; scanf(\"%d\",&amp;temp); uf[UF(temp)] = UF(captain);//将temp的根链接到captain的根上 &#125; &#125; int cnt = 0; REP(n) if(UF(o)==UF(0)) cnt++; /*REP(n) printf(\"%d %d\\n\",o,UF(o));*/ printf(\"%d\\n\",cnt); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"并查集","slug":"Union-Find","permalink":"https://www.oyohyee.com/tags/Union-Find/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"POJ 2388.Who's in the Middle","date":"2016-05-08T15:50:00.000Z","path":"/post/POJ/2388.html","text":"题目 Description FJ is surveying his herd to find the most average cow. He wants to know how much milk this ‘median’ cow gives: half of the cows give as much or more than the median; half give as much or less. Given an odd number of cows N (1 &lt;= N &lt; 10,000) and their milk output (1..1,000,000), find the median amount of milk given such that at least half the cows give the same amount of milk or more and at least half give the same or less. Input Line 1: A single integer N Lines 2..N+1: Each line contains a single integer that is the milk output of one cow. Output Line 1: A single integer that is the median milk output. Sample Input 524135 Sample Output 3 Hint INPUT DETAILS: Five cows with milk outputs of 1..5 OUTPUT DETAILS: 1 and 2 are below 3; 4 and 5 are above 3. 题解对一组数求其中位数(连有两个中位数的情况都不用考虑) 直接排序即可 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 10005;int a[maxn];bool Do() &#123; int n; if(scanf(\"%d\",&amp;n) == EOF) return false; REP(n) scanf(\"%d\",&amp;a[o]); sort(a,a + n); printf(\"%d\\n\",a[n/2]); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"POJ 1936.All in All","date":"2016-05-08T15:36:00.000Z","path":"/post/POJ/1936.html","text":"题目 Description You have devised a new encryption technique which encodes a message by inserting between its characters randomly generated strings in a clever way. Because of pending patent issues we will not discuss in detail how the strings are generated and inserted into the original message. To validate your method, however, it is necessary to write a program that checks if the message is really encoded in the final string. Given two strings s and t, you have to decide whether s is a subsequence of t, i.e. if you can remove characters from t such that the concatenation of the remaining characters is s. InputThe input contains several testcases. Each is specified by two strings s, t of alphanumeric ASCII characters separated by whitespace.The length of s and t will no more than 100000. Output For each test case output “Yes”, if s is a subsequence of t,otherwise output “No”. Sample Input sequence subsequenceperson compressionVERDI vivaVittorioEmanueleReDiItaliacaseDoesMatter CaseDoesMatter Sample Output YesNoYesNo &nbsp; 题解应该算是水题吧~ 用两个变量记录指向s、t字符串的位置。 如果相等，则把指向s的+1 看循环完s是否在最后即可 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 100005;bool Do() &#123; char s[maxn],t[maxn]; if(scanf(\"%s%s\",s,t) == EOF) return false; int t_len = strlen(t); int s_len = strlen(s); int it = 0; for(int i = 0;i &lt; t_len;i++) &#123; if(s[it] == t[i]) it++; if(it == s_len) break; &#125; printf(\"%s\\n\",(it == s_len) ? \"Yes\" : \"No\"); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"最长公共子序列","date":"2016-05-08T14:39:00.000Z","path":"/post/Algorithm/LCS.html","text":"一个数列 ，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则 称为已知序列的最长公共子序列。 百度百科 对于两个数最长公共子序列，意思为从两个序列中，尽可能少的删除一些数，从未使得两个序列相同 对于用dp[i][j]记录到字符串a的第i个字符和字符串b的第j个字符时的最长公共子序列 显然有若 a[i]==b[j] dp[i][j] = dp[i-1][j-1]+1否则 dp[i][j] = max&#123; dp[i-1][j] , dp[i][j-1] &#125; 如上图，可以发现每个匹配的字符，都是每种数字的最“左上”的一个 因此可以根据这个规律倒叙出最长公共子序列的一个解 模板//最长公共子序列//输入字符串a 及其长度 字符串b 及其长度 保存最长公共子序列的数组//字符从0开始int LCS(char *a,char *b,char s[] = NULL) &#123; int len1 = strlen(a); int len2 = strlen(b); char *aa = a - 1; char *bb = b - 1; //声明二维数组 int * m = new int[(len1 + 1)*(len2 + 1)]; int **dp = new int *[len1 + 1]; for(int i = 0;i &lt;= len1;i++) dp[i] = m + i*(len2 + 1); //初始化 for(int i = 0;i &lt;= len1;i++) dp[i][0] = 0; for(int i = 0;i &lt;= len2;i++) dp[0][i] = 0; //动态规划 for(int i = 1;i &lt;= len1;i++) for(int j = 1;j &lt;= len2;j++) if(aa[i] == bb[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j],dp[i][j - 1]); /*for(int i = 0;i &lt;= len1;i++)&#123; for(int j = 0;j &lt;= len2;j++) printf(\"%d\\t\",dp[i][j]); printf(\"\\n\"); &#125;*/ //如果c未传值 if(s == NULL) return dp[len1][len2]; //逆序推出一条符合串 int ans = dp[len1][len2]; int x = len1; int y = len2; int it = ans; s[it] = '\\0'; while(it) &#123; if(dp[x - 1][y] == it) &#123; x--; continue; &#125; if(dp[x][y - 1] == it) &#123; y--; continue; &#125; s[--it] = aa[x]; x--; y--; &#125; return ans;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"最长公共子序列","slug":"LCS","permalink":"https://www.oyohyee.com/tags/LCS/"}]},{"title":"动态规划专题","date":"2016-05-08T13:27:00.000Z","path":"/post/Project/DP.html","text":"必考题型 动态规划问题，最重要的是确定状态，找出动态转移方程 其经典类型有 背包问题 最长上升子序列 最长公共子序列 &gt;更多的动态规划题解&lt; OJ编号 题目名称 题目题解 HDU 1024 Max Sum Plus Plus &nbsp; HDU 1029 Ignatius and the Princess IV &nbsp; HDU 1069 Monkey and Banana &nbsp; HDU 1074 Doing Homework &nbsp; HDU 1087 Super Jumping! Jumping! Jumping! &nbsp; HDU 1114 Piggy-Bank &nbsp; HDU 1176 免费馅饼 &nbsp; HDU 1260 Tickets &nbsp; HDU 1257 最少拦截系统 &nbsp; HDU 1160 FatMouse’s Speed &nbsp; POJ 1015 Jury Compromise &nbsp; POJ 1458 Common Subsequence &nbsp; POJ 1661 Help Jimmy &nbsp; POJ 2533 Longest Ordered Subsequence POJ 2533.Longest Ordered Subsequence POJ 3186 Treats for the Cows &nbsp; HDU 1078 FatMouse and Cheese &nbsp; HDU 2859 Phalanx &nbsp; POJ 3616 Milking Time &nbsp; POJ 3666 Making the Grade &nbsp; POJ 1837 Balance POJ 1837.Balance POJ 1276 Cash Machine POJ 1276.Cash Machine POJ 3267 The Cow Lexicon &nbsp; POJ 1836 Alignment POJ 1836.Alignment POJ 1260 Pearls POJ 1260 Pearls POJ 2533 Longest Ordered Subsequence POJ 2533.Longest_Ordered_Subsequence POJ 3176 Cow Bowling POJ 3176 Cow Bowling POJ 1080 Human Gene Functions &nbsp; POJ 1159 Palindroe &nbsp;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"}]},{"title":"POJ 3176.Cow Bowling","date":"2016-05-01T16:54:00.000Z","path":"/post/POJ/3176.html","text":"题目 Description The cows don’t use actual bowling balls when they go bowling. They each take a number (in the range 0..99), though, and line up in a standard bowling-pin-like triangle like this: 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5Then the other cows traverse the triangle starting from its tip and moving “down” to one of the two diagonally adjacent cows until the “bottom” row is reached. The cow’s score is the sum of the numbers of the cows visited along the way. The cow with the highest score wins that frame. Given a triangle with N (1 &lt;= N &lt;= 350) rows, determine the highest possible sum achievable. Input Line 1: A single integer, N Lines 2..N+1: Line i+1 contains i space-separated integers that represent row i of the triangle. Output Line 1: The largest sum achievable using the traversal rules Sample Input 573 88 1 02 7 4 44 5 2 6 5 Sample Output 30 Hint Explanation of the sample: 7 * 3 8 * 8 1 0 * 2 7 4 4 &nbsp;&nbsp;&nbsp;* 4 5 2 6 5The highest score is achievable by traversing the cows as shown above. 题解非常明显的dp+贪心 对于n行的三角形，其一共有 n*(n+1)/2 个数 dp[left(i)] = max{ dp[left(i) , dp[i] + a[left(i)] } dp[left(i+1)+1] = max{ dp[left(i)+1] , dp[i] + a[left(i)+1] } 其中，left(i)表示i下一层左边的数 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)#define t(n) (((n) * ((n)+1))/2)const int maxn = 1005;int n;int a[t(maxn)];int dp[t(maxn)];int left(int n) &#123; int i; for(i = 0;t(i) &lt; n;i++); return n + i;&#125;bool Do() &#123; if(scanf(\"%d\",&amp;n) == EOF) return false; for(int i = 1;i &lt;= t(n);i++) scanf(\"%d\",&amp;a[i]); memset(dp,0,sizeof(dp)); for(int i = 0;i &lt;= t(n - 1);i++) &#123; dp[left(i)] = max(dp[left(i)],dp[i] + a[left(i)]); dp[left(i) + 1] = max(dp[left(i) + 1],dp[i] + a[left(i) + 1]); &#125; int Max = -1; for(int i = t(n - 1) + 1;i &lt;= t(n);i++) Max = max(Max,dp[i]); printf(\"%d\\n\",Max); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"POJ 2533.Longest Ordered Subsequence","date":"2016-05-01T15:18:00.000Z","path":"/post/POJ/2533.html","text":"题目 Description A numeric sequence of ai is ordered if a1 &lt; a2 &lt; … &lt; aN. Let the subsequence of the given numeric sequence ( a1, a2, …, aN) be any sequence ( ai1, ai2, …, aiK), where 1 &lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N. For example, sequence (1, 7, 3, 5, 9, 4, 8) has ordered subsequences, e. g., (1, 7), (3, 4, 8) and many others. All longest ordered subsequences are of length 4, e. g., (1, 3, 5, 8). Your program, when given the numeric sequence, must find the length of its longest ordered subsequence. InputThe first line of input file contains the length of sequence N. The second line contains the elements of sequence - N integers in the range from 0 to 10000 each, separated by spaces. 1 &lt;= N &lt;= 1000 Output Output file must contain a single integer - the length of the longest ordered subsequence of the given sequence. Sample Input 71 7 3 5 9 4 8 Sample Output 4 &nbsp; 题解模板题，最长上升子序列 套用模板即可 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 1005;int n;int a[maxn];class LIS_stack &#123;private: static const int SIZE = maxn; int len;//长度 int Stack[SIZE];public: LIS_stack() &#123; len = 0; memset(Stack,0,sizeof(Stack)); &#125; void push(int num) &#123; if(len == 0 || Stack[len - 1] &lt; num) &#123; Stack[len++] = num; &#125; else &#123; for(int i = 0;i &lt; len;i++) &#123; if(Stack[i] &gt; num) &#123; Stack[i] = num; break; &#125; &#125; &#125; &#125; int lenth() &#123; return len; &#125;&#125;;int LIS(int *a,int len) &#123; LIS_stack s; for(int i = 0;i &lt; len;i++) s.push(a[i]); return s.lenth();&#125;bool Do() &#123; if(scanf(\"%d\",&amp;n) == EOF) return false; REP(n) scanf(\"%d\",&amp;a[o]); printf(\"%d\\n\",LIS(a,n)); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"最长上升子序列","slug":"LIS","permalink":"https://www.oyohyee.com/tags/LIS/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"POJ 1260.Pearls","date":"2016-05-01T10:59:00.000Z","path":"/post/POJ/1260.html","text":"题目 Description In Pearlania everybody is fond of pearls. One company, called The Royal Pearl, produces a lot of jewelry with pearls in it. The Royal Pearl has its name because it delivers to the royal family of Pearlania. But it also produces bracelets and necklaces for ordinary people. Of course the quality of the pearls for these people is much lower then the quality of pearls for the royal family.In Pearlania pearls are separated into 100 different quality classes. A quality class is identified by the price for one single pearl in that quality class. This price is unique for that quality class and the price is always higher then the price for a pearl in a lower quality class.Every month the stock manager of The Royal Pearl prepares a list with the number of pearls needed in each quality class. The pearls are bought on the local pearl market. Each quality class has its own price per pearl, but for every complete deal in a certain quality class one has to pay an extra amount of money equal to ten pearls in that class. This is to prevent tourists from buying just one pearl.Also The Royal Pearl is suffering from the slow-down of the global economy. Therefore the company needs to be more efficient. The CFO (chief financial officer) has discovered that he can sometimes save money by buying pearls in a higher quality class than is actually needed.No customer will blame The Royal Pearl for putting better pearls in the bracelets, as long as theprices remain the same.For example 5 pearls are needed in the 10 Euro category and 100 pearls are needed in the 20 Euro category. That will normally cost: (5+10)10+(100+10)20 = 2350 Euro.Buying all 105 pearls in the 20 Euro category only costs: (5+100+10)*20 = 2300 Euro.The problem is that it requires a lot of computing work before the CFO knows how many pearls can best be bought in a higher quality class. You are asked to help The Royal Pearl with a computer program. Given a list with the number of pearls and the price per pearl in different quality classes, give the lowest possible price needed to buy everything on the list. Pearls can be bought in the requested,or in a higher quality class, but not in a lower one. InputThe first line of the input contains the number of test cases. Each test case starts with a line containing the number of categories c (1&lt;=c&lt;=100). Then, c lines follow, each with two numbers ai and pi. The first of these numbers is the number of pearls ai needed in a class (1 &lt;= ai &lt;= 1000).The second number is the price per pearl pi in that class (1 &lt;= pi &lt;= 1000). The qualities of the classes (and so the prices) are given in ascending order. All numbers in the input are integers. Output For each test case a single line containing a single number: the lowest possible price needed to buy everything on the list. Sample Input 22100 1100 231 101 11100 12 Sample Output 3301344 题解用dp[i]表示买前i种珍珠所需要的最少的钱数根据贪心，买第i种珍珠时，买的越多越划算。也即，对于第i种珍珠，要么一个都不买，要么把前面更便宜的没买的和本组该买的都买了 因此，对于每一层， 只有买和不买两种选择并且不可能出现便宜的没买但是贵的买了 dp[i]= min{ dp[i-1] + (num[i] + 10)*price[i] , dp[j] + (sum[i] - sum[j] + 10)*price[i] } 0&lt;=j&lt;i 前部分是每一组都买的情况，后部分是j~i未买的情况 不要使用sort排序，会WA。 就按照输入的顺序计算即可，不考虑不是按照价钱从小到大输入的情况 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)/* 题意理解： 珍珠有不同的价格，需要买一定数量指定价格的珍珠 对于买的一种价格的珍珠，需要额外付出10个该类珍珠价格的手续费 可以用更好的珠宝代替较差的珍珠 求出所花费的最小价格*/typedef int LL;const int maxn = 105;struct Pearl &#123; int num; int price; bool operator &lt; (const Pearl &amp;rhs)const &#123; return price &lt; rhs.price; &#125;&#125;;Pearl p[maxn];//买完前i种珍珠所需要的最小值LL dp[maxn];int m[maxn];void Do() &#123; int n; scanf(\"%d\",&amp;n); m[0] = 0; REP(n) scanf(\"%d%d\",&amp;p[o + 1].num,&amp;p[o + 1].price); memset(dp,0,sizeof(dp)); //sort(p + 1,p + 1 + n); REP(n) m[o + 1] = m[o] + p[o+1].num; for(int i = 1;i &lt;= n;i++) &#123; dp[i] = dp[i - 1] + (p[i].num + 10) * p[i].price; for(int j = 0;j &lt; i;j++) dp[i] = min(dp[i],dp[j] + (LL)(m[i] - m[j] + 10) * p[i].price); &#125; printf(\"%d\\n\",dp[n]); return;&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"POJ 1836.Alignment","date":"2016-04-30T17:24:00.000Z","path":"/post/POJ/1836.html","text":"题目 DescriptionIn the army, a platoon is composed by n soldiers. During the morning inspection, the soldiers are aligned in a straight line in front of the captain. The captain is not satisfied with the way his soldiers are aligned; it is true that the soldiers are aligned in order by their code number: 1 , 2 , 3 , . . . , n , but they are not aligned by their height. The captain asks some soldiers to get out of the line, as the soldiers that remain in the line, without changing their places, but getting closer, to form a new line, where each soldier can see by looking lengthwise the line at least one of the line’s extremity (left or right). A soldier see an extremity if there isn’t any soldiers with a higher or equal height than his height between him and that extremity.Write a program that, knowing the height of each soldier, determines the minimum number of soldiers which have to get out of line. Input On the first line of the input is written the number of the soldiers n. On the second line is written a series of n floating numbers with at most 5 digits precision and separated by a space character. The k-th number from this line represents the height of the soldier who has the code k (1 &lt;= k &gt; &lt;= n). There are some restrictions:• 2 &lt;= n &lt;= 1000• the height are floating numbers from the interval [0.5, 2.5] Output The only line of output will contain the number of the soldiers who have to get out of the line. Sample Input 81.86 1.86 1.30621 2 1.4 1 1.97 2.2 Sample Output 4 题解题意的大概意思就是删去数列中的一些数后，能够保证对于任一个数，其左边严格单调递减或者右边严格单调递增 因此删除后的数列中间两项是可以相等的 首先应该算出对于每一个数，从其向左的递减数列和向右的递增数列 也即，从两头分别算出最长上升子序列(dp[i]是在确保使用上i的情况下的最长上升子序列) 对于dp[i] 若a[i]&gt;a[j] dp[i]=max&#123; dp[i] , dp[j]+1 &#125;否则 dp[i]=max&#123; dp[i] , 1&#125; 将dp初始化为1，则只需要判断a[i]&gt;a[j]的内容即可 即dp[i]=max{ dp[i] , dp[j]+1 } 最后枚举i、j求出dp1[i]+dp2[j]的最大值，即队伍中剩下的人数 用n减去得到答案 代码/*By:OhYeeGithub:OhYeeHomePage:http://www.oyohyee.comEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 1005;double num[maxn];int ans[maxn];int dp1[maxn];int dp2[maxn];//最长上升子序列void LIS(double *a,int n,int *dp) &#123; REP(n) dp[o] = 1; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; i;j++) if(a[i] &gt; a[j]) dp[i] = max(dp[i],dp[j] + 1);&#125;void LIS2(double *a,int n,int *dp) &#123; REP(n) dp[o] = 1; for(int i = n-1;i &gt;= 0;i--) for(int j = n-1;j &gt; i;j--) if(a[i] &gt; a[j]) dp[i] = max(dp[i],dp[j] + 1);&#125;bool Do() &#123; int n; if(scanf(\"%d\",&amp;n) == EOF) return false; REP(n) scanf(\"%lf\",&amp;num[o]); //最小上升子序列 /* dp[i]为前i个数能生成的最小上升子序列长度 对于第i个数有两种情况： 若a[i]&gt;a[j] dp[i]=max&#123;dp[j]+1,dp[i]&#125; 若a[i]&lt;a[j] dp[i]=max&#123;1,dp[i]&#125; 即dp[i] = max(dp[i],dp[j] + 1) (a[i]&gt;a[j]) 初始为1 */ LIS(num,n,dp1); LIS2(num,n,dp2); /* int Max = -1; bool flag = false; REP(n) &#123; ans[o] = dp1[o] + dp2[o]; if(Max == ans[o] &amp;&amp; ans[o-1] == Max) &#123; flag = true; &#125; else &#123; if(Max &lt; ans[o]) &#123; Max = ans[o]; flag = false; &#125; &#125; &#125; */ int ans2 = -1; for(int i = 0;i &lt; n ;i++) for(int j = i + 1;j &lt; n ;j++) ans2 = max(ans2,dp1[i] + dp2[j]); /* REP(n) printf(\"%d \",dp1[o]); printf(\"\\n\"); REP(n) printf(\"%d \",dp2[o]); printf(\"\\n\"); REP(n) printf(\"%d \",ans[o]); printf(\"\\n\"); */ //printf(\"%d\\n\",n - (Max - 1) - flag); printf(\"%d\\n\",n - ans2); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"最长上升子序列","slug":"LIS","permalink":"https://www.oyohyee.com/tags/LIS/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"最长上升子序列","date":"2016-04-30T14:37:00.000Z","path":"/post/Algorithm/LIS.html","text":"对于一个数列a1,a2,a3,a4……求取其最长的子序列s1,s2,s3……使其满足单调递增的算法，叫做最长上升子序列 对于该问题有两种思路： 动态规划方法求解 O(n2) 贪心+二分 O(nlogn) 动态规划 A[i]表示序列中的第i个数 dp[i]表示从1到i这一段中以i结尾的最长上升子序列的长度 初始时设dp[i] = 0(i = 1, 2, ...)。 则有动态规划方程：dp[i] = max{dp[j] + 1} (j = 1, 2, ..., i - 1, 且A[j] &lt; A[i]) 贪心+二分构造一个有顺序的栈s 每次取栈顶元素top和读取到的元素a if top &lt; a s.push(a)else 用a替换栈中第一个比a大的数 最后栈中的元素的数量就是所求的数量(但是栈中元素可能并不是最长上升子序列) 举例：原序列为1，5，8，3，6，7 栈为1，5，8，此时读到3，则用3替换5，得到栈中元素为1，3，8， 再读6，用6替换8，得到1，3，6，再读7，得到最终栈为1，3，6，7 ，最长递增子序列为长度4。 模板 class LIS_stack &#123;private: static const int SIZE = maxn;//最大长度 int len;//长度 int Stack[SIZE];public: LIS_stack() &#123; len = 0; memset(Stack,0,sizeof(Stack)); &#125; void push(int num) &#123; if(len == 0 || Stack[len - 1] &lt; num) &#123; Stack[len++] = num; &#125; else &#123; for(int i = 0;i &lt; len;i++) &#123; if(Stack[i] &gt; num) &#123; Stack[i] = num; break; &#125; &#125; &#125; &#125; int lenth() &#123; return len; &#125;&#125;;int LIS(int *a,int len) &#123; LIS_stack s; for(int i = 0;i &lt; len;i++) s.push(a[i]); return s.lenth();&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"最长上升子序列","slug":"LIS","permalink":"https://www.oyohyee.com/tags/LIS/"},{"name":"二分","slug":"Division","permalink":"https://www.oyohyee.com/tags/Division/"}]},{"title":"背包问题","date":"2016-04-30T13:36:00.000Z","path":"/post/Algorithm/Package_Problem.html","text":"背包问题(Knapsack problem)是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。相似问题经常出现在商业、组合数学，计算复杂性理论、密码学和应用数学等领域中。也可以将背包问题描述为决定性问题，即在总重量不超过W的前提下，总价值是否能达到V？它是在1978年由Merkel和Hellman提出的。 百度百科——背包问题 在背包问题里，有很著名的《背包九讲》来帮助我们理解背包问题。 下载：《背包九讲》 &gt;更多的背包问题题目&lt; 01背包问题条件： 背包大小V 物品件数n(每个物体只有1个) 第i个物品的花费c[i] 第i个物品的价值w[i] 即在保证花费和不超过V的情况下，尽可能让价值最大(有的题目中花费就是价值) 用dp[i][j]表示前i个物品在最大体积为j的情况下的最大价值(所求答案为dp[n][V]) 对于第i个物品，我们可以选择“选”( dp[i-1][ j-c[i] ] + w[i] )或“不选”(dp[i-1][ j ]) 有dp[i][j] = max{ dp[i-1][j] , dp[i-1][j - c[i]] + w[i] } 当从i=1开始循环时，在计算dp[i][]时，dp[i-1][]已经计算过了，因此我们可以算出所有的值 同时，可以发现我们计算dp[i][j]之会用到dp[i-1][j]和dp[i-1][j-c[i]] 并且 j&gt;j-c[i] 如图，可以将二维数组降为一维数组，只要保证比当前计算的dp[i][j]的j小的还停留在“上一层”(i-1)即可 也即从后往前刷(逆序刷表) 并且可以知道可能更新的的最小的值为dp[i][c[i]] (当剩余空间比c[i]还小时，j-c[i]不在合法范围内) 因此，可以写出如下代码 void ZeroOnePack(int cost,int weight) &#123; for (int i = v; i &gt;= cost; i--) dp[i] = max(dp[i],dp[i - cost] + weight); &#125; 使用时只需从i=1到i=n进行一遍循环即可 for(int i=1;i &lt;= n;i++) ZeroOnePack(c[i],w[i]); 初始时要将dp[0][]初始化为0 完全背包问题条件： 背包大小V 物品件数n(每个物体有无数个) 第i个物品的花费c[i] 第i个物品的价值w[i] 即在保证花费和不超过V的情况下，尽可能让价值最大(有的题目中花费就是价值) 用dp[i][j]表示前i个物品在最大体积为j的情况下的最大价值(所求答案为dp[n][V]) 对于第i个物品，我们可以选择“不选”(dp[i-1][j]) 或 “选1个”( dp[i-1][ j-c[i] ] + w[i] ) 或 “选2个”( dp[i-1][ j- 2*c[i] ] + 2*w[i] ) …… 有dp[i][j] = max{ dp[i][j] , dp[i-1][j - k*c[i]] + k*w[i] } (0&lt;=k&lt;=∞ 当 j - k*c[i] &lt;= 0 时结束循环) 由于dp[i][j]已经是选出来的最大值了，在计算dp[i][j+cost[i]]时，只需比较dp[i][j]和dp[i-1][j+c[i]]+w[i] 也即dp[i][j]=max{ dp[i][j-c[i]]+w[i] , dp[i-1][j] } 可以看出来，我们计算dp[i][j]时，需要的是不大于j的i层的数据 因此，应该从前往后刷(正向刷表) void CompletePack(int cost,int weight) &#123; for (int i = cost; i &lt;= v; i++) dp[i] = max(dp[i],dp[i - cost] + weight); &#125; 同上，使用时只需循环1-n即可 for(int i=1;i &lt;= n;i++) ComplatePack(c[i],w[i]); 多重背包问题条件： 背包大小V 物品件数n(每个物体有无数个) 第i个物品的花费c[i] 第i个物品的价值w[i] 第i个物品的上限max[i] 即在保证花费和不超过V的情况下，尽可能让价值最大(有的题目中花费就是价值) 用dp[i][j]表示前i个物品在最大体积为j的情况下的最大价值(所求答案为dp[n][V]) 有dp[i][j] = max{ dp[i-1][ j - k * D[i] ] + k * D[i] , dp[i][j] } (0 &lt;= k &lt;= max[i]) 此时，时间复杂度为O(V*∑n[i]) 采用二进制分解可以优化到O(V*∑log n[i]) 对于数量为0-n的物品i，可以将其分割成多个组合。 使得所有组合加起来能够等于n，并且选取一定量的组合可以组成0-n的任意数 例如13可以分解成1、2、4、6 0=01=12=23=1+24=45=1+46=2+47=1+2+48=2+69=1+2+610=4+611=1+4+612=2+4+613=1+2+4+6 一个数可以分成两个数，两个数相加可以得到这个数 而这两个数还能继续分成两个数 …………如果分成的两个数相等，则可以再下次分割只分其中一个 这样在保证尽可能少分的情况下分到最深就是需要的计算方法 这样，对于一个最多有n个的物品，可以分成(近似)log(2)n个，然后对这些进行01背包求解 如果物品i的总体积大于背包体积，则不必再分割(在范围内没有上限可以看作无限)。 使用完全背包求解 void MultiplePack(int cost,int weight,int n) &#123; if (cost * n &gt; v) &#123; CompletePack(cost,weight); &#125; else &#123; int k = 1; while (k &lt; n) &#123; ZeroOnePack(cost * k,weight * k); n -= k; k *= 2; &#125; ZeroOnePack(cost * n,weight * n); &#125;&#125; 计算时需要 for(int i=1;i &lt;= n;i++) MultiplePack(c[i],w[i]，max[i]);","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"}]},{"title":"POJ 1276.Cash Machine","date":"2016-04-28T12:41:00.000Z","path":"/post/POJ/1276.html","text":"题目 Description A Bank plans to install a machine for cash withdrawal. The machine is able to deliver appropriate @ bills for a requested cash amount. The machine uses exactly N distinct bill denominations, say Dk, k=1,N, and for each denomination Dk the machine has a supply of nk bills. For example, N=3, n1=10, D1=100, n2=4, D2=50, n3=5, D3=10 means the machine has a supply of 10 bills of @100 each, 4 bills of @50 each, and 5 bills of @10 each. Call cash the requested amount of cash the machine should deliver and write a program that computes the maximum amount of cash less than or equal to cash that can be effectively delivered according to the available bill supply of the machine. Notes:@ is the symbol of the currency delivered by the machine. For instance, @ may stand for dollar, euro, pound etc. InputThe program input is from standard input. Each data set in the input stands for a particular transaction and has the format: cash N n1 D1 n2 D2 … nN DNwhere 0 &lt;= cash &lt;= 100000 is the amount of cash requested, 0 &lt;=N &lt;= 10 is the number of bill denominations and 0 &lt;= nk &lt;= 1000 is the number of available bills for the Dk denomination, 1 &lt;= Dk &lt;= 1000, k=1,N. White spaces can occur freely between the numbers in the input. The input data are &gt; correct. Output For each set of data the program prints the result to the standard output on a separate line as shown in the examples below. Sample Input 735 3 4 125 6 5 3 350633 4 500 30 6 100 1 5 0 1735 00 3 10 100 10 50 10 10 Sample Output 73563000 Hint The first data set designates a transaction where the amount of cash requested is @735. The machine contains 3 bill denominations: 4 bills of @125, 6 bills of @5, and 3 bills of @350. The machine can deliver the exact amount of requested cash. In the second case the bill supply of the machine does not fit the exact amount of cash requested. The maximum cash that can be delivered is @630. Notice that there can be several possibilities to combine the bills in the machine for matching the delivered cash. In the third case the machine is empty and no cash is delivered. In the fourth case the amount of cash requested is @0 and, therefore, the machine delivers no cash. 题解动态规划问题状态分析 &gt;背包问题&lt; cash - 背包容量D[i] - 物品的重量n[i] - 物品的数量上限(下限为0) 答案为 dp[N][cash] (使用前N个物品，背包容量为cash时的总重量) 按照第一组样例有 dp[3][735] = dp[2][735] + dp[2][385] + dp[2][35] + dp[2][-325]dp[2][735] = dp[1][735] + dp[1][730] + dp[1][725] + dp[1][720] + dp[1][715] + dp[1][710] + dp[1][705]dp[1][735] = dp[0][735] + dp[0][610] + dp[0][485] + dp[0][360] + dp[0][235]……dp[2][385] = dp[1][385] + dp[1][380] + dp[1][375] + dp[1][370] + dp[1][365] + dp[1][360] + dp[1][355]……dp[2][35] = dp[1][35] + dp[1][30] + dp[1][25] + dp[1][20] + dp[1][15] + dp[1][10] + dp[1][5]…… 也即 dp[i][j] = max(dp[i-1][j-k*D[i]] + k*D[i] , dp[i][j]) (0 &lt;= k &lt;= D[i]) 优化时间效率：对于多重背包问题，可以采取二进制分解来优化对于数量为0-n的物品i，可以将其分割成多个组合。使得所有组合加起来能够等于n，并且选取一定量的组合可以组成0-n的任意数 例如13可以分解成1、2、4、6 0=01=12=23=1+24=45=1+46=2+47=1+2+48=2+69=1+2+610=4+611=1+4+612=2+4+613=1+2+4+6 一个数可以分成两个数，两个数相加可以得到这个数而这两个数还能继续分成两个数…………如果分成的两个数相等，则可以再下次分割只分其中一个这样在保证尽可能少分的情况下分到最深就是需要的计算方法 这样，对于一个最多有n个的物品，可以分成(近似)log(2)n个，然后对这些进行01背包求解 如果物品i的总体积大于背包体积，则不必再分割(在范围内没有上限可以看作无限)。使用完全背包求解 因此可以将多重背包问题转化为完全背包问题和01背包问题由于对于每一层，之前的算法循环了n[i]次，新算法循环&lt;log n[i]次相当于O(V*∑n[i])优化到O(V*∑log n[i]) 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)/*状态分析背包问题cash - 背包容量D[i] - 物品的重量n[i] - 物品的数量上限(下限为0)答案为 dp[N][cash] (使用前N个物品，背包容量为cash时的总重量)按照第一组样例有dp[3][735] = dp[2][735] + dp[2][385] + dp[2][35] + dp[2][-325]dp[2][735] = dp[1][735] + dp[1][730] + dp[1][725] + dp[1][720] + dp[1][715] + dp[1][710] + dp[1][705]dp[1][735] = dp[0][735] + dp[0][610] + dp[0][485] + dp[0][360] + dp[0][235]……dp[2][385] = dp[1][385] + dp[1][380] + dp[1][375] + dp[1][370] + dp[1][365] + dp[1][360] + dp[1][355]……dp[2][35] = dp[1][35] + dp[1][30] + dp[1][25] + dp[1][20] + dp[1][15] + dp[1][10] + dp[1][5]……也即 dp[i][j] = max(dp[i-1][j-k*D[i]] + k*D[i] , dp[i][j]) (0 &lt;= k &lt;= D[i])优化时间效率：对于多重背包问题，可以采取二进制分解来优化对于数量为0-n的物品i，可以将其分割成多个组合。使得所有组合加起来能够等于n，并且选取一定量的组合可以组成0-n的任意数例如13可以分解成1、2、4、6 0=0 1=1 2=2 3=1+2 4=4 5=1+4 6=2+4 7=1+2+4 8=2+6 9=1+2+6 10=4+6 11=1+4+6 12=2+4+6 13=1+2+4+6 一个数可以分成两个数，两个数相加可以得到这个数 而这两个数还能继续分成两个数 ………… 如果分成的两个数相等，则可以再下次分割只分其中一个 这样在保证尽可能少分的情况下分到最深就是需要的计算方法 这样，对于一个最多有n个的物品，可以分成(近似)log(2)n个，然后对这些进行01背包求解 如果物品i的总体积大于背包体积，则不必再分割(在范围内没有上限可以看作无限)。 使用完全背包问题求解 因此可以将多重背包问题转化为完全背包问题和01背包问题 由于对于每一层，之前的算法循环了n[i]次，新算法循环&lt;log n[i]次 相当于O(V*∑n[i])优化到O(V*∑log n[i]) */const int maxn = 15;const int maxv = 100001;int cash,N;int n[maxn],D[maxn];int dp[maxv];int v;//0-1背包问题void ZeroOnePack(int cost,int weight) &#123; //printf(\" ZeroOnePack cost:%d weight:%d\\n\",cost,weight); for (int i = v; i &gt;= cost; i--) dp[i] = max(dp[i],dp[i - cost] + weight);&#125;//完全背包问题void CompletePack(int cost,int weight) &#123; //printf(\" ComplatePack cost:%d weight:%d\\n\",cost,weight); for (int i = cost; i &lt;= v; i++) dp[i] = max(dp[i],dp[i - cost] + weight);&#125;//多重背包问题void MultiplePack(int cost,int weight,int n) &#123; //printf(\"MultiplePack cost:%d weight:%d cnt:%d\\n\",cost,weight,n); if (cost * n &gt; v) &#123; CompletePack(cost,weight); &#125; else &#123; int k = 1; while (k &lt; n) &#123; ZeroOnePack(cost * k,weight * k); n -= k; k *= 2; &#125; ZeroOnePack(cost * n,weight * n); &#125;&#125;bool Do() &#123; if (scanf(\"%d%d\",&amp;cash,&amp;N) == EOF) return false; REP(N) scanf(\"%d%d\",&amp;n[o + 1],&amp;D[o + 1]); memset(dp,0,sizeof(dp)); v = cash; for (int i = 1; i &lt;= N; i++) MultiplePack(D[i],D[i],n[i]); printf(\"%d\\n\",dp[cash]); return true;&#125;int main() &#123; while (Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"背包问题","slug":"PackageProblem","permalink":"https://www.oyohyee.com/tags/PackageProblem/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"POJ 1837.Balance","date":"2016-04-25T16:24:00.000Z","path":"/post/POJ/1837.html","text":"题目 Description Gigel has a strange “balance” and he wants to poise it. Actually, the device is different from any other ordinary balance. It orders two arms of negligible weight and each arm’s length is 15. Some hooks are attached to these arms and Gigel wants to hang up some weights from his collection of G weights (1 &lt;= G &lt;= 20) knowing that these weights have distinct values in the range 1..25. Gigel may droop any weight of any hook but he is forced to use all the weights. Finally, Gigel managed to balance the device using the experience he gained at the National Olympiad in Informatics. Now he would like to know in how many ways the device can be balanced. Knowing the repartition of the hooks and the set of the weights write a program that calculates the number of possibilities to balance the device. It is guaranteed that will exist at least one solution for each test case at the evaluation. InputThe input has the following structure: • the first line contains the number C (2 &lt;= C &lt;= 20) and the number G (2 &lt;= G &lt;= 20);• the next line contains C integer numbers (these numbers are also distinct and sorted in ascending order) in the range -15..15 representing the repartition of the hooks; each number represents the position relative to the center of the balance on the X axis (when no weights are attached the device is balanced and lined up to the X axis; the absolute value of the distances represents the distance between the hook and the balance center and the sign of the numbers determines the arm of the balance to which the hook is attached: ‘-‘ for the left arm and ‘+’ for the right arm); • on the next line there are G natural, distinct and sorted in ascending order numbers in the range 1..25 representing the weights’ values. Output The output contains the number M representing the number of possibilities to poise the balance. Sample Input 2 4 -2 3 3 4 5 8 Sample Output 2 题解动态规划问题 状态分析 采用动态规划，可以看出有一维是使用前i个砝码最后一层的意义是：将第i个砝码加入到天平系统中，使天平达到平衡则每一层的意义是：将第i个砝码加入到天平系统中，使天平达到特定的状态对于天平来说，平衡状态可以用力矩表示 i为使用的砝码个数 j为力矩答案应该为dp[G][0],即使用G个砝码(全部用完)，并且力矩为0(保持平衡) 初始状态为dp[0][0]=1(使用前0个砝码时保持平衡，即不放置砝码平衡) 按照样例有： dp[4][0]=dp[3][16]+dp[3][-24] dp[3][16]=dp[2][26]+dp[2][1] dp[2][26]=dp[1][34]+dp[1][13] dp[1][13]=dp[0][19]+dp[0][4] dp[1][34]=dp[0][40]+dp[0][25] dp[2][1]=dp[1][9]+dp[1][-11] dp[1][9]=dp[0][15]+dp[0][0] dp[1][-11]=dp[0][-5]+dp[0][-20] dp[3][-24]=dp[2][-14]+dp[2][-39] dp[2][-14]=dp[1][-6]+dp[1][-28] dp[1][-6]=dp[0][0]+dp[0][-15] dp[1][-28]=dp[0][-22]+dp[0][-37] dp[2][-39]=dp[1][-31]+dp[1][-51] dp[1][-31]=dp[0][-25]+dp[0][-40] dp[1][-51]=dp[0][-45]+dp[0][-60] dp[i][j]=dp[i-1][j-weight[i]*hook[0]]+dp[i-1][j-weight[i]*hook[1]]+......即 使用i个砝码且力矩为j 等于 使用i-1个砝码且力矩为(j减去砝码i可能的力矩) 也即dp[i][j]+=dp[i-1][j-weight[i]*hook[k]] k=0,1......k-1 由于下标不能为负数，因此要将力矩变为正数钩子在-15~+15之间 砝码最多20个，每个最终25 即力矩最大为 15*20*25=7500 原力矩范围为 -7500~0~7500加上7500后有 0~7500~15000 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)int C,G;//C钩子数 G砝码数const int maxn = 25;int hook[maxn];//hook钩子位置int weight[maxn];//weight砝码重量int dp[maxn][15005];bool Do() &#123; if(scanf(\"%d%d\",&amp;C,&amp;G) == EOF) return false; REP(C) scanf(\"%d\",&amp;hook[o+1]); REP(G) scanf(\"%d\",&amp;weight[o+1]); //DP /* 状态分析 采用动态规划，可以看出有一维是使用前i个砝码 最后一层的意义是：将第i个砝码加入到天平系统中，使天平达到平衡 则每一层的意义是：将第i个砝码加入到天平系统中，使天平达到特定的状态 对于天平来说，平衡状态可以用力矩表示 i为使用的砝码个数 j为力矩 答案应该为dp[G][0],即使用G个砝码(全部用完)，并且力矩为0(保持平衡) 初始状态为dp[0][0]=1(使用前0个砝码时保持平衡，即不放置砝码平衡) 按照样例有： dp[4][0]=dp[3][16]+dp[3][-24] dp[3][16]=dp[2][26]+dp[2][1] dp[2][26]=dp[1][34]+dp[1][13] dp[1][13]=dp[0][19]+dp[0][4] dp[1][34]=dp[0][40]+dp[0][25] dp[2][1]=dp[1][9]+dp[1][-11] dp[1][9]=dp[0][15]+dp[0][0] dp[1][-11]=dp[0][-5]+dp[0][-20] dp[3][-24]=dp[2][-14]+dp[2][-39] dp[2][-14]=dp[1][-6]+dp[1][-28] dp[1][-6]=dp[0][0]+dp[0][-15] dp[1][-28]=dp[0][-22]+dp[0][-37] dp[2][-39]=dp[1][-31]+dp[1][-51] dp[1][-31]=dp[0][-25]+dp[0][-40] dp[1][-51]=dp[0][-45]+dp[0][-60] dp[i][j]=dp[i-1][j-weight[i]*hook[0]]+dp[i-1][j-weight[i]*hook[1]]+...... 即 使用i个砝码且力矩为j 等于 使用i-1个砝码且力矩为(j减去砝码i可能的力矩) 也即dp[i][j]+=dp[i-1][j-weight[i]*hook[k]] k=0,1......k-1 由于下标不能为负数，因此要将力矩变为正数 钩子在-15~+15之间 砝码最多20个，每个最终25 即力矩最大为 15*20*25=7500 原力矩范围为 -7500~0~7500 加上7500后有 0~7500~15000 */ memset(dp,0,sizeof(dp)); dp[0][0+7500] = 1; for(int i = 1;i &lt;= G;i++) for(int j = 1;j &lt;= 15000;j++) for(int k = 1;k &lt;= C;k++) if(j - weight[i] * hook[k] &gt;= 0 &amp;&amp; j-weight[i]*hook[k]&lt;=15000) dp[i][j] += dp[i - 1][j - weight[i] * hook[k]]; printf(\"%d\\n\",dp[G][7500]); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"BFS专题","date":"2016-04-24T16:11:00.000Z","path":"/post/Project/BFS.html","text":"BFS(宽度优先遍历 或 广度优先遍历)是一种从起点开始，逐层向外拓展的算法。 采用队列或优先队列来保证逐层的特性。 当第一次访问到终点时，即得到最短路径 &gt;简单的BFS算法&lt; &gt;更多的BFS题解&lt; BFS专题： OJ编号 题目名称 题目题解 HDU 1548 A strange lift HDU 1548.A strange lift HDU 1372 Knight Moves HDU 1372.Knight Moves HDU 2717 Catch That Cow HDU 2717.Catch That Cow POJ 1324 Holedox Moving &nbsp; HDU 1026 Ignatius and the Princess I HDU 1026.Ignatius and the Princess I HDU 1072 Nightmare HDU 1072.Nightmare HDU 1073 Online Judge &nbsp; HDU 1175 连连看 HDU 1175.连连看 HDU 1180 诡异的楼梯 HDU 1180.诡异的楼梯 HDU 1242 Rescue HDU 1242.Rescue HDU 1728 逃离迷宫 HDU 1728.逃离迷宫 HDU 2579 Dating with girls(2) HDU 2579.Dating with girls(2) HDU 2102 A计划 HDU 2102.A计划 HDU 1253 胜利大逃亡 HDU 1253.胜利大逃亡 HDU 1240 Asteroids! HDU 1240.Asteroids! HDU 1429 胜利大逃亡(续) HDU 1429.胜利大逃亡(续) HDU 1254 推箱子 &nbsp; HDU 2612 Find a way HDU 2612.Find a way HDU 1983 Kaitou Kid - The Phantom Thief (2) &nbsp; HDU 1195 Open the Lock HDU 1195.Open the Lock HDU 2128 Tempter of the Bone II &nbsp;","tags":[{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"}]},{"title":"HDU 1195.Open the Lock","date":"2016-04-24T14:35:00.000Z","path":"/post/HDU/1195.html","text":"题目 Description Now an emergent task for you is to open a password lock. The password is consisted of four digits. Each digit is numbered from 1 to 9.Each time, you can add or minus 1 to any digit. When add 1 to ‘9’, the digit will change to be ‘1’ and when minus 1 to ‘1’, the digit will change to be ‘9’. You can also exchange the digit with its neighbor. Each action will take one step. Now your task is to use minimal steps to open the lock. Note: The leftmost digit is not the neighbor of the rightmost digit. Input The input file begins with an integer T, indicating the number of test cases. Each test case begins with a four digit N, indicating the initial state of the password lock. Then followed a line with anotther four dight M, indicating the password which can open the lock. There is one blank line after each test case. Output For each test case, print the minimal steps in one line. Sample Input 212342144 11119999 Sample Output 24 题解变相的BFS，交换的次数为层数3 遍历所有交换的可能，计算每种可能下，距离答案的“距离” 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)int del(int a,int b) &#123; int cnt = 0; while (a) &#123; int t1 = (a % 10); int t2 = (b % 10); cnt += abs(t1-t2)&gt;4?(9 - abs(t1 - t2)): abs(t1 - t2); a /= 10; b /= 10; &#125; return cnt;&#125;int Swap(int s,int a,int b) &#123; int t[4] = &#123;0&#125;; for (int i = 3;i &gt;= 0;i--) &#123; t[i] = s % 10; s /= 10; &#125; swap(t[a],t[b]); return t[0] * 1000 + t[1] * 100 + t[2] * 10 + t[3];&#125;int BFS(int s,int v) &#123; int Min = del(s,v); bool visited[9999]; memset(visited,false,sizeof(visited)); queue&lt;pair&lt;int,int&gt; &gt; Q; Q.push(pair&lt;int,int&gt;(s,0)); visited[s] = true; while (!Q.empty()) &#123; int k = Q.front().first; int n = Q.front().second; Q.pop(); for (int i = 0;i &lt; 3;i++) &#123; int kk = Swap(k,i,i + 1); int nn = n + 1; if (visited[kk]) continue; visited[kk] = true; Min = min(nn + del(kk,v),Min); //printf(\" %d %d+%d=%d\\n\",kk,nn,del(kk,v),nn + del(kk,v)); Q.push(pair&lt;int,int&gt;(kk,nn)); &#125; &#125; return Min;&#125;bool Do() &#123; int s,v; scanf(\"%d%d\",&amp;s,&amp;v); printf(\"%d\\n\",BFS(s,v)); return true;&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while (T--) Do(); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"}]},{"title":"HDU 2612.Find a way","date":"2016-04-24T13:15:00.000Z","path":"/post/HDU/2612.html","text":"题目 Description Pass a year learning in Hangzhou, yifenfei arrival hometown Ningbo at finally. Leave Ningbo one year, yifenfei have many people to meet. Especially a good friend Merceki.Yifenfei’s home is at the countryside, but Merceki’s home is in the center of city. So yifenfei made arrangements with Merceki to meet at a KFC. There are many KFC in Ningbo, they want to choose one that let the total time to it be most smallest.Now give you a Ningbo map, Both yifenfei and Merceki can move up, down ,left, right to the adjacent road by cost 11 minutes. Input The input contains multiple test cases.Each test case include, first two integers n, m. (2&lt;=n,m&lt;=200).Next n lines, each line included m character.‘Y’ express yifenfei initial position.‘M’ express Merceki initial position.‘#’ forbid road;‘.’ Road.‘@’ KCF Output For each test case output the minimum total time that both yifenfei and Merceki to arrival one of KFC.You may sure there is always have a KFC that can let them meet. Sample Input 4 4Y.#@…..#..@..M4 4Y.#@…..#..@#.M5 5Y..@..#….#…@..M.#…# Sample Output 668866 题解有两个起点的BFS，每个KFS是一个出口，分别计算出每个出口距离两个入口的距离，计算其最小值 要特别注意：KFC有可能不能到达 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 205;int n,m;char Map[maxn][maxn];const int delta[] = &#123;1,-1,0,0&#125;;struct point &#123; int x,y; point() &#123; x = y = -1; &#125; point(int a,int b) &#123; x = a; y = b; &#125;&#125;;int num;int BFS(point s,int (&amp;dis)[maxn][maxn]) &#123; memset(dis,-1,sizeof(dis)); queue&lt;point&gt; Q; Q.push(s); dis[s.x][s.y] = 0; while (!Q.empty()) &#123; int x = Q.front().x; int y = Q.front().y; Q.pop(); REP(4) &#123; int xx = x + delta[o]; int yy = y + delta[3 - o]; if (xx &lt; 0 || xx &gt;= n || yy &lt; 0 || yy &gt;= m) continue; if (Map[xx][yy] == '#') continue; if (dis[xx][yy] == -1) &#123; dis[xx][yy] = dis[x][y] + 1; Q.push(point(xx,yy)); &#125; &#125; &#125; return -1;&#125;bool Do() &#123; if (scanf(\"%d%d\",&amp;n,&amp;m) == EOF) return false; point s1,s2; num = 0; point v[maxn*maxn]; for (int i = 0;i &lt; n;i++) for (int j = 0;j &lt; m;j++) &#123; scanf(\"\\n%c\",&amp;Map[i][j]); if (Map[i][j] == 'Y') s1 = point(i,j); if (Map[i][j] == 'M') s2 = point(i,j); if (Map[i][j] == '@') v[num++] = point(i,j); &#125; int dis1[maxn][maxn]; int dis2[maxn][maxn]; BFS(s1,dis1); BFS(s2,dis2); int Min = 100000; for (int i = 0;i &lt; num;i++) if(dis1[v[i].x][v[i].y]!=-1&amp;&amp; dis2[v[i].x][v[i].y]!=-1) Min = min(Min,dis1[v[i].x][v[i].y]+ dis2[v[i].x][v[i].y]); printf(\"%d\\n\",Min * 11); return true;&#125;int main() &#123; while (Do()); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"}]},{"title":"HDU 1240.Asteroids!","date":"2016-04-24T12:37:00.000Z","path":"/post/HDU/1240.html","text":"题目 Description You’re in space.You want to get home.There are asteroids.You don’t want to hit them. Input Input to this problem will consist of a (non-empty) series of up to 100 data sets. Each data set will be formatted according to the following description, and there will be no blank lines separating data sets. A single data set has 5 components: Start line - A single line, “START N”, where 1 &lt;= N &lt;= 10. Slice list - A series of N slices. Each slice is an N x N matrix representing a horizontal slice through the asteroid field. Each position in the matrix will be one of two values: ‘O’ - (the letter “oh”) Empty space ‘X’ - (upper-case) Asteroid present Starting Position - A single line, “A B C”, denoting the &lt;A,B,C&gt; coordinates of your craft’s starting position. The coordinate values will be integers separated by individual spaces. Target Position - A single line, “D E F”, denoting the &lt;D,E,F&gt; coordinates of your target’s position. The coordinate values will be integers separated by individual spaces. End line - A single line, “END” The origin of the coordinate system is &lt;0,0,0&gt;. Therefore, each component of each coordinate vector will be an integer between 0 and N-1, inclusive. The first coordinate in a set indicates the column. Left column = 0. The second coordinate in a set indicates the row. Top row = 0. The third coordinate in a set indicates the slice. First slice = 0. Both the Starting Position and the Target Position will be in empty space. Output For each data set, there will be exactly one output set, and there will be no blank lines separating output sets. A single output set consists of a single line. If a route exists, the line will be in the format “X Y”, where X is the same as N from the corresponding input data set and Y is the least number of moves necessary to get your ship from the starting position to the target position. If there is no &gt; &gt; route from the starting position to the target position, the line will be “NO ROUTE” instead. A move can only be in one of the six basic directions: up, down, left, right, forward, back. Phrased more precisely, a move will either increment or decrement a single component of your current position vector by 1. Sample Input START 1O0 0 00 0 0ENDSTART 3XXXXXXXXXOOOOOOOOOXXXXXXXXX0 0 12 2 1ENDSTART 5OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOXXXXXXXXXXXXXXXXXXXXXXXXXOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO0 0 04 4 4END Sample Output 1 03 4NO ROUTE 题解三维空间中的BFS 难点不在于算法……在于读入（我觉得） 由于前面有START 后面有END 因此直接读入会产生问题 因此换用了自己写的函数来读入数据 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 11;int n;int dis[maxn][maxn][maxn];char Map[maxn][maxn][maxn];const int delta[6][3] = &#123;&#123;1,0,0&#125;,&#123;-1,0,0&#125;,&#123;0,1,0&#125;,&#123;0,-1,0&#125;,&#123;0,0,1&#125;,&#123;0,0,-1&#125;&#125;;struct point &#123; int x,y,z; point() &#123; x = y = z = -1; &#125; point(int a,int b,int c) &#123; x = a; y = b; z = c; &#125; bool operator == (const point &amp;rhs)const &#123; return ((x == rhs.x) &amp;&amp; (y == rhs.y) &amp;&amp; (z == rhs.z)); &#125;&#125;;inline int read_int() &#123; char c; int ans = 0; while (c = getchar(),!(c &gt;= '0' &amp;&amp; c &lt;= '9')); while (c &gt;= '0'&amp;&amp;c &lt;= '9') &#123; ans *= 10; ans += (int)c - '0'; c = getchar(); &#125; return ans;&#125;int BFS(point s,point v) &#123; if (s == v) return 0; memset(dis,-1,sizeof(dis)); queue&lt;point&gt; Q; Q.push(s); dis[s.x][s.y][s.z] = 0; while (!Q.empty()) &#123; int x = Q.front().x; int y = Q.front().y; int z = Q.front().z; Q.pop(); REP(6) &#123; int xx = x + delta[o][0]; int yy = y + delta[o][1]; int zz = z + delta[o][2]; //非法路径 if (xx &lt; 0 || xx &gt;= n || yy &lt; 0 || yy &gt;= n || zz &lt; 0 || zz &gt;= n) continue; //墙 if (Map[xx][yy][zz] == 'X') continue; //尚未访问过 if (dis[xx][yy][zz] == -1) &#123; dis[xx][yy][zz] = dis[x][y][z] + 1; //到达终点 if (point(xx,yy,zz) == v) return dis[xx][yy][zz]; Q.push(point(xx,yy,zz)); &#125; &#125; &#125; return -1;&#125;bool Do() &#123; char c; if (scanf(\"\\n%c\",&amp;c) == EOF) return false; n = read_int(); //printf(\" (%d) \\n\",n); for (int k = 0;k &lt; n;k++)//块 for (int i = 0;i &lt; n;i++)//行 scanf(\"%s\",Map[k][i]); int s1,s2,s3,v1,v2,v3; s1 = read_int(); s2 = read_int(); s3 = read_int(); v1 = read_int(); v2 = read_int(); v3 = read_int(); //scanf(\"%d%d%d\",&amp;s1,&amp;s2,&amp;s3); //scanf(\"%d%d%d\",&amp;v1,&amp;v2,&amp;v3); point s = point(s3,s1,s2); point v = point(v3,v1,v2); int ans = BFS(s,v); if (ans == -1) printf(\"NO ROUTE\\n\"); else printf(\"%d %d\\n\",n,ans); scanf(\"%*s\"); return true;&#125;int main() &#123; while (Do()); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"}]},{"title":"HDU 1429.胜利大逃亡(续)","date":"2016-04-22T17:42:00.000Z","path":"/post/HDU/1429.html","text":"题目 Description Ignatius再次被魔王抓走了(搞不懂他咋这么讨魔王喜欢)…… 这次魔王汲取了上次的教训，把Ignatius关在一个n*m的地牢里，并在地牢的某些地方安装了带锁的门，钥匙藏在地牢另外的某些地方。刚开始Ignatius被关在(sx,sy)的位置，离开地牢的门在(ex,ey)的位置。Ignatius每分钟只能从一个坐标走到相邻四个坐标中的其中一个。魔王每t分钟回地牢视察一次，若发现Ignatius不在原位置便把他拎回去。经过若干次的尝试,Ignatius已画出整个地牢的地图。现在请你帮他计算能否再次成功逃亡。只要在魔王下次视察之前走到出口就算离开地牢，如果魔王回来的时候刚好走到出口或还未到出口都算逃亡失败。 Input 每组测试数据的第一行有三个整数n,m,t(2&lt;=n,m&lt;=20,t&gt;0)。接下来的n行m列为地牢的地图，其中包括: . 代表路* 代表墙@ 代表Ignatius的起始位置^ 代表地牢的出口A-J 代表带锁的门,对应的钥匙分别为a-ja-j 代表钥匙，对应的门分别为A-J 每组测试数据之间有一个空行。 Output 针对每组测试数据，如果可以成功逃亡，请输出需要多少分钟才能离开，如果不能则输出-1。 Sample Input 4 5 17@A.B.a*.*.*..*^c..b* 4 5 16@A.B.a*.*.*..*^c..b* Sample Output 16-1 题解总觉得上面背景里的意思和样例不一样…… 这种错觉导致的问题就是，理解错了题意 最初理解的是：在t时间后传送回初始位置，但是不会死，而是继续寻路(可以在t时间内拿到钥匙，开t时间距离的门，即使钥匙距离大于t/2) 在这个错误的思路下，写出了一个错误的答案，不知道能不能“AC” 不过也算一种相似题型的思路吧 不好好看样例的下场/* HDU 1429.胜利大逃亡(续) 的错误理解 理解为：t时间后强行传送到起点(不结束，还能继续走)*//*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 25;char Map[maxn][maxn];int dis[maxn][maxn];int n,m,t;typedef pair&lt;int,int&gt; point;const int delta[] = &#123;1,-1,0,0&#125;;int BFS(int s1,int s2,int v1,int v2) &#123; queue&lt;point&gt; Q,door; memset(dis,-1,sizeof(dis)); bool key[10]; memset(key,false,sizeof(key)); Q.push(point(s1,s2)); dis[s1][s2] = 0; while(!Q.empty() || !door.empty()) &#123; if(!Q.empty()) &#123; int x = Q.front().first; int y = Q.front().second; Q.pop(); REP(4) &#123; int xx = x + delta[o]; int yy = y + delta[3 - o]; //非法访问 if(xx &lt; 0 || xx &gt;= n || yy &lt; 0 || yy &gt;= m) continue; //墙 if(Map[xx][yy] == '*') continue; //钥匙 if(Map[xx][yy] &gt;= 'a' &amp;&amp; Map[xx][yy] &lt;= 'j') key[Map[xx][yy] - 'a'] = true; //门 if(Map[xx][yy] &gt;= 'A' &amp;&amp; Map[xx][yy] &lt;= 'J') if(!key[Map[xx][yy] - 'A']) door.push(point(xx,yy)); //更新节点 int temp = dis[xx][yy]; dis[xx][yy] = (dis[xx][yy] == -1 ? dis[x][y] + 1 : min(dis[x][y] + 1,dis[xx][yy])); //剪枝：如果已超过时间，就不再考虑 if(dis[xx][yy] &gt;= t) continue; if(temp != dis[xx][yy]) Q.push(point(xx,yy)); &#125; &#125; else &#123; int size = door.size(); bool flag = false; while(size--) &#123; int x = door.front().first; int y = door.front().second; door.pop(); if(key[Map[x][y] - 'A']) &#123; Q.push(point(x,y)); flag = true; break; &#125; door.push(point(x,y)); &#125; if(flag) continue; else break; &#125; &#125; return dis[v1][v2];&#125;bool Do() &#123; if(scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;t) == EOF) return false; int s1,s2,v1,v2; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) &#123; scanf(\"\\n%c\\n\",&amp;Map[i][j]); if(Map[i][j] == '@') &#123; s1 = i; s2 = j; &#125; if(Map[i][j] == '^') &#123; v1 = i; v2 = j; &#125; &#125; printf(\"%d\\n\",BFS(s1,s2,v1,v2)); return true;&#125;int main() &#123; while(Do()); return 0;&#125; 换回正确思路，我们发现，需要保存有哪些钥匙 对于a-j 10把钥匙，我们共有1024种可能 因此，我们可以采用二进制来记录钥匙的集合 //返回新的钥匙集合 //参数：原始的钥匙集合 获得的钥匙的编号inline int get_key(int key,int num) &#123; return key | (1 &lt;&lt; num);&#125;//返回是否存在门的钥匙//参数：钥匙集合 门的编号inline bool has_key(int key,int num) &#123; return (key &amp; (1 &lt;&lt; num)) &gt; 0;&#125; 然后看成3维空间的BFS，层数代表钥匙的集合 由于可能有1024层，因此要即时剪枝 (觉得会有更好的算法来解决吧，整个三维数组开出来有640000，略大) 另外，晚上真的不适合做题…… 删错行，把if当成while找bug…… 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 25;char Map[maxn][maxn];int dis[maxn][maxn][1024];int n,m,t;const int delta[] = &#123;1,-1,0,0&#125;;struct point &#123; int x,y; int key; point(int a,int b,int c) &#123; x = a; y = b; key = c; &#125;&#125;;//返回新的钥匙集合 //参数：原始的钥匙集合 获得的钥匙的编号inline int get_key(int key,int num) &#123; return key | (1 &lt;&lt; num);&#125;//返回是否存在门的钥匙//参数：钥匙集合 门的编号inline bool has_key(int key,int num) &#123; return (key &amp; (1 &lt;&lt; num)) &gt; 0;&#125;int BFS(int s1,int s2,int v1,int v2) &#123; int Min = -1; queue&lt;point&gt; Q; memset(dis,-1,sizeof(dis)); Q.push(point(s1,s2,0)); dis[s1][s2][0] = 0; while(!Q.empty()) &#123; int x = Q.front().x; int y = Q.front().y; int key = Q.front().key; Q.pop(); REP(4) &#123; int xx = x + delta[o]; int yy = y + delta[3 - o]; int kk = key; //非法访问 if(xx &lt; 0 || xx &gt;= n || yy &lt; 0 || yy &gt;= m) continue; //墙 if(Map[xx][yy] == '*') continue; //钥匙 if(Map[xx][yy] &gt;= 'a' &amp;&amp; Map[xx][yy] &lt;= 'j') kk = get_key(kk,Map[xx][yy] - 'a'); //门 if(Map[xx][yy] &gt;= 'A' &amp;&amp; Map[xx][yy] &lt;= 'J') if(!has_key(kk,Map[xx][yy] - 'A')) continue; //更新节点 if(dis[xx][yy][kk] == -1) &#123; dis[xx][yy][kk] = dis[x][y][key] + 1; //剪枝：如果已超过时间，就不再考虑 if(dis[xx][yy][kk] &gt;= t) continue; if(xx == v1 &amp;&amp; yy == v2) &#123; Min = ((Min == -1) ? dis[xx][yy][kk] : min(Min,dis[xx][yy][kk])); continue; &#125; Q.push(point(xx,yy,kk)); &#125; &#125; &#125; return Min;&#125;bool Do() &#123; if(scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;t) == EOF) return false; int s1,s2,v1,v2; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) &#123; scanf(\"\\n%c\",&amp;Map[i][j]); if(Map[i][j] == '@') &#123; s1 = i; s2 = j; &#125; if(Map[i][j] == '^') &#123; v1 = i; v2 = j; &#125; &#125; printf(\"%d\\n\",BFS(s1,s2,v1,v2)); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"}]},{"title":"HDU 1253.胜利大逃亡","date":"2016-04-22T07:54:00.000Z","path":"/post/HDU/1253.html","text":"题目 Problem Description Ignatius被魔王抓走了,有一天魔王出差去了,这可是Ignatius逃亡的好机会. 魔王住在一个城堡里,城堡是一个ABC的立方体,可以被表示成A个B*C的矩阵,刚开始Ignatius被关在(0,0,0)的位置,离开城堡的门在(A-1,B-1,C-1)的位置,现在知道魔王将在T分钟后回到城堡,Ignatius每分钟能从一个坐标走到相邻的六个坐标中的其中一个.现在给你城堡的地图,请你计算出Ignatius能否在魔王回来前离开城堡(只要走到出口就算离开城堡,如果走到出口的时候魔王刚好回来也算逃亡成功),如果可以请输出需要多少分钟才能离开,如果不能则输出-1. Input 输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1&lt;=A,B,C&lt;=50,1&lt;=T&lt;=1000),它们分别代表城堡的大小和魔王回来的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块……),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙.(如果对输入描述不清楚,可以参考Sample Input中的迷宫描述,它表示的就是上图中的迷宫) 特别注意:本题的测试数据非常大,请使用scanf输入,我不能保证使用cin能不超时.在本OJ上请使用Visual C++提交. Output 对于每组测试数据,如果Ignatius能够在魔王回来前离开城堡,那么请输出他最少需要多少分钟,否则输出-1. Sample Input 13 3 4 200 1 1 10 0 1 10 1 1 11 1 1 11 0 0 10 1 1 10 0 0 00 1 1 00 1 1 0 Sample Output 11 题解题目是三维的BFS，思路上比较明确，类似BFS从一维拓展成二维，将BFS从二维拓展成三维即可 不过该题数据量较大，需要进行各种优化 当达到时间限制后，就不必再进行BFS了，应该直接输出-1 当找到答案后，就不必进行BFS了，应该直接输出答案 不过第一次尽管这样处理还是TLE，于是又优化了下读入 int read_int() &#123; char c; int ans = 0; while(c = getchar(),!(c &gt;= '0' &amp;&amp; c &lt;= '9')); while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ans *= 10; ans += (int)c - '0'; c = getchar(); &#125; return ans;&#125; 不过第一次写的有点小问题，导致WA。 看了下问题出在优化输入上，修改了下后AC 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 55;int a,b,c;int t;int dis[maxn][maxn][maxn];int Map[maxn][maxn][maxn];const int delta[6][3] = &#123;&#123;1,0,0&#125;,&#123;-1,0,0&#125;,&#123;0,1,0&#125;,&#123;0,-1,0&#125;,&#123;0,0,1&#125;,&#123;0,0,-1&#125;&#125;;struct point &#123; int x,y,z; point() &#123; x = y = z = -1; &#125; point(int a,int b,int c) &#123; x = a; y = b; z = c; &#125;&#125;;//优化输入int read_int() &#123; char c; int ans = 0; while(c = getchar(),!(c &gt;= '0' &amp;&amp; c &lt;= '9')); while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; ans *= 10; ans += (int)c - '0'; c = getchar(); &#125; return ans;&#125;int BFS(point s,point v) &#123; memset(dis,-1,sizeof(dis)); queue&lt;point&gt; Q; Q.push(s); dis[s.x][s.y][s.z] = 0; while(!Q.empty()) &#123; int x = Q.front().x; int y = Q.front().y; int z = Q.front().z; Q.pop(); //时间已到 if(dis[x][y][z] &gt;= t) return -1; REP(6) &#123; int xx = x + delta[o][0]; int yy = y + delta[o][1]; int zz = z + delta[o][2]; //非法路径 if(xx &lt; 0 || xx &gt;= a || yy &lt; 0 || yy &gt;= b || zz &lt; 0 || zz &gt;= c) continue; //墙 if(Map[xx][yy][zz] == 1) continue; //尚未访问过 if(dis[xx][yy][zz] == -1) &#123; dis[xx][yy][zz] = dis[x][y][z] + 1; //到达终点 if(xx == v.x &amp;&amp; yy == v.y &amp;&amp; zz == v.z) return dis[xx][yy][zz]; Q.push(point(xx,yy,zz)); &#125; &#125; &#125; return -1;&#125;void Do() &#123; //scanf(\"%d%d%d%d\",&amp;a,&amp;b,&amp;c,&amp;t); a = read_int(); b = read_int(); c = read_int(); t = read_int(); for(int k = 0;k &lt; a;k++)//块 for(int i = 0;i &lt; b;i++)//行 for(int j = 0;j &lt; c;j++)//列 //scanf(\"\\n%c\\n\",&amp;Map[k][i][j]); Map[k][i][j] = read_int(); if debug for(int k = 0;k &lt; a;k++) &#123; for(int i = 0;i &lt; b;i++) &#123; for(int j = 0;j &lt; c;j++) printf(\"%d\",Map[k][i][j]); printf(\"\\n\"); &#125; printf(\"\\n\"); &#125; endif if(a*b*c == 1) printf(\"0\\n\"); else printf(\"%d\\n\",BFS(point(0,0,0),point(a - 1,b - 1,c - 1)));&#125;int main() &#123; int T; T = read_int(); //scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"}]},{"title":"HDU 2102.A计划","date":"2016-04-21T07:23:00.000Z","path":"/post/HDU/2102.html","text":"题目 Description 可怜的公主在一次次被魔王掳走一次次被骑士们救回来之后，而今，不幸的她再一次面临生命的考验。魔王已经发出消息说将在T时刻吃掉公主，因为他听信谣言说吃公主的肉也能长生不老。年迈的国王正是心急如焚，告招天下勇士来拯救公主。不过公主早已习以为常，她深信智勇的骑士LJ肯定能将她救出。现据密探所报，公主被关在一个两层的迷宫里，迷宫的入口是S（0，0，0），公主的位置用P表示，时空传输机用#表示，墙用*表示，平地用.表示。骑士们一进入时空传输机就会被转到另一层的相对位置，但如果被转到的位置是墙的话，那骑士们就会被撞死。骑士们在一层中只能前后左右移动，每移动一格花1时刻。层间的移动只能通过时空传输机，且不需要任何时间。 Input 输入的第一行C表示共有C个测试数据，每个测试数据的前一行有三个整数N，M，T。 N，M迷宫的大小N*M（1 &lt;= N,M &lt;=10)。T如上所意。接下去的前N*M表示迷宫的第一层的布置情况，后N*M表示迷宫第二层的布置情况。 Output 如果骑士们能够在T时刻能找到公主就输出“YES”，否则输出“NO”。 Sample Input 15 5 14S*#*..#……..****.…#. ..*.P.*..***..…*.*.#.. Sample Output YES 题解三维的BFS，开成三维数组进行BFS即可 在超时后及时返回 直接套用模板 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 15;int n,m,k;int dis[maxn][maxn][2];char Map[maxn][maxn][2];const int delta[] = &#123;1,-1,0,0&#125;;struct point &#123; int x,y,z; point() &#123; x = y = z = -1; &#125; point(int a,int b,int c) &#123; x = a; y = b; z = c; &#125; bool operator == (const point &amp;rhs)const &#123; return (x == rhs.x &amp;&amp; y == rhs.y &amp;&amp; z == rhs.z); &#125;&#125;;bool BFS(point s,point v,int t) &#123; memset(dis,-1,sizeof(dis)); queue&lt;point&gt; Q; Q.push(s); dis[s.x][s.y][s.z] = 0; while(!Q.empty()) &#123; int x = Q.front().x; int y = Q.front().y; int z = Q.front().z; Q.pop(); if(dis[x][y][z] &gt;= t) return false; REP(4) &#123; int xx = x + delta[o]; int yy = y + delta[3 - o]; int zz = z; if(xx &lt; 0 || xx &gt;= n || yy &lt; 0 || yy &gt;= m) continue; if(Map[xx][yy][zz] == '#') zz = !zz; if(Map[xx][yy][zz] == '*' || Map[xx][yy][zz] == '#') continue; if(dis[xx][yy][zz] == -1) &#123; dis[xx][yy][zz] = dis[x][y][z] + 1; if(point(xx,yy,zz) == v) return true; Q.push(point(xx,yy,zz)); &#125; &#125; &#125; return false;&#125;void Do() &#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); point s,v; for(int k = 0;k &lt; 2;k++) for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) &#123; scanf(\"\\n%c\\n\",&amp;Map[i][j][k]); if(Map[i][j][k] == 'S') s = point(i,j,k); if(Map[i][j][k] == 'P') v = point(i,j,k); &#125; if debug for(int k = 0;k &lt; 2;k++) &#123; for(int i = 0;i &lt; n;i++) &#123; for(int j = 0;j &lt; m;j++) printf(\"%c\",Map[i][j][k]); printf(\"\\n\"); &#125; printf(\"\\n\"); &#125; endif printf(\"%s\\n\",BFS(s,v,k) ? \"YES\" : \"NO\");&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"}]},{"title":"HDU 2579.Dating with girls(2)","date":"2016-04-21T06:33:00.000Z","path":"/post/HDU/2579.html","text":"题目 Problem Description If you have solved the problem Dating with girls(1).I think you can solve this problem too.This problem is also about dating with girls. Now you are in a maze and the girl you want to date with is also in the maze.If you can find the girl, then you can date with the girl.Else the girl will date with other boys. What a pity!The Maze is very strange. There are many stones in the maze. The stone will disappear at time t if t is a multiple of k(2&lt;= k &lt;= 10), on the other time , stones will be still there.There are only ‘.’ or ‘#’, ’Y’, ’G’ on the map of the maze. ’.’ indicates the blank which you can move on, ‘#’ indicates stones. ’Y’ indicates the your location. ‘G’ indicates the girl’s location . There is only one ‘Y’ and one ‘G’. Every seconds you can move left, right, up or down. Input The first line contain an integer T. Then T cases followed. Each case begins with three integers r and c (1 &lt;= r , c &lt;= 100), and k(2 &lt;=k &lt;= 10).The next r line is the map’s description. Output For each cases, if you can find the girl, output the least time in seconds, else output “Please give me another chance!”. Sample Input 16 6 2…Y..…#...#….…#..…#....#G#. Sample Output 7 题解由于在不同时间，墙有存在和不存在两种情况。 因此，在判重时，也要考虑到时间。只需考虑time%k即可 其他部分就是正常的BFS问题 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 105;const int maxk = 15;int n,m,k;int dis[maxn][maxn][maxk];char Map[maxn][maxn];const int delta[] = &#123;1,-1,0,0&#125;;struct point &#123; int x,y; int dis; point(int a,int b,int c) &#123; x = a; y = b; dis = c; &#125;&#125;;int BFS(int s1,int s2,int v1,int v2) &#123; memset(dis,-1,sizeof(dis)); queue&lt;point&gt; Q; Q.push(point(s1,s2,0)); dis[s1][s2][0] = 0; while(!Q.empty()) &#123; int x = Q.front().x; int y = Q.front().y; int dist = Q.front().dis; Q.pop(); REP(4) &#123; int xx = x + delta[o]; int yy = y + delta[3 - o]; if(xx &lt; 0 || xx &gt;= n || yy &lt; 0 || yy &gt;= m) continue; if(Map[xx][yy] != '#' || (Map[xx][yy] == '#' &amp;&amp; (dist+1) % k == 0)) &#123; int dd = dist + 1; if(dis[xx][yy][dd%k] == -1) &#123; dis[xx][yy][dd%k] = dd; if(xx == v1 &amp;&amp; yy == v2) return dd; Q.push(point(xx,yy,dd)); &#125; &#125; &#125; &#125; return -1;&#125;void Do() &#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); int s1,s2,v1,v2; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) &#123; scanf(\"\\n%c\\n\",&amp;Map[i][j]); if(Map[i][j] == 'Y') &#123; s1 = i; s2 = j; &#125; if(Map[i][j] == 'G') &#123; v1 = i; v2 = j; &#125; &#125; int ans = BFS(s1,s2,v1,v2); if(ans == -1) printf(\"Please give me another chance!\\n\"); else printf(\"%d\\n\",ans);&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"}]},{"title":"HDU 1782.逃离迷宫","date":"2016-04-21T03:04:00.000Z","path":"/post/HDU/1782.html","text":"题目 Description 给定一个m × n (m行, n列)的迷宫，迷宫中有两个位置，gloria想从迷宫的一个位置走到另外一个位置，当然迷宫中有些地方是空地，gloria可以穿越，有些地方是障碍，她必须绕行，从迷宫的一个位置，只能走到与它相邻的4个位置中,当然在行走过程中，gloria不能走到迷宫外面去。令人头痛的是，gloria是个没什么方向感的人，因此，她在行走过程中，不能转太多弯了，否则她会晕倒的。我们假定给定的两个位置都是空地，初始时，gloria所面向的方向未定，她可以选择4个方向的任何一个出发，而不算成一次转弯。gloria能从一个位置走到另外一个位置吗？ Input 第1行为一个整数t (1 ≤ t ≤ 100),表示测试数据的个数，接下来为t组测试数据，每组测试数据中， 第1行为两个整数m, n (1 ≤ m, n ≤ 100),分别表示迷宫的行数和列数，接下来m行，每行包括n个字符，其中字符’.’表示该位置为空地，字符’*’表示该位置为障碍，输入数据中只有这两种字符，每组测试数据的最后一行为5个整数k, x1, y1, x2, y2 (1 ≤ k ≤ 10, 1 ≤ x1, x2 ≤ n, 1 ≤ y1, y2 ≤ m),其中k表示gloria最多能转的弯数，(x1, y1), (x2, &gt; y2)表示两个位置，其中x1，x2对应列，y1, y2对应行。 Output 每组测试数据对应为一行，若gloria能从一个位置走到另外一个位置，输出“yes”，否则输出“no”。 Sample Input 25 5…*..…..…..*….1 1 1 1 35 5…***.**.…..…..*….2 1 1 1 3 Sample Output noyes 题解BFS不记录距离，记录转的弯数 套用BFS模板即可 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 105;int n,m;char Map[maxn][maxn];int dis[maxn][maxn];typedef pair&lt;int,int&gt; point;const int delta[] = &#123;1,-1,0,0&#125;;bool BFS(int s1,int s2,int v1,int v2,int k) &#123; if(k &lt; 0) return false; if(s1 == v1 &amp;&amp; s2 == v2) return true; memset(dis,-1,sizeof(dis)); queue&lt;point&gt; Q; Q.push(point(s1,s2)); dis[s1][s2] = 0; while(!Q.empty()) &#123; int x = Q.front().first; int y = Q.front().second; Q.pop(); if(dis[x][y] == k+1) return false; REP(4) &#123; int xx,yy; for(int i = 1;;i++) &#123; xx = x + delta[o] * i; yy = y + delta[3 - o] * i; if(xx &lt; 0 || xx &gt; n || yy &lt; 0 || yy &gt; m || Map[xx][yy] == '*') break; if(dis[xx][yy] == -1) &#123; dis[xx][yy] = dis[x][y] + 1; if(xx == v1 &amp;&amp; yy == v2) return true; Q.push(point(xx,yy)); &#125; &#125; &#125; &#125; return false;&#125;void Do() &#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) scanf(\"\\n%c\\n\",&amp;Map[i][j]); int s1,s2,v1,v2,k; scanf(\"%d%d%d%d%d\",&amp;k,&amp;s2,&amp;s1,&amp;v2,&amp;v1); printf(\"%s\\n\",BFS(s1 - 1,s2 - 1,v1 - 1,v2 - 1,k) ? \"yes\" : \"no\");&#125;int main() &#123; int T; scanf(\"%d\",&amp;T); while(T--) Do(); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"}]},{"title":"HDU 1242.Rescue","date":"2016-04-20T16:14:00.000Z","path":"/post/HDU/1242.html","text":"题目 Description Angel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M &lt;= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison. Angel’s friends want to save Angel. Their task is: approach Angel. We assume that “approach Angel” is to get to the position where Angel stays. When there’s a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up, down, right, left takes us 1 unit time, &gt; and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards. You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.) InputFirst line contains two integers stand for N and M. Then N lines follows, every line has M characters. “.” stands for road, “a” stands for Angel, and “r” stands for each of Angel’s friend. Process to the end of the file. Output For each test case, your program should output a single integer, standing for the minimal time needed. If such a number does no exist, you should output a line containing “Poor ANGEL has to stay in the prison all his life.” Sample Input 7 8#.#####.#.a#..r.#..#x…..#..#.##…##...#………….. Sample Output 13 题解根据friend和friends，我们可以推知angel有多个朋友 也就是说，这是一个有一个入口多个出口的迷宫 从angel所在位置开始BFS，队列使用优先队列，确保按照距离层数访问节点 (第一次交蜜汁RE) 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 250;int n,m;char Map[maxn][maxn];int s1,s2;int dis[maxn][maxn];const int delta[] = &#123;1,-1,0,0&#125;;struct point &#123; int x,y; int dis; point(int a,int b,int c) &#123; x = a; y = b; dis = c; &#125; bool operator &lt; (const point &amp;rhs)const &#123; return dis&gt;rhs.dis; &#125;&#125;;int BFS() &#123; priority_queue&lt;point&gt; Q; memset(dis,-1,sizeof(dis)); Q.push(point(s1,s2,0)); dis[s1][s2] = 0; while(!Q.empty()) &#123; int x = Q.top().x; int y = Q.top().y; int dist = Q.top().dis; Q.pop(); REP(4) &#123; int xx = x + delta[o]; int yy = y + delta[3 - o]; int dd = dist + 1; if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy&gt;=0 &amp;&amp; yy &lt; m) &#123; if(Map[xx][yy] != '#' &amp;&amp; dis[xx][yy] == -1) &#123; if(Map[xx][yy] == 'x') dd++; if(Map[xx][yy] == 'r') return dd; dis[xx][yy] = dd; Q.push(point(xx,yy,dd)); &#125; &#125; &#125; &#125; return -1;&#125;bool Do() &#123; if(scanf(\"%d%d\",&amp;n,&amp;m) == EOF) return false; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) &#123; scanf(\"\\n%c\\n\",&amp;Map[i][j]); if(Map[i][j] == 'a') &#123; s1 = i; s2 = j; &#125; &#125; int ans = BFS(); if(ans == -1) printf(\"Poor ANGEL has to stay in the prison all his life.\\n\"); else printf(\"%d\\n\",ans); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"}]},{"title":"HDU 1026.Ignatius and the Princess I","date":"2016-04-19T13:05:00.000Z","path":"/post/HDU/1026.html","text":"题目 DescriptionThe Princess has been abducted by the BEelzebub feng5166, our hero Ignatius has to rescue our pretty Princess. Now he gets into feng5166’s castle. The castle is a large labyrinth. To make the problem simply, we assume the labyrinth is a N*M two-dimensional array which left-top corner is (0,0) and &gt; &gt; right-bottom corner is (N-1,M-1). Ignatius enters at (0,0), and the door to feng5166’s room is at (N-1,M-1), that is our target. There are some monsters in the castle, if Ignatius meet them, he has to kill them. Here is some rules: 1.Ignatius can only move in four directions(up, down, left, right), one step per second. A step is defined as follow: if current position is (x,y), after a step, Ignatius can only stand on (x-1,y), (x+1,y), (x,y-1) or (x,y+1).2.The array is marked with some characters and numbers. We define them like this:. : The place where Ignatius can walk on.X : The place is a trap, Ignatius should not walk on it.n : Here is a monster with n HP(1&lt;=n&lt;=9), if Ignatius walk on it, it takes him n seconds to kill the monster. Your task is to give out the path which costs minimum seconds for Ignatius to reach target position. You may assume that the start position and the target position will never be a trap, and there will never be a monster at the start position. Input The input contains several test cases. Each test case starts with a line contains two numbers N and M(2=N&lt;=100,2&lt;=M&lt;=100) which indicate the size of the labyrinth. Then a N*M two-dimensional array follows, which describe the whole labyrinth. The input is terminated by the end of file. More details in the Sample Input. Output For each test case, you should output “God please help our poor hero.” if Ignatius can’t reach the target position, or you should output “It takes n seconds to reach the target position, let me show you the way.”(n is the minimum seconds), and tell our hero the whole path. Output a line contains “FINISH” after each test case. If there are more than one path, any one is OK in this problem. More details in the Sample Output. Sample Input 5 6.XX.1...X.2.2…X.…XX.XXXXX.5 6.XX.1...X.2.2…X.…XX.XXXXX15 6.XX…..XX1.2…X.…XX.XXXXX. Sample Output It takes 13 seconds to reach the target position, let me show you the way.1s:(0,0)-&gt;(1,0)2s:(1,0)-&gt;(1,1)3s:(1,1)-&gt;(2,1)4s:(2,1)-&gt;(2,2)5s:(2,2)-&gt;(2,3)6s:(2,3)-&gt;(1,3)7s:(1,3)-&gt;(1,4)8s:FIGHT AT (1,4)9s:FIGHT AT (1,4)10s:(1,4)-&gt;(1,5)11s:(1,5)-&gt;(2,5)12s:(2,5)-&gt;(3,5)13s:(3,5)-&gt;(4,5)FINISHIt takes 14 seconds to reach the target position, let me show you the way.1s:(0,0)-&gt;(1,0)2s:(1,0)-&gt;(1,1)3s:(1,1)-&gt;(2,1)4s:(2,1)-&gt;(2,2)5s:(2,2)-&gt;(2,3)6s:(2,3)-&gt;(1,3)7s:(1,3)-&gt;(1,4)8s:FIGHT AT (1,4)9s:FIGHT AT (1,4)10s:(1,4)-&gt;(1,5)11s:(1,5)-&gt;(2,5)12s:(2,5)-&gt;(3,5)13s:(3,5)-&gt;(4,5)14s:FIGHT AT (4,5)FINISHGod please help our poor hero.FINISH 题解这道题牵扯到了权值 因此，不能单纯地使用BFS 在牵扯权值时，我们要不断走最短的路，使用dijkstra算法 以怪物的HP+1(移动耗时+战斗耗时)为权值(没有怪物权值为1) 由于最后要输出路径， 因此每次进行松弛操作(更新距离)要记录下最短的路径 最后输出需要正序输出，因此可使用栈 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 155;int N,M;char Map[maxn][maxn];pair&lt;int,int&gt; last[maxn][maxn];int dis[maxn][maxn];struct point &#123; int x,y; int dis; point(int a,int b,int c) &#123; x = a; y = b; dis = c; &#125; bool operator &lt; (const point &amp;rhs)const &#123; return dis &gt; rhs.dis; &#125;&#125;;const int delta[] = &#123;1,-1,0,0&#125;;int BFS() &#123; priority_queue&lt;point&gt; Q; bool visited[maxn][maxn]; memset(visited,false,sizeof(visited)); memset(dis,-1,sizeof(dis)); Q.push(point(0,0,0)); dis[0][0] = 0; while (!Q.empty()) &#123; int th1 = Q.top().x; int th2 = Q.top().y; int thdis = Q.top().dis; Q.pop(); if (visited[th1][th2] == true) continue; visited[th1][th2] = true; //达到终点 //if (th1 == N - 1 &amp;&amp; th2 == M - 1) // return dis[N - 1][M - 1]; //拓展节点 REP(4) &#123; int next1 = th1 + delta[o]; int next2 = th2 + delta[3 - o]; if (Map[next1][next2] != 'X' &amp;&amp; next1 &gt;= 0 &amp;&amp; next1 &lt; N &amp;&amp; next2 &gt;= 0 &amp;&amp; next2 &lt; M) &#123; int weight; if (Map[next1][next2] == '.') weight = 1; else weight = Map[next1][next2] - '0' + 1; int temp = dis[next1][next2]; dis[next1][next2] = dis[next1][next2] == -1 ? dis[th1][th2] + weight : min(dis[th1][th2] + weight,dis[next1][next2]); if (temp != dis[next1][next2]) &#123;//记录路径 last[next1][next2] = pair&lt;int,int&gt;(th1,th2); //printf(\"%d %d -&gt; %d %d\\n\", th1, th2, next1, next2); &#125; Q.push(point(next1,next2,dis[next1][next2])); &#125; &#125; &#125; if (dis[N - 1][M - 1]) return dis[N - 1][M - 1]; else return -1;&#125;bool Do() &#123; if (scanf(\"%d%d\",&amp;N,&amp;M) == EOF) return false; for (int i = 0; i &lt; N; i++) for (int j = 0; j &lt; M; j++) scanf(\"\\n%c\\n\",&amp;Map[i][j]); /* for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) printf(\"%c\", Map[i][j]); printf(\"\\n\"); &#125; */ if (BFS() == -1) &#123; printf(\"God please help our poor hero.\\nFINISH\\n\"); &#125; else &#123; printf(\"It takes %d seconds to reach the target position, let me show you the way.\\n\",dis[N - 1][M - 1] ); stack&lt;pair&lt;int,int&gt; &gt; s; int x = N - 1,y = M - 1; while (!(x == 0 &amp;&amp; y == 0)) &#123; //printf(\"s %d %d\\n\", x, y); s.push(pair&lt;int,int&gt;(x,y)); pair&lt;int,int&gt; t = last[x][y]; x = t.first; y = t.second; &#125; //s.pop(); //s.push(point(0, 0)); REP(dis[N - 1][M - 1]) &#123; printf(\"%ds:\",o + 1); x = s.top().first; y = s.top().second; s.pop(); printf(\"(%d,%d)-&gt;(%d,%d)\\n\",last[x][y].first,last[x][y].second,x,y); if (Map[x][y] &gt;= '0'&amp;&amp;Map[x][y] &lt;= '9') &#123; int wait = Map[x][y] - '0'; for (o++; wait; wait--,o++) printf(\"%ds:FIGHT AT (%d,%d)\\n\",o + 1,x,y); o--; &#125; &#125; printf(\"FINISH\\n\"); &#125; return true;&#125;int main() &#123; while (Do()); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"https://www.oyohyee.com/tags/Dijkstra/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"}]},{"title":"HDU 1180.诡异的楼梯","date":"2016-04-19T12:32:00.000Z","path":"/post/HDU/1180.html","text":"题目 Problem Description Hogwarts正式开学以后,Harry发现在Hogwarts里,某些楼梯并不是静止不动的，相反,他们每隔一分钟就变动一次方向.比如下面的例子里,一开始楼梯在竖直方向,一分钟以后它移动到了水平方向,再过一分钟它又回到了竖直方向.Harry发现对他来说很难找到能使得他最快到达目的地的路线,这时Ron(Harry最好的朋友)告诉Harry正好有一个魔法道具可以帮助他寻找这样的路线,而那个魔法道具上的咒语,正是由你纂写的. Input 测试数据有多组，每组的表述如下：第一行有两个数,M和N,接下来是一个M行N列的地图,’*’表示障碍物,’.’表示走廊,’|’或者’-‘表示一个楼梯,并且标明了它在一开始时所处的位置:’|’表示的楼梯在最开始是竖直方向,’-‘表示的楼梯在一开始是水平方向.地图中还有一个’S’是起点,’T’是目标,0&lt;=M,N&lt;=20,地图中不会出现两个相连的梯子.Harry每秒只能停留在’.’或’S’和’T’所标记的格子内. Output 只有一行,包含一个数T,表示到达目标的最短时间.注意:Harry只能每次走到相邻的格子而不能斜走,每移动一次恰好为一分钟,并且Harry登上楼梯并经过楼梯到达对面的整个过程只需要一分钟,Harry从来不在楼梯上停留.并且每次楼梯都恰好在Harry移动完毕以后才改变方向. Sample Input 5 5**..T**.*...|...*.*.S…. Sample Output 7 ## Hint 地图如下 题解猛一看，这道题思路非常清晰，二维矩阵中进行BFS，根据时间来判断梯子的走向。然而交了好多次都没AC开始是由于直接复制BFS的模板，结果忘记改maxn导致超时（竟然不是RE）后来就是莫名其妙的WA再看一遍题，可以发现一个很关键的地方题目中没有说如果路径不存在则输出-1也就是说，不管怎么样一定存在路径 那么我们仔细想下，类似 S|T 这样的迷宫显然是没有路径的，如果通过绕路的方式，可以发现在回到该位置后，梯子的方向不变。那么，真相只有一个：可以原地等待一步 明白了这点，稍加修改就可以得到符合题意得算法 另外有一点需要注意：由于等待改变了BFS层数的先后顺序(等待的层数额外加1)，这回破坏BFS天然的顺序因此，要采用优先队列来存储 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 30;int n,m;char Map[maxn][maxn];#if debugpair&lt;int,int&gt; last[maxn][maxn];#endifconst int delta[4] = &#123;1,-1,0,0&#125;;struct point &#123; int x,y; int dis;//楼梯是否已变化 point(int a,int b,int c) &#123; x = a; y = b; dis = c; &#125; bool operator &lt; (const point &amp;rhs) const &#123; return dis&gt;rhs.dis; &#125;&#125;;int BFS(int s1,int s2,int v1,int v2) &#123; priority_queue&lt;point&gt; Q; int dis[maxn][maxn]; memset(dis,-1,sizeof(dis)); Q.push(point(s1,s2,false)); dis[s1][s2] = 0; while (!Q.empty()) &#123; point temp = Q.top(); Q.pop(); int x = temp.x; int y = temp.y; int dist = temp.dis; REP(4) &#123; int xx = x + delta[o]; int yy = y + delta[3 - o]; int dd = dist + 1; if (xx &lt; 0 || xx &gt;= m || yy &lt; 0 || yy &gt;= n || Map[xx][yy] == '*') continue; if (Map[xx][yy] == '-' || Map[xx][yy] == '|') &#123;//是梯子 if (x == xx) &#123;//水平方向移动 //需要等待一步 if ((Map[xx][yy] == '-' &amp;&amp; dist % 2 == 1) || (Map[xx][yy] == '|' &amp;&amp; dist % 2 != 1)) dd++; yy += yy - y; &#125; else &#123;//竖直方向移动 //需要等待一步 if ((Map[xx][yy] == '|' &amp;&amp; dist % 2 == 1) || (Map[xx][yy] == '-' &amp;&amp; dist % 2 != 1)) dd++; xx += xx - x; &#125; &#125; if (xx &lt; 0 || xx &gt;= m || yy &lt; 0 || yy &gt;= n || Map[xx][yy] != '.') continue; if (dis[xx][yy] == -1) &#123; dis[xx][yy] = dd;#if debug last[xx][yy] = pair&lt;int,int&gt;(x,y);#endif if (xx == v1 &amp;&amp; yy == v2) break; Q.push(point(xx,yy,dd)); &#125; &#125; &#125;#if debug pair&lt;int,int&gt; w; w = pair&lt;int,int&gt;(v1,v2); while (!(w.first == s1 &amp;&amp; w.second == s2)) &#123; printf(\"%d %d\\n\",w.first,w.second); w = last[w.first][w.second]; &#125;#endif return dis[v1][v2];&#125;bool Do() &#123; int s1,v1; int s2,v2; if (scanf(\"%d%d\\n\",&amp;m,&amp;n) == EOF) return false; for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) &#123; scanf(\"\\n%c\\n\",&amp;Map[i][j]); if (Map[i][j] == 'S') &#123; s1 = i; s2 = j; Map[i][j] = '.'; &#125; if (Map[i][j] == 'T') &#123; v1 = i; v2 = j; Map[i][j] = '.'; &#125; &#125;#if debug for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) printf(\"%c\",Map[i][j]); printf(\"\\n\"); &#125;#endif printf(\"%d\\n\",BFS(s1,s2,v1,v2)); return true;&#125;int main() &#123; while (Do()); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"}]},{"title":"HDU 1175.连连看","date":"2016-04-16T16:58:00.000Z","path":"/post/HDU/1175.html","text":"题目 Description 有一种新的游戏，游戏规则如下：在棋盘中，存在一些棋子。如果某两个棋子，可以通过一条线连起来（这条线不能经过其它棋子），而且线的转折次数不超过两次，那么这两个棋子就可以在棋盘上消去。注意：连线不能从外面绕过去的。给出当前棋盘的情况，试判断某些棋子能不能消去。现在你的任务就是写这个后台程序。呵呵，这个跟“连连看”很像。 Input输入数据有多组。每组数据的第一行有两个正整数n,m(0&lt;n&lt;=1000,0&lt;m&lt;1000)，分别表示棋盘的行数与列数。在接下来的n行中，每行有m个非负整数描述棋盘的方格分布。0表示这个位置没有棋子，正整数表示棋子的类型。接下来的一行是一个正整数q(0&lt;q&lt;50)，表示下面有q次询问。在接下来的q行里，每行有四个正整数x1, y1, x2, y2,表示询问第x1行y1列的棋子与第&gt; &gt; x2行y2列的棋子能不能消去。n=0,m= 0时，输入结束。注意：询问之间无先后关系，都是针对当前状态的！ Output 每一组输入数据对应一行输出。如果能消去则输出”YES”, 不能则输出”NO”。 Sample Input 3 41 2 3 40 0 0 04 3 2 141 1 3 41 1 2 41 1 3 32 1 2 43 40 1 4 30 2 4 10 0 0 021 1 2 41 3 2 30 0 Sample Output YESNONONONOYES 题解连连看游戏的后台实现 根据我们接触到的练练看游戏，可以确定一下规则： 要点击两个不同的位置 点击的两个位置应该是合法位置 点击的两个位置应该对应的是相应的棋子，并且不能有空白格 棋子间路径只能通过空白格，并且最多只能转过两个拐角 如同正常的BFS一样，只是每次拓展路径要拓展一条直线，记录下到该点转过的拐角，拓展3层(两个拐角) 判断目标点是否能到达即可 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 1005;int m,n;int Map[maxn][maxn];int dis[maxn][maxn];typedef pair&lt;int,int&gt; point;int BFS(int s1,int s2,int v1,int v2) &#123; define con1(nn) (nn&lt;=0||nn&gt;n) define con2(mm) (mm&lt;=0||mm&gt;m) //位置错误 if(con1(s1) || con1(v1) || con2(s2) || con2(v2)) return -1; //同一位置 if(s1 == v1 &amp;&amp; s2 == v2) return -1; //棋子不同 或 无棋子 if(Map[s1][s2] != Map[v1][v2] || Map[s1][s2]==0) return -1; queue&lt;point&gt; Q; memset(dis,-1,sizeof(dis)); Q.push(point(s1,s2)); dis[s1][s2] = 0; while(!Q.empty()) &#123; int th1 = Q.front().first; int th2 = Q.front().second; Q.pop(); //达到终点 if(th1 == v1 &amp;&amp; th2 == v2) break; //拓展节点 define condition \\ (next1 &gt; 0 &amp;&amp; next1 &lt;= n &amp;&amp; next2 &gt; 0 &amp;&amp; next2 &lt;= m \\ &amp;&amp; (Map[next1][next2] == 0||(next1==v1 &amp;&amp; next2==v2))) define push \\ if(dis[next1][next2]==-1 &amp;&amp; dis[th1][th2]&lt;=2) &#123;\\ Q.push(point(next1,next2));\\ dis[next1][next2] = dis[th1][th2] + 1;\\ &#125;\\ int next1,next2; for(next1 = th1,next2 = th2 + 1;condition;next2++) &#123; push; &#125; for(next1 = th1 + 1,next2 = th2;condition;next1++) &#123; push; &#125; for(next1 = th1,next2 = th2 - 1;condition;next2--) &#123; push; &#125; for(next1 = th1 - 1,next2 = th2;condition;next1--) &#123; push; &#125; &#125; return dis[v1][v2];&#125;bool Do() &#123; if(scanf(\"%d%d\",&amp;n,&amp;m),n == 0 &amp;&amp; m == 0) return false; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) scanf(\"%d\",&amp;Map[i][j]); int T; scanf(\"%d\",&amp;T); while(T--) &#123; int s1,s2,v1,v2; scanf(\"%d%d%d%d\",&amp;s1,&amp;s2,&amp;v1,&amp;v2); printf(\"%s\\n\",BFS(s1,s2,v1,v2)==-1?\"NO\":\"YES\"); &#125; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"}]},{"title":"HDU 5650.so easy","date":"2016-04-16T16:42:00.000Z","path":"/post/HDU/5650.html","text":"题目Description Given an array withnnintegers, assume f(S)f(S) as the result of executing xor operation among all the elements of set SS. e.g. if S={1,2,3}S={1,2,3} then f(S)=0f(S)=0. your task is: calculate xor of all f(s)f(s), here s⊆Ss⊆S. InputThis problem has multi test cases. First line contains a single integer T(T≤20)T(T≤20) which represents the number of test cases.For each test case, the first line contains a single integer number n(1≤n≤1,000)n(1≤n≤1,000) that represents the size of the given set. then the following line consists of nn different integer numbers indicate elements(≤109≤109) of the given set. Output For each test case, print a single integer as the answer. Sample Input 1 3 1 2 3 Sample Output 0 Hint In the sample，S={1,2,3}S={1,2,3}, subsets of SS are: ∅∅, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3} 题解非常简单的一道题，但是理解题意得难度要大于做出来…… 其题意就是要求出集合{S}的所有子集{s}元素异或的异或 同一个数自己对自己异或为0 0对任何书异或都是该数本身 a^b^a=b 同时，异或操作满足交换律的结合律 因此，只要一个元素出现偶数次，就可以不再考虑该数 可以发现，除非只有一个元素，否则每个元素在最后总的计算中必定出现偶数次，因此，当n=0时，答案为该数本身，否则，答案为0 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 10000;int n, m;int Map[maxn][maxn];void Do() &#123; int n; scanf(\"%d\", &amp;n); int temp, ans; if (n==1) &#123; REP(n) &#123; if (o == 0) scanf(\"%d\", &amp;ans); else scanf(\"%*d\", &amp;temp); &#125; &#125; else &#123; REP(n) scanf(\"%*d\"); ans = 0; &#125; printf(\"%d\\n\", ans);&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; Do(); &#125; return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"位运算","slug":"Bit","permalink":"https://www.oyohyee.com/tags/Bit/"}]},{"title":"HDU 5642.King's Order","date":"2016-04-16T16:37:00.000Z","path":"/post/HDU/5642.html","text":"题目 DescriptionAfter the king’s speech , everyone is encouraged. But the war is not over. The king needs to give orders from time to time. But sometimes he can not speak things well. So in his order there are some ones like this: “Let the group-p-p three come to me”. As you can see letter ‘p’ repeats for 3 times. &gt; &gt; Poor king! Now , it is war time , because of the spies from enemies , sometimes it is pretty hard for the general to tell which orders come from the king. But fortunately the general know how the king speaks: the king never repeats a letter for more than 3 times continually .And only this kind of order is &gt; &gt; legal. For example , the order: “Let the group-p-p-p three come to me” can never come from the king. While the order:” Let the group-p three come to me” is a legal statement. The general wants to know how many legal orders that has the length of n To make it simple , only lower case English Letters can appear in king’s order , and please output the answer modulo 10000000071000000007 We regard two strings are the same if and only if each charactor is the same place of these two strings are the same. InputThe first line contains a number T(T≤10)T(T≤10)――The number of the testcases. For each testcase, the first line and the only line contains a positive number n(n≤2000)n(n≤2000). Output For each testcase, print a single number as the answer. Sample Input 224 Sample Output 676456950 hint: All the order that has length 2 are legal. So the answer is 26*26. For the order that has length 4. The illegal order are : “aaaa” , “bbbb”……..”zzzz” 26 orders in total. So the answer for n == 4 is 26^4-26 = 456950 题解排列问题，计算26个字母，最多有3个连续的情况个数 将字符所在的层数(其后还有多少个字符)和字符已经连续了多少次，看作状态条件 可以发现每种状态存在关联，而且不相互影响 将每条分支乘上去，加起来即是所求的答案 可以发现其中有重读的计算(如(2,1)) 因此，可以采用动态规划的记忆化搜索 n为层数 m为连续数目dp[n][m]=dp[n-1][m+1]+dp[n-1][m]*25 dp[n-1][m+1]代表选择和上一位一样的 dp[n-1][m]代表选择和上一位不一样的 其边界条件就是n=0和m=4 由于达到边界时，应该返回1，因此应该让dp[0][m!=1]来返回1，dp[0][1]返回0(会乘上25) 如果m=4时，要返回0，说明不能再往下走 由于数据较大，因此需要mod 1000000007 而且在10层左右时，就需要开始取余数，而我们可能要算到2000层因此，每一次更新值都需要进行取余操作 (a+b) mod c = ((a mod c) + (b mod c)) mod c(a*b) mod c = ((a mod c) * (b mod c)) mod c 根据该定理，可以将更新操作写成 (dp[n][m] = (DP(n - 1, m + 1) % mod) + ((25 * (DP(n - 1, 1) % mod)) % mod)) % mod; 最后在输入n后，26*dp[n][1]就是我们需要的答案 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int mod = 1000000007;const int maxn = 2005;typedef unsigned long long LL;LL dp[maxn][5];//n层数 m连续数目LL DP(int n, int m) &#123; if (n == 0) &#123; if (m == 1) return 0; else return 1; &#125; if (m == 4) return 0; if (dp[n][m] == 0) &#123; //(a+b) mod c = ((a mod c) + (b mod c)) mod c //(a*b) mod c = ((a mod c) * (b mod c)) mod c return (dp[n][m] = (DP(n - 1, m + 1) % mod) + ((25 * (DP(n - 1, 1) % mod)) % mod)) % mod; &#125; else &#123; return dp[n][m]; &#125;&#125;void Do() &#123; int n; scanf(\"%d\", &amp;n); LL ans = (DP(n, 1) % mod) * 26; printf(\"%llu\\n\", ans % mod); return;&#125;int main() &#123; memset(dp, 0, sizeof(dp)); int T; scanf(\"%d\", &amp;T); while (T--) &#123; Do(); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"记忆化搜索","slug":"Memory-Search","permalink":"https://www.oyohyee.com/tags/Memory-Search/"}]},{"title":"POJ 1306.Combinations","date":"2016-04-16T16:20:00.000Z","path":"/post/POJ/1306.html","text":"题目 Description Computing the exact number of ways that N things can be taken M at a time can be a great challenge when N and/or M become very large. Challenges are the stuff of contests. Therefore, you are to make just such a computation given the following:GIVEN: 5 &lt;= N &lt;= 100; 5 &lt;= M &lt;= 100; M &lt;= NCompute the EXACT value of: C = N! / (N-M)!M!You may assume that the final value of C will fit in a 32-bit Pascal LongInt or a C long. For the record, the exact value of 100! is:93,326,215,443,944,152,681,699,238,856,266,700,490,715,968,264,381,621, 468,592,963,895,217,599,993,229,915,608,941,463,976,156,518,286,253, 697,920,827,223,758,251,185,210,916,864,000,000,000,000,000,000,000,000 Input The input to this program will be one or more lines each containing zero or more leading spaces, a value for N, one or more spaces, and a value for M. The last line of the input file will contain a dummy N, M pair with both values equal to zero. Your program should terminate when this line is read. Output The output from this program should be in the form:N things taken M at a time is C exactly. Sample Input 100 620 518 60 0 Sample Output 100 things taken 6 at a time is 1192052400 exactly.20 things taken 5 at a time is 15504 exactly.18 things taken 6 at a time is 18564 exactly. 题解题目题意比较简单 计算N!/(N-M)!M!关键在于数值的计算上尽管最后结果我们或许可以保存下，但是其中间要乘到很大的数再除下去，因此要尽可能让中间数小 由于N&gt;M，我们可以剩下很大一部分乘法，只需计算N*(N-1)*······*(M+2)*(M+1) 因此，比较下M和N-M，选择其中较大的与N！约分 然后在计算另一部分，分母和分子同时乘数，每乘一次进行一次约分(gcd) 这样就能在不溢出的情况下计算出我们想要的答案 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)unsigned long long gcd(unsigned long long a, unsigned long long b) &#123; return b == 0 ? a : gcd(b, a%b);&#125;bool Do() &#123; int n, m; if (scanf(\"%d%d\", &amp;n, &amp;m), n == 0 &amp;&amp; m == 0) return false; unsigned long long ans = 1; int a = max(m, n - m); int b = min(m, n - m); unsigned long long t = 1; for (int i = n, j = 2; i &gt; a; i--, j++) &#123; ans *= i; if (j &lt;= b || t &gt; 1) &#123; if (j &lt;= b) t *= j; if (t &gt; 1) &#123; unsigned long long q = gcd(ans, t); ans /= q; t /= q; &#125; &#125; &#125; printf(\"%d things taken %d at a time is %llu exactly.\\n\", n, m, ans); return true;&#125;int main() &#123; while (Do()); return 0;&#125;","tags":[{"name":"辗转相除法","slug":"gcd","permalink":"https://www.oyohyee.com/tags/gcd/"},{"name":"高精度算法","slug":"High-precision","permalink":"https://www.oyohyee.com/tags/High-precision/"},{"name":"POJ","slug":"POJ","permalink":"https://www.oyohyee.com/tags/POJ/"}]},{"title":"HDU 5640.King's Cake","date":"2016-04-16T16:06:00.000Z","path":"/post/HDU/5640.html","text":"题目 Description It is the king’s birthday before the military parade . The ministers prepared a rectangle cake of size n \\times m(1\\le n, m \\le 10000)2×22×2 InputThe first line contains a number T(T \\leq 1000), the number of the testcases. For each testcase, the first line and the only line contains two positive numbers n , m(1\\le n, m \\le 10000)1×11×1 Output For each testcase, print a single number as the answer. Sample Input 2 2 3 2 5 Sample Output 3 4 hint: For the first testcase you can divide the into one cake of , 2 cakes of 题解把长方形按照一刀一刀切成正方形，最后求出所有正方形的个数 如图，2*3的长方形，第一刀可以分割成2*2的正方形和1*2的长方形；第二刀可以分成两个1*1的正方形即3个正方形 可以看出，对于一个n*m的长方形（n&gt;m），其操作为分成m*m的正方形和(n-m)*m的长方形 提取出相同的操作，写成递归来统计个数 //a长 b宽int DFS(int a, int b) &#123; if (a == b) return 1; return 1 + DFS(max(a - b, b), min(a - b, b));&#125; 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;//a长 b宽int DFS(int a, int b) &#123; if (a == b) return 1; return 1 + DFS(max(a - b, b), min(a - b, b));&#125;void Do() &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); printf(\"%d\\n\", DFS(max(m, n), min(m, n)));&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) Do(); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"}]},{"title":"HDU 1072.Nightmare","date":"2016-04-14T17:23:00.000Z","path":"/post/HDU/1072.html","text":"题目 Description Ignatius had a nightmare last night. He found himself in a labyrinth with a time bomb on him. The labyrinth has an exit, Ignatius should get out of the labyrinth before the bomb explodes. The initial exploding time of the bomb is set to 6 minutes. To prevent the bomb from exploding by shake, Ignatius had to move slowly, that is to move from one area to the nearest area(that is, if Ignatius stands on (x,y) now, he could only on (x+1,y), (x-1,y), (x,y+1), or (x,y-1) in the next minute) takes him 1 minute. Some area in the labyrinth contains a Bomb-Reset-Equipment. They could reset the &gt; &gt; exploding time to 6 minutes. Given the layout of the labyrinth and Ignatius’ start position, please tell Ignatius whether he could get out of the labyrinth, if he could, output the minimum time that he has to use to find the exit of the labyrinth, else output -1. Here are some rules: We can assume the labyrinth is a 2 array. Each minute, Ignatius could only get to one of the nearest area, and he should not walk out of the border, of course he could not walk on a wall, too. If Ignatius get to the exit when the exploding time turns to 0, he can’t get out of the labyrinth. If Ignatius get to the area which contains Bomb-Rest-Equipment when the exploding time turns to 0, he can’t use the equipment to reset the bomb. A Bomb-Reset-Equipment can be used as many times as you wish, if it is needed, Ignatius can get to any areas in the labyrinth as many times as you wish. The time to reset the exploding time can be ignore, in other words, if Ignatius get to an area which contain Bomb-Rest-Equipment, and the exploding time is larger than 0, the exploding time would be reset to 6. Input The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.Each test case starts with two integers N and M(1&lt;=N,Mm=8) which indicate the size of the labyrinth. Then N lines follow, each line contains M integers. The array indicates the layout of the labyrinth.There are five integers which indicate the different type of area in the labyrinth:0: The area is a wall, Ignatius should not walk on it.1: The area contains nothing, Ignatius can walk on it.2: Ignatius’ start position, Ignatius starts his escape from this position.3: The exit of the labyrinth, Ignatius’ target position.4: The area contains a Bomb-Reset-Equipment, Ignatius can delay the exploding time by walking to these areas. Output For each test case, if Ignatius can get out of the labyrinth, you should output the minimum time he needs, else you should just output -1. Sample Input 3 3 3 2 1 1 1 1 0 1 1 3 4 8 2 1 1 0 1 1 1 0 1 0 4 1 1 0 4 1 1 0 0 0 0 0 0 1 1 1 1 4 1 1 1 3 5 8 1 2 1 1 1 1 1 4 1 0 0 0 1 0 0 1 1 4 1 0 1 1 0 1 1 0 0 0 0 3 0 1 1 1 4 1 1 1 1 1 Sample Output 4 -1 13 题解由于多了一个时间变量，在不同时间，即使在同一位置也会造成不同的结果。因此每种状态由位置(x,y)和时间(t)构成 构造一个结构体，来存储每种状态，遍历所有情况， 找到最优解 在状态更新时，只更新剩余时间更长的情况即可 struct point &#123; int x, y; int time; int dis; point(int a, int b, int c, int d) &#123; x = a; y = b; time = c; dis = d; &#125;&#125;; 最初使用了三维数组，然而超时……找不到问题，最后重写了遍 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 10;int n, m;int Map[maxn][maxn];const int delta[4] = &#123; 1,-1,0,0 &#125;;struct point &#123; int x, y; int time; int dis; point(int a, int b, int c, int d) &#123; x = a; y = b; time = c; dis = d; &#125;&#125;;int BFS(int s1, int s2, int v1, int v2) &#123; queue&lt;point&gt; Q; int mark[maxn][maxn]; memset(mark, -1, sizeof(mark)); int ans = -1; Q.push(point(s1, s2, 6, 0)); mark[s1][s2] = 6; while (!Q.empty()) &#123; point temp = Q.front(); Q.pop(); int x = temp.x; int y = temp.y; int time = temp.time; int dis = temp.dis; if (x == v1 &amp;&amp; y == v2) &#123; ans = ((ans == -1) ? (dis) : min(ans, dis)); //printf(\" (%d,%d)%d %d\\n\", x,y,time,dis); &#125; //** REP(4) &#123; int xx = x + delta[o]; int yy = y + delta[3-o]; int tt = time - 1; int dd = dis + 1; if (xx &lt; 0 || xx &gt;= n || yy &lt; 0 || yy &gt;= m || Map[xx][yy] == 0 || tt == 0) continue; if (Map[xx][yy] == 4) tt = 6; if (mark[xx][yy] &lt; tt) &#123; mark[xx][yy] = tt; //printf(\"%d %d %d %d\\n\", xx, yy, tt, dd); Q.push(point(xx, yy, tt, dd)); &#125; &#125; &#125; return ans;&#125;void Do() &#123; char s1, v1; int s2, v2; scanf(\"%d%d\\n\", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) &#123; scanf(\"%d\", &amp;Map[i][j]); if (Map[i][j] == 2) &#123; s1 = i; s2 = j; Map[i][j] = 1; &#125; if (Map[i][j] == 3) &#123; v1 = i; v2 = j; Map[i][j] = 1; &#125; &#125; printf(\"%d\\n\", BFS(s1, s2, v1, v2));&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) Do(); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"}]},{"title":"HDU 2717.Catch That Cow","date":"2016-04-13T16:25:00.000Z","path":"/post/HDU/2717.html","text":"题目 DescriptionFarmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 ≤ N ≤ 100,000) on a number line and the cow is at a point K (0 ≤ K ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and &gt; teleporting. Walking: FJ can move from any point X to the points X - 1 or X + 1 in a single minute Teleporting: FJ can move from any point X to the point 2 × X in a single minute. If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it? InputLine 1: Two space-separated integers: N and K Output Line 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow. Sample Input 5 17 Sample Output 4 Hint The fastest way for Farmer John to reach the fugitive cow is to move along the following path: 5-10-9-18-17, which takes 4 minutes. 题解由于移动方式只有 +1 -1 *2 因此如果 起点大于终点，直接相减即可 剩下就是标准的BFS模板 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 100005;int BFS(int s,int v) &#123; if(s == v) return 0; if(s &gt; v) return s - v; queue&lt;int&gt; Q; bool visited[maxn]; memset(visited,false,sizeof(visited)); int dis[maxn]; memset(dis,0,sizeof(dis)); Q.push(s); visited[s] = true; while(!Q.empty()) &#123; int th = Q.front(); Q.pop(); //达到终点 if(th == v) break; //拓展节点 define push \\ if(next &gt; maxn || next &lt;= 0) \\ continue;\\ if(!visited[next]) &#123;\\ Q.push(next);\\ visited[next] = true;\\ dis[next] = dis[th] + 1;\\ &#125;\\ int next; next = th + 1; push; next = th - 1; push; next = th * 2; push; &#125; if(dis[v]) return dis[v]; else return -1;&#125;bool Do() &#123; int s,v; if(scanf(\"%d%d\",&amp;s,&amp;v)==EOF) return false; printf(\"%d\\n\",BFS(s,v)); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"}]},{"title":"HDU 1372.Knight Moves","date":"2016-04-13T16:22:00.000Z","path":"/post/HDU/1372.html","text":"题目 Description A friend of you is doing research on the Traveling Knight Problem (TKP) where you are to find the shortest closed tour of knight moves that visits each square of a given set of n squares on a chessboard exactly once. He thinks that the most difficult part of the problem is determining the smallest &gt; &gt; number of knight moves between two given squares and that, once you have accomplished this, finding the tour would be easy.Of course you know that it is vice versa. So you offer him to write a program that solves the “difficult” part. Your job is to write a program that takes two squares a and b as input and then determines the number of knight moves on a shortest route from a to b. InputThe input file will contain one or more test cases. Each test case consists of one line containing two squares separated by one space. A square is a string consisting of a letter (a-h) representing the column and a digit (1-8) representing the row on the chessboard. Output For each test case, print one line saying “To get from xx to yy takes n knight moves.”. Sample Input e2 e4 a1 b2 b2 c3 a1 h8 a1 h7 h8 a1 b1 c3 f6 f6 Sample Output To get from e2 to e4 takes 2 knight moves.To get from a1 to b2 takes 4 knight moves.To get from b2 to c3 takes 2 knight moves.To get from a1 to h8 takes 6 knight moves.To get from a1 to h7 takes 5 knight moves.To get from h8 to a1 takes 6 knight moves.To get from b1 to c3 takes 1 knight moves.To get from f6 to f6 takes 0 knight moves. 题解国际象棋中，骑士(马)的行走方式是： 直走一个，再斜走一步（即1，2，-1，-2的组合） 如图(绿色为起始位置，红色为能够到达的位置) 由于读入数据中有字符，因此要注意避免错误读入回车(\\n) 剩下就是标准标准的BFS模板 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 10;int k[maxn];const int delta[8] = &#123;-1,-1,1,1,-2,2,2,-2&#125;;int BFS(int s1,int s2,int v1,int v2) &#123; if(s1 == v1 &amp;&amp; s2 == v2) return 0; queue&lt;pair&lt;int,int&gt; &gt; Q; bool visited[maxn][maxn]; memset(visited,false,sizeof(visited)); int dis[maxn][maxn]; memset(dis,0,sizeof(dis)); Q.push(pair&lt;int,int&gt;(s1,s2)); visited[s1][s2] = true; while(!Q.empty()) &#123; int th1 = Q.front().first; int th2 = Q.front().second; Q.pop(); //达到终点 if(th1 == v1 &amp;&amp; th2 == v2) break; //拓展节点 int next1,next2; for(int i = 0;i &lt; 8;i++) &#123; next1 = th1 + delta[i]; next2 = th2 + delta[7 - i]; if(next1 &gt; 8 || next1 &lt; 1 || next2 &gt; 8 || next2 &lt; 1) continue; if(!visited[next1][next2]) &#123; Q.push(pair&lt;int,int&gt;(next1,next2)); visited[next1][next2] = true; dis[next1][next2] = dis[th1][th2] + 1; &#125; &#125; &#125; if(dis[v1][v2]) return dis[v1][v2]; else return -1;&#125;bool Do() &#123; char s1,v1; int s2,v2; if(scanf(\"%c%d %c%d\\n\",&amp;s1,&amp;s2,&amp;v1,&amp;v2) == EOF) return false; printf(\"To get from %c%d to %c%d takes %d knight moves.\\n\", s1,s2,v1,v2,BFS(s1 - 'a' + 1,s2,v1 - 'a' + 1,v2)); return true;&#125;int main() &#123; while(Do()); return 0;&#125; ```","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"}]},{"title":"HDU 1548.A strange lift","date":"2016-04-13T16:16:00.000Z","path":"/post/HDU/1548.html","text":"题目 Description There is a strange lift.The lift can stop can at every floor as you want, and there is a number Ki(0 &lt;= Ki &lt;= N) on every floor.The lift have just two buttons: up and down.When you at floor i,if you press the button “UP” , you will go up Ki floor,i.e,you will go to the i+Ki th floor,as the same, if you press the button “DOWN” , you will go down Ki floor,i.e,you will go to the i-Ki th floor. Of course, the lift can’t go up high than N,and can’t go down lower than 1. For example, there is a buliding with 5 floors, and k1 = 3, k2 = 3,k3 = 1,k4 = 2, k5 = 5.Begining from the 1 st floor,you can &gt; &gt; press the button “UP”, and you’ll go up to the 4 th floor,and if you press the button “DOWN”, the lift can’t do it, because it can’t go down to the -2 th floor,as you know ,the -2 th floor isn’t exist.Here comes the problem: when you are on floor A,and you want to go to floor B,how many times at least he has to press the button “UP” or “DOWN”? InputThe input consists of several test cases.,Each test case contains two lines.The first line contains three integers N ,A,B( 1 &lt;= N,A,B &lt;= 200) which describe above,The second line consist N integers k1,k2,….kn.A single 0 indicate the end of the input. Output For each case of the input output a interger, the least times you have to press the button when you on floor A,and you want to go to floor B.If you can’t reach floor B,printf “-1”. Sample Input 5 1 5 3 3 1 2 5 0 Sample Output 3 题解BFS题目直接套用模板即可 其中有一点是如果”DOWN”到负数楼层，则不下降层数，而非降至1楼；”UP”同理（我觉得没人会读错吧……） 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;//DEBUG MODE#define debug 0//循环#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 205;int k[maxn];int N;int BFS(int s,int v) &#123; if(s == v) return 0; queue&lt;int&gt; Q; bool visited[maxn]; memset(visited,false,sizeof(visited)); int dis[maxn]; memset(dis,0,sizeof(dis)); Q.push(s); visited[s] = true; while(!Q.empty()) &#123; int th = Q.front(); Q.pop(); //达到终点 if(th == v) break; //拓展节点 int next; for(int i = -1;i == -1 || i == 1;i += 2) &#123; next = th + i * k[th]; if(next &gt; N || next &lt;= 0) continue; if(!visited[next]) &#123; Q.push(next); visited[next] = true; dis[next] = dis[th] + 1; &#125; &#125; &#125; if(dis[v]) return dis[v]; else return -1;&#125;bool Do() &#123; int s,v; if(scanf(\"%d%d%d\",&amp;N,&amp;s,&amp;v),N == 0) return false; REP(N) scanf(\"%d\",&amp;k[o + 1]); printf(\"%d\\n\",BFS(s,v)); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"HDU","slug":"HDU","permalink":"https://www.oyohyee.com/tags/HDU/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"}]},{"title":"AOJ 802.运输宝物","date":"2016-04-10T11:49:00.000Z","path":"/post/AOJ/802.html","text":"题目 Time Limit: 1000 msCase Time Limit: 1000 msMemory Limit: 64 MBTotal Submission: 53Submission Accepted: 22 Description 众所周知，“西瓜”是大名鼎鼎的江洋大盗。有一次他偷到了一批宝库。这批宝物共有n个，他一共有k个箱子。他只能用这些箱子把这些宝物运出去，为了保证运输安全，他不会把两个以上的宝物装入同一个箱子（一个箱子只能装1个或者2个宝物）。这些宝物的大小分别是s(1)、s(2)、s(3)……s(n)。（题目给出的重量保证是非降序，即s(i-1)&lt;=s(i) 对于任何i&gt;1)。装进宝物后，每个箱子的容量要大于或者等于所装的宝物大小之和。为了规格统一，这些箱子每个的容量要一致。为了降低运费，箱子的容量要尽可能小。“西瓜”想要知道，在能运走的情况下，箱子容量最小是多少。 Input 多组输入先输入n和k (1≤n≤2·k≤100 000)，n是宝物数量，k是箱子数量。下一行输入空格分隔的n个整数, s1,s2,…,sn (1≤s1≤s2≤…≤sn≤1 000 000),代表这些宝物的重量。 Output 输出一个整数，代表这些箱子容量的最小值。 Sample Input 4 32 3 5 9 Sample Output 9 题解只需将宝物按照从大到小装箱，然后再将剩下的宝物按照从大到小装入从小到大的箱子中 最后求出所有箱子中最大值即可 代码#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;memory&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std; #define debug 0 /*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#define REP(n) for(int o=0;o&lt;n;o++)const int maxn=100005;const int maxk=50005; int n,k;int s[maxn]; bool Do()&#123; if(scanf(\"%d%d\",&amp;n,&amp;k)==EOF) return false; REP(n) scanf(\"%d\",&amp;s[o]); if(k&gt;=n)&#123; printf(\"%d\\n\",s[n-1]); return true; &#125; int w[maxk]; REP(k)&#123; w[o]=s[n-k+o]; &#125; if debug REP(n) printf(\"s[%d]=%d\\n\",o,s[o]); printf(\"\\n\"); REP(k) printf(\"w[%d]=%d\\n\",o,w[o]); printf(\"\\n\"); endif // debug for(int i=0;i&lt;n-k;i++)&#123; w[i]+=s[n-k-1-i]; &#125; int M=w[0]; REP(k)&#123; M=max(M,w[o]); &#125; if debug REP(k) printf(\"w[%d]=%d\\n\",o,w[o]); endif // debug printf(\"%d\\n\",M); return true; &#125; int main()&#123; if debug freopen(\"in.txt\",\"r\",stdin); endif while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"AOJ 794.西瓜理发记(二)","date":"2016-04-10T11:44:00.000Z","path":"/post/AOJ/794.html","text":"题目 Time Limit: 1000 msCase Time Limit: 1000 msMemory Limit: 64 MBTotal Submission: 151Submission Accepted: 28 Description 剃完光头后，西瓜表示非常开心，于是直接骑上自行车去往勺林寺。等骑到勺林寺的时候，头发已经都长出来了，于是西瓜决定在附近的理发店再剃一次。然而这里的理发店老板WzyJerry表示正在做ACM练习，没空给他理发。西瓜决定帮助老板AK。题目是这样的：你现在有一个培养盒，盒中没有细菌每天早上，你可以向盒中放入一个细菌每天晚上，一个细菌会分裂成两个。求如果你想在将来的某天使盒中恰好有n个细菌，你最少要向盒中放入几个细菌 Input 输入数据包含多组每组一个整数n（1≤n ≤10^9） Output 每组数据输出一个整数x，表示最少需要放入的细菌个数 Sample Input 51 Sample Output 21 题解提供两种思路 模拟 位运算(2进制) 模拟（被注释部分）使用DFS来模拟操作。 从1个细菌开始 早上分别选择放入细菌和不放入细菌，而后与要求匹配，查看是否符合 晚上在两种情况下分别将细菌乘2，继续DFS 这种方法比较直观，代码也很简单，但是效率非常低，需要将树的所有分支都遍历至n，而树有2n个叶，也即时间效率为O(2n) 位运算(2进制)由模拟算法，我们发现时间效率与2n有关系，因此，可以比较容易想到2进制的算法。 早上是否放入，可看做最低位是否为1；晚上乘2可看作左移一位(&lt;&lt;1)。 由于得到n个细菌是唯一的，所以n（2）中的1的个数为最优解，也是唯一解。 因此，只需判断n（2）中的1的个数即可。 该算法的效率只和n的二进制位数有关时间效率为O(n)，并且采用二进制运算，每次运算量也非常小。 代码#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;memory&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std; #define debug 0 /*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/int N;/* int ans=999999;void DFS(int n,int cnt)&#123; //printf(\"%d %d\\n\",n,cnt); if(n==N) ans=min(cnt,ans); if(n+1==N) ans=min(cnt+1,ans); if(n&gt;N) return ; DFS(2*n,cnt); DFS(2*(n+1),cnt+1); return;&#125;*/int niconiconi(int n)&#123; int cnt; for(cnt=0;n;n&gt;&gt;=1) cnt+=(n&amp;1); return cnt;&#125; bool Do()&#123; if(scanf(\"%d\",&amp;N)==EOF) return false; //ans=999999; //DFS(1,1); printf(\"%d\\n\",niconiconi(N));&#125; int main()&#123; if debug freopen(\"in.txt\",\"r\",stdin); endif while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"}]},{"title":"AOJ 793.西瓜理发记(一)","date":"2016-04-10T11:26:00.000Z","path":"/post/AOJ/793.html","text":"题目 Time Limit: 1000 msCase Time Limit: 1000 msMemory Limit: 64 MBTotal Submission: 100Submission Accepted: 42 Description 某天，西瓜决心皈依勺林寺，于是来到安大门口的理发店，准备剃一个光头。然而理发店有很多人排队，西瓜想知道他大概还需要排队排多久。假设一位男生需要8分钟，一位女生需要12分钟。 Input 测试数据包括多组每组数据包含一个字符串s，0&lt;|s|&lt;=2000字符串只包含字符’M’,’W’,’O’M表示男生，W表示女生,O表示西瓜在字符串中的位置越左表示在队伍当中越靠前保证每个字符串不为空,且O只有一个 Output 对应每组数据输出一个整数，表示西瓜大概需要等待的分钟数。 Sample Input MWWWOO Sample Output 440 题解简单模拟即可 代码#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;memory&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std; #define debug 0 /* By:OhYee Github:OhYee Email:oyohyee@oyohyee.com*/ const int maxn =2005;bool Do()&#123; char c; int ans=0; c=getchar(); while(!(c=='M'||c=='W'||c=='O'))&#123; if(c==EOF) return false; c=getchar(); &#125; while(c=='M'||c=='W'||c=='O')&#123; if(c=='M') ans+=8; if(c=='W') ans+=12; if(c=='O')&#123; printf(\"%d\\n\",ans); &#125; c=getchar(); &#125; &#125; int main()&#123; if debug freopen(\"in.txt\",\"r\",stdin); endif while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"AOJ 789.买酒","date":"2016-04-10T11:07:00.000Z","path":"/post/AOJ/789.html","text":"题目 Time Limit: 1000 msCase Time Limit: 1000 msMemory Limit: 64 MBTotal Submission: 43Submission Accepted: 6 Description 众所周知，西瓜是一个很爱喝酒的人。有一天西瓜和朋友去酒楼喝酒，却发现酒楼在大酬宾，活动规则如下。 全场只要买酒可以买二送一，买2瓶酒就可以送一瓶酒，买4瓶酒就送两瓶酒。 4个空瓶可以换一瓶酒。 10个酒瓶盖可以换一瓶酒。 拿瓶子和盖子换酒可以享受换二送一的优惠（比如8个空瓶可以换两瓶酒，然后再送一瓶；12个空瓶+10个盖子可以换4瓶酒，再送两瓶），并且换来的酒产生的的瓶盖和空瓶依旧可以继续拿给酒楼换酒。现在西瓜和朋友们的钱一共有N元, 酒一瓶M元，请问他们最多可以喝多少瓶酒。 Input 题目包含多组输入，EOF结束，数据最多不超过1000组，对于每组数据包含两个数字N，M表示西瓜和朋友们所有钱的数量和一瓶酒的单价，其中1&lt;=N&lt;=1000000, 1&lt;=M&lt;=50 Output 对于每组输入，输出单独一行，表示西瓜和他的朋友们最多能喝到多少瓶酒。 Sample Input 500 1050 5 Sample Output 15427 Hint trick较多，请谨慎读题并且思考情况 题解题意比较简单，但是需要考虑的情况比较多 由于需要最大程度多买酒，而且其中有买两瓶送一瓶的优惠，所以，我们应该尽可能地成对买酒。 有以下情况需要单独考虑： 能兑换奇数瓶酒，把其中一瓶不兑换，留着以后组成一对兑换 留着待兑换的一瓶酒不能再组上队，只能直接兑换 留着待兑换的一瓶酒不能组上队，但兑换后又可以兑换酒//最早未考虑到这种情况 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.comBlog:http://www.cnblogs.com/ohyee/かしこいかわいい？エリーチカ！要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;int Do(int N,int M) &#123; int b = 0,a = 0,ans = 0; //a酒瓶 b酒瓶盖 ans = N / M;//能买的酒数目 ans += ans / 2; a = ans; b = ans; int t = 0; while(!(a &lt; 4 &amp;&amp; b &lt; 10 &amp;&amp; t != 1)) &#123; t += a / 4 + b / 10; a -= (a / 4) * 4; b -= (b / 10) * 10; int add = (t / 2) * 2; //如果这一轮没有不能兑换，则兑换之前没兑换的 if(add == 0) add = t; t -= add; add += add / 2; ans += add; a += add; b += add; &#125; return ans;&#125;int main() &#123; int a,b; while(scanf(\"%d%d\",&amp;a,&amp;b) != EOF) &#123; printf(\"%d\\n\",Do(a,b)); &#125; return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"AOJ 788.数方块","date":"2016-04-10T10:25:00.000Z","path":"/post/AOJ/788.html","text":"题目 Time Limit: 1000 msCase Time Limit: 1000 msMemory Limit: 64 MBTotal Submission: 116Submission Accepted: 38 Description 西瓜在寒假里辅导身为小学生的小西瓜寒假作业，里面有这样一道题目：数一数下图中有几个正方形，小巫女认为只有16个，可是老师说错了。 对于西瓜来说，这样的问题自然很容易解决，但是现在西瓜想知道，如果现在有一个n*m个小正方形组成的长方形，请问里面一共有几个正方形呢？ Input 题目包含多组输入，EOF结束, 数据最多不超过100组，对于每组输入包含两个数字n，m表示现在有一个n*m个小正方形组成的大长方形，其中1&lt;=n,m&lt;=1000。 Output 对于每组输入，输出单独一行，表示大长方形中一共可以数出多少个正方形。 Sample Input 3 44 43 3 Sample Output 203014 题解简单的式子即可求解 使正方形的边长为1，2，3……min(a,b)时，分别算出正方形的个数，相加即可 代码#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;memory&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std; #define debug 0 /* By:OhYee Github:OhYee Email:oyohyee@oyohyee.com*/ int a,b;bool Do()&#123; if(scanf(\"%d%d\",&amp;a,&amp;b)==EOF) return false; int ans=0; for(int i=1;i&lt;=a;i++) for(int j=1;j&lt;=b;j++) if(i==j) ans+=(a-i+1)*(b-j+1); printf(\"%d\\n\",ans); &#125; int main()&#123; if debug freopen(\"in.txt\",\"r\",stdin); sendif while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"网络流","date":"2016-03-26T16:39:00.000Z","path":"/post/Algorithm/Network_Flow.html","text":"网络流 如果城市s有一定的货物，每条路能够运送的货物都有一个上限。 将货物从运送到从s送到t就构成了网络流问题 最大流 尽可能把最多的物品从s送到t，除了s、t之外的节点都只是中转。 其有如下性质 容量限制：f(u,v)&lt;=c(u,v) 斜对称性：f(u,v)==-f(v,u) 流量平衡：除s、t外任意节点u，其向外的总流量为0 增广路算法从零流开始不断增加流量，保证每次增加流量后都满足三个条件。 计算每条边上容量和流量之差(残量)，得到残量网络 每条从s到t的一条路径都为原图的增光路，求出该道路中残量的最小值d，把所有边流量加上d即可(增广) 有Edmonds-Karp算法(BFS) 最小割最大流定理在一个有权图中，源点为Vs，汇点为Vt，从Vs到Vt有很多路径可以走，每条路径都包含若干条边。 这些边可能只属于一条路径，也可能同时出现在两条路径中。 如果拿掉这张图中的一些边，就无法从Vs到达Vt，这些边的组合就叫做割集。 最小割集流量之和=最大流 最小费用最大流当每个边存在费用，还要考虑费用问题 有以下性质: 只要初始流是该流量下的最小费用可行流，则其增广后的新流还是新流量吓得最小费用流 也即优先填充最小费用的边。 二分图匹配把节点分成两部分X和Y，使得每条边恰好一个在X一个在Y。 无权图求包含边数最多的匹配(二分图的最大基数匹配) 增加源点s和汇点t 从s向所有x点，y点到t连接一条容量为1的弧 将每条边变为由x指向y的有向弧，容量为1 求出s到t的最大流 此时流量为1的弧对应了最大奇数匹配 有权图求边权之和最大的匹配 完美匹配所有点都被匹配 为每条边加上权值相反数的费用 求最小费用最大流 非完美匹配不用所有点都被匹配 在求解最小费用流时，记录下流量为0，1……时的最小费用流","tags":[{"name":"网络流","slug":"Network-Flow","permalink":"https://www.oyohyee.com/tags/Network-Flow/"}]},{"title":"最小生成树","date":"2016-03-26T15:23:00.000Z","path":"/post/Algorithm/MST.html","text":"最小生成树 对于无向图G=(V,E)，连接G中所有点，且边集是E的子集的树成为G的生成树 其中权值最小的生成树叫做最小生成树(MST) Kruskal算法Kruskal算法 是一种最小生成树算法。 首先对所有边按照权值进行排序初始化连通分量(并查集)初始化树循环考察每条边 如果边的两个节点不在同一个连通分量 将这个边插入到树中 将两个节点对应的连通分量合并 Prim算法Prim算法是另一种最小生成树算法。 对所有边按照权值排序初始化集合S[i]为false声明队列Q将所有边加入到Q中队列不为空若Q的最顶部的两个节点不全在集合中 将两个点加入到集合中 将边插入到树中否则 从队列中删除这条边 两种最小生成树的算法，大概思路都是对边排序后，将不会产生环的边逐个加入到树中","tags":[{"name":"树","slug":"Tree","permalink":"https://www.oyohyee.com/tags/Tree/"},{"name":"最小生成树","slug":"MST","permalink":"https://www.oyohyee.com/tags/MST/"},{"name":"Kruskal","slug":"Kruskal","permalink":"https://www.oyohyee.com/tags/Kruskal/"},{"name":"Prim","slug":"Prim","permalink":"https://www.oyohyee.com/tags/Prim/"}]},{"title":"初窥Dijkstra算法、Bellman-Ford、SPFA算法、Floyd算法、迭代加深搜索、A*、IDA*","date":"2016-03-26T14:48:00.000Z","path":"/post/Algorithm/Shortest_Path.html","text":"Dijlkstra算法 Dijkstra算法是一种常见的计算正权图上的单源最短路的算法，能同时用在有向图和无向图上。 &gt;Dijkstra算法的解释&lt; 其以BFS为基础进行优化。 BFS算法 宽度优先遍历算法，先从起点向周围拓展，再从拓展后的每个点向外拓展，如果某个节点已经访问过，则不再访问该节点。 由于每个节点只访问一次，并且按层逐层向外访问，因此第一次访问到终点时走过的路径就是最短路径。 可以用于无权图的最短路搜索。 通常使用循环和队列进行搜索。 queue&lt;int&gt; Q;bool visited[maxn];memset(visited,flase,sizeof(visited));Q.push(v);visited[v]=true;while(!Q.empty())&#123; int it=Q.top(); Q.pop(); //拓展到终点 if(it==s)&#123; ... break; &#125; ...//从it向外拓展到itn if(!visited[itn]) Q.push(itn);&#125; DFS算法 深度优先遍历，从起点开始，沿着一条分支一直走到终点。 与BFS不同，DFS的在搜索最短路的大多数情况下，是不如BFS的，它更多是用在状态的转移上。 根据已有的状态向下一个状态进行转移。 在较为复杂的迷宫中（牵扯到时间、方向等各种复杂状态）时，用DFS来传递参数会更有优势 由于DFS强调的是状态的转移。因此，更多用递归来实现。 void DFS(...)&#123; //不符合要求的拓展 if(...) return; //达到叶节点 if(...) return; ...//向下拓展到itn(n=1、2、……) DFS(it1); ... DFS(itn);&#125; 当图为有权图时，如果我们想要走最短的路径，就要优先走权值更小的路，这样才能走出最小的解（可证明） 因此，在BFS中，我们在队列中不应该选取先进队的节点，而应该走权值最小的节点。 将BFS的队列(queue)改成优先队列(priority_queue)即可。 然后每次拓展节点后，更新每个节点的权值(取最小) 最后终点的权值就是最小路的距离。 Bellman-Ford算法Dijkstra算法只适用于正权图上最短路，而Bellman-Ford还可计算副权存在时的最短路。 首先要明确： 如果最短路存在，一定存在一个不含环的最短路。 最短路最多只经过(不含起点)n-1个节点，可以通过n-1轮松弛操作得到。 将起点权值设置为0，其他点权值设置为无穷大。循环节点个数-1次 循环边的个数次(i) 对第i条边进行松弛操作 检测是否存在负权回路 存在 返回false 不存在 继续 SPFA算法Bellman-Ford算法虽然解决了负权路的问题，但是其效率过于底下，并不常使用。 而SPFA算法，是其高效率的替代方法。 其与无权图的BFS较为相近。 不同的是，visited数组记录的不是是否已经访问过，而是是否在队列Q中 每次松弛操作更新估计值(d[i])，如果i点不在队列中，则要把i点入队 如果有边入队的次数超过N次，则说明存在负环。 Floyd算法如果需要求出每两点之间的最短路，则可以使用Floyd算法，这是一个非常简洁的算法 不断进行松弛操作，即可得到最短路径 for(int k=0;k&lt;n;k++) for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]); 迭代加深搜索、A*、IDA*是三种相似并且很有用的算法。 他们是一种解题的思路，并没有具体的实现代码，在脑海中有这种思路，有可能会帮助我们获取解题的思路 迭代加深搜索迭代加深搜索是一种不断拓展搜索范围的搜索方式。 可以将其形象成一棵树，这棵树有无数层（深度无限深），每一层有无限个节点（无限广） 因此，无论是DFS还是BFS，都不能拓展一支，拓展一层。 而其答案可能就在第二层第二支上…… 为了求解这种问题，有了迭代加深搜索。 顾名思义，迭代加深就是逐渐增加搜索的范围。 最初我们只搜索maxd的范围，当maxd内没有我们需要的答案时，我们将maxd+1，而后继续搜索。 for(maxd=1;;maxd++) if(dfs(...)) break; 埃及分数问题，是经典的迭代加深问题 在古埃及，人们使用单位分数的和（形如 1/a 的，a 是正整数）表示一切有理数。 如：2/3 = 1/2 + 1/6，但不允许 2/3 = 1/3 + 1/3，因为加数中有相同的。 首先，加数少的比加数多的好，其次，加数个数相同的，最小的分数越大越好。 首先BFS无法求解这个问题，我们不知道有几个加数；其次DFS也不能求解这个问题，我们不知道加数没有最小值（分母可以无限大）。 因此，我们需要使用迭代加深算法。先让每个加数都大于1/10，进行DFS，如果没有答案，再搜索每个加数都大于1/20…… 很显然，每次maxd的增加，都导致了重复搜索，不过相比搜索总数指数级的增加，重复搜索的这部分可以忽略…… A*算法A*算法，又称启发式搜索。 用公式表示为 f(n)=g(n)+h(n) 其中 f(n)是初始点经由节点n到目标点的估价函数 g(n)是在状态空间中从初始节点到n节点的实际代价 h(n)是从n到目标结点的最佳路径的估计代价 具体是什么意思呢，就是我们要优先选择一条我们估计最好的分支进行拓展，对于我们估计不是很好的分支进行剪枝。 由于最好只是我们的估计，因此，如果估计的不合理，可能会丢失最优解或者并没有有效提升效率。 与Dijkstra对比，我们可以发现，Dijkstra其实是简化的一种A*算法： 它与A*相比少了剪枝的部分，与BFS相比，多了估价的部分 IDA*算法将迭代加深的有上限的搜索和A算法的剪枝与估价结合，就得到了IDA算法 IDA*算法有以下优缺点： 优化了A*对空间的小号 在每一次迭代的过程中避免了判重 比普通的DFS相比更加明确目标，并能够有效剪枝 迭代加深会导致重复搜索内容","tags":[{"name":"Dijkstra","slug":"Dijkstra","permalink":"https://www.oyohyee.com/tags/Dijkstra/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"DFS","slug":"DFS","permalink":"https://www.oyohyee.com/tags/DFS/"},{"name":"A*","slug":"A","permalink":"https://www.oyohyee.com/tags/A/"},{"name":"IDA*","slug":"IDA","permalink":"https://www.oyohyee.com/tags/IDA/"},{"name":"Bellman-Ford","slug":"Bellman-Ford","permalink":"https://www.oyohyee.com/tags/Bellman-Ford/"},{"name":"SPFA","slug":"SPFA","permalink":"https://www.oyohyee.com/tags/SPFA/"},{"name":"Floyd","slug":"Floyd","permalink":"https://www.oyohyee.com/tags/Floyd/"},{"name":"迭代加深","slug":"Iteration","permalink":"https://www.oyohyee.com/tags/Iteration/"}]},{"title":"(转)巧妙运用C语言位运算+位运算笔记","date":"2016-03-25T16:41:00.000Z","path":"/post/Note/bit.html","text":"位运算 位运算的运算分量只能是整型或字符型数据，位运算把运算对象看作是由二进位组成的位串信息，按位完成指定的运算，得到位串信息的结果。位运算符有：&amp;(按位与)、|(按位或)、^(按位异或)、~ (按位取反)。 其中，按位取反运算符是单目运算符，其余均为双目运算符。 位运算符的优先级从高到低，依次为~、&amp;、^、|， 其中~的结合方向自右至左，且优先级高于算术运算符，其余运算符的结合方向都是自左至右，且优先级低于关系运算符。 (1)按位与运算符(&amp;)按位与运算将两个运算分量的对应位按位遵照以下规则进行计算： 0 &amp; 0 = 0, 0 &amp; 1 = 0, 1 &amp; 0 = 0, 1 &amp; 1 = 1。即同为 1 的位，结果为 1，否则结果为 0。例如，设3的内部表示为 000000115的内部表示为 00000101则3&amp;5的结果为 00000001按位与运算有两种典型用法，一是取一个位串信息的某几位，如以下代码截取x的最低7位：x &amp; 0177。二是让某变量保留某几位，其余位置0，如以下代码让x只保留最低6位：x = x &amp; 077。以上用法都先要设计好一个常数，该常数只有需要的位是1，不需要的位是0。用它与指定的位串信息按位与。 (2)按位或运算符(|)按位或运算将两个运算分量的对应位按位遵照以下规则进行计算： 0 | 0 = 0, 0 | 1 = 1, 1 | 0 = 1, 1 | 1 = 1 即只要有1个是1的位，结果为1，否则为0。 例如，023 | 035 结果为037。 按位或运算的典型用法是将一个位串信息的某几位置成1。如将要获得最右4为1，其他位与变量j的其他位相同，可用逻辑或运算017|j。若要把这结果赋给变量j，可写成： j = 017|j (3)按位异或运算符(^)按位异或运算将两个运算分量的对应位按位遵照以下规则进行计算： `0 ^ 0 = 0, 0 ^ 1 = 1, 1 ^ 0 = 1, 1 ^ 1 = 0 ` 即相应位的值相同的，结果为 0，不相同的结果为 1。 例如，013^035结果为026。 异或运算的意思是求两个运算分量相应位值是否相异，相异的为1，相同的为0。按位异或运算的典型用法是求一个位串信息的某几位信息的反。如欲求整型变量j 的最右4位信息的反，用逻辑异或运算017^j，就能求得j最右4位的信息的反,即原来为1的位，结果是0,原来为0的位，结果是1。 (4)按位取反运算符(~)按位取反运算是单目运算，用来求一个位串信息按位的反，即哪些为0的位，结果是1，而哪些为1的位，结果是0。例如, ~7的结果为0xfff8。 取反运算常用来生成与系统实现无关的常数。如要将变量x最低6位置成0，其余位不变，可用代码x = x &amp; ~077实现。以上代码与整数x用2个字节还是用4个字节实现无关。 当两个长度不同的数据进行位运算时(例如long型数据与int型数据)，将两个运算分量的右端对齐进行位运算。如果短的数为正数，高位用0补满；如果短的数为负数，高位用1补满。如果短的为无符号整数，则高位总是用0补满。 位运算用来对位串信息进行运算，得到位串信息结果。如以下代码能取下整型变量k的位串信息的最右边为1的信息位：((k-1)^k) &amp; k。 移位运算移位运算用来将整型或字符型数据作为二进位信息串作整体移动。有两个运算符： &lt;&lt; (左移) 和 &gt;&gt; (右移)移位运算是双目运算，有两个运算分量,左分量为移位数据对象，右分量的值为移位位数。移位运算将左运算分量视作由二进位组成的位串信息,对其作向左或向右移位，得到新的位串信息。 移位运算符的优先级低于算术运算符，高于关系运算符，它们的结合方向是自左至右。 (1)左移运算符(&lt;&lt;)左移运算将一个位串信息向左移指定的位，右端空出的位用0补充。例如014&lt;&lt;2,结果为060,即48。 左移时，空出的右端用0补充，左端移出的位的信息就被丢弃。在二进制数运算中，在信息没有因移动而丢失的情况下，每左移1位相当于乘2。如4 &lt;&lt; 2，结果为16。 (2)右移运算符(&gt;&gt;)右移运算将一个位串信息向右移指定的位，右端移出的位的信息被丢弃。例如12&gt;&gt;2,结果为3。与左移相反，对于小整数，每右移1位，相当于除以2。在右移时，需要注意符号位问题。对无符号数据，右移时，左端空出的位用0补充。对于带符号的数据，如果移位前符号位为0(正数)，则左端也是用0 补充；如果移位前符号位为1(负数)，则左端用0或用1补充，取决于计算机系统。对于负数右移，称用0 补充的系统为“逻辑右移”，用1补充的系统为“算术右移”。以下代码能说明读者上机的系统所采用的右移方法： printf(&quot;%d\\n\\n\\n&quot;, -2&gt;&gt;4); 若输出结果为-1，是采用算术右移；输出结果为一个大整数，则为逻辑右移。 移位运算与位运算结合能实现许多与位串运算有关的复杂计算。设变量的位自右至左顺序编号，自0位至15位，有关指定位的表达式是不超过15的正整数。以下各代码分别有它们右边注释所示的意义： ~（~0 &lt;&lt; n） /* 实现最低n位为1，其余位为0的位串信息 */ (x &gt;&gt; (1+p-n)) &amp; ~(~0 &lt;&lt; n) /* 截取变量x自p位开始的右边n位的信息 */ new |= ((old &gt;&gt; row) &amp; 1) &lt;&lt; (15 – k) /* 截取old变量第row位，并将该位信息装配到变量new的第15-k位 */ s &amp;= ~(1 &lt;&lt; j) /* 将变量s的第j位置成0，其余位不变 */ for(j = 0; ((1 &lt;&lt; j) &amp; s) == 0; j++) ; /* 设s不等于全0，代码寻找最右边为1的位的序号j */ ！为逻辑取反，表示非的意思 经过它处理后的结果为布尔型，要么为0，要么为1，!x，只要x不为0，1,2，3，都可以，那么!x的结果就是0，只有当x为0时，结果为1。如果为真，则！为假，反之如果为假，则！为真 其他lowbit函数int lowbit(int x)&#123; return x&amp;(-x); &#125; 由于程序数据用补码保存，负数是其绝对值取反+1 1（0001） -1（1111） 1&amp;（-1）=0001 其意义是将只保留最低位的1 换成10进制后就是2i（i是最低位的1的位数） 判断最后一位 x&amp;1; 可以取得x最后一位是1还是0 +1将一个数+1，可以将其最后一个0变成1，比其低的位变成0 -1将一个数-1，可以将其最后一个1变成0，比其低的位变成1 计算二进制中1的个数int bitCount(int i) &#123; i = i - ((i &gt;&gt;&gt; 1) &amp; 0x55555555); i = (i &amp; 0x33333333) + ((i &gt;&gt;&gt; 2) &amp; 0x33333333); i = (i + (i &gt;&gt;&gt; 4)) &amp; 0x0f0f0f0f; i = i + (i &gt;&gt;&gt; 8); i = i + (i &gt;&gt;&gt; 16); return i &amp; 0x3f;&#125;","tags":[{"name":"位运算","slug":"Bit","permalink":"https://www.oyohyee.com/tags/Bit/"}]},{"title":"AOJ 716.谢尔宾斯基三角形","date":"2016-03-25T08:45:00.000Z","path":"/post/AOJ/716.html","text":"题目 Time Limit: 3000 msCase Time Limit: 3000 msMemory Limit: 128 MBTotal Submission: 116Submission Accepted: 35 Description 谢尔宾斯基三角形（Sierpinski triangle）是一种分形，由波兰数学家谢尔宾斯基在1915年提出。下面的图片就是谢尔宾斯基三角形的一个简单例子。 现在，Roll想在自己的电脑中画出这个图形，他要求不高，只要实现一个控制台版本就好，也不需要行首的空格缩进，下面是一个25行的控制台版本的谢尔宾斯基三角形例子。（具体的字符可以参考样例输出) 你能帮他实现么 Input 包含多组输入，EOF结束，每组输入包含一行，每行有一个数字N，表示要输出的是N行的谢尔宾斯基三角形。1 &lt;= N &lt;= 512 Output 对于每组输入，输出一个N行的谢尔宾斯基三角形。 Sample Input 12325 Sample Output ******** ***** ****** *** *** * * ********** *** *** * * ***** ***** * * *** ** ** *** * * * * * * ****************** *** *** * * ***** ***** * * *** ** ** *** * * * * * * ********* ********* * * * Source 谢尔宾斯基三角形 题解可以找到规律： n~2n-2行的内容是1~n-1行的内容水平放置两份 递推出关系即可 代码/* By:OhYee Github:OhYee Email:oyohyee@oyohyee.com Blog:http://www.cnblogs.com/ohyee/ かしこいかわいい？ エリーチカ！ 要写出来Хорошо的代码哦~*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;using namespace std;const int maxn = 512 + 5;bool d[maxn][maxn];//将1~n-1行的内容拷贝两份在n~2n-2行（超过maxn时返回）void copy(int n) &#123; for(int i = 1;i &lt; n;i++) &#123; if(i + n - 1 &lt; maxn) for(int j = 1;j &lt;= i;j++) d[i + n - 1][j] = d[i + n - 1][j + n - 1] = d[i][j]; else break; &#125;&#125;int main() &#123; memset(d,false,sizeof(d)); d[1][1] = 1; for(int i = 2;i &lt; maxn;i = 2 * i - 1) copy(i); int n; while(scanf(\"%d\",&amp;n) != EOF) for(int i = 1;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= i;j++) &#123; printf(\"%c\",d[i][j] ? '*' : ' '); &#125; printf(\"\\n\"); &#125; return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"递推","slug":"Recurrence","permalink":"https://www.oyohyee.com/tags/Recurrence/"}]},{"title":"AOJ 803.魔方","date":"2016-03-23T15:51:00.000Z","path":"/post/AOJ/803.html","text":"题目 Time Limit: 5000 msCase Time Limit: 5000 msMemory Limit: 64 MBTotal Submission: 181Submission Accepted: 71 Description 西瓜很喜欢玩魔方，现在西瓜想知道，一个N阶魔方在表面一共有多少个立方体能被看见？ Input 包含多组数据，EOF结束。对于每组输入，包含一个数字N（1 &lt;= N &lt;= 1000），表示魔方的阶数。 Output 对于每组输入，输出一行，表示N阶魔方能看见的立方体数。 Sample Input 1234 Sample Output 182656 题解数学题 对于n阶魔方，如果n=1，那么就是1，否则ans=n3-(n-2)3=6n2-12n+8 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.com*/#include &lt;cstdio&gt;int main() &#123; int n; while(scanf(\"%d\",&amp;n) != EOF) printf(\"%d\\n\",n==1?1:6*n*n-12*n+8); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"}]},{"title":"AOJ 796.数三角形","date":"2016-03-23T15:49:00.000Z","path":"/post/AOJ/796.html","text":"题目 Time Limit: 5000 msCase Time Limit: 5000 msMemory Limit: 128 MBTotal Submission: 112Submission Accepted: 40 Description ACMer最讨厌大段大段的题目描述了，尤其当题目描述是英文的时候。还好，1243France为大家准备了一道简洁且简单的问题。给出平面上n个点的坐标，求这n个点总共可以围成多少个面积大于0的三角形。保证每个点的横纵坐标均为整数且绝对值小于等于100。保证给出点当中没有重点 Input 输入数据包含多组，EOF结束每组数据第一行包含一个数n，表示有n个点(1 ≤ n ≤ 200)之后n行每行两个整数x，y表示一个点和横坐标及纵坐标(- 100 ≤ x，y≤ 100) Output 对于每组输入，输出一个数k表示总共能围成k个面积大于0的三角形 Sample Input 40 01 12 02 211 1 Sample Output 30 题解只需要保证不存在三个点在一条直线即可 （包括横坐标相同、纵坐标相同、斜率相同） （貌似我写的没有考虑到斜率不存在的情况欸~不过AC了） 代码#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;stack&gt;using namespace std; #define REP(n) for(int o=0;o&lt;n;o++) pair&lt;int,int&gt; p[205];bool Do() &#123; int n; if(scanf(\"%d\",&amp;n) == EOF) return false; REP(n) &#123; int x,y; scanf(\"%d%d\",&amp;x,&amp;y); p[o] = pair&lt;int,int&gt;(x,y); &#125; int cnt = 0; for(int i = 0;i &lt; n;i++) for(int j = i + 1;j &lt; n;j++) for(int k = j + 1;k &lt; n;k++) &#123; if(i &lt; j&amp;&amp;j &lt; k) &#123; pair&lt;int,int &gt;a = p[i],b = p[j],c = p[k]; if(!( (a.first == b.first&amp;&amp;a.first == c.first) || (a.second == b.second&amp;&amp;a.second == c.second) || ((double)(a.first - b.first) / (double)(a.second - b.second) == (double)(c.first - b.first) / (double)(c.second - b.second)) )) &#123; cnt++; //printf(\"%d %d %d\\n\",i,j,k); &#125; &#125; &#125; printf(\"%d\\n\",cnt); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"}]},{"title":"AOJ 800.热身之开关灯","date":"2016-03-23T15:45:00.000Z","path":"/post/AOJ/800.html","text":"题目 Time Limit: 1000 msCase Time Limit: 1000 msMemory Limit: 64 MBTotal Submission: 224Submission Accepted: 86 Description 吃完草莓以后，机房的小伙伴们要开始做些运动。在ACM实验室里有N盏灯编号为1到N，起初都是开着的，从第一盏灯开始，凡是编号是一的倍数的灯的开关都要被按一遍（亮的变成暗的，暗的变成亮的），然后到第二盏灯，凡是编号是二的倍数的灯的开关都要被按一遍，一直到第N盏灯，凡是编号是N的倍数的灯都要被按一遍。那么问题来了，在灯质量比较好的情况下，最后还有多少盏灯是亮着的。 Input 题目包括多组输入只有一行，这一行只有一个数N，1&lt;=N&lt;=1000 Output 输出一行，这一行也只有一个数，就是亮着灯的个数 Sample Input 3 Sample Output 2 Hint 经过第一个灯的时候1，2,3号灯都按了依次，经过第二个灯的时候，2号灯按了一次，经过第三个灯的时候，3号灯按了一次，最后只有2，3灯还亮着。 题解强行模拟即可，且数据量较小，可打表 代码#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;stack&gt;using namespace std; #define REP(n) for(int o=0;o&lt;n;o++) int ans[] = &#123;0,0,1,2,2,3,4,5,6,6,7,8,9,10,11,12,12,13,14,15,16,17,18,19,20,20,21,22,23,24,25,26,27,28,29,30,30,31,32,33,34,35,36,37,38,39,40,41,42,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974&#125;; int a(int N) &#123; bool light[1010] = &#123;0&#125;; for(int i = 1;i &lt;= N;i++) for(int j = i;j &lt;= N;j += i) light[j] = !light[j]; int cnt = 0; REP(N) &#123; if(!light[o + 1]) cnt++; &#125; return cnt;&#125; int main() &#123; int N; while(scanf(\"%d\",&amp;N) != EOF) printf(\"%d\\n\",ans[N]); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"打表","slug":"List","permalink":"https://www.oyohyee.com/tags/List/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"AOJ 801.热身之蘸酱吃","date":"2016-03-23T15:44:00.000Z","path":"/post/AOJ/801.html","text":"题目 Time Limit: 1000 msCase Time Limit: 1000 msMemory Limit: 64 MBTotal Submission: 108Submission Accepted: 50 Description 在ACM实验室里有n个草莓，编号依次为1到n，重量依次为w[1]，w[2],…,w[n]。由于某人比较喜欢蘸西瓜酱吃，在接下来的时间内，我会选择m个区间[l,r]并且随机选择一个数字k，使得标号在[l,r]区间内的每个草莓（包括端点）上面都加蘸了k重量的酱。这时候会突然出现T个区间[L,R]，对于每个区间，我们需要计算标号属于这个区间的草莓的重量和（包括上面的西瓜酱的重量，区间也包括端点）并输出。 Input 题目包括多组输入第一行输入3个数n，m，T,空格分开，1&lt;=n&lt;=1000，1&lt;=m&lt;=1000，1&lt;=T&lt;=1000第二行输入n个数，空格分开，w[1],w[2],…,w[n]，1&lt;=w[i]&lt;=100接下来m行,每行有三个数，空格分开，分别为l,r,k，1&lt;=l&lt;=r&lt;=n, 0&lt;=k&lt;=100接下来T行，每行有两个数，空格分开，分别为L,R, 1&lt;=L&lt;=R&lt;=n Output 输出公有T行，每行一个数字表示标号属于区间[L,R]的草莓加酱的重量 Sample Input 4 1 21 2 3 41 2 11 22 4 Sample Output 510 Hint 注意数据范围 题解直接强行模拟即可 代码#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;stack&gt;using namespace std; #define REP(n) for(int o=0;o&lt;n;o++) const int maxn = 1005;int w[maxn]; bool Do() &#123; int n,m,T; if(scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;T) == EOF) return false; REP(n) scanf(\"%d\",&amp;w[o+1]); REP(m) &#123; int l,r,k; scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;k); for(;l &lt;= r;l++) w[l] += k; &#125; REP(T) &#123; int L,R; int ans=0; scanf(\"%d%d\",&amp;L,&amp;R); for(;L &lt;= R;L++) ans += w[L]; printf(\"%d\\n\",ans); &#125; return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"AOJ 799.热身之回家养猪","date":"2016-03-23T15:43:00.000Z","path":"/post/AOJ/799.html","text":"题目 Time Limit: 1000 msCase Time Limit: 1000 msMemory Limit: 64 MBTotal Submission: 203Submission Accepted: 14 Description 快毕业了，同学们开始为自己的未来做打算。某人打算回家养猪。由于养猪还得去卖，所以交通是个问题，现在有n个村庄，村庄的编号是1到n，有m条路。若想使得所有的村庄连通，至少还需要修多少条路？ Input 题目包括多组输入第一行，n,m 1&lt;=n&lt;=1000, 0&lt;=m&lt;=n^2接下来m行，每行两个数 a,b ，用空格分隔，表示村庄a到村庄b已经有一条道路 Output 一行，一个数ans，表示至少还需要修的路的数量 Sample Input 3 11 2 Sample Output 1 Hint 需要修一条1到3的边或者2到3的边 题解可采用并查集求解，然而当时对并查集并不怎么熟练 采用了较为暴力的写法 代码#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std; #define REP(n) for(int o=0;o&lt;n;o++) const int maxn = 1005;int edge[maxn][maxn]; inline void road(int a,int b) &#123; edge[a][++edge[a][0]] = b; edge[b][++edge[b][0]] = a; //printf(\" %d %d\\n\",a,b);&#125; bool Do() &#123; int n,m; if(scanf(\"%d%d\",&amp;n,&amp;m) == EOF) return false; for(int i = 1;i &lt;= n;i++) edge[i][0] = 0; REP(m) &#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); road(a,b); &#125; bool can[maxn] = &#123;0&#125;; int cnt = 0; queue&lt;int&gt; Q; Q.push(1); while(!Q.empty()) &#123; int top = Q.front(); Q.pop(); if(can[top]) continue; can[top] = 1; REP(edge[top][0]) Q.push(edge[top][o+1]); &#125; /* printf(\"===\\n\"); REP(n) printf(\"can[%d]=%d\\n\",o + 1,can[o + 1]); */ while(1) &#123; bool ok = true; REP(n) &#123; if(!can[o + 1]) &#123; road(1,o + 1); cnt++; Q.push(o + 1); while(!Q.empty()) &#123; int top = Q.front(); Q.pop(); if(can[top]) continue; can[top] = 1; REP(edge[top][0]) &#123; Q.push(edge[top][o+1]); &#125; &#125; ok = false; break; &#125; &#125; if(ok) break; &#125; printf(\"%d\\n\",cnt); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"并查集","slug":"Union-Find","permalink":"https://www.oyohyee.com/tags/Union-Find/"}]},{"title":"AOJ 606.LOL系列之德玛短路","date":"2016-03-12T12:06:00.000Z","path":"/post/AOJ/606.html","text":"题目 Time Limit: 1000 msCase Time Limit: 1000 msMemory Limit: 64 MBTotal Submission: 215Submission Accepted: 79 Description 德玛的经典台词：人在塔在。由于最近LOL增加了草丛数量（草丛伦怎能不开心？！）由于太过于兴奋，盖伦突然变成白痴了- -，连最经典的台词都变为：人在塔亡（变身剑圣？）德玛现在的症状是：如果该单词在句子中的序号为素数的话，他就会把这个单词反过来说（abcd -&gt; dcba），为了治疗盖伦，你得和盖伦交流，寻求找到治疗他的方法。德玛说话完全变反了现在你的任务是将盖伦的话翻译回他本来的意思，比如德玛说:i evil dna tower tsixe其实他的本意是i live and tower exist（因为2,3,5是素数，所以这些位置上的单词反过来了）注意：1不是素数，而且可能会有许多多余的空格！ Input 输入包括多组测试数据，以文件(EOF）结束每行一个字符串，由小写字母和空格组成(最多不会超过500个单词，字符串总长度不超过10^5) Output 输出每个字符串对应的原意 Sample Input i evil dna tower tsixe Sample Output i live and tower exist Source2013年6月月赛。 from victoira 题解提交了10遍才AC 其中要注意对于每一个不是单词的字符，都要如实在输出，对于是单词的字符，按照要求输出。 要判断一个数是否是素数，打表或者用筛法 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.com*/#include &lt;cstdio&gt;using namespace std; #define REP(n) for(int o=0;o&lt;n;o++) const bool prime[] = &#123;0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0&#125;; const int maxn = 100005;char s[maxn]; int main() &#123; int i = 1;//第i个单词 char c; while((c = getchar()) != EOF) &#123; //如果是单词 if(c &gt;= 'a'&amp;&amp;c &lt;= 'z') &#123; //读入单词 s[0] = c; int size = 1; while(c = getchar(),c &gt;= 'a'&amp;&amp;c &lt;= 'z') s[size++] = c; //输出单词 if(prime[i]) REP(size) putchar(s[size - o - 1]); else REP(size) putchar(s[o]); i++;//记录单词序号 &#125; if(c == '\\n') &#123; i = 1; &#125; putchar(c); &#125; //putchar('\\n'); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"质数","slug":"Prime","permalink":"https://www.oyohyee.com/tags/Prime/"},{"name":"打表","slug":"List","permalink":"https://www.oyohyee.com/tags/List/"}]},{"title":"AOJ 708.序列匹配","date":"2016-03-12T12:04:00.000Z","path":"/post/AOJ/708.html","text":"题目 Time Limit: 5000 msMemory Limit: 128 MBTotal Submission: 146Submission Accepted: 34 Description 给定两个长度均为3的数字序列，每位上为一个范围是1-N的正整数，求有多少个仍然由3个1-N的整数构成的数字序列能与给定的两个序列中的任意一个匹配。如果两个序列匹配，当且仅当两个序列中的每个对应数字的最近距离不超过2。比如当N为9时，每一位数字可能是1,2,3,4,5,6,7,8,9，并且数字是循环的。也就是说9和1是相邻的。数字之间的距离就是两个数字的位置之差。也就是说在上面的例子中，9和1的最近距离是1,9和2的最近距离是2,2和5的最近距离是3。比如现在给定两个序列组合为(1,2,3)和(4,5,6), (2,4,8)或者(1, N, 5) 是能和两个序列匹配中的至少一个匹配的，但是(1, 5, 6)是不能和给定的两个序列中的任何一个匹配的。 Input 多组输入，以EOF结束。每组输入包含三行第一行为一个整数N(1 &lt;= N &lt;= 50)，第二行和第三行都是以三个空格分隔的整数。 Output 对于每组输入，输出一个数字，表示能和给定的两个序列中的任意一个匹配的序列的个数。 Sample Input 501 2 35 6 7 Sample Output 249 Source Roll 题解建立一个三维坐标系，把能覆盖到的地方全部标记上，然后计算数量 其中要注意小于等于0和大于N的情况（转换后还应该在0-N之间）。 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.com*/#include &lt;cstdio&gt;using namespace std; const int maxn = 55; bool Do() &#123; int N,a1,b1,c1,a2,b2,c2; int cnt = 0; if(scanf(\"%d%d%d%d%d%d%d\",&amp;N,&amp;a1,&amp;b1,&amp;c1,&amp;a2,&amp;b2,&amp;c2) == EOF) return false; bool map[maxn][maxn][maxn] = &#123;0&#125;; for(int x = a1 - 2;x &lt;= a1 + 2;x++) for(int y = b1 - 2;y &lt;= b1 + 2;y++) for(int z = c1 - 2;z &lt;= c1 + 2;z++) &#123; int xx = x &lt;= 0 ? N + x : x &gt; N ? x - N : x; int yy = y &lt;= 0 ? N + y : y &gt; N ? y - N : y; int zz = z &lt;= 0 ? N + z : z &gt; N ? z - N : z; if(!map[xx][yy][zz] &amp;&amp; xx &gt; 0 &amp;&amp; xx &lt;= N&amp;&amp;yy &gt; 0 &amp;&amp; yy &lt;= N&amp;&amp;zz &gt; 0 &amp;&amp; zz &lt;= N) cnt++; map[xx][yy][zz] = 1; &#125; for(int x = a2 - 2;x &lt;= a2 + 2;x++) for(int y = b2 - 2;y &lt;= b2 + 2;y++) for(int z = c2 - 2;z &lt;= c2 + 2;z++) &#123; int xx = x &lt;= 0 ? N + x : x &gt; N ? x - N : x; int yy = y &lt;= 0 ? N + y : y &gt; N ? y - N : y; int zz = z &lt;= 0 ? N + z : z &gt; N ? z - N : z; if(!map[xx][yy][zz] &amp;&amp; xx &gt; 0 &amp;&amp; xx &lt;= N&amp;&amp;yy &gt; 0 &amp;&amp; yy &lt;= N&amp;&amp;zz &gt; 0 &amp;&amp; zz &lt;= N) cnt++; &#125; printf(\"%d\\n\",cnt); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"}]},{"title":"AOJ 589.多米诺","date":"2016-03-12T12:02:00.000Z","path":"/post/AOJ/589.html","text":"题目 Time Limit: 1000 msCase Time Limit: 1000 msMemory Limit: 64 MBTotal Submission: 34Submission Accepted: 12 Description 有一个n*m的网格，用一些2*1的多米诺去填充。有以下规则：1、每一个多米诺必须完整覆盖两个格子2、多米诺之间不能重叠3、多米诺不能超过网格边界4、摆放多米诺时可以旋转，但是不能斜着摆放问最多可以用多少个多米诺去覆盖网格。 Input 一个整数 T，表示有 T 组测试数据。（1&lt;=T&lt;=3000）每组数据输入格式如下：对于每一组数据，输入如下：两个整数n,m （1&lt;=n,m&lt;=100000） Output 对于每一组数据，输出一个整数，表示最多可以摆放的多米诺的数量 Sample Input 31 24 23 3 Sample Output 144 题解贪心算法？不算贪心算法吧~先竖着摆，尽可能摆满（m*n/2），剩下的位置换个方向尽可能摆（n/2）*（m%2），加起来即可 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.com*/#include &lt;cstdio&gt;using namespace std; int main() &#123; int T,n,m; scanf(\"%d\",&amp;T); while(T--) &#123; scanf(\"%d%d\",&amp;n,&amp;m); printf(\"%lld\\n\",(long long)(n / 2)*(long long)m + (long long) (n % 2)*(long long)(m / 2)); &#125; return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"}]},{"title":"AOJ 335.三角形","date":"2016-03-12T11:59:00.000Z","path":"/post/AOJ/335.html","text":"题目 Time Limit: 1000 ms Case Time Limit: 1000 ms Memory Limit: 64 MBTotal Submission: 41 Submission Accepted: 26 Description 一个名为PC的安大学生希望写一个程序来计算三角形的三条边长，你可以帮帮她吗？ Input 第一行是一个整数m(0&lt;m&lt;200)，代表有m组数据。之后m行，每行有三个整数(x&lt;10000),三角形的三条边 Output 如果可以构成三角形，输出三边之和，否则输出”Wrong” Sample Input 23 4 53 4 9 Sample Output 12Wrong Hint 采用结构：……scanf(“%d”,&amp;ncase);for(……){scanf(……);……printf(……);} 题解使用三角形两边之和大于第三边、两边之差（的绝对值）小于第三边判断三角形是否成立 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.com*/#include &lt;cstdio&gt;using namespace std; int main() &#123; int m,a,b,c; scanf(\"%d\",&amp;m); while(m--) &#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); if(a + b &gt; c &amp;&amp; abs(a - b) &lt; c) &#123; printf(\"%d\\n\",a + b + c); &#125; else &#123; printf(\"Wrong\\n\"); &#125; &#125; return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"}]},{"title":"AOJ 162.杨辉三角","date":"2016-03-12T11:57:00.000Z","path":"/post/AOJ/162.html","text":"题目 Time Limit: 1000 msCase Time Limit: 1000 msMemory Limit: 64 MBTotal Submission: 47Submission Accepted: 26 Description 11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 1上面的图形熟悉吗？它就是我们中学时候学过的杨辉三角。现在请你输出一个m层的杨辉三角 Input 输入包含n组数据行1至行n：一个正整数m，m∈[1,30]行n+1：一个整数0，代表输入结束 Output 对应于每一个输入，请输出相应层数的杨辉三角每一层的整数之间用一个空格隔开每一个杨辉三角后面加一个空行 Sample Input 230 Sample Output 11 1 11 11 2 1 题解动态规划 s[i][j]=s[i-1][j]+s[i-1][j-1] 不过数据只有30组，可以采用打表法 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.com*/#include &lt;cstdio&gt;using namespace std; char s[30][10000] = &#123; \"1\", \"1 1\", \"1 2 1\", \"1 3 3 1\", \"1 4 6 4 1\", \"1 5 10 10 5 1\", \"1 6 15 20 15 6 1\", \"1 7 21 35 35 21 7 1\", \"1 8 28 56 70 56 28 8 1\", \"1 9 36 84 126 126 84 36 9 1\", \"1 10 45 120 210 252 210 120 45 10 1\", \"1 11 55 165 330 462 462 330 165 55 11 1\", \"1 12 66 220 495 792 924 792 495 220 66 12 1\", \"1 13 78 286 715 1287 1716 1716 1287 715 286 78 13 1\", \"1 14 91 364 1001 2002 3003 3432 3003 2002 1001 364 91 14 1\", \"1 15 105 455 1365 3003 5005 6435 6435 5005 3003 1365 455 105 15 1\", \"1 16 120 560 1820 4368 8008 11440 12870 11440 8008 4368 1820 560 120 16 1\", \"1 17 136 680 2380 6188 12376 19448 24310 24310 19448 12376 6188 2380 680 136 17 1\", \"1 18 153 816 3060 8568 18564 31824 43758 48620 43758 31824 18564 8568 3060 816 153 18 1\", \"1 19 171 969 3876 11628 27132 50388 75582 92378 92378 75582 50388 27132 11628 3876 969 171 19 1\", \"1 20 190 1140 4845 15504 38760 77520 125970 167960 184756 167960 125970 77520 38760 15504 4845 1140 190 20 1\", \"1 21 210 1330 5985 20349 54264 116280 203490 293930 352716 352716 293930 203490 116280 54264 20349 5985 1330 210 21 1\", \"1 22 231 1540 7315 26334 74613 170544 319770 497420 646646 705432 646646 497420 319770 170544 74613 26334 7315 1540 231 22 1\", \"1 23 253 1771 8855 33649 100947 245157 490314 817190 1144066 1352078 1352078 1144066 817190 490314 245157 100947 33649 8855 1771 253 23 1\", \"1 24 276 2024 10626 42504 134596 346104 735471 1307504 1961256 2496144 2704156 2496144 1961256 1307504 735471 346104 134596 42504 10626 2024 276 24 1\", \"1 25 300 2300 12650 53130 177100 480700 1081575 2042975 3268760 4457400 5200300 5200300 4457400 3268760 2042975 1081575 480700 177100 53130 12650 2300 300 25 1\", \"1 26 325 2600 14950 65780 230230 657800 1562275 3124550 5311735 7726160 9657700 10400600 9657700 7726160 5311735 3124550 1562275 657800 230230 65780 14950 2600 325 26 1\", \"1 27 351 2925 17550 80730 296010 888030 2220075 4686825 8436285 13037895 17383860 20058300 20058300 17383860 13037895 8436285 4686825 2220075 888030 296010 80730 17550 2925 351 27 1\", \"1 28 378 3276 20475 98280 376740 1184040 3108105 6906900 13123110 21474180 30421755 37442160 40116600 37442160 30421755 21474180 13123110 6906900 3108105 1184040 376740 98280 20475 3276 378 28 1\", \"1 29 406 3654 23751 118755 475020 1560780 4292145 10015005 20030010 34597290 51895935 67863915 77558760 77558760 67863915 51895935 34597290 20030010 10015005 4292145 1560780 475020 118755 23751 3654 406 29 1\"&#125;; int main() &#123; int m; while(scanf(\"%d\",&amp;m),m!=0) &#123; for(int i = 0;i &lt; m;i++) printf(\"%s\\n\",s[i]); printf(\"\\n\"); &#125; /* int s[31][31] = &#123;0&#125;; s[0][0] = 1; for(int i = 1;i &lt;= 30;i++) &#123; for(int j = 1;j &lt;= i;j++) &#123; s[i][j] = s[i - 1][j - 1] + s[i - 1][j]; &#125; &#125; for(int i = 1;i &lt;= 30;i++) &#123; printf(\"\\\"\"); for(int j = 1;j &lt;= i;j++) &#123; printf(\"%d\",s[i][j]); if(j != i) printf(\" \"); &#125; printf(\"\\\",\"); printf(\"\\n\"); &#125; */ return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"打表","slug":"List","permalink":"https://www.oyohyee.com/tags/List/"}]},{"title":"AOJ 609.LOL系列之回到现实","date":"2016-03-12T11:55:00.000Z","path":"/post/AOJ/609.html","text":"题目 Time Limit: 1000 msCase Time Limit: 1000 msMemory Limit: 64 MBTotal Submission: 72Submission Accepted: 28 Description 天天LOL，没怎么上过自习，这就是小小明生活的真实写照，殊不知，期末考试悄悄降临，首先考的是大物，纳尼？！！！这学期物理卷子改版？只有一道计算题？！题目描述如下：你在一数轴原点上，需要朝正方向一颗炮弹，你可以给炮弹提供的最大初速度为V，你应该调整炮弹的发射角度为多少才可以使得炮弹水平飞行距离最大呢？请输出炮弹最远飞行的水平距离，由于期末考试只有一题，所以要么AC，要么挂大物，你们自己看着办吧（这就是天天撸的后果，学霸们早已在你们看完这题的时候AC了）（g = 9.8）注：不考虑空气阻力 Input 输入包括多组数据，以文件(EOF）结束每组测试数据只包括一个实数v(v&gt;0)，表示可以提供的最大初始速度 Output 输出一个实数x（精确到小数点后3位）表示最远飞行距离 Sample Input 2 Sample Output 0.408 题解物理公式推导可得答案算法 x=v^2/g 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.com*/#include &lt;cstdio&gt;using namespace std; int main() &#123; double v; while(scanf(\"%lf\",&amp;v) != EOF) printf(\"%.3f\\n\",v*v / 9.8); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"}]},{"title":"AOJ 579.期末考试之传纸条","date":"2016-03-12T11:53:00.000Z","path":"/post/AOJ/579.html","text":"题目 Time Limit: 1000 msCase Time Limit: 1000 msMemory Limit: 32 MBTotal Submission: 12Submission Accepted: 8 Description 平时不努力，考试得着急呐。传说中的BT监考老师竟然搬来了信号屏蔽工具，手机不管用啦有木有。不过这难不到大家，cxlove见证了同学们使用传统的作弊方式—-传纸条，纸条得从A同学传到B同学处，在一个N*M的教室里，零散着坐着一些同学，监考老师游荡在教室某些位置，能否成功将纸条传到B同学处，且不被老师发现。每一次传纸条不能斜传，只能传给前后左右四个同学，监考老师的监视范围为相邻的八个位置，当纸条传到老师监视范围内就会被逮住了，纸条传到空位置处时传送失败。帮cxlove计算下最少需要多少时间才能完成传纸条。 Input 多组测试数据第一行两个整数，N,M(1&lt;=N,M&lt;=100)，分别表示教室有N*M个位置接下来N行，每行M个字符，表示教室的情况‘A’表示纸条的初始位置，’B’表示纸条的目标位置，’.’表示一般同学的位置，’#’表示当前位置没有人坐，’T’表示监考老师。（可能有多个监考老师） Output 输出仅一个整数，表示需要的最少时间传到B同学处如果不能传达，输出-1 Sample Input 5 5A.T...#..#…...….B1 5A.T.B Sample Output 8-1 题解BFS寻路 注意各种边界条件 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.com*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std; const int maxn = 105; char map[maxn][maxn];const int delta[] = &#123;0,0,1,-1&#125;; bool Do() &#123; int n,m; int x1,y1,x2,y2; if(scanf(\"%d%d\",&amp;n,&amp;m) == EOF) return false; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) map[i][j] = '.'; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) &#123; char temp; scanf(\"\\n%c\\n\",&amp;temp); if(temp == 'A') &#123; x1 = i; y1 = j; &#125; if(temp == 'B') &#123; x2 = i; y2 = j; &#125; if(temp == 'T') &#123; temp = '#'; for(int k = 0;k &lt; 4;k++) &#123; int xx = i + delta[k]; int yy = j + delta[3 - k]; if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;=0 &amp;&amp; yy &lt; m) map[xx][yy] = '#'; &#125; for(int k = 2;k &lt; 4;k++) &#123; for(int l = 2;l &lt; 4;l++) &#123; int xx = i + delta[k]; int yy = j + delta[l]; if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m) map[xx][yy] = '#'; &#125; &#125; &#125; if(temp == '#') map[i][j] = '#'; &#125; /* for(int i = 0;i &lt; n;i++) &#123; for(int j = 0;j &lt; m;j++) printf(\"%c\",map[i][j]); printf(\"\\n\"); &#125; */ queue &lt;pair&lt;int,int&gt; &gt; Q; int len[maxn][maxn] = &#123;0&#125;; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; m;j++) len[i][j] = -1; len[x1][y1] = 0; Q.push(pair&lt;int,int&gt;(x1,y1)); while(!Q.empty()) &#123; int x = Q.front().first; int y = Q.front().second; Q.pop(); if(x == x2 &amp;&amp; y == y2) break; for(int i = 0;i &lt; 4;i++) &#123; int xx = x + delta[i]; int yy = y + delta[3 - i]; if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy&gt;=0 &amp;&amp; yy &lt; m &amp;&amp; map[xx][yy]=='.' &amp;&amp; len[xx][yy] == -1) &#123; len[xx][yy] = len[x][y] + 1; Q.push(pair&lt;int,int&gt;(xx,yy)); &#125; &#125; &#125; printf(\"%d\\n\",len[x2][y2]); return true;&#125; int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"}]},{"title":"AOJ 491.扑克牌","date":"2016-03-12T11:52:00.000Z","path":"/post/AOJ/491.html","text":"题目 Time Limit: 1000 msCase Time Limit: 1000 msMemory Limit: 64 MBTotal Submission: 54Submission Accepted: 24 Description 扑克牌大家非常熟悉，扑克牌从小到大的顺序为：3,4,5,6,7,8,9,10,J,Q,K,A,2我们就做个简单的事，单张扑克牌比大小，并且还没有花色区别，也没有大小王。 Input 第1行：一个整数T（T&lt;=20），代表测试数据的组数。第2到T+1行：每行输入两个扑克牌值，也就是描述中的那13个代号，以空格分隔。输入的字母为大写字母。 Output 输出T行，每行为前者和后者的关系。前者大于后者则输出&gt;前者等于后者则输出=前者小于后者则输出&lt; Sample Input 23 3A K Sample Output => 题解应特别注意其中唯一一个占据两个字符空间10。 可以通过读入字符串来读入数据，判断c[0]（因为1对应的只有10，数字1用A表示） 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.com*/#include &lt;cstdio&gt;using namespace std; const char d[13] = &#123;'3','4','5','6','7','8','9','1','J','Q','K','A','2'&#125;; int main() &#123; int T; scanf(\"%d\",&amp;T); REP(T) &#123; char a[3],b[3]; scanf(\"\\n%s%s\\n\",&amp;a,&amp;b); if(a[0] == b[0]) &#123; printf(\"=\\n\"); continue; &#125; int i,j; for(i = 0;i &lt; 13;i++) if(d[i] == a[0]) break; for(j = 0;j &lt; 13;j++) if(d[j] == b[0]) break; printf(\"%c\\n\",i &lt; j ? '&lt;' : '&gt;'); &#125; return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"AOJ 718.计算GPA","date":"2016-03-12T11:47:00.000Z","path":"/post/AOJ/718.html","text":"题目 Time Limit: 1000 msCase Time Limit: 1000 msMemory Limit: 128 MBTotal Submission: 72Submission Accepted: 32 Description 上学期面对繁重的课程和考试，TYF终于考完了。成绩出来之后，TYF想看一下GPA(Grade Point Average,平均成绩点数)是多少，之后他熟练的打开了教务处，看到绩点显示0.00，他丝毫没有感到吃惊，他知道教务处又出现问题了。之后TYF决定自己写一个程序来计算自己的GPA。想必大家都知道GPA如何计算的，就是加权平均数。计算方式如下：例如某学生的五门课程的学分和他所获得的绩点为：A课程四个学分，绩点4；B课程三个学分，绩点3；C课程两个学分，绩点4；D课程六个学分，绩点2；E课程三个学分，绩点3。以上五项成绩GPA为：GPA=（44+33+24+62+3*3）/（4+3+2+6+3）=3.00现在让你帮助TYF完成这项任务。 Input 多组输入，EOF结束对于每组输入，第一行一个整数n (1&lt;=n&lt;=40)，表示课程的数目。接下来n行，每行两个数，一个整数ai(1&lt;=ai&lt;=10)表示一门课的学分，一个浮点数bi(0&lt;=bi&lt;=4.00),表示一门课的绩点。 Output 对于每组输入，输出一行， 为平均成绩点数（保留两位小数)。 Sample Input 54 4.03 3.02 4.06 2.03 3.0 Sample Output 3.00 题解按照公式计算即可 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.com*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;stack&gt;using namespace std; #define REP(n) for(int o=0;o&lt;n;o++) int main() &#123; int n; while(scanf(\"%d\",&amp;n) != EOF) &#123; double ans1 = 0,ans2 = 0; double a,b; REP(n) &#123; scanf(\"%lf%lf\",&amp;a,&amp;b); ans1 += a*b; ans2 += a; &#125; printf(\"%.2f\\n\",ans2 != 0 ? ans1 / ans2 : 0); &#125; return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"AOJ 11.Rails","date":"2016-03-09T08:28:00.000Z","path":"/post/AOJ/11.html","text":"模拟栈 按照目标一个一个试着移动即可#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;stack&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 1005;bool Do() &#123; int n; int a[maxn]; scanf(\"%d\",&amp;n); if(n == 0) return false; while(scanf(\"%d\",&amp;a[0]),a[0] != 0) &#123; REP(n - 1) scanf(\"%d\",&amp;a[o + 1]); stack&lt;int&gt; S,A; REP(n) A.push(n - o); bool ok = true; //尝试将编号i+1出站 for(int i = 0;i &lt; n;i++) &#123; //从中转站出站 /* while的原理 如果中转站中的车符合要求，让它出站，结束该次循环·····1 如果中转站最外面的车不符合要求，检查A口，将它进站，继续上一步·····2 如果A口已经没有车，则无解·····3 */ while(1) &#123; if(!S.empty()&amp;&amp;S.top() == a[i]) &#123;//·····1 S.pop(); break; &#125; else &#123;//·····3 if(A.empty()) &#123; ok = false; break; &#125; else &#123;//·····2 S.push(A.top()); A.pop(); &#125; &#125; &#125; //不能达到题目的要求 if(!ok) break; &#125; printf(\"%s\",ok ? \"Yes\\n\" : \"No\\n\"); &#125; printf(\"\\n\"); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"栈(stack)","slug":"Stack","permalink":"https://www.oyohyee.com/tags/Stack/"}]},{"title":"AOJ 592.神奇的叶子","date":"2016-03-07T14:57:00.000Z","path":"/post/AOJ/592.html","text":"水题 等差数列求和 #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)int main() &#123; int a1,n,d; scanf(\"%d%d%d\",&amp;a1,&amp;n,&amp;d); printf(\"%d\\n\",a1*n + (n*(n - 1)*d) / 2); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"AOJ 10.目标柏林","date":"2016-03-07T13:30:00.000Z","path":"/post/AOJ/10.html","text":"优化！优化！ 读入的字符串包含空格！ 数据量较大，vector string都会降低效率 简直优化哭了要( ▼-▼ )#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1005;int read(char s[]) &#123; char c; int i = 0; c = getchar(); if(c == EOF) return 0; while(c != '\\n'&amp;&amp;c != EOF) &#123; s[i++] = c; c = getchar(); &#125; s[i] = '\\0'; return i;&#125;int main() &#123; //std::ios::sync_with_stdio(false); char s[maxn]; while(read(s)) &#123; int len = (int)strlen(s); for(int i = len / 2 + 1;i &gt; 0;i--) &#123; char temp[maxn]; strcpy(temp,s); int v[maxn]; int it = 0; for(int j = i;j &lt;= len;j += i) v[it++] = j; for(int j = 0;j &lt; it;j++) &#123; int t = (i % 2 ? j + 1 : j - 1); t = t == -1 ? it - 1 : t == it ? t == 0 : t; s[v[j] - 1] = temp[v[t] - 1]; &#125; //cout &lt;&lt; \" \" &lt;&lt; s &lt;&lt; endl; //v.erase(v.begin(),v.end()); &#125; cout &lt;&lt; s &lt;&lt; endl; &#125; return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"AOJ 9.University","date":"2016-03-07T11:40:00.000Z","path":"/post/AOJ/9.html","text":"打表#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 10000005;bool is_prime[maxn];int prime_cnt[maxn];void prime() &#123; memset(is_prime,true,sizeof(is_prime)); int len = (int)sqrt(maxn + 0.5); for(int i = 2;i &lt;= len;i++) if(is_prime[i]) for(int j = i*i;j &lt; maxn;j += i) is_prime[j] = false; is_prime[1] = false; prime_cnt[0] = 0; for(int i = 1;i &lt; maxn;i++) prime_cnt[i] = prime_cnt[i - 1] + is_prime[i];&#125;int main() &#123; prime(); int n; while(scanf(\"%d\",&amp;n), n!= 0) &#123; printf(\"%d\\n\",prime_cnt[n]); &#125; return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"打表","slug":"List","permalink":"https://www.oyohyee.com/tags/List/"}]},{"title":"AOJ 8.童年生活二三事","date":"2016-03-07T11:23:00.000Z","path":"/post/AOJ/8.html","text":"动态规划+打表#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 41;int ans[maxn]=&#123;1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141&#125;;int main() &#123; //ans[0] = 1; //ans[1] = 1; //for(int i = 2;i &lt; maxn;i++) &#123; // ans[i] = ans[i - 1] + ans[i - 2]; //&#125; //printf(\"ans[]=&#123;\"); //REP(maxn) // printf(\"%d,\",ans[o]); //printf(\"&#125;;\\n\"); int n; while(scanf(\"%d\",&amp;n),n != 0) &#123; printf(\"%d\\n\",ans[n]); &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"Dp","permalink":"https://www.oyohyee.com/tags/Dp/"},{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"打表","slug":"List","permalink":"https://www.oyohyee.com/tags/List/"}]},{"title":"AOJ 7.Redraiment猜想","date":"2016-03-07T11:22:00.000Z","path":"/post/AOJ/7.html","text":"筛法求素数#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 10000005;bool is_prime[maxn];int prime_cnt[maxn];void prime() &#123; memset(is_prime,true,sizeof(is_prime)); int len = (int)sqrt(maxn + 0.5); for(int i = 2;i &lt;= len;i++) if(is_prime[i]) for(int j = i*i;j &lt; maxn;j += i) is_prime[j] = false; is_prime[1] = false; prime_cnt[0] = 0; for(int i = 1;i &lt; maxn;i++) prime_cnt[i] = prime_cnt[i - 1] + is_prime[i];&#125;int main() &#123; prime(); int n; while(scanf(\"%d\",&amp;n), n!= 0) &#123; printf(\"%d\\n\",prime_cnt[n]); &#125; return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"质数","slug":"Prime","permalink":"https://www.oyohyee.com/tags/Prime/"}]},{"title":"AOJ 667.抢占白房子","date":"2016-03-05T17:30:00.000Z","path":"/post/AOJ/667.html","text":"题目 Time Limit: 1000 msCase Time Limit: 1000 msMemory Limit: 64 MBTotal Submission: 79Submission Accepted: 25 Description 在一个8×8的宫格图中，每个格子要么是白色，要么是黑色，且相邻的两个格子的颜色一定不同；已知左上角（1，1）的格子的颜色为白色。现给出用字符描述的该图G，如果有G（i，j）=’F’，则说明从上向下数的第i行（从1开始数），从左向右数的第j行（从1开始数）交叉的格子被占领，否则这个格子是空的，未被占领。求出被占领的白格子数量。 Input 单组数据一个8×8的地图，具体参考输入样例。 Output 一个整数：被占领的白格子数量。 Sample Input ……....F…..…..F..…..F..……..……..…….F.F…… Sample Output 2 题解若从（0，0）开始，则横坐标和纵坐标对2取余后再取反为真的为白房子。 输入读到’F’时，!((x%2)^(y%2))判断即可 代码/*By:OhYeeGithub:OhYeeEmail:oyohyee@oyohyee.com*/#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;stack&gt;using namespace std; int main() &#123; int cnt = 0; for(int i = 0;i &lt; 8;i++) for(int j = 0;j &lt; 8;j++) &#123; char temp; scanf(\"\\n%c\\n\",&amp;temp); //printf(\"i=%d j=%d -&gt; %c\\n\",i,j,temp); if(temp == 'F') if(!((i % 2) ^ (j % 2)))//奇偶性相同的为白色，对2取模后异或取反 cnt++; &#125; printf(\"%d\\n\",cnt); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"}]},{"title":"AOJ 6.Hero In Maze","date":"2016-03-05T17:30:00.000Z","path":"/post/AOJ/6.html","text":"简单的最短路 BFS DFS都可以实现（BFS应该会更快一点吧） 其中输入的N、M、T中，N是列，M是行，而不是和大多数题目一样，N是行，M是列 另外，类中不要乱放常量，类中不要直接为类变量赋初值（不是所有编译器都承认貌似~） #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)const int maxn = 25;const int delta[4] = &#123;0,0,1,-1&#125;;class LOVE &#123;private: int N,M,T; int x1,y1,x2,y2; bool visited[maxn][maxn];//是否已访问过该位置 char map[maxn][maxn];//地图 int ans;//结果 void dfs(int x,int y,int l) &#123; if(x &lt; 0 || y &lt; 0 || x &gt;= M || y &gt;= N || visited[x][y] == true || map[x][y] == '*') return; if(x == x2&amp;&amp;y == y2) ans = l; visited[x][y] = true; for(int i = 0;i &lt; 4;i++) dfs(x + delta[i],y + delta[3 - i],l + 1); &#125;public: bool Do() &#123; scanf(\"%d%d%d\",&amp;N,&amp;M,&amp;T); //测试数据结束 if(N == 0 &amp;&amp; M == 0 &amp;&amp; T == 0) return false; //输入地图 for(int i = 0;i &lt; M;i++) &#123; for(int j = 0;j &lt; N;j++) &#123; char temp; scanf(\"\\n%c\\n\",&amp;temp); if(temp == 'S') &#123; x1 = i; y1 = j; temp = '.'; &#125; if(temp == 'P') &#123; x2 = i; y2 = j; temp = '.'; &#125; map[i][j] = temp; &#125; &#125; //输出地图 /* for(int i = 0;i &lt; M;i++) &#123; for(int j = 0;j &lt; N;j++) printf(\"%c\",map[i][j]); printf(\"\\n\"); &#125; printf(\"\\n\"); */ //初始化 ans = -1; memset(visited,false,sizeof(visited)); //dfs寻求最短路（用bfs应该会更快点，不过数据小，就不改了） dfs(x1,y1,0); /* for(int i = 0;i &lt; M;i++) &#123; for(int j = 0;j &lt; N;j++) printf(\"%d\",visited[i][j]); printf(\"\\n\"); &#125; printf(\"\\n\"); */ printf(\"%s\\n\",ans == -1 || ans &gt; T ? \"NO\" : \"YES\"); return true; &#125;&#125;;int main() &#123; LOVE LIVE; while(LIVE.Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"https://www.oyohyee.com/tags/BFS/"},{"name":"DFS","slug":"DFS","permalink":"https://www.oyohyee.com/tags/DFS/"}]},{"title":"AOJ 5.渊子赛马","date":"2016-03-05T06:14:00.000Z","path":"/post/AOJ/5.html","text":"贪心算法#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)bool Do() &#123; const int maxn = 1005; int N;//马的数量 int a[maxn];//渊子的马 int b[maxn];//对手的马 //数据读入 scanf(\"%d\",&amp;N); if(N == 0) return false; REP(N) scanf(\"%d\",&amp;a[o]); REP(N) scanf(\"%d\",&amp;b[o]); //从小到大排序 sort(a,a + N); sort(b,b + N); int ans = 0; int i = 0,j = 0; while(1) &#123; while(a[i] &lt;= b[j]) &#123; i++; if(i &gt;= N) break; &#125; if(i &gt;= N) break; ans++; i++; if(i &gt;= N) break; j++; if(j &gt;= N) break; &#125; printf(\"%s\\n\",2 * ans &gt; N ? \"YES\" : \"NO\"); return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"}]},{"title":"AOJ 4.1、2、3、4、5","date":"2016-03-05T05:50:00.000Z","path":"/post/AOJ/4.html","text":"鸡兔同笼 注意各种Error情况#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)bool Do() &#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); if(n == 0 &amp;&amp; m == 0)return false; int r,c; r = m / 2 - n; c = n - r; if(m % 2 != 0 || r &lt; 0 || c &lt; 0) &#123; printf(\"Error\\n\"); &#125; else &#123; printf(\"%d %d\\n\",c,r); &#125; return true;&#125;int main() &#123; while(Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"}]},{"title":"AOJ 3.Redraiment的遭遇","date":"2016-03-05T05:32:00.000Z","path":"/post/AOJ/3.html","text":"打表 要注意不到7月前和8月后的情况 同时注意“0号”等特殊情况#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)//bool first = true;int main() &#123; bool a[2][32];//是否停电 memset(a, 0, sizeof(a)); //停电日期打表 int i = 1; bool *it = &amp;a[0][1]; bool first_8 = true; while (1) &#123; if (it &gt; &amp;a[1][31]) break; if (it &gt;= &amp;a[1][0] &amp;&amp; first_8 == true) &#123; first_8 = false; it++; &#125; *it = true; it += ++i; &#125; //日历输出调试 /** for (int i = 0; i &lt; 2; i++) &#123; printf(\"%d\\n\", i + 7); for (int j = 1; j &lt; 32; j++) &#123; printf(\"%3d(%d) \", j, a[i][j]); if (j % 7 == 0)printf(\"\\n\"); &#125; printf(\"\\n\"); &#125; /**/ //输出 int m, d; scanf(\"%d/%d\", &amp;m, &amp;d); while (m != 0 &amp;&amp; d != 0) &#123; /* if (!first) printf(\"\\n\"); first = false; */ //月份不在7、8月 if (m &lt; 7) &#123; printf(\"10\\n\"); scanf(\"%d/%d\", &amp;m, &amp;d); continue; &#125; if (m &gt; 8) &#123; printf(\"0\\n\"); scanf(\"%d/%d\", &amp;m, &amp;d); continue; &#125; int cnt = 0; for (bool *i = &amp;a[m - 7][d]; i &lt;= &amp;a[1][31]; i++) &#123; if (i == &amp;a[1][0]) continue; if (*i == true) cnt++; &#125; printf(\"%d\\n\", cnt); scanf(\"%d/%d\", &amp;m, &amp;d); &#125; return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"打表","slug":"List","permalink":"https://www.oyohyee.com/tags/List/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"}]},{"title":"AOJ 2.Home Work","date":"2016-03-05T05:30:00.000Z","path":"/post/AOJ/2.html","text":"打表 要注意不到7月前和8月后的情况 同时注意“0号”等特殊情况#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)class LOVE &#123;private: static const int maxn = 25; int M, N; struct node &#123; int T, V; double p; &#125;paper[maxn]; static bool compare_node(node a, node b) &#123; return a.p &gt; b.p; &#125;public: bool Do() &#123; scanf(\"%d%d\", &amp;M, &amp;N); if (M == 0 &amp;&amp; N == 0)return false; REP(M) &#123; int T, V; scanf(\"%d%d\", &amp;T, &amp;V); paper[o].T = T; paper[o].V = V; paper[o].p = (double)V / (double)T; &#125; sort(paper, paper + M, compare_node); //REP(M) //printf(\"T=%d V=%d p=%f\\n\", paper[o].T, paper[o].V, paper[o].p); double ans = 0; for (int i = 0; i &lt; M; i++) &#123; int temp = N - paper[i].T; ans += paper[i].V; if (temp &lt; 0) &#123; ans += temp*paper[i].p; break; &#125; N = temp; &#125; printf(\"%.2f\\n\", ans); return true; &#125;&#125;;int main() &#123; LOVE LIVE; while (LIVE.Do()); return 0;&#125;","tags":[{"name":"AOJ","slug":"AOJ","permalink":"https://www.oyohyee.com/tags/AOJ/"},{"name":"贪心算法","slug":"Greed","permalink":"https://www.oyohyee.com/tags/Greed/"}]},{"title":"Uva 400.Unix is","date":"2016-02-26T17:08:00.000Z","path":"/post/Uva/400.html","text":"怎么看这道题都是理解比实现难 特别是英语版，最后如何输出被绕进去了 大概意思就是在保证每行不超过60字符的情况下，尽可能让行数最少输出。 注意三目运算符的运算优先度，记得加括号#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class LOVE&#123; private: static const int len=65; static const int maxn=105; public: bool Do()&#123; int n,Max=0; if(!(cin&gt;&gt;n)) return false; cout&lt;&lt;\"------------------------------------------------------------\\n\"; string str[maxn]; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;str[i]; Max=max(Max,(int)str[i].size()); &#125; sort(str,str+n); int L,H; for(int i=n;i&gt;0;i--)&#123; L=i; H=n/L+(n%L?1:0); int size=Max*L+2*(L-1); if(size&lt;=60)break; &#125; //cout&lt;&lt;\"\\n\"&lt;&lt;L&lt;&lt;\" \"&lt;&lt;H&lt;&lt;\"\\n\"; for(int i=0;i&lt;H;i++)&#123; for(int j=0;j&lt;L;j++)&#123; cout&lt;&lt;str[i+j*H]; for(int k=0;k&lt;(j==L-1?0:2)+Max-(int)str[i+j*H].size();k++) cout&lt;&lt;\" \"; &#125; cout&lt;&lt;\"\\n\"; &#125; return true; &#125;&#125;;int main()&#123; //freopen(\"in.txt\",\"r\",stdin); std::ios::sync_with_stdio(false); LOVE LIVE; while(LIVE.Do()); return 0;&#125;","tags":[{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"}]},{"title":"Uva 540.Team Queue","date":"2016-02-18T13:08:00.000Z","path":"/post/Uva/540.html","text":"队列问题，思路较为清晰 通过模拟操作可以发现可以先队内排列，然后进行队伍排列 其中个别操作由于vector、map嵌套，可能会发生打错凌乱的情况。#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;int kase=0;class LOVE&#123; private: vector&lt;int&gt; Q; queue&lt;int&gt; Q_team[1005]; map&lt;int,int&gt; team; void debug()&#123; printf(\"\\n\"); printf(\"################\\n\"); for(size_t i=0;i&lt;Q.size();i++) printf(\"%d \",Q[i]); printf(\"\\n\"); for(int i=0;i&lt;1005;i++) if(!Q_team[i].empty()) printf(\"%d\\n\",i); printf(\"################\\n\\n\"); &#125; public: bool start()&#123; //Init Q.erase(Q.begin(),Q.end()); for(int i=0;i&lt;1005;i++) while(!Q_team[i].empty()) Q_team[i].pop(); team.clear(); //Input int n; scanf(\"%d\",&amp;n); if(n==0) return false; printf(\"Scenario #%d\\n\",++kase); for(int i=0;i&lt;n;i++)&#123; int m; scanf(\"%d\",&amp;m); while(m--)&#123; int temp; scanf(\"%d\",&amp;temp); team[temp]=i; &#125; &#125; char com[10]; while(scanf(\"%s\",com),com[0]!='S')&#123; if(com[0]=='E')&#123; int temp; scanf(\"%d\",&amp;temp); Q_team[team[temp]].push(temp); if(find(Q.begin(),Q.end(),team[temp])==Q.end())&#123; Q.push_back(team[temp]); &#125; &#125; if(com[0]=='D')&#123; int t= *Q.begin(); printf(\"%d\\n\",Q_team[t].front()); Q_team[t].pop(); if(Q_team[t].empty()) Q.erase(Q.begin()); &#125; &#125; printf(\"\\n\"); return true; &#125;&#125;;int main()&#123; //freopen(\"in.txt\",\"r\",stdin); LOVE LIVE; while(LIVE.start()); return 0;&#125;","tags":[{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"}]},{"title":"Uva 12096.The SetStack Computer","date":"2016-02-17T09:37:00.000Z","path":"/post/Uva/12096.html","text":"嗯……这道题大思路很明显，但是细节好烦人…… 大体上就是stack+set 对于栈中的元素，可以发现每个元素都是一个集合（set），而集合中的元素也是集合 因此，应该对每个集合（元素）进行编号 typedef set&lt;int&gt; element ，这样就能把每个元素看作保存整数的栈 stack s; 用map和vector进行映射集合（元素）和编号 map&lt;element,int&gt; ID_eache; vector&lt;int&gt; ID_eache2; 然后再按照要求写就行了 其中可用switch case判断操作。 要注意每个case都需要 break; 因为case只是入口，并不是出口。只要进去后，没有break就会一直运行下去#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class LOVE&#123; private: int n; typedef set&lt;int&gt; element; stack &lt;int&gt; s; map&lt;element,int&gt; ID_cache; vector&lt;element&gt; ID_cache2; int ID(element x)&#123; if(ID_cache.count(x))return ID_cache[x]; ID_cache2.push_back(x); return ID_cache[x]=ID_cache2.size()-1; &#125; public: void start()&#123; scanf(\"%d\",&amp;n); char com[10]; while(n--)&#123; scanf(\"%s\",com); element temp1,temp2,temp3; element::iterator it1,it2,it; switch(com[0])&#123; case 'P': s.push(ID(element())); break; case 'D': s.push(s.top()); break; case 'U': temp1=ID_cache2[s.top()]; s.pop(); temp2=ID_cache2[s.top()]; s.pop(); for(it=temp2.begin();it!=temp2.end();it++) temp1.insert(*it); s.push(ID(temp1)); break; case 'I': temp1=ID_cache2[s.top()]; s.pop(); temp2=ID_cache2[s.top()]; s.pop(); for(it1=temp1.begin();it1!=temp1.end();it1++)&#123; for(it2=temp2.begin();it2!=temp2.end();it2++)&#123; if(*it1==*it2)&#123; temp3.insert(*it1); temp2.erase(*it2); break; &#125; &#125; &#125; s.push(ID(temp3)); break; case 'A': temp1=ID_cache2[s.top()]; s.pop(); temp2=ID_cache2[s.top()]; s.pop(); temp2.insert(ID(temp1)); s.push(ID(temp2)); break; &#125; cout&lt;&lt;ID_cache2[s.top()].size()&lt;&lt;endl; &#125; &#125;&#125;;int main()&#123; //freopen(\"in.txt\",\"r\",stdin); int n; scanf(\"%d\",&amp;n); while(n--)&#123; LOVE LIVE; LIVE.start(); printf(\"***\\n\"); &#125; return 0;&#125;","tags":[{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"}]},{"title":"Uva 156.Ananagrams","date":"2016-02-17T07:06:00.000Z","path":"/post/Uva/156.html","text":"写麻烦了貌似 不过算同时复习了下 vector set map#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int read(char s[])&#123; char c; int i=0; while(!(((c=getchar())&gt;='A'&amp;&amp;c&lt;='Z')||(c&gt;='a'&amp;&amp;c&lt;='z'))) if(c=='#') return 0; while((c&gt;='A'&amp;&amp;c&lt;='Z')||(c&gt;='a'&amp;&amp;c&lt;='z'))&#123; s[i++]=c; c=getchar(); &#125; s[i]='\\0'; return i;&#125;string code(char s[])&#123; int i=0; char s2[100]; while(s[i]!='\\0')&#123; s2[i]=(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z'?s[i]-'A'+'a':s[i]); i++; &#125; s2[i]='\\0'; sort(s2,s2+strlen(s2)); return s2;&#125;int main()&#123; //freopen(\"in.txt\",\"r\",stdin); set&lt;string&gt; s; set&lt;string&gt;::iterator it; map&lt;string,string&gt; m; map&lt;string,string&gt;::iterator it_map; char str[100]; while(read(str))&#123; string temp=code(str); //cout&lt;&lt;str&lt;&lt;\" \"&lt;&lt;temp&lt;&lt;endl; it_map=m.find(temp); if(it_map==m.end())&#123; m.insert(pair&lt;string,string&gt;(temp,str)); s.insert(temp); &#125; else s.erase(temp); &#125; vector&lt;string&gt; v; for(it=s.begin();it!=s.end();it++) v.push_back(m.find(*it)-&gt;second); sort(v.begin(),v.end()); for(size_t i=0;i&lt;v.size();i++) cout&lt;&lt;v[i]&lt;&lt;endl; return 0;&#125;","tags":[{"name":"向量(vector)","slug":"Vector","permalink":"https://www.oyohyee.com/tags/Vector/"},{"name":"映射(map)","slug":"Map","permalink":"https://www.oyohyee.com/tags/Map/"},{"name":"集合(set)","slug":"Set","permalink":"https://www.oyohyee.com/tags/Set/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"}]},{"title":"Uva 10815.Andy's First Dictionary","date":"2016-02-17T04:02:00.000Z","path":"/post/Uva/10815.html","text":"题意和思路都非常非常明确，直接读入-&gt;set-&gt;输出 然而，在读入上竟然出了问题 最早是是用的string temp;scanf(\"%s\",temp);printf(\"%s\",temp); 这种写法，但是编译器报错，提示 error: cannot pass objects of non-trivially-copyable type ‘std::string {aka class std::basic_string}’ through ‘…’ scanf(“%s”,s); 查了一下，是因为string类本身长度是不定的，在没有给他赋值上字符串前，是没意义的，而scanf需要一个地址来存储，所以直接读入是很有可能出现问题的。 而输出的时候，则由于c、c++不同的特性，需要用temp.c_str() 本来想换成cin读入，但是因为不关闭同步会很慢，就查了下怎么能读入更快，看到用 getchar() 更快，想了下，就自己写吧 里面顺便把大小写也转化了下 快速读入int read(char s[])&#123; char c; int i=0; while(!(((c=getchar())&gt;='A'&amp;&amp;c&lt;='Z')||(c&gt;='a'&amp;&amp;c&lt;='z'))) if(c==EOF) return 0; while((c&gt;='A'&amp;&amp;c&lt;='Z')||(c&gt;='a'&amp;&amp;c&lt;='z'))&#123; s[i++]=(c&gt;='A'&amp;&amp;c&lt;='Z'?c-'A'+'a':c); c=getchar(); &#125; s[i]='\\0'; return i;&#125; 另外，在之前用string通过for(int i=0;i&lt;str.size();i++) 时，又出现了 omparison between signed and unsigned integer expressions [-Wsign-compare] 这个查了下是因为 str.size() 返回的是无符号整数，而i是有符号整数，所以两个直接比有可能会出现问题。 所以有了 for(size_t i=0;i&lt;str.size();i++) 这种写法，其中 size_t 是std命名空间里的，他可以兼容不同的运行环境，保证与返回的size能够兼容 明明一个很简单的题，牵扯出来一群乱七八糟的问题，不过总算学了好多 #include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int read(char s[])&#123; char c; int i=0; while(!(((c=getchar())&gt;='A'&amp;&amp;c&lt;='Z')||(c&gt;='a'&amp;&amp;c&lt;='z'))) if(c==EOF) return 0; while((c&gt;='A'&amp;&amp;c&lt;='Z')||(c&gt;='a'&amp;&amp;c&lt;='z'))&#123; s[i++]=(c&gt;='A'&amp;&amp;c&lt;='Z'?c-'A'+'a':c); c=getchar(); &#125; s[i]='\\0'; return i;&#125;int main()&#123; //freopen(\"in.txt\",\"r\",stdin); set&lt;string&gt; s; set&lt;string&gt;::iterator it; char str[100]; while(read(str)) s.insert(str); for(it=s.begin();it!=s.end();it++) cout&lt;&lt;*it&lt;&lt;endl; return 0;&#125;","tags":[{"name":"集合(set)","slug":"Set","permalink":"https://www.oyohyee.com/tags/Set/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"}]},{"title":"Uva 101.The Blocks Problem","date":"2016-02-14T16:37:00.000Z","path":"/post/Uva/101.html","text":"题意比较容易理解 《入门经典》上用的是向量，不过觉得用链表更快点~ 于是，就在链表这个大坑中爬不出来了…… 要注意对两种情况的排除，一个是a==b，另一个就是a、b在同一堆 在链表中，要注意什么时候链表到尽头，到底用 temp!=NULL 还是用 temp-&gt;next!=NULL 做循环判断的条件 另外，当链表的节点进行移动操作的时候，要注意移动 temp-&gt;next-&gt;last 和 temp-&gt;last-&gt;next （其中还要判断 temp-&gt;last 和 temp-&gt;next 存在与否） （要在这里被坑多少次才能记住╮(╯-╰)╭） 保证这些地方没问题，剩下就对着要求操作就好 #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;struct blocks&#123; int n; blocks *up; blocks *down;&#125;;int n;blocks *b[30],*p[30];void back(int n)&#123; if(b[n]-&gt;up!=NULL) back(b[n]-&gt;up-&gt;n); if(b[n]-&gt;down!=NULL) b[n]-&gt;down-&gt;up=NULL; b[n]-&gt;up=b[n]-&gt;down=NULL; p[n]=b[n];&#125;void pr()&#123; printf(\"=====================\\n\"); for(int i=0;i&lt;n;i++)&#123; printf(\"%d:\",i); blocks *temp=p[i]; while(temp!=NULL)&#123; printf(\" %d\",temp-&gt;n); temp=temp-&gt;up; &#125; printf(\"\\n\"); &#125; printf(\"\\n\"); for(int i=0;i&lt;n;i++)&#123; printf(\"%d: %d %d %d\\n\",i,b[i]-&gt;down==NULL?-1:b[i]-&gt;down-&gt;n,i,b[i]-&gt;up==NULL?-1:b[i]-&gt;up-&gt;n); &#125; printf(\"=====================\\n\"); return;&#125;int main()&#123; //freopen(\"in.txt\",\"r\",stdin); //======init====== for(int i=0;i&lt;30;i++) p[i]=b[i]=new blocks&#123;i,NULL,NULL&#125;; //================ scanf(\"%d\",&amp;n); char com1[5],com2[5]; int A,B; while(1)&#123; scanf(\"%s %d %s %d\",com1,&amp;A,com2,&amp;B); if(!strcmp(com1,\"quit\"))break; //pr(); //printf(\"%s %d %s %d\\n\",com1,A,com2,B); if(A==B)continue; bool can=true; blocks *t=b[A]; while(t!=NULL)&#123; t=t-&gt;up; if(t==b[B]) can=false; &#125; t=b[A]; while(t!=NULL)&#123; t=t-&gt;down; if(t==b[B]) can=false; &#125; if(!can)continue; if(!(strcmp(com1,\"move\")||strcmp(com2,\"onto\")))&#123; back(A); if(b[B]-&gt;up!=NULL) back(b[B]-&gt;up-&gt;n); b[B]-&gt;up=b[A]; b[A]-&gt;down=b[B]; if(p[A]==b[A]) p[A]=NULL; &#125; if(!(strcmp(com1,\"move\")||strcmp(com2,\"over\")))&#123; back(A); blocks *temp=b[B]; while(temp-&gt;up!=NULL) temp=temp-&gt;up; temp-&gt;up=b[A]; b[A]-&gt;down=temp; if(p[A]==b[A]) p[A]=NULL; &#125; if(!(strcmp(com1,\"pile\")||strcmp(com2,\"onto\")))&#123; if(b[B]-&gt;up!=NULL) back(b[B]-&gt;up-&gt;n); b[B]-&gt;up=b[A]; if(b[A]-&gt;down!=NULL) b[A]-&gt;down-&gt;up=NULL; b[A]-&gt;down=b[B]; if(p[A]==b[A]) p[A]=NULL; &#125; if(!(strcmp(com1,\"pile\")||strcmp(com2,\"over\")))&#123; blocks *temp=b[B]; while(temp-&gt;up!=NULL) temp=temp-&gt;up; temp-&gt;up=b[A]; if(b[A]-&gt;down!=NULL) b[A]-&gt;down-&gt;up=NULL; b[A]-&gt;down=temp; if(p[A]==b[A]) p[A]=NULL; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; printf(\"%d:\",i); blocks *temp=p[i]; while(temp!=NULL)&#123; printf(\" %d\",temp-&gt;n); temp=temp-&gt;up; &#125; printf(\"\\n\"); &#125; return 0;&#125;","tags":[{"name":"向量(vector)","slug":"Vector","permalink":"https://www.oyohyee.com/tags/Vector/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"},{"name":"链表(list)","slug":"List","permalink":"https://www.oyohyee.com/tags/List/"}]},{"title":"Uva 1588.Kickdown","date":"2016-01-23T15:22:00.000Z","path":"/post/Uva/1588.html","text":"题目比较简单，反而我觉得这道题英语比算法难233333 读入数据后，循环判断每个位置是不是都是2就行 #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)bool Do();int main()&#123; //freopen(\"in.txt\",\"r\",stdin); while(Do()); return 0;&#125;bool Do()&#123; const int maxn=105; char s1[maxn],s2[maxn]; REP(maxn) s1[o]=s2[o]='\\0'; if(scanf(\"%s%s\",s1,s2)==EOF) return false; int len1=strlen(s1),len2=strlen(s2); int Min=len1+len2; for(int i=-len1;i&lt;=len2;i++)&#123; bool can=true; for(int j=0;j&lt;len1;j++) if(i+j&gt;=0&amp;&amp;i+j&lt;len2&amp;&amp;s1[j]=='2'&amp;&amp;s2[i+j]=='2') can=false; //printf(\" %d %d\\n\",i,max(len2,len1+i)-min(i,0)); if(can) Min=min(Min,max(len2,len1+i)-min(i,0)); &#125; printf(\"%d\\n\",Min); return true;&#125;","tags":[{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"}]},{"title":"Uva 1587.Box","date":"2016-01-23T08:43:00.000Z","path":"/post/Uva/1587.html","text":"思路比较清晰吧 如果可以拼成长方体，要满足： 保证6个长方形能够成对相同（相同）有3组不同的数据（长、宽、高），且每组有4个使用排序进行排序。 相邻两个排序，确保每一个长方形都是以（宽，长）的顺序记录（sort排序时，开始位置是第一个位置，结束为止是最后一个数据的下一个位置） 然后整体排序，每4个一组，进行比较 #include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)bool Do();int main()&#123; //freopen(\"in.txt\",\"r\",stdin); while(Do()); return 0;&#125;bool Do()&#123; int a[13]; if(scanf(\"%d\",&amp;a[1])==EOF) return false; REP(11) scanf(\"%d\",&amp;a[o+2]); REP(6) sort(&amp;a[1+o*2],&amp;a[3+o*2]); bool can=true; for(int i=0;i&lt;6;i++)&#123; int cnt=0; for(int j=0;j&lt;6;j++)&#123; if(a[1+i*2]==a[1+j*2]&amp;&amp;a[2+i*2]==a[2+j*2]) cnt++; &#125; if(cnt&lt;2)&#123; can=false; break; &#125; &#125; if(can)&#123; sort(a+1,a+13); REP(3) if(!(a[1+o*4]==a[2+o*4]&amp;&amp;a[2+o*4]==a[3+o*4]&amp;&amp;a[3+o*4]==a[4+o*4])) can=false; &#125; printf(\"%s\\n\",can?\"POSSIBLE\":\"IMPOSSIBLE\"); return true;&#125;","tags":[{"name":"排序","slug":"Sort","permalink":"https://www.oyohyee.com/tags/Sort/"},{"name":"模拟","slug":"Simulation","permalink":"https://www.oyohyee.com/tags/Simulation/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"}]},{"title":"Uva 10340.All in All","date":"2016-01-23T03:38:00.000Z","path":"/post/Uva/10340.html","text":"哎~这题没什么要注意的吧。。。注意数组别开太小就行 然后往下比较下去……十分钟就能撸完吧 #include &lt;cstdio&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)bool Do();int main()&#123; //freopen(\"in.txt\",\"r\",stdin); while(Do()); return 0;&#125;bool Do()&#123; const int maxn=1000000; char s[maxn]; char t[maxn]; REP(maxn) s[o]=t[o]='\\0'; if(scanf(\"%s%s\",s,t)==EOF) return false; int si=0,ti=0; bool yes=false; while(1)&#123; if(s[si]=='\\0')&#123; yes=true; break; &#125; if(t[ti]=='\\0')break; if(s[si]==t[ti])si++; ti++; &#125; printf(\"%s\\n\",yes?\"Yes\":\"No\"); return true;&#125;","tags":[{"name":"字符串(string)","slug":"String","permalink":"https://www.oyohyee.com/tags/String/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"}]},{"title":"Uva 202.Repeating Decimals","date":"2016-01-22T15:41:00.000Z","path":"/post/Uva/202.html","text":"题目大意就是取循环小数的循环节 思路比较清晰 完全模拟人脑做除法，同时分组标记被除数和除数，判断循环节 中间需要判断是除尽和没除尽两种情况 最后要关注格式，每两个输出要有空行，且第二行前有3个空格 #include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)struct node&#123; int a,b;&#125;;bool Do();int visited(int a,int b,node n[],int len);int main()&#123; //freopen(\"in.txt\",\"r\",stdin); while(Do()); return 0;&#125;bool Do()&#123; int a,b; node mark[10000]; int cnt=1; int decimal[10000]; if(scanf(\"%d%d\",&amp;a,&amp;b)==EOF)return false; REP(10000)mark[o]=&#123;0,b&#125;; REP(10000)decimal[o]=-1; int x=(a%b)*10; while(1)&#123; //printf(\" %d / %d = %d ...... %d mark[%d]=&#123;%d,%d&#125;\\n\",x,b,x/b,x%b,cnt,x,b); decimal[cnt]=x/b; if(visited(x,b,mark,cnt))break; mark[cnt]=&#123;x,b&#125;; x=(x%b)*10; cnt++; &#125; cnt--; //REP(cnt+1)printf(\" mark[%d]=&#123;%d,%d&#125;\\n\",o,mark[o].a,mark[o].b); int begin=visited((mark[cnt].a%b)*10,mark[cnt].b,mark,cnt); //printf(\"\\n\\n%d\\n\\n\",begin); printf(\"%d/%d = %d.\",a,b,a/b); for(int i=1;i&lt;=cnt;i++)&#123; if(begin==i)printf(\"(\"); printf(\"%d\",decimal[i]); if(i==50)&#123; printf(\"...\"); break; &#125; &#125; if(begin==0)printf(\"(0\"); printf(\")\\n %d = number of digits in repeating cycle\\n\\n\",begin==0?1:cnt-begin+1); return true;&#125;int visited(int a,int b,node n[],int len)&#123; for(int o=1;o&lt;=len;o++)&#123; if(n[o].a==a&amp;&amp;n[o].b==b)&#123; return o; &#125; &#125; return 0;&#125;","tags":[{"name":"字符串(string)","slug":"String","permalink":"https://www.oyohyee.com/tags/String/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"}]},{"title":"Uva 232.Crossword Answers","date":"2016-01-10T14:01:00.000Z","path":"/post/Uva/232.html","text":"下面的输出一定要是%3d的格式来输出序号 另外注意两个解之间的空格 #include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;//#define Debugint kase=0;bool Do();int main()&#123; //freopen(\"in.txt\",\"r\",stdin); while(Do()); return 0;&#125;bool Do()&#123; int r,c; char map[15][15]; int number[15][15]; int n=1; memset(number,0,sizeof(number)); //INPUT scanf(\"%d\",&amp;r); if(r==0)return false; scanf(\"%d\",&amp;c); for(int i=0;i&lt;r;i++) scanf(\"%s\",map[i]); getchar();//\\n //INPUT FINISHED //MARK for(int i=0;i&lt;r;i++) for(int j=0;j&lt;c;j++) if(map[i][j]!='*'&amp;&amp;(i==0||j==0||map[i-1][j]=='*'||map[i][j-1]=='*'))number[i][j]=n++; #ifdef Debug printf(\"##########DEBUG##########\\n\"); printf(\"%d %d\\n\",r,c); for(int i=0;i&lt;r;i++)&#123; for(int j=0;j&lt;c;j++)&#123; printf(\"%c\",map[i][j]); &#125; printf(\"\\n\"); &#125; for(int i=0;i&lt;r;i++)&#123; for(int j=0;j&lt;c;j++)&#123; printf(\"%3d\",number[i][j]); &#125; printf(\"\\n\"); &#125; printf(\"##########DEBUG##########\\n\"); #endif if(kase!=0)printf(\"\\n\"); printf(\"puzzle #%d:\\n\",++kase); bool mark[15][15]; printf(\"Across\\n\"); memset(mark,false,sizeof(mark)); for(int i=0;i&lt;r;i++)&#123; for(int j=0;j&lt;c;j++)&#123; if(number[i][j] &amp;&amp; !mark[i][j])&#123; printf(\"%3d.\",number[i][j]); for(int k=j;k&lt;c&amp;&amp;map[i][k]!='*';k++)&#123; printf(\"%c\",map[i][k]); mark[i][k]=true; &#125; printf(\"\\n\"); &#125; &#125; &#125; printf(\"Down\\n\"); memset(mark,false,sizeof(mark)); for(int i=0;i&lt;r;i++)&#123; for(int j=0;j&lt;c;j++)&#123; if(number[i][j] &amp;&amp; !mark[i][j])&#123; printf(\"%3d.\",number[i][j]); for(int k=i;k&lt;r&amp;&amp;map[k][j]!='*';k++)&#123; printf(\"%c\",map[k][j]); mark[k][j]=true; &#125; printf(\"\\n\"); &#125; &#125; &#125; return true;&#125;","tags":[{"name":"字符串(string)","slug":"String","permalink":"https://www.oyohyee.com/tags/String/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"}]},{"title":"Uva 1368.DNA Consensus String","date":"2016-01-10T12:42:00.000Z","path":"/post/Uva/1368.html","text":"题目要求是对几个字符串进行分析，得到一个最优的字符串，使它满足与要求的字符串不同的字符之和最小。如果有多种解，则输出字典序最小的。 注意：字符串的结束时 \\0 一定要加上 #include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn=1005;char DNA[55][maxn];struct node&#123; int i; char n; bool operator &lt; (const node rhs)const&#123; return i&lt;rhs.i || (i==rhs.i &amp;&amp; n&gt;rhs.n); &#125;&#125;;void Do();int Hamming(char s1[],char s2[],int len);int main()&#123; //freopen(\"in.txt\",\"r\",stdin); int N; scanf(\"%d\",&amp;N); for(int i=0;i&lt;N;i++) Do(); return 0;&#125;void Do()&#123; int m,n; scanf(\"%d%d\",&amp;m,&amp;n); int A[maxn],C[maxn],G[maxn],T[maxn]; memset(A,0,sizeof(A)); memset(C,0,sizeof(C)); memset(G,0,sizeof(G)); memset(T,0,sizeof(T)); for(int i=0;i&lt;m;i++)&#123; scanf(\"%s\",DNA[i]); for(int j=0;j&lt;n;j++)&#123; if(DNA[i][j]=='A')A[j]++; if(DNA[i][j]=='C')C[j]++; if(DNA[i][j]=='G')G[j]++; if(DNA[i][j]=='T')T[j]++; &#125; &#125; char DNA_min[maxn]; for(int i=0;i&lt;maxn;i++) DNA_min[i]='\\0'; for(int i=0;i&lt;n;i++)&#123; node a[4]=&#123;&#123;A[i],'A'&#125;,&#123;C[i],'C'&#125;,&#123;G[i],'G'&#125;,&#123;T[i],'T'&#125;&#125;; sort(a,a+4); DNA_min[i]=a[3].n; &#125; int ans=0; for(int i=0;i&lt;m;i++)&#123; ans+=Hamming(DNA_min,DNA[i],n); &#125; printf(\"%s\\n%d\\n\",DNA_min,ans); return;&#125;int Hamming(char s1[],char s2[],int len)&#123; int ans=0; for(int i=0;i&lt;len;i++) if(s1[i]!=s2[i]) ans++; return ans;&#125;","tags":[{"name":"字符串(string)","slug":"String","permalink":"https://www.oyohyee.com/tags/String/"},{"name":"Uva","slug":"Uva","permalink":"https://www.oyohyee.com/tags/Uva/"}]},{"title":"关于cin","date":"2015-10-15T04:05:00.000Z","path":"/post/Note/cin.html","text":"若要判断文件尾，有很多种方法。 作为对比，有 while(cin&gt;&gt;s)&#123; ...&#125;while(!cin.eof())&#123; ...&#125;while(scanf(\"%s\",&amp;s)!=EOF)&#123; ...&#125; 但是cin.eof()并不像其看着的样子那样，能够直接判断，他还需要我们再读一下字符才能正确判断是否达到文件尾 ABCDEFG(EOF) 也即，我们若使用scanf的话，在G(处就可判断到是否到达结尾 而cin.eof()则需要我们到达)处","tags":[{"name":"读入输出","slug":"IO","permalink":"https://www.oyohyee.com/tags/IO/"}]},{"title":"代码优化方案","date":"2015-08-22T10:57:00.000Z","path":"/post/Note/CodeBetter.html","text":"转载自：http://www.uml.org.cn/c++/200811103.asp#_Toc110958704 1、选择合适的算法和数据结构 选择一种合适的数据结构很重要，如果在一堆随机存放的数中使用了大量的插入和删除指令，那使用链表要快得多。数组与指针语句具有十分密切的关系，一般来说，指针比较灵活简洁，而数组则比较直观，容易理解。对于大部分的编译器，使用指针比使用数组生成的代码更短，执行效率更高。在许多种情况下，可以用指针运算代替数组索引，这样做常常能产生又快又短的代码。与数组索引相比，指针一般能使代码速度更快，占用空间更少。使用多维数组时差异更明显。下面的代码作用是相同的，但是效率不一样�数组索引指针运算&nbsp;For(;;){&nbsp;&nbsp;&nbsp; A=array[t++];&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;。。。。。。。。。&nbsp;&nbsp;&nbsp; }&nbsp;p=array&nbsp; for(;;){&nbsp; &nbsp; a=(p++);&nbsp;&nbsp; &nbsp;。。。。。。。。。&nbsp;&nbsp;&nbsp; }&nbsp;指针方法的优点是，array的地址每次装入地址p后，在每次循环中只需对p增量操作。在数组索引方法中，每次循环中都必须根据t值求数组下标的复杂运算。2、使用尽量小的数据类型能够使用字符型(char)定义的变量，就不要使用整型(int)变量来定义；能够使用整型变量定义的变量就不要用长整型(long int)，能不使用浮点型(float)变量就不要使用浮点型变量。当然，在定义变量后不要超过变量的作用范围，如果超过变量的范围赋值，C编译器并不报错，但程序运行结果却错了，而且这样的错误很难发现。在ICCAVR中，可以在Options中设定使用printf参数，尽量使用基本型参数(%c、%d、%x、%X、%u和%s格式说明符)，少用长整型参数(%ld、%lu、%lx和%lX格式说明符)，至于浮点型的参数(%f)则尽量不要使用，其它C编译器也一样。在其它条件不变的情况下，使用%f参数，会使生成的代码的数量增加很多，执行速度降低。3、减少运算的强度（1）、查表(游戏程序员必修课)一个聪明的游戏大虾，基本上不会在自己的主循环里搞什么运算工作，绝对是先计算好了，再到循环里查表。看下面的例子：旧代码： long factorial(int i) { if (i == 0) return 1; else return i factorial(i - 1); }&nbsp;新代码： static long factorial_table[] = {1， 1， 2， 6， 24， 120， 720 / etc / }; long factorial(int i) { return factorial_table[i]; }&nbsp;如果表很大，不好写，就写一个init函数，在循环外临时生成表格。（2）、求余运算&nbsp; a=a%8;&nbsp;可以改为：&nbsp; a=a&amp;7;&nbsp;说明：位操作只需一个指令周期即可完成，而大部分的C编译器的&ldquo;%&rdquo;运算均是调用子程序来完成，代码长、执行速度慢。通常，只要求是求2n方的余数，均可使用位操作的方法来代替。（3）、平方运算&nbsp;a=pow(a, 2.0);&nbsp;可以改为：&nbsp;a=aa;&nbsp;说明：在有内置硬件乘法器的单片机中(如51系列)，乘法运算比求平方运算快得多，因为浮点数的求平方是通过调用子程序来实现的，在自带硬件乘法器的AVR单片机中，如ATMega163中，乘法运算只需2个时钟周期就可以完成。既使是在没有内置硬件乘法器的AVR单片机中，乘法运算的子程序比平方运算的子程序代码短，执行速度快。如果是求3次方，如：&nbsp;a=pow(a，3。0);&nbsp;更改为：&nbsp;a=aaa；&nbsp;则效率的改善更明显。（4）、用移位实现乘除法运算&nbsp; a=a4; b=b/4;&nbsp;可以改为：&nbsp; a=a&lt;&lt;2; b=b&gt;&gt;2;&nbsp;通常如果需要乘以或除以2n，都可以用移位的方法代替。在ICCAVR中，如果乘以2n，都可以生成左移的代码，而乘以其它的整数或除以任何数，均调用乘除法子程序。用移位的方法得到代码比调用乘除法子程序生成的代码效率高。实际上，只要是乘以或除以一个整数，均可以用移位的方法得到结果，如：&nbsp; a=a9&nbsp;可以改为：&nbsp;a=(a&lt;&lt;3)+a&nbsp;采用运算量更小的表达式替换原来的表达式，下面是一个经典例子:旧代码: x = w % 8; y = pow(x， 2.0); z = y 33; for (i = 0;i &lt; MAX;i++) { h = 14 i; printf(“%d“， h); }&nbsp;新代码: x = w &amp; 7; / 位操作比求余运算快/ y = x x; / 乘法比平方运算快/ z = (y &lt;&lt; 5) + y; / 位移乘法比乘法快 / for (i = h = 0; i &lt; MAX; i++) { h += 14; / 加法比乘法快 / printf(“%d“，h);}&nbsp;（5）、避免不必要的整数除法整数除法是整数运算中最慢的，所以应该尽可能避免。一种可能减少整数除法的地方是连除，这里除法可以由乘法代替。这个替换的副作用是有可能在算乘积时会溢出，所以只能在一定范围的除法中使用。不好的代码：int , j, k, m;m = i / j / k;&nbsp;推荐的代码：int i， j, k, m;m = i / (j k);&nbsp;（6）、使用增量和减量操作符在使用到加一和减一操作时尽量使用增量和减量操作符，因为增量符语句比赋值语句更快，原因在于对大多数CPU来说，对内存字的增、减量操作不必明显地使用取内存和写内存的指令，比如下面这条语句：&nbsp;x=x+1;&nbsp;模仿大多数微机汇编语言为例，产生的代码类似于：move A，x ;把x从内存取出存入累加器Aadd A，1 ;累加器A加1store x ;把新值存回x 如果使用增量操作符，生成的代码如下：&nbsp;incr x ;x加1&nbsp;显然，不用取指令和存指令，增、减量操作执行的速度加快，同时长度也缩短了。（7）、使用复合赋值表达式复合赋值表达式(如a-=1及a+=1等)都能够生成高质量的程序代码。（8）、提取公共的子表达式在某些情况下，C++编译器不能从浮点表达式中提出公共的子表达式，因为这意味着相当于对表达式重新排序。需要特别指出的是，编译器在提取公共子表达式前不能按照代数的等价关系重新安排表达式。这时，程序员要手动地提出公共的子表达式（在VC.NET里有一项&ldquo;全局优化&rdquo;选项可以完成此工作，但效果就不得而知了）。不好的代码：float a， b， c， d， e， f；。。。e = b c / d；f = b / d a；&nbsp;推荐的代码：float a， b， c， d， e， f；。。。const float t(b / d)；e = c t；f = a t；&nbsp;不好的代码：float a， b， c， e， f；。。。e = a / c；f = b / c；&nbsp;推荐的代码：float a， b， c， e， f；。。。const float t(1.0f / c)；e = a t；f = b t；&nbsp;4、结构体成员的布局很多编译器有&ldquo;使结构体字，双字或四字对齐&rdquo;的选项。但是，还是需要改善结构体成员的对齐，有些编译器可能分配给结构体成员空间的顺序与他们声明的不同。但是，有些编译器并不提供这些功能，或者效果不好。所以，要在付出最少代价的情况下实现最好的结构体和结构体成员对齐，建议采取下列方法：（1）按数据类型的长度排序把结构体的成员按照它们的类型长度排序，声明成员时把长的类型放在短的前面。编译器要求把长型数据类型存放在偶数地址边界。在申明一个复杂的数据类型 (既有多字节数据又有单字节数据) 时，应该首先存放多字节数据，然后再存放单字节数据，这样可以避免内存的空洞。编译器自动地把结构的实例对齐在内存的偶数边界。（2）把结构体填充成最长类型长度的整倍数把结构体填充成最长类型长度的整倍数。照这样，如果结构体的第一个成员对齐了，所有整个结构体自然也就对齐了。下面的例子演示了如何对结构体成员进行重新排序：不好的代码，普通顺序：struct{char a[5]；long k；double x；} baz；&nbsp;推荐的代码，新的顺序并手动填充了几个字节：struct{double x；long k；char a[5]；char pad[7]；} baz；&nbsp;这个规则同样适用于类的成员的布局。（3）按数据类型的长度排序本地变量当编译器分配给本地变量空间时，它们的顺序和它们在源代码中声明的顺序一样，和上一条规则一样，应该把长的变量放在短的变量前面。如果第一个变量对齐了，其它变量就会连续的存放，而且不用填充字节自然就会对齐。有些编译器在分配变量时不会自动改变变量顺序，有些编译器不能产生4字节对齐的栈，所以4字节可能不对齐。下面这个例子演示了本地变量声明的重新排序：不好的代码，普通顺序short ga， gu， gi；long foo， bar；double x， y， z[3]；char a， b；float baz；&nbsp;推荐的代码，改进的顺序double z[3]；double x， y；long foo， bar；float baz；short ga， gu， gi； &nbsp;（4）把频繁使用的指针型参数拷贝到本地变量避免在函数中频繁使用指针型参数指向的值。因为编译器不知道指针之间是否存在冲突，所以指针型参数往往不能被编译器优化。这样数据不能被存放在寄存器中，而且明显地占用了内存带宽。注意，很多编译器有&ldquo;假设不冲突&rdquo;优化开关（在VC里必须手动添加编译器命令行/Oa或/Ow），这允许编译器假设两个不同的指针总是有不同的内容，这样就不用把指针型参数保存到本地变量。否则，请在函数一开始把指针指向的数据保存到本地变量。如果需要的话，在函数结束前拷贝回去。不好的代码：// 假设 q != rvoid isqrt(unsigned long a， unsigned long q， unsigned long r){ q = a； if (a &gt; 0) { while (q &gt; (r = a / q)) { q = (q + r) &gt;&gt; 1； } } r = a - q q；}&nbsp;推荐的代码：// 假设 q != rvoid isqrt(unsigned long a， unsigned long q， unsigned long r){ unsigned long qq， rr； qq = a； if (a &gt; 0) { while (qq &gt; (rr = a / qq)) { qq = (qq + rr) &gt;&gt; 1； } } rr = a - qq qq； q = qq； r = rr；}&nbsp;5、循环优化（1）、充分分解小的循环要充分利用CPU的指令缓存，就要充分分解小的循环。特别是当循环体本身很小的时候，分解循环可以提高性能。注意:很多编译器并不能自动分解循环。 不好的代码：// 3D转化：把矢量 V 和 4x4 矩阵 M 相乘for (i = 0； i &lt; 4； i ++){ r[i] = 0； for (j = 0； j &lt; 4； j ++) { r[i] += M[j][i]V[j]； }}&nbsp;推荐的代码：r[0] = M[0][0]V[0] + M[1][0]V[1] + M[2][0]V[2] + M[3][0]V[3]；r[1] = M[0][1]V[0] + M[1][1]V[1] + M[2][1]V[2] + M[3][1]V[3]；r[2] = M[0][2]V[0] + M[1][2]V[1] + M[2][2]V[2] + M[3][2]V[3]；r[3] = M[0][3]V[0] + M[1][3]V[1] + M[2][3]V[2] + M[3][3]v[3]；&nbsp;（2）、提取公共部分对于一些不需要循环变量参加运算的任务可以把它们放到循环外面，这里的任务包括表达式、函数的调用、指针运算、数组访问等，应该将没有必要执行多次的操作全部集合在一起，放到一个init的初始化程序中进行。（3）、延时函数通常使用的延时函数均采用自加的形式： void delay (void) {unsigned int i; for (i=0;i&lt;1000;i++) ; }&nbsp;将其改为自减延时函数： void delay (void) {unsigned int i; for (i=1000;i&gt;0;i–) ; }&nbsp;两个函数的延时效果相似，但几乎所有的C编译对后一种函数生成的代码均比前一种代码少1~3个字节，因为几乎所有的MCU均有为0转移的指令，采用后一种方式能够生成这类指令。在使用while循环时也一样，使用自减指令控制循环会比使用自加指令控制循环生成的代码更少1~3个字母。但是在循环中有通过循环变量&ldquo;i&rdquo;读写数组的指令时，使用预减循环有可能使数组超界，要引起注意。（4）、while循环和do&hellip;while循环用while循环时有以下两种循环形式：unsigned int i; i=0; while (i&lt;1000) { i++; //用户程序 }&nbsp;或：unsigned int i; i=1000;do{ i–; //用户程序}while (i&gt;0);&nbsp;在这两种循环中，使用do&hellip;while循环编译后生成的代码的长度短于while循环。（6）、循环展开这是经典的速度优化，但许多编译程序(如gcc -funroll-loops)能自动完成这个事，所以现在你自己来优化这个显得效果不明显。旧代码:for (i = 0; i &lt; 100; i++){do_stuff(i);}&nbsp;新代码:for (i = 0; i &lt; 100; ){do_stuff(i); i++;do_stuff(i); i++;do_stuff(i); i++;do_stuff(i); i++;do_stuff(i); i++;do_stuff(i); i++;do_stuff(i); i++;do_stuff(i); i++;do_stuff(i); i++;do_stuff(i); i++;}&nbsp;可以看出，新代码里比较指令由100次降低为10次，循环时间节约了90%。不过注意:对于中间变量或结果被更改的循环，编译程序往往拒绝展开，(怕担责任呗)，这时候就需要你自己来做展开工作了。还有一点请注意，在有内部指令cache的CPU上(如MMX芯片)，因为循环展开的代码很大，往往cache溢出，这时展开的代码会频繁地在CPU 的cache和内存之间调来调去，又因为cache速度很高，所以此时循环展开反而会变慢。还有就是循环展开会影响矢量运算优化。（6）、循环嵌套把相关循环放到一个循环里，也会加快速度。旧代码:for (i = 0; i &lt; MAX; i++) / initialize 2d array to 0’s / for (j = 0; j &lt; MAX; j++) a[i][j] = 0.0; for (i = 0; i &lt; MAX; i++) / put 1’s along the diagonal / a[i][i] = 1.0;&nbsp;新代码:for (i = 0; i &lt; MAX; i++) / initialize 2d array to 0’s /{ for (j = 0; j &lt; MAX; j++) a[i][j] = 0.0; a[i][i] = 1.0; / put 1’s along the diagonal /}&nbsp;（7）、Switch语句中根据发生频率来进行case排序Switch 可能转化成多种不同算法的代码。其中最常见的是跳转表和比较链/树。当switch用比较链的方式转化时，编译器会产生if-else-if的嵌套代码，并按照顺序进行比较，匹配时就跳转到满足条件的语句执行。所以可以对case的值依照发生的可能性进行排序，把最有可能的放在第一位，这样可以提高性能。此外，在case中推荐使用小的连续的整数，因为在这种情况下，所有的编译器都可以把switch 转化成跳转表。不好的代码：int days_in_month， short_months， normal_months， long_months；。。。。。。switch (days_in_month){ case 28: case 29: short_months ++； break； case 30: normal_months ++； break； case 31: long_months ++； break； default: cout &lt;&lt; “month has fewer than 28 or more than 31 days“ &lt;&lt; endl； break；}&nbsp;推荐的代码：int days_in_month， short_months， normal_months， long_months；。。。。。。switch (days_in_month){ case 31: long_months ++； break； case 30: normal_months ++； break； case 28: case 29: short_months ++； break； default: cout &lt;&lt; “month has fewer than 28 or more than 31 days“ &lt;&lt; endl； break；} &nbsp;（8）、将大的switch语句转为嵌套switch语句当switch语句中的case标号很多时，为了减少比较的次数，明智的做法是把大switch语句转为嵌套switch语句。把发生频率高的case 标号放在一个switch语句中，并且是嵌套switch语句的最外层，发生相对频率相对低的case标号放在另一个switch语句中。比如，下面的程序段把相对发生频率低的情况放在缺省的case标号内。pMsg=ReceiveMessage(); switch (pMsg-&gt;type) { case FREQUENT_MSG1: handleFrequentMsg(); break; case FREQUENT_MSG2: handleFrequentMsg2(); break; 。。。。。。 case FREQUENT_MSGn: handleFrequentMsgn(); break; default: //嵌套部分用来处理不经常发生的消息 switch (pMsg-&gt;type) { case INFREQUENT_MSG1: handleInfrequentMsg1(); break; case INFREQUENT_MSG2: handleInfrequentMsg2(); break; 。。。。。。 case INFREQUENT_MSGm: handleInfrequentMsgm(); break; } }如果switch中每一种情况下都有很多的工作要做，那么把整个switch语句用一个指向函数指针的表来替换会更加有效，比如下面的switch语句，有三种情况：enum MsgType{Msg1， Msg2， Msg3} switch (ReceiveMessage() { case Msg1; 。。。。。。 case Msg2; 。。。。。 case Msg3; 。。。。。 }&nbsp;为了提高执行速度，用下面这段代码来替换这个上面的switch语句。 /准备工作/ int handleMsg1(void); int handleMsg2(void); int handleMsg3(void); /创建一个函数指针数组/ int (MsgFunction [])()={handleMsg1， handleMsg2， handleMsg3}; /用下面这行更有效的代码来替换switch语句/ status=MsgFunctionReceiveMessage();&nbsp;（9）、循环转置有些机器对JNZ(为0转移)有特别的指令处理，速度非常快，如果你的循环对方向不敏感，可以由大向小循环。旧代码:for (i = 1; i &lt;= MAX; i++){ 。。。 }&nbsp;新代码:i = MAX+1;while (–i){。。。}&nbsp;不过千万注意，如果指针操作使用了i值，这种方法可能引起指针越界的严重错误(i = MAX+1;)。当然你可以通过对i做加减运算来纠正，但是这样就起不到加速的作用，除非类似于以下情况：旧代码:char a[MAX+5];for (i = 1; i &lt;= MAX; i++){(a+i+4)=0;}&nbsp;新代码:i = MAX+1;while (–i){ (a+i+4)=0;}&nbsp;（10）、公用代码块一些公用处理模块，为了满足各种不同的调用需要，往往在内部采用了大量的if-then-else结构，这样很不好，判断语句如果太复杂，会消耗大量的时间的，应该尽量减少公用代码块的使用。(任何情况下，空间优化和时间优化都是对立的–东楼)。当然，如果仅仅是一个(3==x)之类的简单判断，适当使用一下，也还是允许的。记住，优化永远是追求一种平衡，而不是走极端。（11）提升循环的性能要提升循环的性能，减少多余的常量计算非常有用（比如，不随循环变化的计算）。不好的代码(在for()中包含不变的if())：for( i 。。。 ){ if( CONSTANT0 ) { DoWork0( i )； // 假设这里不改变CONSTANT0的值 } else { DoWork1( i )； // 假设这里不改变CONSTANT0的值 }}&nbsp;推荐的代码：if( CONSTANT0 ){ for( i 。。。 ) { DoWork0( i )； }}else{ for( i 。。。 ) { DoWork1( i )； }} &nbsp;如果已经知道if()的值，这样可以避免重复计算。虽然不好的代码中的分支可以简单地预测，但是由于推荐的代码在进入循环前分支已经确定，就可以减少对分支预测的依赖。（12）、选择好的无限循环在编程中，我们常常需要用到无限循环，常用的两种方法是while (1) 和 for (；；)。这两种方法效果完全一样，但那一种更好呢？然我们看看它们编译后的代码：编译前：while (1)；&nbsp;编译后：mov eax，1test eax，eaxje foo+23hjmp foo+18h &nbsp;编译前：for (；；)；&nbsp;编译后：jmp foo+23h&nbsp;显然，for (；；)指令少，不占用寄存器，而且没有判断、跳转，比while (1)好。6、提高CPU的并行性（1）使用并行代码尽可能把长的有依赖的代码链分解成几个可以在流水线执行单元中并行执行的没有依赖的代码链。很多高级语言，包括C++，并不对产生的浮点表达式重新排序，因为那是一个相当复杂的过程。需要注意的是，重排序的代码和原来的代码在代码上一致并不等价于计算结果一致，因为浮点操作缺乏精确度。在一些情况下，这些优化可能导致意料之外的结果。幸运的是，在大部分情况下，最后结果可能只有最不重要的位（即最低位）是错误的。不好的代码：double a[100]， sum；int i；sum = 0.0f；for (i=0； i&lt;100； i++)sum += a[i]；&nbsp;推荐的代码：double a[100]， sum1， sum2， sum3， sum4， sum；int i；sum1 = sum2 = sum3 = sum4 = 0.0；for (i = 0； i &lt; 100； i += 4){ sum1 += a[i]； sum2 += a[i+1]； sum3 += a[i+2]； sum4 += a[i+3]；}sum = (sum4+sum3)+(sum1+sum2)； &nbsp;要注意的是：使用4路分解是因为这样使用了4段流水线浮点加法，浮点加法的每一个段占用一个时钟周期，保证了最大的资源利用率。（2）避免没有必要的读写依赖当数据保存到内存时存在读写依赖，即数据必须在正确写入后才能再次读取。虽然AMD Athlon等CPU有加速读写依赖延迟的硬件，允许在要保存的数据被写入内存前读取出来，但是，如果避免了读写依赖并把数据保存在内部寄存器中，速度会更快。在一段很长的又互相依赖的代码链中，避免读写依赖显得尤其重要。如果读写依赖发生在操作数组时，许多编译器不能自动优化代码以避免读写依赖。所以推荐程序员手动去消除读写依赖，举例来说，引进一个可以保存在寄存器中的临时变量。这样可以有很大的性能提升。下面一段代码是一个例子：不好的代码：float x[VECLEN]， y[VECLEN]， z[VECLEN]；。。。。。。for (unsigned int k = 1； k &lt; VECLEN； k ++){ x[k] = x[k-1] + y[k]；}for (k = 1； k &lt;VECLEN； k++){ x[k] = z[k] (y[k] - x[k-1])；}&nbsp;推荐的代码：float x[VECLEN]， y[VECLEN]， z[VECLEN]；。。。。。。float t(x[0])；for (unsigned int k = 1； k &lt; VECLEN； k ++){ t = t + y[k]； x[k] = t；}t = x[0]；for (k = 1； k &lt;； VECLEN； k ++){ t = z[k] (y[k] - t)； x[k] = t；} &nbsp;7、循环不变计算对于一些不需要循环变量参加运算的计算任务可以把它们放到循环外面，现在许多编译器还是能自己干这件事，不过对于中间使用了变量的算式它们就不敢动了，所以很多情况下你还得自己干。对于那些在循环中调用的函数，凡是没必要执行多次的操作通通提出来，放到一个init函数里，循环前调用。另外尽量减少喂食次数，没必要的话尽量不给它传参，需要循环变量的话让它自己建立一个静态循环变量自己累加，速度会快一点。还有就是结构体访问，东楼的经验，凡是在循环里对一个结构体的两个以上的元素执行了访问，就有必要建立中间变量了(结构这样，那C++的对象呢?想想看)，看下面的例子:旧代码: total = a-&gt;b-&gt;c[4]-&gt;aardvark + a-&gt;b-&gt;c[4]-&gt;baboon + a-&gt;b-&gt;c[4]-&gt;cheetah + a-&gt;b-&gt;c[4]-&gt;dog;&nbsp;新代码: struct animals temp = a-&gt;b-&gt;c[4]; total = temp-&gt;aardvark + temp-&gt;baboon + temp-&gt;cheetah + temp-&gt;dog;&nbsp;一些老的C语言编译器不做聚合优化，而符合ANSI规范的新的编译器可以自动完成这个优化，看例子: float a， b， c， d， f， g; 。。。 a = b / c d; f = b g / c;&nbsp;这种写法当然要得，但是没有优化 float a， b， c， d， f， g; 。。。 a = b / c d; f = b / c g;&nbsp;如果这么写的话，一个符合ANSI规范的新的编译器可以只计算b/c一次，然后将结果代入第二个式子，节约了一次除法运算。8、函数优化（1）Inline函数在C++中，关键字Inline可以被加入到任何函数的声明中。这个关键字请求编译器用函数内部的代码替换所有对于指出的函数的调用。这样做在两个方面快于函数调用：第一，省去了调用指令需要的执行时间；第二，省去了传递变元和传递过程需要的时间。但是使用这种方法在优化程序速度的同时，程序长度变大了，因此需要更多的ROM。使用这种优化在Inline函数频繁调用并且只包含几行代码的时候是最有效的。（2）不定义不使用的返回值函数定义并不知道函数返回值是否被使用，假如返回值从来不会被用到，应该使用void来明确声明函数不返回任何值。（3）减少函数调用参数&nbsp;&nbsp;&nbsp; 使用全局变量比函数传递参数更加有效率。这样做去除了函数调用参数入栈和函数完成后参数出栈所需要的时间。然而决定使用全局变量会影响程序的模块化和重入，故要慎重使用。（4）所有函数都应该有原型定义一般来说，所有函数都应该有原型定义。原型定义可以传达给编译器更多的可能用于优化的信息。（5）尽可能使用常量(const)尽可能使用常量(const)。C++ 标准规定，如果一个const声明的对象的地址不被获取，允许编译器不对它分配储存空间。这样可以使代码更有效率，而且可以生成更好的代码。（6）把本地函数声明为静态的(static)如果一个函数只在实现它的文件中被使用，把它声明为静态的(static)以强制使用内部连接。否则，默认的情况下会把函数定义为外部连接。这样可能会影响某些编译器的优化&mdash;&mdash;比如，自动内联。9、采用递归与LISP之类的语言不同，C语言一开始就病态地喜欢用重复代码循环，许多C程序员都是除非算法要求，坚决不用递归。事实上，C编译器们对优化递归调用一点都不反感，相反，它们还很喜欢干这件事。只有在递归函数需要传递大量参数，可能造成瓶颈的时候，才应该使用循环代码，其他时候，还是用递归好些。10、变量（1）register变量在声明局部变量的时候可以使用register关键字。这就使得编译器把变量放入一个多用途的寄存器中，而不是在堆栈中，合理使用这种方法可以提高执行速度。函数调用越是频繁，越是可能提高代码的速度。在最内层循环避免使用全局变量和静态变量，除非你能确定它在循环周期中不会动态变化，大多数编译器优化变量都只有一个办法，就是将他们置成寄存器变量，而对于动态变量，它们干脆放弃对整个表达式的优化。尽量避免把一个变量地址传递给另一个函数，虽然这个还很常用。C语言的编译器们总是先假定每一个函数的变量都是内部变量，这是由它的机制决定的，在这种情况下，它们的优化完成得最好。但是，一旦一个变量有可能被别的函数改变，这帮兄弟就再也不敢把变量放到寄存器里了，严重影响速度。看例子：a = b();c(&amp;d);因为d的地址被c函数使用，有可能被改变，编译器不敢把它长时间的放在寄存器里，一旦运行到c(&amp;d)，编译器就把它放回内存，如果在循环里，会造成N次频繁的在内存和寄存器之间读写d的动作，众所周知，CPU在系统总线上的读写速度慢得很。比如你的赛杨300，CPU主频300，总线速度最多66M，为了一个总线读，CPU可能要等4-5个周期，得。。得。。得。。想起来都打颤。（2）、同时声明多个变量优于单独声明变量（3）、短变量名优于长变量名，应尽量使变量名短一点（4）、在循环开始前声明变量11、使用嵌套的if结构在if结构中如果要判断的并列条件较多，最好将它们拆分成多个if结构，然后嵌套在一起，这样可以避免无谓的判断。说明：上面的优化方案由王全明收集整理。很多资料来源与网上，出处不祥，在此对所有作者一并致谢！该方案主要是考虑到在嵌入式开发中对程序执行速度的要求特别高，所以该方案主要是为了优化程序的执行速度。注意：优化是有侧重点的，优化是一门平衡的艺术，它往往要以牺牲程序的可读性或者增加代码长度为代价。(任何情况下，空间优化和时间优化都是对立的–东楼)。&nbsp;&nbsp;","tags":[]},{"title":"主流播放器的强行联网对比","date":"2015-08-07T03:18:00.000Z","path":"/post/Writing/Music_Player.html","text":"结论： pc版百度音乐阉割联网功能 手机版天天动听或网易云音乐阉割联网功能 起因 作为一名虔诚的LoveLiver，听μ’s的歌写程序是必须的~ 无疑，音乐一定要是flac无损的（尽管我听不出来），带高清专辑封面（尽管我不看），有双语歌词的（尽管我也不怎么看） 在众多LoveLiver的共同努力下，我们有了符合以上要求的歌曲（如图，有高清专辑封面，在同文件夹下有同名歌词） 科研内容包括常见播放器对本地专辑封面，本地歌词的支持情况（包括pc版和手机版） 测试歌曲 START DASH-μ&#39;s PC版所有软件由360软件管家下载（毕竟那么多，我也不能一个一个跑官网下载吧） 有：QQ音乐，百度音乐，多米音乐，酷狗音乐，酷我音乐，千千静听，天天动听，网易云音乐，虾米音乐 （2015-08-07 09:59:08最新版） QQ音乐作为腾讯大老爷的播放器，QQ音乐的使用者应该不少 能正常读取本地歌词，但是没有专辑封面 百度音乐曾经的千千静听 能正常显示封面，正常显示歌词 但是存在间接性读不到歌词，自己上网下载的情况，建议随便设个代理服务器，阉割上网功能 多米音乐 在图片上右键可以选择图片，我选择了专辑封面后，还是一片黑→_→ 而且这歌词可不是我本地的歌词，本地歌词只有中日，没有罗马音的 要你何用→_→ 酷狗音乐Hello kugou~ 同上，没专辑封面，不是本地歌词 酷我音乐听音乐，用酷我 我丝毫不能理解前几首为什么不能播放→_→ 没专辑封面歌词这些功能就算了，作为一个音乐播放器不能放歌→_→ 不过背景……南酱prpr 千千静听 图片选择专辑封面，也不读取，而且这歌词也不是本地的 天天动听 歌词不对，封面看似对，然而我们进入缓存目录，发现这个图片是他下的，只是凑巧一样~ 而且 没点进播放界面的图片不对~~ 网易云音乐看名字就不会用本地的→_→ 在未断网情况下，上网下载图片和歌词 断网情况下，没封面，只有本地歌词 虾米音乐 PC版测试完毕，推荐不联网的百度音乐 手机版所有软件由PP助手下载 有：百度音乐，QQ音乐，酷狗音乐，Rockbox，酷我音乐，虾米音乐，多米音乐，网易云音乐，咪咕音乐，天天动听 百度音乐 本地歌词，没专辑图片 QQ音乐 歌词不对，封面不对 酷狗音乐 什么都没有→_→ 酷我音乐 带着胎毛的小鸟→_→（所以我一定要本地歌词，太TM乱了） 没专辑，不是本地歌词 虾米音乐 没歌词 多米音乐 没专辑图片，歌词非本地 网易云音乐 专辑图片，歌词都是自己下的，不过断网情况下会调用本地专辑图片和歌词 然而在调用本地歌词的时候，切歌后，桌面歌词不变，需要手动关闭桌面歌词再打开更新→_→ 此bug已提交，如果可以修复还是不错的 咪咕音乐 天天动听 本地专辑封面，联网时去上网搜歌词，然而很可能搜不到，断网时本地歌词 注意，断网指关闭wifi，开wifi不给联网权限它还是会去搜，但是搜不到 断网听，目前这个效果最好，没有其他问题，正在研究怎么阉割他的联网功能 Rockbox神器 这玩意根本没法联网= =歌词，专辑封面支持的都不错 但是上手太难=_= 如果网易云音乐能修复bug推荐网易云音乐（禁止联网权限） 否则就用天天动听应付着吧 如果不怕麻烦，Rockbox也不错，只是没有桌面歌词","tags":[]},{"title":"康托（逆）展开","date":"2015-08-06T03:34:00.000Z","path":"/post/Algorithm/Contour.html","text":"康托展开 X=a[n](n-1)!+a[n-1](n-2)!+…+a[i](i-1)!+…+a[1]0! 其中，a[i]为整数，并且X=a[n](n-1)!+a[n-1](n-2)!+…+a[i](i-1)!+…+a[1]0!。这就是康托展开。康托展开可用代码实现。 ——百度百科 这个东西，我们高三的时候称作OhYee第一定理（还有第二第三）。当时做排列组合做到疯的时候推出来的。然而我们数学老师觉得没什么琴里用→_→ 对于八数码问题，在储存时有一个问题，就是八数码共有9！=362800种可能，但是如果用9维数组，包含了99=387420489项，显然造成了极大地浪费。 当然，我们可以采用哈希表来进行映射，而哈希函数便可以使用康托展开（OhYee第一定理）。 当年我可是在有OhYee第一定理的情况下做过八数码的，可惜当时竟然没有想到用OhYee第一定理。。。 嗯嗯，我们就不管是康托展开，还是康托逆展开了，反正都是OhYee定理的内容23333333333 含义 对于｛1，2，3，4｝其排列有：1234，1243，1324，1342，1423，1432，2134，2143，2314，2341，2413，2431，3124，3142，3214，3241，3412，3421，4123，4132，4213，4231，4312，4321共24种。 这样我们就可以按照从小到大的顺序，给他们编上号，就有了一个映射关系 123456789101112123412431324134214231432213421432314234124132431131415161718192021222324312431423214324134123421412341324213423143124321 这样将序号和数字的映射就是康托（逆）展开 原理由上面｛1，2，3，4｝的例子很容易发现，从小到大排列，有着一定的规律。 以每个数开头的，分别占据了总数（4!）的1/4，即3！。 第一个以1开头的在0×3！+1=1 第一个以2开头的在1×3！+1=7 …… 也就是说N个数全排列，第一个数是x的数出现在(x-1)×(N-1)!+1处。 第一个数确定后，我们再看第二个数。假如第一个数是2，那么还有{1，3，4}三个数。 令1=1，2=3，3=4，我们便可看成{1，2，3}三个数的排列 假如是那么第一个2便在1×2!+1=3 再映射回去，也就是第二个是3的在第3个，对照上表看，在第一个是2的数中第二个是3的第一个数就是第3个 就这样，不断类比下去，就可以得到一个数在其排列中的位置。这就是OhYee第一定理 ps:最后的+1只需要加一次 例子假如我们想要计算在{1，2，3，4}的全排列中，2413的位置 首先有对2，比2小的有1，共1个。1×3！=6 此时剩下1，3，4。 然后对4，比4小的有1，3，共2个。2×2！=4 此时剩下1，3。 然后对1，比1小的有0个。0×1！=0 此时剩下3，比3小的有0个。0×0！=0 所以，2413的位置是6+4+0+0+1=11 逆着来一遍排列中，第11个是什么呢~ 首先划分区间3！=6，也就是6个一组（以相同的数字开头） 这样11-6=5&lt;=6 在第2区间。第一个数是2 再往下划分区间2！=2 5-2=3 3-2=1&lt;=2在第3区间。第二个数是4 再往下划分1！=1 1&lt;=1在第一区间。第三个数是1 再往下划分0！=1 1&lt;=1在第一区间。第四个数是3 所以，第11个数是2413 根据上面的分析，我们需要不断插入删除数字，需要用链表来记录还存在的数 用指针弄一个链表（输出了中间运算过程） 链表class linked_list&#123;private: struct link&#123; int num; link *next; &#125;; link *head;public: linked_list()&#123; head=NULL; &#125; void Add(int n)&#123; link *it; if(head==NULL)&#123; head=new link; it=head; &#125;else&#123; it=head; while((it-&gt;next)!=NULL)&#123; it=it-&gt;next; &#125; it-&gt;next=new link; it=it-&gt;next; &#125; it-&gt;num=n; it-&gt;next=NULL; cout&lt;&lt;\"add \"&lt;&lt;n&lt;&lt;\" (\"&lt;&lt;it&lt;&lt;\")\"&lt;&lt;endl; &#125; void Del(int n)&#123; link *it=head; if(it-&gt;num==n)&#123; head=it-&gt;next; delete(it); cout&lt;&lt;\"delete \"&lt;&lt;n&lt;&lt;\" (\"&lt;&lt;it&lt;&lt;\")\\n\"; return; &#125; while(it-&gt;next-&gt;num!=n)&#123; it= it-&gt;next; if(it-&gt;next==NULL)return; &#125; link *temp=it-&gt;next; it-&gt;next=it-&gt;next-&gt;next; delete(temp); cout&lt;&lt;\"delete \"&lt;&lt;n&lt;&lt;\" (\"&lt;&lt;temp&lt;&lt;\")\\n\"; &#125; int get(int n)&#123; link *it=head; int cnt=0; cout&lt;&lt;\"begin \"; while(it-&gt;num!=n)&#123; cout&lt;&lt;\"----&gt;\"&lt;&lt;it&lt;&lt;\"(\"&lt;&lt; it-&gt;num &lt;&lt;\") \"; it=it-&gt;next; cnt++; &#125; cout&lt;&lt;endl; return cnt; &#125; int get2(int n)&#123; link *it=head; cout&lt;&lt;\"begin \"; while(n&gt;1)&#123; cout&lt;&lt;\"----&gt;\"&lt;&lt;it&lt;&lt;\"(\"&lt;&lt; it-&gt;num &lt;&lt;\") \"; it=it-&gt;next; n--; &#125; cout&lt;&lt;\"----&gt;\"&lt;&lt;it&lt;&lt;\"(\"&lt;&lt; it-&gt;num &lt;&lt;\") \"&lt;&lt;endl; return it-&gt;num; &#125;&#125;; 其中Add()是向链表最后插入，Del()是删除存储制定数据的节点，get()是获取指定数据前面的节点数，get2()是获取指定节点存储的数 代码int factorial[]=&#123;1,1,2,6,24,120,720,5040,40320&#125;;//n!int KT(int N,int x)&#123; int ans=1; linked_list L; stack&lt;int&gt; S; while(x)&#123; S.push(x%10); x/=10; &#125; REP(N)&#123; L.Add(o+1); &#125; REP(N)&#123; int a=L.get(S.top()); L.Del(S.top()); S.pop(); ans+=a*factorial[N-o-1]; &#125; return ans;&#125;int KTN(int N,int n)&#123; int ans=0; linked_list L; REP(N)&#123; L.Add(o+1); &#125; REP(N)&#123; ans*=10; int t=1; while(n&gt;factorial[N-o-1])&#123; n-=factorial[N-o-1]; t++; &#125; int temp=L.get2(t); ans+=temp; L.Del(temp); &#125; return ans;&#125;","tags":[{"name":"康托","slug":"Contour","permalink":"https://www.oyohyee.com/tags/Contour/"}]},{"title":"高精度算法","date":"2015-08-01T15:17:00.000Z","path":"/post/Algorithm/High_precision.html","text":"c++中，变量的大小是有限制的。 比如int是 -2147483648~2147483647 long long是-9223372036854775808~18446744073709551615 然而他们都有一个范围，如果数据过大，就会出现错误。这时，我们需要高精度计算。 同过数组来存储各位上的情况，模拟计算加减乘除。 首先，我们定义一个叫做bigNumber的类 然后，在里面声明一个整数数组（1000位） 其中，num[0]保存该数位数，num[i]表示对应数位上的数 数据的存储方式为(以13为例) num 0 1 2 3数值 2 1 3 0备注 位数 个位 十位 百位 接着，我们要定义构造函数来初始化它 要注意，构造函数本身被调用是没什么琴里用的，可以再写一个初始化函数，然后在构造函数里调用它，但需要初始化时，调用初始化函数，而不是构造函数 bigNumber()&#123;//初始化 init();&#125;void init()&#123; memset(num,0,sizeof(num));&#125; 然后，就是一些基本的功能的实现,例如等于、小于、大于…… 这些都是比较容易实现的，不详细说明了 而四则运算则相对更为复杂 加法首先是加法 我们先来看一下我们自己是如何计算加法的。 例如5135+139 对齐数位 5 1 3 5 + 1 3 9 从低位开始加，当低位相加后大于9时，把较大数加到下一位上 而且，我们可以知道，即使是9+9也才等于18。也即计算后，和的位数最多比加数的位数多1 bigNumber operator + (const bigNumber rhs)const&#123; bigNumber temp; int len; len=num[0]&gt;rhs.num[0]?num[0]:rhs.num[0]; len++;//两数相加，位数最多比较大的位数多1 REP(len)&#123; temp.num[o+1]+=num[o+1]+rhs.num[o+1]; temp.num[o+2]+=temp.num[o+1]/10; temp.num[o+1]%=10; &#125; REP(len)&#123; if(temp.num[len-o]!=0)&#123; temp.num[0]=len-o; break; &#125; &#125; return temp;&#125; 乘法而乘法相似，只是是乘数相乘加上进位(乘数与乘数各数位都要乘一次) 5 1 3 5 × 1 3 9 ------------------------- 4 6 2 1 5 1 5 4 0 5 5 1 3 5 ------------------------- 7 1 3 7 6 5 bigNumber operator * (const bigNumber rhs)const&#123; bigNumber temp; int len; len=num[0]+rhs.num[0]; //len++; for(int i=1;i&lt;=num[0];i++)&#123; for(int j=1;j&lt;=rhs.num[0];j++)&#123; temp.num[i+j-1]+=num[i]*rhs.num[j]; temp.num[i+j]+=temp.num[i+j-1]/10; temp.num[i+j-1]%=10; &#125; &#125; REP(len)&#123; if(temp.num[len-o]!=0)&#123; temp.num[0]=len-o; break; &#125; &#125; return temp;&#125; 减法而减法和除法则较为麻烦 首先，本高精度计算不考虑负数情况，不过负数也并不难写，可以再加上一个bool来储存是否为负数 不管减数和被减数谁大，都应该是绝对值大的减去绝对值小的（符号相同） 与加法不同，减法存在借数。不过如果不管需不需要借都借一下，然后如果结果是两位数再进上去更便于书写 模仿加法稍加修改 bigNumber operator - (const bigNumber rhs)const&#123; bigNumber temp,a,b; temp=Max(*this,rhs); b=Min(*this,rhs); a=temp; temp=0; int len=a.num[0]; REP(len)&#123; temp.num[o+1]+=10+a.num[o+1]-b.num[o+1]; temp.num[o+2]--; temp.num[o+2]+=temp.num[o+1]/10; temp.num[o+1]%=10; &#125; REP(len)&#123; if(temp.num[len-o]!=0)&#123; temp.num[0]=len-o; break; &#125; &#125; return temp;&#125; 除法除法是最难写的一部分了，因为牵扯到试商的问题 我们先来理解一下除法的计算过程（以11311÷12为例） 首先，从被除数的最高位开始除有1÷12=0······1 余数乘10加上被除数的下一位11÷12=0······11 余数乘10加上被除数的下一位113÷12=9······5 余数乘10加上被除数的下一位51÷12=4·····3 余数乘10加上被除数的下一位31÷12=2·····7 得到答案11311÷12=942······7 2016.7.3 修正 0 不输出的问题 bigNumber operator / (const bigNumber rhs)const&#123; bigNumber a; int it=num[0]; bigNumber d; bigNumber c; while(it&gt;0)&#123; a=(d*10)+num[it]; c=c*10; int t; REP(9)&#123; if(a &lt; rhs * (o+1))&#123; t=o; break; &#125; t=9; &#125; c=c+t; d=a-rhs*t; it--; &#125; return c;&#125; 取余稍加修改，就成了取余bigNumber operator % (const bigNumber rhs)const&#123; bigNumber a; int it=num[0]; bigNumber d; bigNumber c; while(it&gt;0)&#123; a=(d*10)+num[it]; c=c*10; int t; REP(9)&#123; if(a &lt; rhs * (o+1))&#123; t=o; break; &#125; t=9; &#125; c=c+t; d=a-rhs*t; it--; &#125; return d;&#125; 完整的代码高精度算法： class bigNumber&#123; private: int num[1001]; public: bigNumber()&#123; init(); &#125; void init()&#123; memset(num,0,sizeof(num)); &#125; bigNumber operator = (const bigNumber&amp; rhs)&#123; init(); REP(rhs.num[0]+1)num[o]=rhs.num[o]; return *this; &#125; bigNumber operator = (long long rhs)&#123; init(); int i=1; while(rhs)&#123; num[i]=rhs%10; rhs/=10; i++; &#125; num[0]=i-1; return *this; &#125; bool operator &lt; (const bigNumber rhs)const&#123; if(num[0]!=rhs.num[0])return (num[0]&lt;rhs.num[0]); REP(num[0])&#123; int temp=num[0]-o; if(num[temp]!=rhs.num[temp])return (num[temp]&lt;rhs.num[temp]); &#125; return 0; &#125; bool operator &gt; (const bigNumber rhs)const&#123; if(num[0]!=rhs.num[0])return (num[0]&gt;rhs.num[0]); REP(num[0])&#123; int temp=num[0]-o; if(num[temp]!=rhs.num[temp])return (num[temp]&gt;rhs.num[temp]); &#125; return 0; &#125; bool operator == (const bigNumber rhs)const&#123; return !(*this&gt;rhs||*this&lt;rhs); &#125; bool operator &lt;= (const bigNumber rhs)const&#123; return *this&lt;rhs||*this ==rhs; &#125; bigNumber operator + (const bigNumber rhs)const&#123; bigNumber temp; int len; len=num[0]&gt;rhs.num[0]?num[0]:rhs.num[0]; len++; REP(len)&#123; temp.num[o+1]+=num[o+1]+rhs.num[o+1]; temp.num[o+2]+=temp.num[o+1]/10; temp.num[o+1]%=10; &#125; REP(len)&#123; if(temp.num[len-o]!=0)&#123; temp.num[0]=len-o; break; &#125; &#125; return temp; &#125; bigNumber operator + (const long long rhs)const&#123; bigNumber temp1,temp2; temp1=*this; temp2=rhs; return temp1 + temp2; &#125; bigNumber operator * (const bigNumber rhs)const&#123; bigNumber temp; int len; len=num[0]+rhs.num[0]; //len++; for(int i=1;i&lt;=num[0];i++)&#123; for(int j=1;j&lt;=rhs.num[0];j++)&#123; temp.num[i+j-1]+=num[i]*rhs.num[j]; temp.num[i+j]+=temp.num[i+j-1]/10; temp.num[i+j-1]%=10; &#125; &#125; REP(len)&#123; if(temp.num[len-o]!=0)&#123; temp.num[0]=len-o; break; &#125; &#125; return temp; &#125; bigNumber operator * (const long long rhs)const&#123; bigNumber temp1,temp2; temp1=*this; temp2=rhs; return temp1 * temp2; &#125; bigNumber operator - (const bigNumber rhs)const&#123; bigNumber temp,a,b; temp=Max(*this,rhs); b=Min(*this,rhs); a=temp; temp=0; int len=a.num[0]; REP(len)&#123; temp.num[o+1]+=10+a.num[o+1]-b.num[o+1]; temp.num[o+2]--; temp.num[o+2]+=temp.num[o+1]/10; temp.num[o+1]%=10; &#125; REP(len)&#123; if(temp.num[len-o]!=0)&#123; temp.num[0]=len-o; break; &#125; &#125; return temp; &#125; bigNumber operator - (const long long rhs)const&#123; bigNumber temp1,temp2; temp1=*this; temp2=rhs; return temp1 - temp2; &#125; bigNumber operator / (const bigNumber rhs)const&#123; bigNumber a; int it=num[0]; bigNumber d; bigNumber c; while(it&gt;0)&#123; a=(d*10)+num[it]; c=c*10; int t; REP(9)&#123; if(a &lt; rhs * (o+1))&#123; t=o; break; &#125; t=9; &#125; c=c+t; d=a-rhs*t; it--; &#125; return c; &#125; bigNumber operator / (const long long rhs)const&#123; bigNumber temp1,temp2; temp1=*this; temp2=rhs; return temp1 / temp2; &#125; bigNumber operator % (const bigNumber rhs)const&#123; bigNumber a; int it=num[0]; bigNumber d; bigNumber c; while(it&gt;0)&#123; a=(d*10)+num[it]; c=c*10; int t; REP(9)&#123; if(a &lt; rhs * (o+1))&#123; t=o; break; &#125; t=9; &#125; c=c+t; d=a-rhs*t; it--; &#125; return d; &#125; bigNumber operator % (const long long rhs)const&#123; bigNumber temp1,temp2; temp1=*this; temp2=rhs; return temp1 % temp2; &#125; void p()&#123; if(num[0] == 0) printf(\"0\"); REP(num[0])&#123; printf(\"%d\",num[num[0]-o]); &#125; &#125;&#125;;","tags":[{"name":"高精度算法","slug":"High-precision","permalink":"https://www.oyohyee.com/tags/High-precision/"}]},{"title":"筛法求素数","date":"2015-07-30T07:48:00.000Z","path":"/post/Algorithm/Prime.html","text":"质数（prime number）又称素数，有无限个。一个大于1的自然数，除了1和它本身外，不能被其他自然数（质数）整除，换句话说就是该数除了1和它本身以外不再有其他的因数；否则称为合数。 ——百度百科 要想判断一个数是不是质数，就要看他能不能被除了1和自己之外的数分解 显然如果当需要多次判断数据是否是素数时，每次都计算一次是很慢的。 但是可以声明一个布尔型数组，保存对应下标是否为素数，这样只需要计算一次。 开始时，从2开始，分别乘上2以上的数，所得的数全都不是素数 以下部分证明有误#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;bool is_prime[10001];int main()&#123; memset(is_prime,true,sizeof(is_prime)); for(int i=2;i&lt;=100;i++)&#123; for(int j=2;j&lt;=100;j++)&#123; is_prime[i*j]=false; &#125; &#125;// printf(\"%d\",is_prime[4]); int num; //cin&gt;&gt;num; for (num=2;num&lt;100;num++)&#123; if(is_prime[num]==true)&#123; cout&lt;&lt;num&lt;&lt;\"是素数\"&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;num&lt;&lt;\"不是素数\"&lt;&lt;endl; &#125; &#125; return 0;&#125; 显然，对于12，这样既计算了26，也计算了62（还有34，43），所以这样重复计算了大量数据 修改一下算法，可以让运算量稍小。 合数可以分解成质数相乘，而根据算法，如果一个合数已经被确定，那么由它得出的合数也都被确定。 所以，如果发现一个数是合数，那么就不必再计算由它乘出的数 同时，保证相乘的两个数都是前一个小后一个大，这样可以避免同一组数的重复计算。 Eratosthenes筛法#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int maxn=10000;bool is_prime[maxn+1];int main()&#123; int m=sqrt(maxn+0.5); memset(is_prime,true,sizeof(is_prime)); for(int i=2;i&lt;=m;i++)&#123; if(is_prime)&#123; for(int j=i*i;j&lt;=maxn;j+=i)&#123; is_prime[j]=false; &#125; &#125; &#125; for(int num=2;num&lt;100;num++)&#123; if(is_prime[num]==true)&#123; cout&lt;&lt;num&lt;&lt;\"是素数\"&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;num&lt;&lt;\"不是素数\"&lt;&lt;endl; &#125; &#125; return 0;&#125; 然而，如果我们添加一个count变量来记录每个数被重复运算的次数。会发现，仍然有好多数被重复运算。 不过，线性的算法还是存在的 算术基本定理可表述为：任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积N=P1a1P2a2P3a3……Pnan，这里P1&lt;P2&lt;P3……&lt;Pn均为质数，其中指数ai是正整数。这样的分解称为 N 的标准分解式。最早证明是由欧几里得给出的，现代是由陈述证明。此定理可推广至更一般的交换代数和代数数论。 ——百度百科 只需要计算出所有 i×(小于i的素数) ，那么我们便可以得到所有的合数。同时，通过排除掉i是(小于i的素数)的整倍数的情况来保证只计算一次 #include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int maxn=10000;int main()&#123; int count[maxn+1]=&#123;0&#125;; int prime[maxn]=&#123;0&#125;,num_prime=0; bool isNotPrime[maxn]=&#123;1,1&#125;; for(long i=2;i&lt;maxn;i++)&#123; if(!isNotPrime[i])prime[num_prime++]=i; for(int j=0;j&lt;num_prime&amp;&amp;i*prime[j]&lt;maxn;j++)&#123; isNotPrime[i*prime[j]]=true; count[i*prime[j]]++; if(!(i%prime[j]))break; &#125; &#125; for(int num=1;num&lt;100;num++)&#123; if(isNotPrime[num]!=true)&#123; cout&lt;&lt;num&lt;&lt;\"是素数\"&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;num&lt;&lt;\"不是素数\"&lt;&lt;endl; &#125; &#125; for(int i=1;i&lt;=maxn;i++)if(count[i]&gt;1)cout&lt;&lt;i&lt;&lt;\":\"&lt;&lt;count[i]&lt;&lt;endl; return 0;&#125;","tags":[{"name":"质数","slug":"Prime","permalink":"https://www.oyohyee.com/tags/Prime/"}]},{"title":"欧几里得算法","date":"2015-07-30T05:07:00.000Z","path":"/post/Algorithm/Euclid.html","text":"需要知识 同余数论中的重要概念。给定一个正整数m，如果两个整数a和b满足（a-b）能够整除m，即（a-b）/m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)。对模m同余是整数的一个等价关系。——百度百科 关于同余的定理 欧几里德算法 辗转相除法， 又名欧几里德算法（Euclidean algorithm）乃求两个正整数之最大公因子的算法。它是已知最古老的算法， 其可追溯至3000年前。这种算法，在中国则可以追溯至东汉出现的《九章算术》。——百度百科简单明了的最大公因数计算算法。 int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125; 证明如下 有整数X，Y。其中，X=ar，Y=br(a,b互质，且r为最大公因数)。有X-Y=(a-b)*r。则，X、Y、X-Y互相间最大公因数相同。 有整数X，Y。其中，X=ar+c，Y=br+d(r为最大公因数，且c，d小于r)。设e=X%Y，也即(e+d+br)n=ar+c，有e=ar+c-d-br=(a-b)r+(c-d)，所以X、Y、X%Y互相间最大公因数相同。","tags":[{"name":"欧几里得算法","slug":"Euclid","permalink":"https://www.oyohyee.com/tags/Euclid/"},{"name":"辗转相除法","slug":"gcd","permalink":"https://www.oyohyee.com/tags/gcd/"}]},{"title":"快速幂取模","date":"2015-07-29T12:59:00.000Z","path":"/post/Algorithm/Raising_Modulo_Numbers.html","text":"取余数有%，即 10%3 可以得到1 但是当数比较大时(比如2999999)，计算机可能就无法计算 然而，根据数论的结论，我们可以简化一下。根据a*b mod c = ( (a mod c) * (b mod c) ) mod c 可以得出 an mod b = (a mod b)n mod b 所以，有 an mod b = (a mod b)n mod b = (a mod b)n/22 mod b = (an/2 mod b)2 mod b = (an/2 mod b)2 mod b 如果用exp_mod(a,n,b)表示an mod b那么就是exp_mod(a,n,b) = exp_mod(a,n/2,b)*exp_mod(a,n/2,b) mod b 那么我们可以不断二分幂，从而减小运算 有几种特殊情况需要考虑 n=0，也即a^n=1，此时模为1%b n=1，这时二分已经到了终点，可以直接用a%b得到答案 n为奇数，此时n/2会被舍去小数部分，会少乘一个a mod b，可以在补上a mod b 代码如下：typedef long long LL;LL exp_mod(LL a,LL n,LL b)&#123; LL t; if(n==0) return 1%b; if(n==1) return a%b; t=exp_mod(a,n/2,b); t=t*t%b; if((n&amp;1)==1) t=t*a%b; return t;&#125;","tags":[{"name":"二分","slug":"Division","permalink":"https://www.oyohyee.com/tags/Division/"},{"name":"快速幂取模","slug":"Raising-Modulo-Numbers","permalink":"https://www.oyohyee.com/tags/Raising-Modulo-Numbers/"},{"name":"递归与分治","slug":"Recursion","permalink":"https://www.oyohyee.com/tags/Recursion/"}]},{"title":"同余","date":"2015-07-28T12:17:00.000Z","path":"/post/Algorithm/Congruence.html","text":"同余指两个整数除以同一正数，余数相同。同余指两个整数相减能够被一个整数整除。 反身性 a≡a(mod m) 对称性 若a≡b(mod m)，则b≡a (mod m) 传递性 若a≡b (mod m)，b≡c (mod m)，则a≡c (mod m) 同余式相加 若a≡b (mod m)，c≡d(mod m)，则a+-c≡b+-d (mod m) 同余式相乘 若a≡b (mod m)，c≡d(mod m)，则ac≡bd (mod m) 线性运算如果a ≡ b (mod m)，c ≡ d (mod m),那么(1)a ± c ≡ b ± d (mod m)，(2)a c ≡ b d (mod m) 除法若ac ≡ bc (mod m) c≠0 则 a≡ b (mod m/gcd(c,m)) 其中gcd(c,m)表示c,m的最大公约数.特殊地 ,gcd(c,m)=1 则a ≡ b (mod m) 幂运算如果a ≡ b (mod m)，那么a^n ≡ b^n (mod m) a ≡ b (mod m)，n|m,则 a ≡ b (mod n) 若a ≡ b (mod mi) (i=1,2…n) 则 a ≡ b (mod [m1,m2,…mn]) 其中[m1,m2,…mn]表示m1,m2,…mn的最小公倍数 欧拉定理设a,m∈N,(a,m)=1,则a^(φ(m))≡1(mod m)(注:φ(m)指模m的简系个数， φ(m)=m-1, 如果m是素数；φ(m=q1^r1 q2^r2 …*qi^ri)=m (1-1/q1)(1-1/q2)…(1-1/qi))推论: 费马小定理: 若p为质数，则a^p ≡ a (mod p) 即a^(p-1) ≡ 1 (mod p) （但是当p|a时不等价） 中国剩余定理设整数m1,m2,m3,……,mn 两两互素，令m=m1m2m3m4m5…mn（mi的连乘）。则对于任意的J在（1,n)整数，下列联立的同余式有解：{xj≡1(mod mj){xj≡0(mod mi) i不等于j令x为从1到najxj的和，则x适合下列联立同余式x≡aj（mod mj）, j=1,2,3,…..,n","tags":[{"name":"数学","slug":"Math","permalink":"https://www.oyohyee.com/tags/Math/"},{"name":"同余","slug":"Congruence","permalink":"https://www.oyohyee.com/tags/Congruence/"}]},{"title":"图论相关算法","date":"2015-07-27T10:20:00.000Z","path":"/post/Algorithm/Graph.html","text":"转载自：http://cojs.tk/cogs/page/page.php?aid=30 最小生成树 Kruskal+ufs int ufs(int x)&#123; return f[x] == x ? x : f[x] = ufs(f[x]); &#125; int Kruskal(int n,int m) &#123; int w = 0; for(int i = 0; i &lt; n; i++) f[i] = i; sort(e,e + m); for(int i = 0; i &lt; m; i++) &#123; int x = ufs(e[i].u),y = ufs(e[i].v); if(x != y) &#123; f[x] = y; w += e[i].w; &#125; &#125; return w;&#125; prim int Prim() &#123; int w = 0; priority_queue&lt;pair&lt;int, int&gt; &gt; q; bool l[N] = &#123;0&#125;; l[1] = 1; q.push(make_pair(0, 1)); for(int k=1; k&lt;n; k++) &#123; int u = q.top().second; q.pop(); for(int i=0; i&lt;G[u].size(); i++) if(!l[G[u][i]]) q.push(make_pair(-c[u][i], G[u][i])); while(!q.empty() &amp;&amp; l[q.top().second]) q.pop(); l[q.top().second] = 1; w += -q.top().first; q.pop(); &#125; return w;&#125; 最短路径 Dijkstra+priority_queue void Dijkstra(int s) &#123; priority_queue&lt;pair&lt;int, int&gt; &gt; q; bool l[N] = &#123;0&#125;; l[s] = 1; fill_n(f, n, INF); f[s] = 0; q.push(make_pair(-f[s], s)); while(!q.empty()) &#123; int u = q.front().second; q.pop(); for(int i=0; i&lt;G[u].size(); i++) &#123; int v = G[u][i]; if(f[v] &gt; f[u] + c[u][i]) &#123; f[v] = f[u] + c[u][i]; if(!l[v]) &#123; l[v] = 1; q.push(make_pair(-f[v], v)); &#125; &#125; &#125; &#125; &#125; Bellman-Ford (SPFA) void BellmanFord(int s) &#123; // SPFA queue&lt;int&gt; q; bool l[N] = &#123;0&#125;; l[s] = 1; fill_n(f, n, INF); f[s] = 0; q.push(s); while(!q.empty()) &#123; int u = q.front(); q.pop(); l[u] = 0; for(int i=0; i&lt;G[u].size(); i++) &#123; int v = G[u][i]; if(f[v] &gt; f[u] + c[u][i]) &#123; f[v] = f[u] + c[u][i]; if(!l[v]) &#123; l[v] = 1; q.push(v); &#125; &#125; &#125; &#125;&#125; Floyd void Floyd() &#123; for(int k=0; k&lt;n; k++) for(int i=0; i&lt;n; i++) for(int j=0; j&lt;n; j++) f[i][j] = min(f[i][j], f[i][k] + f[k][j]);&#125; 二分图 ufs 验证 Hungary bool DFS(int u) &#123; for(int i=0; i&lt;G[u].size(); i++) &#123; int v = G[u][i]; if(!l[v]) &#123; l[v] = 1; if(!f[v] || DFS(f[v])) &#123; f[v] = u; return true; &#125; &#125; &#125; return false; &#125; int Hungary() &#123; int w = 0; for(int i=0; i&lt;n; i++) &#123; fill_n(l, l+n, 0); if(DFS(i)) w++; &#125; return w;&#125; 连通分量 Tarjan stack stack&lt;int&gt; s; void Tarjan(int u) &#123; dfn[u] = low[u] = ++time; l[u] = 1; s.push(u); for(int i=0; i&lt;G[u].size(); i++) &#123; int v = G[u][i]; if(!dfn[v]) &#123; Tarjan(v); low[u] = min(low[u], low[v]); &#125; else if(l[v]) low[u] = min(low[u], dfn[v]); &#125; if(dfn[u] == low[u]) &#123; w++; do &#123;int v; l[v = s.top()] = 0; f[v] = w; s.pop(); &#125; while(u != v); &#125; &#125; void SCC() &#123; fill_n(dfn, n, 0); for(int i=0; i&lt;n; i++) if(!dfn(i)) Tarjan(i); &#125; 网络流 费用流：Bellman-Ford 找增广路，或者用贪心求解 最大流：Edmonds-KarpS","tags":[{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"}]},{"title":"STL笔记","date":"2015-07-27T09:22:00.000Z","path":"/post/Note/STLNote.html","text":"STL方面的笔记以下为vector queue map set stack的基本用法可编译结合注释查看 #include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;#define REP(n) for(int o=0;o&lt;n;o++)int main()&#123; cout&lt;&lt;\"vector功能\"&lt;&lt;endl; vector&lt;int&gt; vec;//声明名称为vec的整数型向量 vector&lt;int&gt;::iterator it_vec;//迭代器 vec.clear();//清空 cout&lt;&lt;\"插入数据\"&lt;&lt;endl; vec.push_back(1);//在末尾插入 vec.push_back(3); it_vec=vec.end();//指向vec的末尾 it_vec--;//向前移动一位（既1和3的中间） vec.insert(it_vec,2);//在此处插入2 REP(vec.size())cout&lt;&lt;vec[o]&lt;&lt;endl;//访问数据 cout&lt;&lt;\"清除第一个数据后输出\"&lt;&lt;endl; vec.erase(vec.begin()); it_vec=vec.begin(); REP(vec.size())&#123; cout&lt;&lt;*it_vec&lt;&lt;endl;//访问数据 it_vec++;//向后一位 &#125; cout&lt;&lt;\"#####################################\"&lt;&lt;endl&lt;&lt;endl; cout&lt;&lt;\"map功能\"&lt;&lt;endl; map&lt;string,vector&lt;int&gt; &gt; m;//声明 key的类型为string value类型为int型vector 的 映射m map&lt;string,vector&lt;int&gt; &gt;::iterator it_map;//迭代器 cout&lt;&lt;\"插入数据\"&lt;&lt;endl; m.insert(pair&lt;string,vector&lt;int&gt; &gt;(\"aaa\",vec)); it_map=m.find(\"aaa\");//或者指定key的位置（迭代器） cout&lt;&lt;\"key:\"&lt;&lt;it_map-&gt;first&lt;&lt;endl; cout&lt;&lt;\"value:\"&lt;&lt;endl; REP(vec.size())cout&lt;&lt;\" \"&lt;&lt;vec[o]&lt;&lt;endl; cout&lt;&lt;\"查找一个不存在的数据 find()会返回map的末尾\"&lt;&lt;endl; it_map=m.find(\"Niconiconi~\"); if(it_map==m.end())cout&lt;&lt;\"No Niconiconi~\"&lt;&lt;endl; cout&lt;&lt;\"#####################################\"&lt;&lt;endl&lt;&lt;endl; cout&lt;&lt;\"set功能\"&lt;&lt;endl; set&lt;int&gt; s;//声明一个整数型集合 set&lt;int&gt;::iterator it_set;//迭代器 cout&lt;&lt;\"倒叙插入数据并且有重复的4\"&lt;&lt;endl; s.insert(5); s.insert(4); s.insert(4); s.insert(2); s.insert(1); it_set=s.begin(); while(it_set!=s.end())&#123; cout&lt;&lt;*it_set&lt;&lt;endl; it_set++; &#125; cout&lt;&lt;\"输出时4自动保留一个，并且数据由小到大输出\"&lt;&lt;endl; cout&lt;&lt;\"#####################################\"&lt;&lt;endl&lt;&lt;endl; cout&lt;&lt;\"queue功能\"&lt;&lt;endl; queue&lt;string&gt; q;//声明一个字符串型队列 q cout&lt;&lt;\"按顺序插入\"&lt;&lt;endl; q.push(\"L\"); q.push(\"O\"); q.push(\"V\"); q.push(\"E\"); q.push(\"L\"); q.push(\"I\"); q.push(\"V\"); q.push(\"E\"); q.push(\"!\"); while(!q.empty())&#123; cout&lt;&lt;q.front(); q.pop(); &#125; cout&lt;&lt;endl; cout&lt;&lt;\"先入队的先出来\"&lt;&lt;endl; cout&lt;&lt;\"#################################\"&lt;&lt;endl&lt;&lt;endl; cout&lt;&lt;\"priority_queue功能\"&lt;&lt;endl; priority_queue&lt;string&gt; pq;//声明priority_queue一个字符串型优先队列 cout&lt;&lt;\"乱序插入具有可比较大小的数据\"&lt;&lt;endl; pq.push(\"B\"); pq.push(\"A\"); pq.push(\"C\"); while(!pq.empty())&#123; cout&lt;&lt;pq.top(); pq.pop(); &#125; cout&lt;&lt;endl; cout&lt;&lt;\"权值大的先出来\"&lt;&lt;endl; cout&lt;&lt;\"###############################\"&lt;&lt;endl&lt;&lt;endl; cout&lt;&lt;\"stack功能\"&lt;&lt;endl; stack&lt;string&gt; sta;//声明一个字符串类型的栈 cout&lt;&lt;\"倒序插入数据\"&lt;&lt;endl; sta.push(\"+\"); sta.push(\"+\"); sta.push(\"C\"); while(!sta.empty())&#123; cout&lt;&lt;sta.top(); sta.pop(); &#125; cout&lt;&lt;endl; cout&lt;&lt;\"先进入的后出来\"&lt;&lt;endl; return 0;&#125; 编译结果 vector功能 插入数据 1 2 3 清除第一个数据后输出 2 3 # map功能 插入数据 key:aaa value: 2 3 查找一个不存在的数据 find()会返回map的末尾 No Niconiconi~ # set功能 倒叙插入数据并且有重复的4 1 2 4 5 输出时4自动保留一个，并且数据由小到大输出 # queue功能 按顺序插入 LOVELIVE! 先入队的先出来 # priority_queue功能 乱序插入具有可比较大小的数据 CBA 权值大的先出来 # stack功能 倒序插入数据 C++ 先进入的后出来","tags":[{"name":"栈(stack)","slug":"Stack","permalink":"https://www.oyohyee.com/tags/Stack/"},{"name":"队列(queue)","slug":"Queue","permalink":"https://www.oyohyee.com/tags/Queue/"},{"name":"向量(vector)","slug":"Vector","permalink":"https://www.oyohyee.com/tags/Vector/"},{"name":"映射(map)","slug":"Map","permalink":"https://www.oyohyee.com/tags/Map/"},{"name":"集合(set)","slug":"Set","permalink":"https://www.oyohyee.com/tags/Set/"}]},{"title":"ACM进阶计划","date":"2015-07-27T09:19:00.000Z","path":"/post/Note/ACM.html","text":"转载自：http://cojs.tk/cogs/page/page.php?aid=38 ACM进阶计划ACM队不是为了一场比赛而存在的，为的是队员的整体提高。 大学期间，ACM队队员必须要学好的课程有： l C/C++两种语言 l 高等数学 l 线性代数 l 数据结构 l 离散数学 l 数据库原理 l 操作系统原理 l 计算机组成原理 l 人工智能 l 编译原理 l 算法设计与分析 除此之外，我希望你们能掌握一些其它的知识，因为知识都是相互联系，触类旁通的。 以下学习计划每学期中的内容不分先后顺序，虽说是为立志于学习ACM的同学列的知识清单，但内容不限于ACM的知识。英语之类与专业相距较远的课程请自行分配时间，这里不再列举。 大一上学期： 必学： C语言基础语法必须全部学会 a) 推荐“语言入门”分类20道题以上 b) 提前完成C语言课程设计 简单数学题（推荐“数学”分类20道以上） 需要掌握以下基本算法： a) 欧几里德算法求最大公约数 b) 筛法求素数 c) 康托展开 d) 逆康托展开 e) 同余定理 f) 次方求模 计算几何初步 a) 三角形面积 b) 三点顺序 学会简单计算程序的时间复杂度与空间复杂度 二分查找法 简单的排序算法 a) 冒泡排序法 b) 插入排序法 贪心算法经典题目 高等数学 以下为选修： 学会使用简单的DOS命令（较重要） a) color/dir/copy/shutdown/mkdir(md)/rmdir(rd)/attrib/cd/ b) 知道什么是绝对路径与相对路径 c) 学会使用C语言调用DOS命令 d) 学会在命令提示符下调用你自己用C语言编写的程序，并使用命令行参数给自己的程序传参（比如自己制作一个copyfile.exe实现与copy命令基本功能一致的功能） e) 学会编写bat批处理文件 学会Windows系统的一些小知识，如设置隐藏文件，autoRun.inf的设置等。 学会编辑注册表（包括使用注册表编辑器regedit和使用DOS命令编辑注册表） 学会使用组策略管理器管理(gpedit.msc)组策略。 大一下学期： 掌握C++部分语法，如引用类型，函数重载等，基本明白什么是类。 学会BFS与DFS a) 迷宫求解（最少步数） b) 水池数目(NYOJ27) c) 图像有用区域(NYOJ92) d) 树的前序中序后序遍历 动态规划（15题以上），要学会使用循环的方法写动态规划，同时也要学会使用记忆化搜索的方法。 a) 最大子串和 b) 最长公共子序列 c) 最长单调递增子序列(O(n)与O(n log n)算法都需要掌握) d) 01背包 e) RMQ算法 学会分析与计算复杂程序的时间复杂度 学会使用栈与队列等线性存储结构 学会分治策略 排序算法 a) 归并排序 b) 快速排序 c) 计数排序 数论 a) 扩展欧几里德算法 b) 求逆元 c) 同余方程 d) 中国剩余定理 博弈论 a) 博弈问题与SG函数的定义 b) 多个博弈问题SG值的合并 图论： a) 图的邻接矩阵与邻接表两种常见存储方式 b) 欧拉路的判定 c) 单最短路bellman-ford算法dijkstra算法。 d) 最小生成树的kruskal算法与prim算法。 学会使用C语言进行网络编程与多线程编程 高等数学 线性代数 a) 明确线性代数的重要性，首先是课本必须学好 b) 编写一个Matrix类，进行矩阵的各种操作，并求编写程序解线性方程组。 c) 推荐做一两道“矩阵运算”分类下的题目。 以下为选修，随便选一两个学学即可： （较重要）使用C语言或C++编写简单程序来调用一些简单的windows API，或者在linux下进行linux系统调用，其目的是明白什么是API（应用程序接口）。 网页设计 a) 学习静态网页技术(html+css+javascript) b) 较具有艺术细胞的可以试试Photoshop c) php或其它动态网页技术 学习matlab，如果想参加数学建模大赛的话，需要学这个软件。 大一假期（如果留校集训） 掌握C++语法，并熟练使用STL 试着实现STL的一些基本容器和函数，使自己基本能看懂STL源码 图论 a) 使用优先队列优化Dijkstra和Prim b) 单源最短路径之SPFA c) 差分约束系统 d) 多源多点最短路径之FloydWarshall算法 e) 求欧拉路(圈套圈算法） 进行复杂模拟题训练 拓扑排序 动态规划进阶 a) 完全背包、多重背包等各种背包问题（参见背包九讲） b) POJ上完成一定数目的动态规划题目 c) 状态压缩动态规划 d) 树形动态规划 搜索 a) 回溯法熟练应用 b) 复杂的搜索题目练习 c) 双向广度优先搜索 d) 启发式搜索(包括A*算法，如八数码问题) 计算几何 a) 判断点是否在线段上 b) 判断线段相交 c) 判断矩形是否包含点 d) 判断圆与矩形关系 e) 判断点是否在多边形内 f) 判断点到线段的最近点 g) 计算两个圆的公切线 h) 求矩形的并的面积 i) 求多边形面积 j) 求多边形重心 k) 求凸包 选修 可以学习一种C++的开发框架来编写一些窗体程序玩玩（如MFC,Qt等)。 学习使用C或C++连接数据库。 大二一整年： 数据结构 a) 单调队列 b) 堆 c) 并查集 d) 树状数组 e) 哈希表 f) 线段树 g) 字典树 图论 a) 强连通分量 b) 双连通分量（求割点，桥） c) 强连通分量与双连通分量缩点 d) LCA、LCA与RMQ的转化 e) 二分图匹配 i. 二分图最大匹配 ii. 最小点集覆盖 iii. 最小路径覆盖 iv. 二分图最优匹配 v. 二分图多重匹配 f) 网络流 i. 最大流的基本SAP ii. 最大流的ISAP或者Dinic等高效算法（任一） iii. 最小费用最大流 iv. 最大流最小割定理 动态规划多做题提高（10道难题以上） 数论 a) 积性函数的应用 b) 欧拉定理 c) 费马小定理 d) 威乐逊定理 组合数学 a) 群论基础 b) Polya定理与计数问题 c) Catalan数 计算几何 a) 各种旋转卡壳相关算法 b) 三维计算几何算法 理解数据库原理，学会SQL语句 学好计算机组成原理 学习Transact-SQL语言，学会使用触发器，存储过程，学会数据库事务等。 图论二 a) 网络流的各种构图训练（重要） b) 最小割与最小点权覆盖等的关系（详见《最小割模型在信息学竞赛中的应用》一文） c) 次小生成树 d) 第k短路 e) 最小比率生成树 线性规划 动态规划更高级进阶 KMP算法 AC自动机理论与实现 博弈论之Alpha-beta剪枝 选修，有相关兴趣的可以学一下： 自学C#或Java做一个项目，比如C++/C#/Java考试系统之类的。 先做一些小游戏玩玩，然后可以学一下DirectX或者OpenGL，或者可以试试XNA游戏框架。 了解一下游戏引擎相关的知识 其中的寒假假期最好： 自学完离散数学 自学概率论的部分章节 自学操作系统部分章节 大三、 巩固之前的知识，进行一遍大复习。 一些如蚁群算法，遗传算法，模拟退火算法等人工智能方面应用较广的随机性算法。 把编译原理上学的东西应用到编程中：如DFA,NFA，还有语法分析的各种方法等。 当你按上面那些一步步走过来时你已经是牛人了，后面要学的东西，就是由牛人自己来发掘的了。 http://acm.nyist.net 2011年6月21日","tags":[]},{"title":"Dijkstra算法","date":"2015-07-27T09:15:00.000Z","path":"/post/Algorithm/Dijkstra.html","text":"吐槽一句，这个东西好难拼 迪杰斯特拉算法是由荷兰计算机科学家狄克斯特拉于1959年提出的，因此又叫狄克斯特拉算法。是从一个顶点到其余各顶点的最短路径算法，解决的是有向图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。——百度百科 Dijkstra算法就是用来算在一个有向带权图中，一个点到其他各点的最短距离 其思路是： 给起始点权值标成0，其他点标成无限大。从出发点开始 向该点向能通向的点走，算出到各点的总距离，并标记在相应点上。 给该点标记上访问标志，以后不再访问该点，然后从所有点中选出权值最小的点，重复步骤2 当所有点均被标记后，各点权值即为到该点最短距离 代码我觉得我写的好冗杂，不过注释应该能看懂的，理会意思即可 #include &lt;iostream&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;class Dijkstra&#123; private: const int INF=100000; struct Edge&#123;//边 int to,weight; &#125;; struct Weight&#123;//用于优先队列的比较 int weight,n; bool operator &lt; (const Weight&amp; rhs)const&#123; return weight&gt;rhs.weight;//权值越大，优先度越小 &#125; &#125;; struct Tree&#123;//树 vector&lt;vector&lt;Edge&gt; &gt; node; vector&lt;int&gt; d;//到各个节点的最小值 int N;//节点数目 void init(int NodeNumber)&#123;//初始化 node.resize(NodeNumber); d.resize(NodeNumber); N=NodeNumber; &#125; void Add(int from,int to,int weight)&#123;//添加边 node[from].push_back((Edge)&#123;to,weight&#125;); &#125; &#125;; Tree T; public: void Add(int from,int to,int weight)&#123; T.Add(from,to,weight); &#125; void init(int NodeNumber)&#123; T.init(NodeNumber); &#125; void dijkstra(int v)&#123;//Dijkstra主算法 vector&lt;int&gt;done;//访问标记 done.resize(T.N); for(int i=0;i&lt;T.d.size();i++)&#123; T.d[i]=INF; done[i]=0; &#125; priority_queue &lt;Weight&gt; Q;//优先队列 Q.push((Weight)&#123;0,v&#125;);//从第一个点开始 T.d[v]=0; //BFS while(!Q.empty())&#123;//只要队列不空就走下去 int u=Q.top().n;//获得优先度最高的节点 Q.pop(); if(done[u])continue;//如果已经访问过就跳过 done[u]=1;//访问标记 for(int i=0;i&lt;T.node[u].size();i++)&#123;//该节点可以访问的节点 Edge&amp; next=T.node[u][i]; if(T.d[u]+next.weight&lt;T.d[next.to])&#123;//如果距离更短，则更新 T.d[next.to]=T.d[u]+next.weight; Q.push((Weight)&#123;next.weight,next.to&#125;); //可以在这里加上一个vector，用来记录路径 &#125; &#125; &#125; &#125; int get(int n)&#123;//返回到达指定节点的最短距离 return T.d[n]; &#125;&#125;;int main()&#123; Dijkstra D; D.init(6); D.Add(0,1,7); D.Add(0,2,9); D.Add(0,5,14); D.Add(1,0,7); D.Add(1,2,10); D.Add(1,3,15); D.Add(2,0,9); D.Add(2,1,10); D.Add(2,3,11); D.Add(2,5,2); D.Add(3,1,15); D.Add(3,2,11); D.Add(3,4,6); D.Add(4,3,6); D.Add(4,5,9); D.Add(5,0,14); D.Add(5,0,14); D.Add(5,4,9); D.dijkstra(0); for(int i=0;i&lt;6;i++)&#123; cout&lt;&lt;D.get(i)&lt;&lt;endl; &#125;&#125; 这个程序实现了如图所示图的最短距离的求得","tags":[{"name":"Dijkstra","slug":"Dijkstra","permalink":"https://www.oyohyee.com/tags/Dijkstra/"},{"name":"最短路","slug":"Shortest-Path","permalink":"https://www.oyohyee.com/tags/Shortest-Path/"},{"name":"图论","slug":"Graph","permalink":"https://www.oyohyee.com/tags/Graph/"}]}]